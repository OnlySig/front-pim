{"ast":null,"code":"import { ObjectUtils } from \"../../util/ObjectUtils\";\n/**\n * Transforms plain old javascript object\n * Entity is constructed based on its entity metadata.\n */\n\nexport class PlainObjectToNewEntityTransformer {\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  transform(newEntity, object, metadata) {\n    let getLazyRelationsPromiseValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    // console.log(\"groupAndTransform entity:\", newEntity);\n    // console.log(\"groupAndTransform object:\", object);\n    this.groupAndTransform(newEntity, object, metadata, getLazyRelationsPromiseValue); // console.log(\"result:\", newEntity);\n\n    return newEntity;\n  } // -------------------------------------------------------------------------\n  // Private Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Since db returns a duplicated rows of the data where accuracies of the same object can be duplicated\n   * we need to group our result and we must have some unique id (primary key in our case)\n   */\n\n\n  groupAndTransform(entity, object, metadata) {\n    let getLazyRelationsPromiseValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    // console.log(\"groupAndTransform entity:\", entity);\n    // console.log(\"groupAndTransform object:\", object);\n    // copy regular column properties from the given object\n    metadata.nonVirtualColumns.forEach(column => {\n      const objectColumnValue = column.getEntityValue(object);\n      if (objectColumnValue !== undefined) column.setEntityValue(entity, objectColumnValue);\n    }); // // copy relation properties from the given object\n\n    if (metadata.relations.length) {\n      metadata.relations.forEach(relation => {\n        let entityRelatedValue = relation.getEntityValue(entity);\n        const objectRelatedValue = relation.getEntityValue(object, getLazyRelationsPromiseValue);\n        if (objectRelatedValue === undefined) return;\n\n        if (relation.isOneToMany || relation.isManyToMany) {\n          if (!Array.isArray(objectRelatedValue)) return;\n\n          if (!entityRelatedValue) {\n            entityRelatedValue = [];\n            relation.setEntityValue(entity, entityRelatedValue);\n          }\n\n          objectRelatedValue.forEach(objectRelatedValueItem => {\n            // check if we have this item from the merging object in the original entity we merge into\n            let objectRelatedValueEntity = entityRelatedValue.find(entityRelatedValueItem => {\n              return relation.inverseEntityMetadata.compareEntities(objectRelatedValueItem, entityRelatedValueItem);\n            }); // if such item already exist then merge new data into it, if its not we create a new entity and merge it into the array\n\n            if (!objectRelatedValueEntity) {\n              objectRelatedValueEntity = relation.inverseEntityMetadata.create(undefined, {\n                fromDeserializer: true\n              });\n              entityRelatedValue.push(objectRelatedValueEntity);\n            }\n\n            this.groupAndTransform(objectRelatedValueEntity, objectRelatedValueItem, relation.inverseEntityMetadata, getLazyRelationsPromiseValue);\n          });\n        } else {\n          // if related object isn't an object (direct relation id for example)\n          // we just set it to the entity relation, we don't need anything more from it\n          // however we do it only if original entity does not have this relation set to object\n          // to prevent full overriding of objects\n          if (!ObjectUtils.isObject(objectRelatedValue)) {\n            if (!ObjectUtils.isObject(entityRelatedValue)) relation.setEntityValue(entity, objectRelatedValue);\n            return;\n          }\n\n          if (!entityRelatedValue) {\n            entityRelatedValue = relation.inverseEntityMetadata.create(undefined, {\n              fromDeserializer: true\n            });\n            relation.setEntityValue(entity, entityRelatedValue);\n          }\n\n          this.groupAndTransform(entityRelatedValue, objectRelatedValue, relation.inverseEntityMetadata, getLazyRelationsPromiseValue);\n        }\n      });\n    }\n  }\n\n}","map":{"version":3,"mappings":"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","names":["ObjectUtils","PlainObjectToNewEntityTransformer","transform","newEntity","object","metadata","getLazyRelationsPromiseValue","groupAndTransform","entity","nonVirtualColumns","forEach","column","objectColumnValue","getEntityValue","undefined","setEntityValue","relations","length","relation","entityRelatedValue","objectRelatedValue","isOneToMany","isManyToMany","Array","isArray","objectRelatedValueItem","objectRelatedValueEntity","find","entityRelatedValueItem","inverseEntityMetadata","compareEntities","create","fromDeserializer","push","isObject"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\query-builder\\transformer\\PlainObjectToNewEntityTransformer.ts"],"sourcesContent":["import { EntityMetadata } from \"../../metadata/EntityMetadata\"\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { ObjectUtils } from \"../../util/ObjectUtils\"\n\n/**\n * Transforms plain old javascript object\n * Entity is constructed based on its entity metadata.\n */\nexport class PlainObjectToNewEntityTransformer {\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    transform<T extends ObjectLiteral>(\n        newEntity: T,\n        object: ObjectLiteral,\n        metadata: EntityMetadata,\n        getLazyRelationsPromiseValue: boolean = false,\n    ): T {\n        // console.log(\"groupAndTransform entity:\", newEntity);\n        // console.log(\"groupAndTransform object:\", object);\n        this.groupAndTransform(\n            newEntity,\n            object,\n            metadata,\n            getLazyRelationsPromiseValue,\n        )\n        // console.log(\"result:\", newEntity);\n        return newEntity\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Since db returns a duplicated rows of the data where accuracies of the same object can be duplicated\n     * we need to group our result and we must have some unique id (primary key in our case)\n     */\n    private groupAndTransform(\n        entity: ObjectLiteral,\n        object: ObjectLiteral,\n        metadata: EntityMetadata,\n        getLazyRelationsPromiseValue: boolean = false,\n    ): void {\n        // console.log(\"groupAndTransform entity:\", entity);\n        // console.log(\"groupAndTransform object:\", object);\n\n        // copy regular column properties from the given object\n        metadata.nonVirtualColumns.forEach((column) => {\n            const objectColumnValue = column.getEntityValue(object)\n            if (objectColumnValue !== undefined)\n                column.setEntityValue(entity, objectColumnValue)\n        })\n\n        // // copy relation properties from the given object\n        if (metadata.relations.length) {\n            metadata.relations.forEach((relation) => {\n                let entityRelatedValue = relation.getEntityValue(entity)\n                const objectRelatedValue = relation.getEntityValue(\n                    object,\n                    getLazyRelationsPromiseValue,\n                )\n                if (objectRelatedValue === undefined) return\n\n                if (relation.isOneToMany || relation.isManyToMany) {\n                    if (!Array.isArray(objectRelatedValue)) return\n\n                    if (!entityRelatedValue) {\n                        entityRelatedValue = []\n                        relation.setEntityValue(entity, entityRelatedValue)\n                    }\n\n                    objectRelatedValue.forEach((objectRelatedValueItem) => {\n                        // check if we have this item from the merging object in the original entity we merge into\n                        let objectRelatedValueEntity = (\n                            entityRelatedValue as any[]\n                        ).find((entityRelatedValueItem) => {\n                            return relation.inverseEntityMetadata.compareEntities(\n                                objectRelatedValueItem,\n                                entityRelatedValueItem,\n                            )\n                        })\n\n                        // if such item already exist then merge new data into it, if its not we create a new entity and merge it into the array\n                        if (!objectRelatedValueEntity) {\n                            objectRelatedValueEntity =\n                                relation.inverseEntityMetadata.create(\n                                    undefined,\n                                    { fromDeserializer: true },\n                                )\n                            entityRelatedValue.push(objectRelatedValueEntity)\n                        }\n\n                        this.groupAndTransform(\n                            objectRelatedValueEntity,\n                            objectRelatedValueItem,\n                            relation.inverseEntityMetadata,\n                            getLazyRelationsPromiseValue,\n                        )\n                    })\n                } else {\n                    // if related object isn't an object (direct relation id for example)\n                    // we just set it to the entity relation, we don't need anything more from it\n                    // however we do it only if original entity does not have this relation set to object\n                    // to prevent full overriding of objects\n                    if (!ObjectUtils.isObject(objectRelatedValue)) {\n                        if (!ObjectUtils.isObject(entityRelatedValue))\n                            relation.setEntityValue(entity, objectRelatedValue)\n                        return\n                    }\n\n                    if (!entityRelatedValue) {\n                        entityRelatedValue =\n                            relation.inverseEntityMetadata.create(undefined, {\n                                fromDeserializer: true,\n                            })\n                        relation.setEntityValue(entity, entityRelatedValue)\n                    }\n\n                    this.groupAndTransform(\n                        entityRelatedValue,\n                        objectRelatedValue,\n                        relation.inverseEntityMetadata,\n                        getLazyRelationsPromiseValue,\n                    )\n                }\n            })\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}