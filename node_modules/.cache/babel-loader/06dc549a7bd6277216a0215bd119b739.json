{"ast":null,"code":"import { TypeORMError } from \"../error\";\n/**\n * Orders insert or remove subjects in proper order (using topological sorting)\n * to make sure insert or remove operations are executed in a proper order.\n */\n\nexport class SubjectTopoligicalSorter {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(subjects) {\n    this.subjects = [...subjects]; // copy subjects to prevent changing of sent array\n\n    this.metadatas = this.getUniqueMetadatas(this.subjects);\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Sorts (orders) subjects in their topological order.\n   */\n\n\n  sort(direction) {\n    // if there are no metadatas it probably mean there is no subjects... we don't have to do anything here\n    if (!this.metadatas.length) return this.subjects;\n    const sortedSubjects = []; // first if we sort for deletion all junction subjects\n    // junction subjects are subjects without entity and database entity set\n\n    if (direction === \"delete\") {\n      const junctionSubjects = this.subjects.filter(subject => !subject.entity && !subject.databaseEntity);\n      sortedSubjects.push(...junctionSubjects);\n      this.removeAlreadySorted(junctionSubjects);\n    } // next we always insert entities with non-nullable relations, sort them first\n\n\n    const nonNullableDependencies = this.getNonNullableDependencies();\n    let sortedNonNullableEntityTargets = this.toposort(nonNullableDependencies);\n    if (direction === \"insert\") sortedNonNullableEntityTargets = sortedNonNullableEntityTargets.reverse(); // so we have a sorted entity targets\n    // go thought each of them and find all subjects with sorted entity target\n    // add those sorted targets and remove them from original array of targets\n\n    sortedNonNullableEntityTargets.forEach(sortedEntityTarget => {\n      const entityTargetSubjects = this.subjects.filter(subject => {\n        var _a;\n\n        return subject.metadata.targetName === sortedEntityTarget || ((_a = subject.metadata.parentEntityMetadata) === null || _a === void 0 ? void 0 : _a.targetName) === sortedEntityTarget;\n      });\n      sortedSubjects.push(...entityTargetSubjects);\n      this.removeAlreadySorted(entityTargetSubjects);\n    }); // next sort all other entities\n    // same process as in above but with other entities\n\n    const otherDependencies = this.getDependencies();\n    let sortedOtherEntityTargets = this.toposort(otherDependencies);\n    if (direction === \"insert\") sortedOtherEntityTargets = sortedOtherEntityTargets.reverse();\n    sortedOtherEntityTargets.forEach(sortedEntityTarget => {\n      const entityTargetSubjects = this.subjects.filter(subject => subject.metadata.targetName === sortedEntityTarget);\n      sortedSubjects.push(...entityTargetSubjects);\n      this.removeAlreadySorted(entityTargetSubjects);\n    }); // if we have something left in the subjects add them as well\n\n    sortedSubjects.push(...this.subjects);\n    return sortedSubjects;\n  } // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Removes already sorted subjects from this.subjects list of subjects.\n   */\n\n\n  removeAlreadySorted(subjects) {\n    subjects.forEach(subject => {\n      this.subjects.splice(this.subjects.indexOf(subject), 1);\n    });\n  }\n  /**\n   * Extracts all unique metadatas from the given subjects.\n   */\n\n\n  getUniqueMetadatas(subjects) {\n    const metadatas = [];\n    subjects.forEach(subject => {\n      if (metadatas.indexOf(subject.metadata) === -1) metadatas.push(subject.metadata);\n    });\n    return metadatas;\n  }\n  /**\n   * Gets dependency tree for all entity metadatas with non-nullable relations.\n   * We need to execute insertions first for entities which non-nullable relations.\n   */\n\n\n  getNonNullableDependencies() {\n    return this.metadatas.reduce((dependencies, metadata) => {\n      metadata.relationsWithJoinColumns.forEach(relation => {\n        if (relation.isNullable) return;\n        dependencies.push([metadata.targetName, relation.inverseEntityMetadata.targetName]);\n      });\n      return dependencies;\n    }, []);\n  }\n  /**\n   * Gets dependency tree for all entity metadatas with non-nullable relations.\n   * We need to execute insertions first for entities which non-nullable relations.\n   */\n\n\n  getDependencies() {\n    return this.metadatas.reduce((dependencies, metadata) => {\n      metadata.relationsWithJoinColumns.forEach(relation => {\n        // if relation is self-referenced we skip it\n        if (relation.inverseEntityMetadata === metadata) return;\n        dependencies.push([metadata.targetName, relation.inverseEntityMetadata.targetName]);\n      });\n      return dependencies;\n    }, []);\n  }\n  /**\n   * Sorts given graph using topological sorting algorithm.\n   *\n   * Algorithm is kindly taken from https://github.com/marcelklehr/toposort repository.\n   */\n\n\n  toposort(edges) {\n    function uniqueNodes(arr) {\n      let res = [];\n\n      for (let i = 0, len = arr.length; i < len; i++) {\n        let edge = arr[i];\n        if (res.indexOf(edge[0]) < 0) res.push(edge[0]);\n        if (res.indexOf(edge[1]) < 0) res.push(edge[1]);\n      }\n\n      return res;\n    }\n\n    const nodes = uniqueNodes(edges);\n    let cursor = nodes.length,\n        sorted = new Array(cursor),\n        visited = {},\n        i = cursor;\n\n    while (i--) {\n      if (!visited[i]) visit(nodes[i], i, []);\n    }\n\n    function visit(node, i, predecessors) {\n      if (predecessors.indexOf(node) >= 0) {\n        throw new TypeORMError(\"Cyclic dependency: \" + JSON.stringify(node)); // todo: better error\n      }\n\n      if (!~nodes.indexOf(node)) {\n        throw new TypeORMError(\"Found unknown node. Make sure to provided all involved nodes. Unknown node: \" + JSON.stringify(node));\n      }\n\n      if (visited[i]) return;\n      visited[i] = true; // outgoing edges\n\n      let outgoing = edges.filter(function (edge) {\n        return edge[0] === node;\n      });\n\n      if (i = outgoing.length) {\n        let preds = predecessors.concat(node);\n\n        do {\n          let child = outgoing[--i][1];\n          visit(child, nodes.indexOf(child), preds);\n        } while (i);\n      }\n\n      sorted[--cursor] = node;\n    }\n\n    return sorted;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["TypeORMError","SubjectTopoligicalSorter","constructor","subjects","metadatas","getUniqueMetadatas","sort","direction","length","sortedSubjects","junctionSubjects","filter","subject","entity","databaseEntity","push","removeAlreadySorted","nonNullableDependencies","getNonNullableDependencies","sortedNonNullableEntityTargets","toposort","reverse","forEach","sortedEntityTarget","entityTargetSubjects","metadata","targetName","parentEntityMetadata","_a","otherDependencies","getDependencies","sortedOtherEntityTargets","splice","indexOf","reduce","dependencies","relationsWithJoinColumns","relation","isNullable","inverseEntityMetadata","edges","uniqueNodes","arr","res","i","len","edge","nodes","cursor","sorted","Array","visited","visit","node","predecessors","JSON","stringify","outgoing","preds","concat","child"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\persistence\\SubjectTopoligicalSorter.ts"],"sourcesContent":["import { Subject } from \"./Subject\"\nimport { EntityMetadata } from \"../metadata/EntityMetadata\"\nimport { TypeORMError } from \"../error\"\n\n/**\n * Orders insert or remove subjects in proper order (using topological sorting)\n * to make sure insert or remove operations are executed in a proper order.\n */\nexport class SubjectTopoligicalSorter {\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Insert subjects needs to be sorted.\n     */\n    subjects: Subject[]\n\n    /**\n     * Unique list of entity metadatas of this subject.\n     */\n    metadatas: EntityMetadata[]\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(subjects: Subject[]) {\n        this.subjects = [...subjects] // copy subjects to prevent changing of sent array\n        this.metadatas = this.getUniqueMetadatas(this.subjects)\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Sorts (orders) subjects in their topological order.\n     */\n    sort(direction: \"insert\" | \"delete\"): Subject[] {\n        // if there are no metadatas it probably mean there is no subjects... we don't have to do anything here\n        if (!this.metadatas.length) return this.subjects\n\n        const sortedSubjects: Subject[] = []\n\n        // first if we sort for deletion all junction subjects\n        // junction subjects are subjects without entity and database entity set\n        if (direction === \"delete\") {\n            const junctionSubjects = this.subjects.filter(\n                (subject) => !subject.entity && !subject.databaseEntity,\n            )\n            sortedSubjects.push(...junctionSubjects)\n            this.removeAlreadySorted(junctionSubjects)\n        }\n\n        // next we always insert entities with non-nullable relations, sort them first\n        const nonNullableDependencies = this.getNonNullableDependencies()\n        let sortedNonNullableEntityTargets = this.toposort(\n            nonNullableDependencies,\n        )\n        if (direction === \"insert\")\n            sortedNonNullableEntityTargets =\n                sortedNonNullableEntityTargets.reverse()\n\n        // so we have a sorted entity targets\n        // go thought each of them and find all subjects with sorted entity target\n        // add those sorted targets and remove them from original array of targets\n        sortedNonNullableEntityTargets.forEach((sortedEntityTarget) => {\n            const entityTargetSubjects = this.subjects.filter(\n                (subject) =>\n                    subject.metadata.targetName === sortedEntityTarget ||\n                    subject.metadata.parentEntityMetadata?.targetName ===\n                        sortedEntityTarget,\n            )\n            sortedSubjects.push(...entityTargetSubjects)\n            this.removeAlreadySorted(entityTargetSubjects)\n        })\n\n        // next sort all other entities\n        // same process as in above but with other entities\n        const otherDependencies: string[][] = this.getDependencies()\n        let sortedOtherEntityTargets = this.toposort(otherDependencies)\n        if (direction === \"insert\")\n            sortedOtherEntityTargets = sortedOtherEntityTargets.reverse()\n\n        sortedOtherEntityTargets.forEach((sortedEntityTarget) => {\n            const entityTargetSubjects = this.subjects.filter(\n                (subject) => subject.metadata.targetName === sortedEntityTarget,\n            )\n            sortedSubjects.push(...entityTargetSubjects)\n            this.removeAlreadySorted(entityTargetSubjects)\n        })\n\n        // if we have something left in the subjects add them as well\n        sortedSubjects.push(...this.subjects)\n        return sortedSubjects\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Removes already sorted subjects from this.subjects list of subjects.\n     */\n    protected removeAlreadySorted(subjects: Subject[]) {\n        subjects.forEach((subject) => {\n            this.subjects.splice(this.subjects.indexOf(subject), 1)\n        })\n    }\n\n    /**\n     * Extracts all unique metadatas from the given subjects.\n     */\n    protected getUniqueMetadatas(subjects: Subject[]) {\n        const metadatas: EntityMetadata[] = []\n        subjects.forEach((subject) => {\n            if (metadatas.indexOf(subject.metadata) === -1)\n                metadatas.push(subject.metadata)\n        })\n        return metadatas\n    }\n\n    /**\n     * Gets dependency tree for all entity metadatas with non-nullable relations.\n     * We need to execute insertions first for entities which non-nullable relations.\n     */\n    protected getNonNullableDependencies(): string[][] {\n        return this.metadatas.reduce((dependencies, metadata) => {\n            metadata.relationsWithJoinColumns.forEach((relation) => {\n                if (relation.isNullable) return\n\n                dependencies.push([\n                    metadata.targetName,\n                    relation.inverseEntityMetadata.targetName,\n                ])\n            })\n            return dependencies\n        }, [] as string[][])\n    }\n\n    /**\n     * Gets dependency tree for all entity metadatas with non-nullable relations.\n     * We need to execute insertions first for entities which non-nullable relations.\n     */\n    protected getDependencies(): string[][] {\n        return this.metadatas.reduce((dependencies, metadata) => {\n            metadata.relationsWithJoinColumns.forEach((relation) => {\n                // if relation is self-referenced we skip it\n                if (relation.inverseEntityMetadata === metadata) return\n\n                dependencies.push([\n                    metadata.targetName,\n                    relation.inverseEntityMetadata.targetName,\n                ])\n            })\n            return dependencies\n        }, [] as string[][])\n    }\n\n    /**\n     * Sorts given graph using topological sorting algorithm.\n     *\n     * Algorithm is kindly taken from https://github.com/marcelklehr/toposort repository.\n     */\n    protected toposort(edges: any[][]) {\n        function uniqueNodes(arr: any[]) {\n            let res = []\n            for (let i = 0, len = arr.length; i < len; i++) {\n                let edge: any = arr[i]\n                if (res.indexOf(edge[0]) < 0) res.push(edge[0])\n                if (res.indexOf(edge[1]) < 0) res.push(edge[1])\n            }\n            return res\n        }\n\n        const nodes = uniqueNodes(edges)\n        let cursor = nodes.length,\n            sorted = new Array(cursor),\n            visited: any = {},\n            i = cursor\n\n        while (i--) {\n            if (!visited[i]) visit(nodes[i], i, [])\n        }\n\n        function visit(node: any, i: number, predecessors: any[]) {\n            if (predecessors.indexOf(node) >= 0) {\n                throw new TypeORMError(\n                    \"Cyclic dependency: \" + JSON.stringify(node),\n                ) // todo: better error\n            }\n\n            if (!~nodes.indexOf(node)) {\n                throw new TypeORMError(\n                    \"Found unknown node. Make sure to provided all involved nodes. Unknown node: \" +\n                        JSON.stringify(node),\n                )\n            }\n\n            if (visited[i]) return\n            visited[i] = true\n\n            // outgoing edges\n            let outgoing = edges.filter(function (edge) {\n                return edge[0] === node\n            })\n            if ((i = outgoing.length)) {\n                let preds = predecessors.concat(node)\n                do {\n                    let child = outgoing[--i][1]\n                    visit(child, nodes.indexOf(child), preds)\n                } while (i)\n            }\n\n            sorted[--cursor] = node\n        }\n\n        return sorted\n    }\n}\n"]},"metadata":{},"sourceType":"module"}