{"ast":null,"code":"import { ColumnMetadata } from \"../metadata/ColumnMetadata\";\nimport { EntityMetadata } from \"../metadata/EntityMetadata\";\nimport { ForeignKeyMetadata } from \"../metadata/ForeignKeyMetadata\";\nimport { IndexMetadata } from \"../metadata/IndexMetadata\";\nimport { TypeORMError } from \"../error\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\n/**\n * Creates EntityMetadata for junction tables.\n * Junction tables are tables generated by many-to-many relations.\n */\n\nexport class JunctionEntityMetadataBuilder {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection) {\n    this.connection = connection;\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Builds EntityMetadata for the junction of the given many-to-many relation.\n   */\n\n\n  build(relation, joinTable) {\n    var _a, _b;\n\n    const referencedColumns = this.collectReferencedColumns(relation, joinTable);\n    const inverseReferencedColumns = this.collectInverseReferencedColumns(relation, joinTable);\n    const joinTableName = joinTable.name || this.connection.namingStrategy.joinTableName(relation.entityMetadata.tableNameWithoutPrefix, relation.inverseEntityMetadata.tableNameWithoutPrefix, relation.propertyPath, relation.inverseRelation ? relation.inverseRelation.propertyName : \"\");\n    const entityMetadata = new EntityMetadata({\n      connection: this.connection,\n      args: {\n        target: \"\",\n        name: joinTableName,\n        type: \"junction\",\n        database: joinTable.database || relation.entityMetadata.database,\n        schema: joinTable.schema || relation.entityMetadata.schema\n      }\n    });\n    entityMetadata.build(); // create original side junction columns\n\n    const junctionColumns = referencedColumns.map(referencedColumn => {\n      const joinColumn = joinTable.joinColumns ? joinTable.joinColumns.find(joinColumnArgs => {\n        return (!joinColumnArgs.referencedColumnName || joinColumnArgs.referencedColumnName === referencedColumn.propertyName) && !!joinColumnArgs.name;\n      }) : undefined;\n      const columnName = joinColumn && joinColumn.name ? joinColumn.name : this.connection.namingStrategy.joinTableColumnName(relation.entityMetadata.tableNameWithoutPrefix, referencedColumn.propertyName, referencedColumn.databaseName);\n      return new ColumnMetadata({\n        connection: this.connection,\n        entityMetadata: entityMetadata,\n        referencedColumn: referencedColumn,\n        args: {\n          target: \"\",\n          mode: \"virtual\",\n          propertyName: columnName,\n          options: {\n            name: columnName,\n            length: !referencedColumn.length && (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === \"aurora-mysql\") && (referencedColumn.generationStrategy === \"uuid\" || referencedColumn.type === \"uuid\") ? \"36\" : referencedColumn.length,\n            width: referencedColumn.width,\n            type: referencedColumn.type,\n            precision: referencedColumn.precision,\n            scale: referencedColumn.scale,\n            charset: referencedColumn.charset,\n            collation: referencedColumn.collation,\n            zerofill: referencedColumn.zerofill,\n            unsigned: referencedColumn.zerofill ? true : referencedColumn.unsigned,\n            enum: referencedColumn.enum,\n            enumName: referencedColumn.enumName,\n            foreignKeyConstraintName: joinColumn === null || joinColumn === void 0 ? void 0 : joinColumn.foreignKeyConstraintName,\n            nullable: false,\n            primary: true\n          }\n        }\n      });\n    }); // create inverse side junction columns\n\n    const inverseJunctionColumns = inverseReferencedColumns.map(inverseReferencedColumn => {\n      const joinColumn = joinTable.inverseJoinColumns ? joinTable.inverseJoinColumns.find(joinColumnArgs => {\n        return (!joinColumnArgs.referencedColumnName || joinColumnArgs.referencedColumnName === inverseReferencedColumn.propertyName) && !!joinColumnArgs.name;\n      }) : undefined;\n      const columnName = joinColumn && joinColumn.name ? joinColumn.name : this.connection.namingStrategy.joinTableInverseColumnName(relation.inverseEntityMetadata.tableNameWithoutPrefix, inverseReferencedColumn.propertyName, inverseReferencedColumn.databaseName);\n      return new ColumnMetadata({\n        connection: this.connection,\n        entityMetadata: entityMetadata,\n        referencedColumn: inverseReferencedColumn,\n        args: {\n          target: \"\",\n          mode: \"virtual\",\n          propertyName: columnName,\n          options: {\n            length: !inverseReferencedColumn.length && (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === \"aurora-mysql\") && (inverseReferencedColumn.generationStrategy === \"uuid\" || inverseReferencedColumn.type === \"uuid\") ? \"36\" : inverseReferencedColumn.length,\n            width: inverseReferencedColumn.width,\n            type: inverseReferencedColumn.type,\n            precision: inverseReferencedColumn.precision,\n            scale: inverseReferencedColumn.scale,\n            charset: inverseReferencedColumn.charset,\n            collation: inverseReferencedColumn.collation,\n            zerofill: inverseReferencedColumn.zerofill,\n            unsigned: inverseReferencedColumn.zerofill ? true : inverseReferencedColumn.unsigned,\n            enum: inverseReferencedColumn.enum,\n            enumName: inverseReferencedColumn.enumName,\n            foreignKeyConstraintName: joinColumn === null || joinColumn === void 0 ? void 0 : joinColumn.foreignKeyConstraintName,\n            name: columnName,\n            nullable: false,\n            primary: true\n          }\n        }\n      });\n    });\n    this.changeDuplicatedColumnNames(junctionColumns, inverseJunctionColumns); // set junction table columns\n\n    entityMetadata.ownerColumns = junctionColumns;\n    entityMetadata.inverseColumns = inverseJunctionColumns;\n    entityMetadata.ownColumns = [...junctionColumns, ...inverseJunctionColumns];\n    entityMetadata.ownColumns.forEach(column => column.relationMetadata = relation); // create junction table foreign keys\n    // Note: UPDATE CASCADE clause is not supported in Oracle.\n    // Note: UPDATE/DELETE CASCADE clauses are not supported in Spanner.\n\n    entityMetadata.foreignKeys = relation.createForeignKeyConstraints ? [new ForeignKeyMetadata({\n      entityMetadata: entityMetadata,\n      referencedEntityMetadata: relation.entityMetadata,\n      columns: junctionColumns,\n      referencedColumns: referencedColumns,\n      name: (_a = junctionColumns[0]) === null || _a === void 0 ? void 0 : _a.foreignKeyConstraintName,\n      onDelete: this.connection.driver.options.type === \"spanner\" ? \"NO ACTION\" : relation.onDelete || \"CASCADE\",\n      onUpdate: this.connection.driver.options.type === \"oracle\" || this.connection.driver.options.type === \"spanner\" ? \"NO ACTION\" : relation.onUpdate || \"CASCADE\"\n    }), new ForeignKeyMetadata({\n      entityMetadata: entityMetadata,\n      referencedEntityMetadata: relation.inverseEntityMetadata,\n      columns: inverseJunctionColumns,\n      referencedColumns: inverseReferencedColumns,\n      name: (_b = inverseJunctionColumns[0]) === null || _b === void 0 ? void 0 : _b.foreignKeyConstraintName,\n      onDelete: this.connection.driver.options.type === \"spanner\" ? \"NO ACTION\" : relation.inverseRelation ? relation.inverseRelation.onDelete : \"CASCADE\",\n      onUpdate: this.connection.driver.options.type === \"oracle\" || this.connection.driver.options.type === \"spanner\" ? \"NO ACTION\" : relation.inverseRelation ? relation.inverseRelation.onUpdate : \"CASCADE\"\n    })] : []; // create junction table indices\n\n    entityMetadata.ownIndices = [new IndexMetadata({\n      entityMetadata: entityMetadata,\n      columns: junctionColumns,\n      args: {\n        target: entityMetadata.target,\n        synchronize: true\n      }\n    }), new IndexMetadata({\n      entityMetadata: entityMetadata,\n      columns: inverseJunctionColumns,\n      args: {\n        target: entityMetadata.target,\n        synchronize: true\n      }\n    })]; // finally return entity metadata\n\n    return entityMetadata;\n  } // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Collects referenced columns from the given join column args.\n   */\n\n\n  collectReferencedColumns(relation, joinTable) {\n    const hasAnyReferencedColumnName = joinTable.joinColumns ? joinTable.joinColumns.find(joinColumn => !!joinColumn.referencedColumnName) : false;\n\n    if (!joinTable.joinColumns || joinTable.joinColumns && !hasAnyReferencedColumnName) {\n      return relation.entityMetadata.columns.filter(column => column.isPrimary);\n    } else {\n      return joinTable.joinColumns.map(joinColumn => {\n        const referencedColumn = relation.entityMetadata.columns.find(column => column.propertyName === joinColumn.referencedColumnName);\n        if (!referencedColumn) throw new TypeORMError(`Referenced column ${joinColumn.referencedColumnName} was not found in entity ${relation.entityMetadata.name}`);\n        return referencedColumn;\n      });\n    }\n  }\n  /**\n   * Collects inverse referenced columns from the given join column args.\n   */\n\n\n  collectInverseReferencedColumns(relation, joinTable) {\n    const hasInverseJoinColumns = !!joinTable.inverseJoinColumns;\n    const hasAnyInverseReferencedColumnName = hasInverseJoinColumns ? joinTable.inverseJoinColumns.find(joinColumn => !!joinColumn.referencedColumnName) : false;\n\n    if (!hasInverseJoinColumns || hasInverseJoinColumns && !hasAnyInverseReferencedColumnName) {\n      return relation.inverseEntityMetadata.primaryColumns;\n    } else {\n      return joinTable.inverseJoinColumns.map(joinColumn => {\n        const referencedColumn = relation.inverseEntityMetadata.ownColumns.find(column => column.propertyName === joinColumn.referencedColumnName);\n        if (!referencedColumn) throw new TypeORMError(`Referenced column ${joinColumn.referencedColumnName} was not found in entity ${relation.inverseEntityMetadata.name}`);\n        return referencedColumn;\n      });\n    }\n  }\n\n  changeDuplicatedColumnNames(junctionColumns, inverseJunctionColumns) {\n    junctionColumns.forEach(junctionColumn => {\n      inverseJunctionColumns.forEach(inverseJunctionColumn => {\n        if (junctionColumn.givenDatabaseName === inverseJunctionColumn.givenDatabaseName) {\n          const junctionColumnName = this.connection.namingStrategy.joinTableColumnDuplicationPrefix(junctionColumn.propertyName, 1);\n          junctionColumn.propertyName = junctionColumnName;\n          junctionColumn.givenDatabaseName = junctionColumnName;\n          const inverseJunctionColumnName = this.connection.namingStrategy.joinTableColumnDuplicationPrefix(inverseJunctionColumn.propertyName, 2);\n          inverseJunctionColumn.propertyName = inverseJunctionColumnName;\n          inverseJunctionColumn.givenDatabaseName = inverseJunctionColumnName;\n        }\n      });\n    });\n  }\n\n}","map":{"version":3,"mappings":"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","names":["ColumnMetadata","EntityMetadata","ForeignKeyMetadata","IndexMetadata","TypeORMError","DriverUtils","JunctionEntityMetadataBuilder","constructor","connection","build","relation","joinTable","referencedColumns","collectReferencedColumns","inverseReferencedColumns","collectInverseReferencedColumns","joinTableName","name","namingStrategy","entityMetadata","tableNameWithoutPrefix","inverseEntityMetadata","propertyPath","inverseRelation","propertyName","args","target","type","database","schema","junctionColumns","map","referencedColumn","joinColumn","joinColumns","find","joinColumnArgs","referencedColumnName","undefined","columnName","joinTableColumnName","databaseName","mode","options","length","isMySQLFamily","driver","generationStrategy","width","precision","scale","charset","collation","zerofill","unsigned","enum","enumName","foreignKeyConstraintName","nullable","primary","inverseJunctionColumns","inverseReferencedColumn","inverseJoinColumns","joinTableInverseColumnName","changeDuplicatedColumnNames","ownerColumns","inverseColumns","ownColumns","forEach","column","relationMetadata","foreignKeys","createForeignKeyConstraints","referencedEntityMetadata","columns","_a","onDelete","onUpdate","_b","ownIndices","synchronize","hasAnyReferencedColumnName","filter","isPrimary","hasInverseJoinColumns","hasAnyInverseReferencedColumnName","primaryColumns","junctionColumn","inverseJunctionColumn","givenDatabaseName","junctionColumnName","joinTableColumnDuplicationPrefix","inverseJunctionColumnName"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\metadata-builder\\JunctionEntityMetadataBuilder.ts"],"sourcesContent":["import { ColumnMetadata } from \"../metadata/ColumnMetadata\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { EntityMetadata } from \"../metadata/EntityMetadata\"\nimport { ForeignKeyMetadata } from \"../metadata/ForeignKeyMetadata\"\nimport { IndexMetadata } from \"../metadata/IndexMetadata\"\nimport { JoinTableMetadataArgs } from \"../metadata-args/JoinTableMetadataArgs\"\nimport { RelationMetadata } from \"../metadata/RelationMetadata\"\nimport { TypeORMError } from \"../error\"\nimport { DriverUtils } from \"../driver/DriverUtils\"\n\n/**\n * Creates EntityMetadata for junction tables.\n * Junction tables are tables generated by many-to-many relations.\n */\nexport class JunctionEntityMetadataBuilder {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private connection: DataSource) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Builds EntityMetadata for the junction of the given many-to-many relation.\n     */\n    build(\n        relation: RelationMetadata,\n        joinTable: JoinTableMetadataArgs,\n    ): EntityMetadata {\n        const referencedColumns = this.collectReferencedColumns(\n            relation,\n            joinTable,\n        )\n        const inverseReferencedColumns = this.collectInverseReferencedColumns(\n            relation,\n            joinTable,\n        )\n\n        const joinTableName =\n            joinTable.name ||\n            this.connection.namingStrategy.joinTableName(\n                relation.entityMetadata.tableNameWithoutPrefix,\n                relation.inverseEntityMetadata.tableNameWithoutPrefix,\n                relation.propertyPath,\n                relation.inverseRelation\n                    ? relation.inverseRelation.propertyName\n                    : \"\",\n            )\n\n        const entityMetadata = new EntityMetadata({\n            connection: this.connection,\n            args: {\n                target: \"\",\n                name: joinTableName,\n                type: \"junction\",\n                database:\n                    joinTable.database || relation.entityMetadata.database,\n                schema: joinTable.schema || relation.entityMetadata.schema,\n            },\n        })\n        entityMetadata.build()\n\n        // create original side junction columns\n        const junctionColumns = referencedColumns.map((referencedColumn) => {\n            const joinColumn = joinTable.joinColumns\n                ? joinTable.joinColumns.find((joinColumnArgs) => {\n                      return (\n                          (!joinColumnArgs.referencedColumnName ||\n                              joinColumnArgs.referencedColumnName ===\n                                  referencedColumn.propertyName) &&\n                          !!joinColumnArgs.name\n                      )\n                  })\n                : undefined\n            const columnName =\n                joinColumn && joinColumn.name\n                    ? joinColumn.name\n                    : this.connection.namingStrategy.joinTableColumnName(\n                          relation.entityMetadata.tableNameWithoutPrefix,\n                          referencedColumn.propertyName,\n                          referencedColumn.databaseName,\n                      )\n\n            return new ColumnMetadata({\n                connection: this.connection,\n                entityMetadata: entityMetadata,\n                referencedColumn: referencedColumn,\n                args: {\n                    target: \"\",\n                    mode: \"virtual\",\n                    propertyName: columnName,\n                    options: {\n                        name: columnName,\n                        length:\n                            !referencedColumn.length &&\n                            (DriverUtils.isMySQLFamily(\n                                this.connection.driver,\n                            ) ||\n                                this.connection.driver.options.type ===\n                                    \"aurora-mysql\") &&\n                            (referencedColumn.generationStrategy === \"uuid\" ||\n                                referencedColumn.type === \"uuid\")\n                                ? \"36\"\n                                : referencedColumn.length, // fix https://github.com/typeorm/typeorm/issues/3604\n                        width: referencedColumn.width,\n                        type: referencedColumn.type,\n                        precision: referencedColumn.precision,\n                        scale: referencedColumn.scale,\n                        charset: referencedColumn.charset,\n                        collation: referencedColumn.collation,\n                        zerofill: referencedColumn.zerofill,\n                        unsigned: referencedColumn.zerofill\n                            ? true\n                            : referencedColumn.unsigned,\n                        enum: referencedColumn.enum,\n                        enumName: referencedColumn.enumName,\n                        foreignKeyConstraintName:\n                            joinColumn?.foreignKeyConstraintName,\n                        nullable: false,\n                        primary: true,\n                    },\n                },\n            })\n        })\n\n        // create inverse side junction columns\n        const inverseJunctionColumns = inverseReferencedColumns.map(\n            (inverseReferencedColumn) => {\n                const joinColumn = joinTable.inverseJoinColumns\n                    ? joinTable.inverseJoinColumns.find((joinColumnArgs) => {\n                          return (\n                              (!joinColumnArgs.referencedColumnName ||\n                                  joinColumnArgs.referencedColumnName ===\n                                      inverseReferencedColumn.propertyName) &&\n                              !!joinColumnArgs.name\n                          )\n                      })\n                    : undefined\n                const columnName =\n                    joinColumn && joinColumn.name\n                        ? joinColumn.name\n                        : this.connection.namingStrategy.joinTableInverseColumnName(\n                              relation.inverseEntityMetadata\n                                  .tableNameWithoutPrefix,\n                              inverseReferencedColumn.propertyName,\n                              inverseReferencedColumn.databaseName,\n                          )\n\n                return new ColumnMetadata({\n                    connection: this.connection,\n                    entityMetadata: entityMetadata,\n                    referencedColumn: inverseReferencedColumn,\n                    args: {\n                        target: \"\",\n                        mode: \"virtual\",\n                        propertyName: columnName,\n                        options: {\n                            length:\n                                !inverseReferencedColumn.length &&\n                                (DriverUtils.isMySQLFamily(\n                                    this.connection.driver,\n                                ) ||\n                                    this.connection.driver.options.type ===\n                                        \"aurora-mysql\") &&\n                                (inverseReferencedColumn.generationStrategy ===\n                                    \"uuid\" ||\n                                    inverseReferencedColumn.type === \"uuid\")\n                                    ? \"36\"\n                                    : inverseReferencedColumn.length, // fix https://github.com/typeorm/typeorm/issues/3604\n                            width: inverseReferencedColumn.width, // fix https://github.com/typeorm/typeorm/issues/6442\n                            type: inverseReferencedColumn.type,\n                            precision: inverseReferencedColumn.precision,\n                            scale: inverseReferencedColumn.scale,\n                            charset: inverseReferencedColumn.charset,\n                            collation: inverseReferencedColumn.collation,\n                            zerofill: inverseReferencedColumn.zerofill,\n                            unsigned: inverseReferencedColumn.zerofill\n                                ? true\n                                : inverseReferencedColumn.unsigned,\n                            enum: inverseReferencedColumn.enum,\n                            enumName: inverseReferencedColumn.enumName,\n                            foreignKeyConstraintName:\n                                joinColumn?.foreignKeyConstraintName,\n                            name: columnName,\n                            nullable: false,\n                            primary: true,\n                        },\n                    },\n                })\n            },\n        )\n\n        this.changeDuplicatedColumnNames(\n            junctionColumns,\n            inverseJunctionColumns,\n        )\n\n        // set junction table columns\n        entityMetadata.ownerColumns = junctionColumns\n        entityMetadata.inverseColumns = inverseJunctionColumns\n        entityMetadata.ownColumns = [\n            ...junctionColumns,\n            ...inverseJunctionColumns,\n        ]\n        entityMetadata.ownColumns.forEach(\n            (column) => (column.relationMetadata = relation),\n        )\n\n        // create junction table foreign keys\n        // Note: UPDATE CASCADE clause is not supported in Oracle.\n        // Note: UPDATE/DELETE CASCADE clauses are not supported in Spanner.\n        entityMetadata.foreignKeys = relation.createForeignKeyConstraints\n            ? [\n                  new ForeignKeyMetadata({\n                      entityMetadata: entityMetadata,\n                      referencedEntityMetadata: relation.entityMetadata,\n                      columns: junctionColumns,\n                      referencedColumns: referencedColumns,\n                      name: junctionColumns[0]?.foreignKeyConstraintName,\n                      onDelete:\n                          this.connection.driver.options.type === \"spanner\"\n                              ? \"NO ACTION\"\n                              : relation.onDelete || \"CASCADE\",\n                      onUpdate:\n                          this.connection.driver.options.type === \"oracle\" ||\n                          this.connection.driver.options.type === \"spanner\"\n                              ? \"NO ACTION\"\n                              : relation.onUpdate || \"CASCADE\",\n                  }),\n                  new ForeignKeyMetadata({\n                      entityMetadata: entityMetadata,\n                      referencedEntityMetadata: relation.inverseEntityMetadata,\n                      columns: inverseJunctionColumns,\n                      referencedColumns: inverseReferencedColumns,\n                      name: inverseJunctionColumns[0]?.foreignKeyConstraintName,\n                      onDelete:\n                          this.connection.driver.options.type === \"spanner\"\n                              ? \"NO ACTION\"\n                              : relation.inverseRelation\n                              ? relation.inverseRelation.onDelete\n                              : \"CASCADE\",\n                      onUpdate:\n                          this.connection.driver.options.type === \"oracle\" ||\n                          this.connection.driver.options.type === \"spanner\"\n                              ? \"NO ACTION\"\n                              : relation.inverseRelation\n                              ? relation.inverseRelation.onUpdate\n                              : \"CASCADE\",\n                  }),\n              ]\n            : []\n\n        // create junction table indices\n        entityMetadata.ownIndices = [\n            new IndexMetadata({\n                entityMetadata: entityMetadata,\n                columns: junctionColumns,\n                args: {\n                    target: entityMetadata.target,\n                    synchronize: true,\n                },\n            }),\n\n            new IndexMetadata({\n                entityMetadata: entityMetadata,\n                columns: inverseJunctionColumns,\n                args: {\n                    target: entityMetadata.target,\n                    synchronize: true,\n                },\n            }),\n        ]\n\n        // finally return entity metadata\n        return entityMetadata\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Collects referenced columns from the given join column args.\n     */\n    protected collectReferencedColumns(\n        relation: RelationMetadata,\n        joinTable: JoinTableMetadataArgs,\n    ): ColumnMetadata[] {\n        const hasAnyReferencedColumnName = joinTable.joinColumns\n            ? joinTable.joinColumns.find(\n                  (joinColumn) => !!joinColumn.referencedColumnName,\n              )\n            : false\n        if (\n            !joinTable.joinColumns ||\n            (joinTable.joinColumns && !hasAnyReferencedColumnName)\n        ) {\n            return relation.entityMetadata.columns.filter(\n                (column) => column.isPrimary,\n            )\n        } else {\n            return joinTable.joinColumns.map((joinColumn) => {\n                const referencedColumn = relation.entityMetadata.columns.find(\n                    (column) =>\n                        column.propertyName === joinColumn.referencedColumnName,\n                )\n                if (!referencedColumn)\n                    throw new TypeORMError(\n                        `Referenced column ${joinColumn.referencedColumnName} was not found in entity ${relation.entityMetadata.name}`,\n                    )\n\n                return referencedColumn\n            })\n        }\n    }\n\n    /**\n     * Collects inverse referenced columns from the given join column args.\n     */\n    protected collectInverseReferencedColumns(\n        relation: RelationMetadata,\n        joinTable: JoinTableMetadataArgs,\n    ): ColumnMetadata[] {\n        const hasInverseJoinColumns = !!joinTable.inverseJoinColumns\n        const hasAnyInverseReferencedColumnName = hasInverseJoinColumns\n            ? joinTable.inverseJoinColumns!.find(\n                  (joinColumn) => !!joinColumn.referencedColumnName,\n              )\n            : false\n        if (\n            !hasInverseJoinColumns ||\n            (hasInverseJoinColumns && !hasAnyInverseReferencedColumnName)\n        ) {\n            return relation.inverseEntityMetadata.primaryColumns\n        } else {\n            return joinTable.inverseJoinColumns!.map((joinColumn) => {\n                const referencedColumn =\n                    relation.inverseEntityMetadata.ownColumns.find(\n                        (column) =>\n                            column.propertyName ===\n                            joinColumn.referencedColumnName,\n                    )\n                if (!referencedColumn)\n                    throw new TypeORMError(\n                        `Referenced column ${joinColumn.referencedColumnName} was not found in entity ${relation.inverseEntityMetadata.name}`,\n                    )\n\n                return referencedColumn\n            })\n        }\n    }\n\n    protected changeDuplicatedColumnNames(\n        junctionColumns: ColumnMetadata[],\n        inverseJunctionColumns: ColumnMetadata[],\n    ) {\n        junctionColumns.forEach((junctionColumn) => {\n            inverseJunctionColumns.forEach((inverseJunctionColumn) => {\n                if (\n                    junctionColumn.givenDatabaseName ===\n                    inverseJunctionColumn.givenDatabaseName\n                ) {\n                    const junctionColumnName =\n                        this.connection.namingStrategy.joinTableColumnDuplicationPrefix(\n                            junctionColumn.propertyName,\n                            1,\n                        )\n                    junctionColumn.propertyName = junctionColumnName\n                    junctionColumn.givenDatabaseName = junctionColumnName\n\n                    const inverseJunctionColumnName =\n                        this.connection.namingStrategy.joinTableColumnDuplicationPrefix(\n                            inverseJunctionColumn.propertyName,\n                            2,\n                        )\n                    inverseJunctionColumn.propertyName =\n                        inverseJunctionColumnName\n                    inverseJunctionColumn.givenDatabaseName =\n                        inverseJunctionColumnName\n                }\n            })\n        })\n    }\n}\n"]},"metadata":{},"sourceType":"module"}