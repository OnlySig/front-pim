{"ast":null,"code":"/**\n * This metadata contains all information about entity's listeners.\n */\nexport class EntityListenerMetadata {\n  // ---------------------------------------------------------------------\n  // Constructor\n  // ---------------------------------------------------------------------\n  constructor(options) {\n    this.entityMetadata = options.entityMetadata;\n    this.embeddedMetadata = options.embeddedMetadata;\n    this.target = options.args.target;\n    this.propertyName = options.args.propertyName;\n    this.type = options.args.type;\n  } // ---------------------------------------------------------------------\n  // Public Methods\n  // ---------------------------------------------------------------------\n\n  /**\n   * Checks if entity listener is allowed to be executed on the given entity.\n   */\n\n\n  isAllowed(entity) {\n    // todo: create in entity metadata method like isInherited?\n    return this.entityMetadata.target === entity.constructor || // todo: .constructor won't work for entity schemas, but there are no entity listeners in schemas since there are no objects, right?\n    typeof this.entityMetadata.target === \"function\" && entity.constructor.prototype instanceof this.entityMetadata.target; // todo: also need to implement entity schema inheritance\n  }\n  /**\n   * Executes listener method of the given entity.\n   */\n\n\n  execute(entity) {\n    if (!this.embeddedMetadata) return entity[this.propertyName]();\n    this.callEntityEmbeddedMethod(entity, this.embeddedMetadata.propertyPath.split(\".\"));\n  } // ---------------------------------------------------------------------\n  // Protected Methods\n  // ---------------------------------------------------------------------\n\n  /**\n   * Calls embedded entity listener method no matter how nested it is.\n   */\n\n\n  callEntityEmbeddedMethod(entity, propertyPaths) {\n    const propertyPath = propertyPaths.shift();\n    if (!propertyPath || !entity[propertyPath]) return;\n\n    if (propertyPaths.length === 0) {\n      if (Array.isArray(entity[propertyPath])) {\n        entity[propertyPath].map(embedded => embedded[this.propertyName]());\n      } else {\n        entity[propertyPath][this.propertyName]();\n      }\n    } else {\n      if (entity[propertyPath]) this.callEntityEmbeddedMethod(entity[propertyPath], propertyPaths);\n    }\n  }\n\n}","map":{"version":3,"mappings":"AAMA;;;AAGA,OAAM,MAAOA,sBAAP,CAA6B;EA+B/B;EACA;EACA;EAEAC,YAAYC,OAAZ,EAIC;IACG,KAAKC,cAAL,GAAsBD,OAAO,CAACC,cAA9B;IACA,KAAKC,gBAAL,GAAwBF,OAAO,CAACE,gBAAhC;IACA,KAAKC,MAAL,GAAcH,OAAO,CAACI,IAAR,CAAaD,MAA3B;IACA,KAAKE,YAAL,GAAoBL,OAAO,CAACI,IAAR,CAAaC,YAAjC;IACA,KAAKC,IAAL,GAAYN,OAAO,CAACI,IAAR,CAAaE,IAAzB;EACH,CA7C8B,CA+C/B;EACA;EACA;;EAEA;;;;;EAGAC,SAAS,CAACC,MAAD,EAAsB;IAC3B;IACA,OACI,KAAKP,cAAL,CAAoBE,MAApB,KAA+BK,MAAM,CAACT,WAAtC,IAAqD;IACpD,OAAO,KAAKE,cAAL,CAAoBE,MAA3B,KAAsC,UAAtC,IACGK,MAAM,CAACT,WAAP,CAAmBU,SAAnB,YACI,KAAKR,cAAL,CAAoBE,MAJhC,CAF2B,CAOzB;EACL;EAED;;;;;EAGAO,OAAO,CAACF,MAAD,EAAsB;IACzB,IAAI,CAAC,KAAKN,gBAAV,EAA4B,OAAOM,MAAM,CAAC,KAAKH,YAAN,CAAN,EAAP;IAE5B,KAAKM,wBAAL,CACIH,MADJ,EAEI,KAAKN,gBAAL,CAAsBU,YAAtB,CAAmCC,KAAnC,CAAyC,GAAzC,CAFJ;EAIH,CA1E8B,CA4E/B;EACA;EACA;;EAEA;;;;;EAGUF,wBAAwB,CAC9BH,MAD8B,EAE9BM,aAF8B,EAEP;IAEvB,MAAMF,YAAY,GAAGE,aAAa,CAACC,KAAd,EAArB;IACA,IAAI,CAACH,YAAD,IAAiB,CAACJ,MAAM,CAACI,YAAD,CAA5B,EAA4C;;IAE5C,IAAIE,aAAa,CAACE,MAAd,KAAyB,CAA7B,EAAgC;MAC5B,IAAIC,KAAK,CAACC,OAAN,CAAcV,MAAM,CAACI,YAAD,CAApB,CAAJ,EAAyC;QACrCJ,MAAM,CAACI,YAAD,CAAN,CAAqBO,GAArB,CAA0BC,QAAD,IACrBA,QAAQ,CAAC,KAAKf,YAAN,CAAR,EADJ;MAGH,CAJD,MAIO;QACHG,MAAM,CAACI,YAAD,CAAN,CAAqB,KAAKP,YAA1B;MACH;IACJ,CARD,MAQO;MACH,IAAIG,MAAM,CAACI,YAAD,CAAV,EACI,KAAKD,wBAAL,CACIH,MAAM,CAACI,YAAD,CADV,EAEIE,aAFJ;IAIP;EACJ;;AAzG8B","names":["EntityListenerMetadata","constructor","options","entityMetadata","embeddedMetadata","target","args","propertyName","type","isAllowed","entity","prototype","execute","callEntityEmbeddedMethod","propertyPath","split","propertyPaths","shift","length","Array","isArray","map","embedded"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\metadata\\EntityListenerMetadata.ts"],"sourcesContent":["import { EventListenerType } from \"./types/EventListenerTypes\"\nimport { EntityListenerMetadataArgs } from \"../metadata-args/EntityListenerMetadataArgs\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { EntityMetadata } from \"./EntityMetadata\"\nimport { EmbeddedMetadata } from \"./EmbeddedMetadata\"\n\n/**\n * This metadata contains all information about entity's listeners.\n */\nexport class EntityListenerMetadata {\n    // ---------------------------------------------------------------------\n    // Properties\n    // ---------------------------------------------------------------------\n\n    /**\n     * Entity metadata of the listener.\n     */\n    entityMetadata: EntityMetadata\n\n    /**\n     * Embedded metadata of the listener, in the case if listener is in embedded.\n     */\n    embeddedMetadata?: EmbeddedMetadata\n\n    /**\n     * Target class to which metadata is applied.\n     * This can be different then entityMetadata.target in the case if listener is in the embedded.\n     */\n    target: Function | string\n\n    /**\n     * Target's property name to which this metadata is applied.\n     */\n    propertyName: string\n\n    /**\n     * The type of the listener.\n     */\n    type: EventListenerType\n\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(options: {\n        entityMetadata: EntityMetadata\n        embeddedMetadata?: EmbeddedMetadata\n        args: EntityListenerMetadataArgs\n    }) {\n        this.entityMetadata = options.entityMetadata\n        this.embeddedMetadata = options.embeddedMetadata\n        this.target = options.args.target\n        this.propertyName = options.args.propertyName\n        this.type = options.args.type\n    }\n\n    // ---------------------------------------------------------------------\n    // Public Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Checks if entity listener is allowed to be executed on the given entity.\n     */\n    isAllowed(entity: ObjectLiteral) {\n        // todo: create in entity metadata method like isInherited?\n        return (\n            this.entityMetadata.target === entity.constructor || // todo: .constructor won't work for entity schemas, but there are no entity listeners in schemas since there are no objects, right?\n            (typeof this.entityMetadata.target === \"function\" &&\n                entity.constructor.prototype instanceof\n                    this.entityMetadata.target)\n        ) // todo: also need to implement entity schema inheritance\n    }\n\n    /**\n     * Executes listener method of the given entity.\n     */\n    execute(entity: ObjectLiteral) {\n        if (!this.embeddedMetadata) return entity[this.propertyName]()\n\n        this.callEntityEmbeddedMethod(\n            entity,\n            this.embeddedMetadata.propertyPath.split(\".\"),\n        )\n    }\n\n    // ---------------------------------------------------------------------\n    // Protected Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Calls embedded entity listener method no matter how nested it is.\n     */\n    protected callEntityEmbeddedMethod(\n        entity: ObjectLiteral,\n        propertyPaths: string[],\n    ): void {\n        const propertyPath = propertyPaths.shift()\n        if (!propertyPath || !entity[propertyPath]) return\n\n        if (propertyPaths.length === 0) {\n            if (Array.isArray(entity[propertyPath])) {\n                entity[propertyPath].map((embedded: ObjectLiteral) =>\n                    embedded[this.propertyName](),\n                )\n            } else {\n                entity[propertyPath][this.propertyName]()\n            }\n        } else {\n            if (entity[propertyPath])\n                this.callEntityEmbeddedMethod(\n                    entity[propertyPath],\n                    propertyPaths,\n                )\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}