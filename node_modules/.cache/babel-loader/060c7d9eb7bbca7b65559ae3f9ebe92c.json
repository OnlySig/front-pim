{"ast":null,"code":"import { QueryRunnerAlreadyReleasedError } from \"../../error/QueryRunnerAlreadyReleasedError\";\nimport { QueryFailedError } from \"../../error/QueryFailedError\";\nimport { AbstractSqliteQueryRunner } from \"../sqlite-abstract/AbstractSqliteQueryRunner\";\nimport { Broadcaster } from \"../../subscriber/Broadcaster\";\nimport { QueryResult } from \"../../query-runner/QueryResult\";\n/**\n * Runs queries on a single sqlite database connection.\n */\n\nexport class NativescriptQueryRunner extends AbstractSqliteQueryRunner {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(driver) {\n    super();\n    this.driver = driver;\n    this.connection = driver.connection;\n    this.broadcaster = new Broadcaster(this);\n  }\n  /**\n   * Called before migrations are run.\n   */\n\n\n  async beforeMigration() {\n    await this.query(`PRAGMA foreign_keys = OFF`);\n  }\n  /**\n   * Called after migrations are run.\n   */\n\n\n  async afterMigration() {\n    await this.query(`PRAGMA foreign_keys = ON`);\n  }\n  /**\n   * Executes a given SQL query.\n   */\n\n\n  async query(query, parameters) {\n    let useStructuredResult = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    if (this.isReleased) {\n      throw new QueryRunnerAlreadyReleasedError();\n    }\n\n    const connection = this.driver.connection;\n    return new Promise(async (ok, fail) => {\n      const databaseConnection = await this.connect();\n      const isInsertQuery = query.substr(0, 11) === \"INSERT INTO\";\n      connection.logger.logQuery(query, parameters, this);\n\n      const handler = (err, raw) => {\n        // log slow queries if maxQueryExecution time is set\n        const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;\n        const queryEndTime = +new Date();\n        const queryExecutionTime = queryEndTime - queryStartTime;\n\n        if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) {\n          connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);\n        }\n\n        if (err) {\n          connection.logger.logQueryError(err, query, parameters, this);\n          fail(new QueryFailedError(query, parameters, err));\n        }\n\n        const result = new QueryResult();\n        result.raw = raw;\n\n        if (!isInsertQuery && Array.isArray(raw)) {\n          result.records = raw;\n        }\n\n        if (useStructuredResult) {\n          ok(result);\n        } else {\n          ok(result.raw);\n        }\n      };\n\n      const queryStartTime = +new Date();\n\n      if (isInsertQuery) {\n        databaseConnection.execSQL(query, parameters, handler);\n      } else {\n        databaseConnection.all(query, parameters, handler);\n      }\n    });\n  } // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Parametrizes given object of values. Used to create column=value queries.\n   */\n\n\n  parametrize(objectLiteral) {\n    let startIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return Object.keys(objectLiteral).map((key, index) => `\"${key}\"` + \"=?\");\n  }\n\n}","map":{"version":3,"mappings":"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","names":["QueryRunnerAlreadyReleasedError","QueryFailedError","AbstractSqliteQueryRunner","Broadcaster","QueryResult","NativescriptQueryRunner","constructor","driver","connection","broadcaster","beforeMigration","query","afterMigration","parameters","useStructuredResult","isReleased","Promise","ok","fail","databaseConnection","connect","isInsertQuery","substr","logger","logQuery","handler","err","raw","maxQueryExecutionTime","options","queryEndTime","Date","queryExecutionTime","queryStartTime","logQuerySlow","logQueryError","result","Array","isArray","records","execSQL","all","parametrize","objectLiteral","startIndex","Object","keys","map","key","index"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\driver\\nativescript\\NativescriptQueryRunner.ts"],"sourcesContent":["import { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { QueryRunnerAlreadyReleasedError } from \"../../error/QueryRunnerAlreadyReleasedError\"\nimport { QueryFailedError } from \"../../error/QueryFailedError\"\nimport { AbstractSqliteQueryRunner } from \"../sqlite-abstract/AbstractSqliteQueryRunner\"\nimport { NativescriptDriver } from \"./NativescriptDriver\"\nimport { Broadcaster } from \"../../subscriber/Broadcaster\"\nimport { QueryResult } from \"../../query-runner/QueryResult\"\n\n/**\n * Runs queries on a single sqlite database connection.\n */\nexport class NativescriptQueryRunner extends AbstractSqliteQueryRunner {\n    /**\n     * Database driver used by connection.\n     */\n    driver: NativescriptDriver\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(driver: NativescriptDriver) {\n        super()\n        this.driver = driver\n        this.connection = driver.connection\n        this.broadcaster = new Broadcaster(this)\n    }\n\n    /**\n     * Called before migrations are run.\n     */\n    async beforeMigration(): Promise<void> {\n        await this.query(`PRAGMA foreign_keys = OFF`)\n    }\n\n    /**\n     * Called after migrations are run.\n     */\n    async afterMigration(): Promise<void> {\n        await this.query(`PRAGMA foreign_keys = ON`)\n    }\n\n    /**\n     * Executes a given SQL query.\n     */\n    async query(\n        query: string,\n        parameters?: any[],\n        useStructuredResult = false,\n    ): Promise<any> {\n        if (this.isReleased) {\n            throw new QueryRunnerAlreadyReleasedError()\n        }\n\n        const connection = this.driver.connection\n\n        return new Promise(async (ok, fail) => {\n            const databaseConnection = await this.connect()\n            const isInsertQuery = query.substr(0, 11) === \"INSERT INTO\"\n            connection.logger.logQuery(query, parameters, this)\n\n            const handler = (err: any, raw: any) => {\n                // log slow queries if maxQueryExecution time is set\n                const maxQueryExecutionTime =\n                    this.driver.options.maxQueryExecutionTime\n                const queryEndTime = +new Date()\n                const queryExecutionTime = queryEndTime - queryStartTime\n\n                if (\n                    maxQueryExecutionTime &&\n                    queryExecutionTime > maxQueryExecutionTime\n                ) {\n                    connection.logger.logQuerySlow(\n                        queryExecutionTime,\n                        query,\n                        parameters,\n                        this,\n                    )\n                }\n\n                if (err) {\n                    connection.logger.logQueryError(\n                        err,\n                        query,\n                        parameters,\n                        this,\n                    )\n                    fail(new QueryFailedError(query, parameters, err))\n                }\n\n                const result = new QueryResult()\n                result.raw = raw\n\n                if (!isInsertQuery && Array.isArray(raw)) {\n                    result.records = raw\n                }\n\n                if (useStructuredResult) {\n                    ok(result)\n                } else {\n                    ok(result.raw)\n                }\n            }\n            const queryStartTime = +new Date()\n\n            if (isInsertQuery) {\n                databaseConnection.execSQL(query, parameters, handler)\n            } else {\n                databaseConnection.all(query, parameters, handler)\n            }\n        })\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Parametrizes given object of values. Used to create column=value queries.\n     */\n    protected parametrize(\n        objectLiteral: ObjectLiteral,\n        startIndex: number = 0,\n    ): string[] {\n        return Object.keys(objectLiteral).map((key, index) => `\"${key}\"` + \"=?\")\n    }\n}\n"]},"metadata":{},"sourceType":"module"}