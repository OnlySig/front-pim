{"ast":null,"code":"import { DriverUtils } from \"../driver/DriverUtils\";\nimport { TypeORMError } from \"../error/TypeORMError\";\nimport { FindOptionsUtils } from \"../find-options/FindOptionsUtils\";\nimport { TreeRepositoryUtils } from \"../util/TreeRepositoryUtils\";\nimport { Repository } from \"./Repository\";\n/**\n * Repository with additional functions to work with trees.\n *\n * @see Repository\n */\n\nexport class TreeRepository extends Repository {\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Gets complete trees for all roots in the table.\n   */\n  async findTrees(options) {\n    const roots = await this.findRoots(options);\n    await Promise.all(roots.map(root => this.findDescendantsTree(root, options)));\n    return roots;\n  }\n  /**\n   * Roots are entities that have no ancestors. Finds them all.\n   */\n\n\n  findRoots(options) {\n    const escapeAlias = alias => this.manager.connection.driver.escape(alias);\n\n    const escapeColumn = column => this.manager.connection.driver.escape(column);\n\n    const joinColumn = this.metadata.treeParentRelation.joinColumns[0];\n    const parentPropertyName = joinColumn.givenDatabaseName || joinColumn.databaseName;\n    const qb = this.createQueryBuilder(\"treeEntity\");\n    FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options);\n    return qb.where(`${escapeAlias(\"treeEntity\")}.${escapeColumn(parentPropertyName)} IS NULL`).getMany();\n  }\n  /**\n   * Gets all children (descendants) of the given entity. Returns them all in a flat array.\n   */\n\n\n  findDescendants(entity, options) {\n    const qb = this.createDescendantsQueryBuilder(\"treeEntity\", \"treeClosure\", entity);\n    FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options);\n    return qb.getMany();\n  }\n  /**\n   * Gets all children (descendants) of the given entity. Returns them in a tree - nested into each other.\n   */\n\n\n  async findDescendantsTree(entity, options) {\n    // todo: throw exception if there is no column of this relation?\n    const qb = this.createDescendantsQueryBuilder(\"treeEntity\", \"treeClosure\", entity);\n    FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options);\n    const entities = await qb.getRawAndEntities();\n    const relationMaps = TreeRepositoryUtils.createRelationMaps(this.manager, this.metadata, \"treeEntity\", entities.raw);\n    TreeRepositoryUtils.buildChildrenEntityTree(this.metadata, entity, entities.entities, relationMaps, {\n      depth: -1,\n      ...options\n    });\n    return entity;\n  }\n  /**\n   * Gets number of descendants of the entity.\n   */\n\n\n  countDescendants(entity) {\n    return this.createDescendantsQueryBuilder(\"treeEntity\", \"treeClosure\", entity).getCount();\n  }\n  /**\n   * Creates a query builder used to get descendants of the entities in a tree.\n   */\n\n\n  createDescendantsQueryBuilder(alias, closureTableAlias, entity) {\n    // create shortcuts for better readability\n    const escape = alias => this.manager.connection.driver.escape(alias);\n\n    if (this.metadata.treeType === \"closure-table\") {\n      const joinCondition = this.metadata.closureJunctionTable.descendantColumns.map(column => {\n        return escape(closureTableAlias) + \".\" + escape(column.propertyPath) + \" = \" + escape(alias) + \".\" + escape(column.referencedColumn.propertyPath);\n      }).join(\" AND \");\n      const parameters = {};\n      const whereCondition = this.metadata.closureJunctionTable.ancestorColumns.map(column => {\n        parameters[column.referencedColumn.propertyName] = column.referencedColumn.getEntityValue(entity);\n        return escape(closureTableAlias) + \".\" + escape(column.propertyPath) + \" = :\" + column.referencedColumn.propertyName;\n      }).join(\" AND \");\n      return this.createQueryBuilder(alias).innerJoin(this.metadata.closureJunctionTable.tableName, closureTableAlias, joinCondition).where(whereCondition).setParameters(parameters);\n    } else if (this.metadata.treeType === \"nested-set\") {\n      const whereCondition = alias + \".\" + this.metadata.nestedSetLeftColumn.propertyPath + \" BETWEEN \" + \"joined.\" + this.metadata.nestedSetLeftColumn.propertyPath + \" AND joined.\" + this.metadata.nestedSetRightColumn.propertyPath;\n      const parameters = {};\n      const joinCondition = this.metadata.treeParentRelation.joinColumns.map(joinColumn => {\n        const parameterName = joinColumn.referencedColumn.propertyPath.replace(\".\", \"_\");\n        parameters[parameterName] = joinColumn.referencedColumn.getEntityValue(entity);\n        return \"joined.\" + joinColumn.referencedColumn.propertyPath + \" = :\" + parameterName;\n      }).join(\" AND \");\n      return this.createQueryBuilder(alias).innerJoin(this.metadata.targetName, \"joined\", whereCondition).where(joinCondition, parameters);\n    } else if (this.metadata.treeType === \"materialized-path\") {\n      return this.createQueryBuilder(alias).where(qb => {\n        const subQuery = qb.subQuery().select(`${this.metadata.targetName}.${this.metadata.materializedPathColumn.propertyPath}`, \"path\").from(this.metadata.target, this.metadata.targetName).whereInIds(this.metadata.getEntityIdMap(entity));\n\n        if (DriverUtils.isSQLiteFamily(this.manager.connection.driver)) {\n          return `${alias}.${this.metadata.materializedPathColumn.propertyPath} LIKE ${subQuery.getQuery()} || '%'`;\n        } else {\n          return `${alias}.${this.metadata.materializedPathColumn.propertyPath} LIKE NULLIF(CONCAT(${subQuery.getQuery()}, '%'), '%')`;\n        }\n      });\n    }\n\n    throw new TypeORMError(`Supported only in tree entities`);\n  }\n  /**\n   * Gets all parents (ancestors) of the given entity. Returns them all in a flat array.\n   */\n\n\n  findAncestors(entity, options) {\n    const qb = this.createAncestorsQueryBuilder(\"treeEntity\", \"treeClosure\", entity);\n    FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options);\n    return qb.getMany();\n  }\n  /**\n   * Gets all parents (ancestors) of the given entity. Returns them in a tree - nested into each other.\n   */\n\n\n  async findAncestorsTree(entity, options) {\n    // todo: throw exception if there is no column of this relation?\n    const qb = this.createAncestorsQueryBuilder(\"treeEntity\", \"treeClosure\", entity);\n    FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options);\n    const entities = await qb.getRawAndEntities();\n    const relationMaps = TreeRepositoryUtils.createRelationMaps(this.manager, this.metadata, \"treeEntity\", entities.raw);\n    TreeRepositoryUtils.buildParentEntityTree(this.metadata, entity, entities.entities, relationMaps);\n    return entity;\n  }\n  /**\n   * Gets number of ancestors of the entity.\n   */\n\n\n  countAncestors(entity) {\n    return this.createAncestorsQueryBuilder(\"treeEntity\", \"treeClosure\", entity).getCount();\n  }\n  /**\n   * Creates a query builder used to get ancestors of the entities in the tree.\n   */\n\n\n  createAncestorsQueryBuilder(alias, closureTableAlias, entity) {\n    // create shortcuts for better readability\n    // const escape = (alias: string) => this.manager.connection.driver.escape(alias);\n    if (this.metadata.treeType === \"closure-table\") {\n      const joinCondition = this.metadata.closureJunctionTable.ancestorColumns.map(column => {\n        return closureTableAlias + \".\" + column.propertyPath + \" = \" + alias + \".\" + column.referencedColumn.propertyPath;\n      }).join(\" AND \");\n      const parameters = {};\n      const whereCondition = this.metadata.closureJunctionTable.descendantColumns.map(column => {\n        parameters[column.referencedColumn.propertyName] = column.referencedColumn.getEntityValue(entity);\n        return closureTableAlias + \".\" + column.propertyPath + \" = :\" + column.referencedColumn.propertyName;\n      }).join(\" AND \");\n      return this.createQueryBuilder(alias).innerJoin(this.metadata.closureJunctionTable.tableName, closureTableAlias, joinCondition).where(whereCondition).setParameters(parameters);\n    } else if (this.metadata.treeType === \"nested-set\") {\n      const joinCondition = \"joined.\" + this.metadata.nestedSetLeftColumn.propertyPath + \" BETWEEN \" + alias + \".\" + this.metadata.nestedSetLeftColumn.propertyPath + \" AND \" + alias + \".\" + this.metadata.nestedSetRightColumn.propertyPath;\n      const parameters = {};\n      const whereCondition = this.metadata.treeParentRelation.joinColumns.map(joinColumn => {\n        const parameterName = joinColumn.referencedColumn.propertyPath.replace(\".\", \"_\");\n        parameters[parameterName] = joinColumn.referencedColumn.getEntityValue(entity);\n        return \"joined.\" + joinColumn.referencedColumn.propertyPath + \" = :\" + parameterName;\n      }).join(\" AND \");\n      return this.createQueryBuilder(alias).innerJoin(this.metadata.targetName, \"joined\", joinCondition).where(whereCondition, parameters);\n    } else if (this.metadata.treeType === \"materialized-path\") {\n      // example: SELECT * FROM category category WHERE (SELECT mpath FROM `category` WHERE id = 2) LIKE CONCAT(category.mpath, '%');\n      return this.createQueryBuilder(alias).where(qb => {\n        const subQuery = qb.subQuery().select(`${this.metadata.targetName}.${this.metadata.materializedPathColumn.propertyPath}`, \"path\").from(this.metadata.target, this.metadata.targetName).whereInIds(this.metadata.getEntityIdMap(entity));\n\n        if (DriverUtils.isSQLiteFamily(this.manager.connection.driver)) {\n          return `${subQuery.getQuery()} LIKE ${alias}.${this.metadata.materializedPathColumn.propertyPath} || '%'`;\n        } else {\n          return `${subQuery.getQuery()} LIKE CONCAT(${alias}.${this.metadata.materializedPathColumn.propertyPath}, '%')`;\n        }\n      });\n    }\n\n    throw new TypeORMError(`Supported only in tree entities`);\n  }\n  /**\n   * Extends tree repository with provided functions.\n   */\n\n\n  extend(custom) {\n    const thisRepo = this.constructor;\n    const {\n      target,\n      manager,\n      queryRunner\n    } = this;\n    const cls = new class extends thisRepo {}(target, manager, queryRunner);\n    Object.assign(cls, custom);\n    return cls;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["DriverUtils","TypeORMError","FindOptionsUtils","TreeRepositoryUtils","Repository","TreeRepository","findTrees","options","roots","findRoots","Promise","all","map","root","findDescendantsTree","escapeAlias","alias","manager","connection","driver","escape","escapeColumn","column","joinColumn","metadata","treeParentRelation","joinColumns","parentPropertyName","givenDatabaseName","databaseName","qb","createQueryBuilder","applyOptionsToTreeQueryBuilder","where","getMany","findDescendants","entity","createDescendantsQueryBuilder","entities","getRawAndEntities","relationMaps","createRelationMaps","raw","buildChildrenEntityTree","depth","countDescendants","getCount","closureTableAlias","treeType","joinCondition","closureJunctionTable","descendantColumns","propertyPath","referencedColumn","join","parameters","whereCondition","ancestorColumns","propertyName","getEntityValue","innerJoin","tableName","setParameters","nestedSetLeftColumn","nestedSetRightColumn","parameterName","replace","targetName","subQuery","select","materializedPathColumn","from","target","whereInIds","getEntityIdMap","isSQLiteFamily","getQuery","findAncestors","createAncestorsQueryBuilder","findAncestorsTree","buildParentEntityTree","countAncestors","extend","custom","thisRepo","constructor","queryRunner","cls","Object","assign"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\repository\\TreeRepository.ts"],"sourcesContent":["import { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { DriverUtils } from \"../driver/DriverUtils\"\nimport { TypeORMError } from \"../error/TypeORMError\"\nimport { FindOptionsUtils } from \"../find-options/FindOptionsUtils\"\nimport { FindTreeOptions } from \"../find-options/FindTreeOptions\"\nimport { SelectQueryBuilder } from \"../query-builder/SelectQueryBuilder\"\nimport { TreeRepositoryUtils } from \"../util/TreeRepositoryUtils\"\nimport { Repository } from \"./Repository\"\n\n/**\n * Repository with additional functions to work with trees.\n *\n * @see Repository\n */\nexport class TreeRepository<\n    Entity extends ObjectLiteral,\n> extends Repository<Entity> {\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets complete trees for all roots in the table.\n     */\n    async findTrees(options?: FindTreeOptions): Promise<Entity[]> {\n        const roots = await this.findRoots(options)\n        await Promise.all(\n            roots.map((root) => this.findDescendantsTree(root, options)),\n        )\n        return roots\n    }\n\n    /**\n     * Roots are entities that have no ancestors. Finds them all.\n     */\n    findRoots(options?: FindTreeOptions): Promise<Entity[]> {\n        const escapeAlias = (alias: string) =>\n            this.manager.connection.driver.escape(alias)\n        const escapeColumn = (column: string) =>\n            this.manager.connection.driver.escape(column)\n\n        const joinColumn = this.metadata.treeParentRelation!.joinColumns[0]\n        const parentPropertyName =\n            joinColumn.givenDatabaseName || joinColumn.databaseName\n\n        const qb = this.createQueryBuilder(\"treeEntity\")\n        FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options)\n\n        return qb\n            .where(\n                `${escapeAlias(\"treeEntity\")}.${escapeColumn(\n                    parentPropertyName,\n                )} IS NULL`,\n            )\n            .getMany()\n    }\n\n    /**\n     * Gets all children (descendants) of the given entity. Returns them all in a flat array.\n     */\n    findDescendants(\n        entity: Entity,\n        options?: FindTreeOptions,\n    ): Promise<Entity[]> {\n        const qb = this.createDescendantsQueryBuilder(\n            \"treeEntity\",\n            \"treeClosure\",\n            entity,\n        )\n        FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options)\n        return qb.getMany()\n    }\n\n    /**\n     * Gets all children (descendants) of the given entity. Returns them in a tree - nested into each other.\n     */\n    async findDescendantsTree(\n        entity: Entity,\n        options?: FindTreeOptions,\n    ): Promise<Entity> {\n        // todo: throw exception if there is no column of this relation?\n\n        const qb: SelectQueryBuilder<Entity> =\n            this.createDescendantsQueryBuilder(\n                \"treeEntity\",\n                \"treeClosure\",\n                entity,\n            )\n        FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options)\n\n        const entities = await qb.getRawAndEntities()\n        const relationMaps = TreeRepositoryUtils.createRelationMaps(\n            this.manager,\n            this.metadata,\n            \"treeEntity\",\n            entities.raw,\n        )\n        TreeRepositoryUtils.buildChildrenEntityTree(\n            this.metadata,\n            entity,\n            entities.entities,\n            relationMaps,\n            {\n                depth: -1,\n                ...options,\n            },\n        )\n\n        return entity\n    }\n\n    /**\n     * Gets number of descendants of the entity.\n     */\n    countDescendants(entity: Entity): Promise<number> {\n        return this.createDescendantsQueryBuilder(\n            \"treeEntity\",\n            \"treeClosure\",\n            entity,\n        ).getCount()\n    }\n\n    /**\n     * Creates a query builder used to get descendants of the entities in a tree.\n     */\n    createDescendantsQueryBuilder(\n        alias: string,\n        closureTableAlias: string,\n        entity: Entity,\n    ): SelectQueryBuilder<Entity> {\n        // create shortcuts for better readability\n        const escape = (alias: string) =>\n            this.manager.connection.driver.escape(alias)\n\n        if (this.metadata.treeType === \"closure-table\") {\n            const joinCondition =\n                this.metadata.closureJunctionTable.descendantColumns\n                    .map((column) => {\n                        return (\n                            escape(closureTableAlias) +\n                            \".\" +\n                            escape(column.propertyPath) +\n                            \" = \" +\n                            escape(alias) +\n                            \".\" +\n                            escape(column.referencedColumn!.propertyPath)\n                        )\n                    })\n                    .join(\" AND \")\n\n            const parameters: ObjectLiteral = {}\n            const whereCondition =\n                this.metadata.closureJunctionTable.ancestorColumns\n                    .map((column) => {\n                        parameters[column.referencedColumn!.propertyName] =\n                            column.referencedColumn!.getEntityValue(entity)\n                        return (\n                            escape(closureTableAlias) +\n                            \".\" +\n                            escape(column.propertyPath) +\n                            \" = :\" +\n                            column.referencedColumn!.propertyName\n                        )\n                    })\n                    .join(\" AND \")\n\n            return this.createQueryBuilder(alias)\n                .innerJoin(\n                    this.metadata.closureJunctionTable.tableName,\n                    closureTableAlias,\n                    joinCondition,\n                )\n                .where(whereCondition)\n                .setParameters(parameters)\n        } else if (this.metadata.treeType === \"nested-set\") {\n            const whereCondition =\n                alias +\n                \".\" +\n                this.metadata.nestedSetLeftColumn!.propertyPath +\n                \" BETWEEN \" +\n                \"joined.\" +\n                this.metadata.nestedSetLeftColumn!.propertyPath +\n                \" AND joined.\" +\n                this.metadata.nestedSetRightColumn!.propertyPath\n            const parameters: ObjectLiteral = {}\n            const joinCondition = this.metadata\n                .treeParentRelation!.joinColumns.map((joinColumn) => {\n                    const parameterName =\n                        joinColumn.referencedColumn!.propertyPath.replace(\n                            \".\",\n                            \"_\",\n                        )\n                    parameters[parameterName] =\n                        joinColumn.referencedColumn!.getEntityValue(entity)\n                    return (\n                        \"joined.\" +\n                        joinColumn.referencedColumn!.propertyPath +\n                        \" = :\" +\n                        parameterName\n                    )\n                })\n                .join(\" AND \")\n\n            return this.createQueryBuilder(alias)\n                .innerJoin(this.metadata.targetName, \"joined\", whereCondition)\n                .where(joinCondition, parameters)\n        } else if (this.metadata.treeType === \"materialized-path\") {\n            return this.createQueryBuilder(alias).where((qb) => {\n                const subQuery = qb\n                    .subQuery()\n                    .select(\n                        `${this.metadata.targetName}.${\n                            this.metadata.materializedPathColumn!.propertyPath\n                        }`,\n                        \"path\",\n                    )\n                    .from(this.metadata.target, this.metadata.targetName)\n                    .whereInIds(this.metadata.getEntityIdMap(entity))\n\n                if (\n                    DriverUtils.isSQLiteFamily(this.manager.connection.driver)\n                ) {\n                    return `${alias}.${\n                        this.metadata.materializedPathColumn!.propertyPath\n                    } LIKE ${subQuery.getQuery()} || '%'`\n                } else {\n                    return `${alias}.${\n                        this.metadata.materializedPathColumn!.propertyPath\n                    } LIKE NULLIF(CONCAT(${subQuery.getQuery()}, '%'), '%')`\n                }\n            })\n        }\n\n        throw new TypeORMError(`Supported only in tree entities`)\n    }\n\n    /**\n     * Gets all parents (ancestors) of the given entity. Returns them all in a flat array.\n     */\n    findAncestors(\n        entity: Entity,\n        options?: FindTreeOptions,\n    ): Promise<Entity[]> {\n        const qb = this.createAncestorsQueryBuilder(\n            \"treeEntity\",\n            \"treeClosure\",\n            entity,\n        )\n        FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options)\n        return qb.getMany()\n    }\n\n    /**\n     * Gets all parents (ancestors) of the given entity. Returns them in a tree - nested into each other.\n     */\n    async findAncestorsTree(\n        entity: Entity,\n        options?: FindTreeOptions,\n    ): Promise<Entity> {\n        // todo: throw exception if there is no column of this relation?\n        const qb = this.createAncestorsQueryBuilder(\n            \"treeEntity\",\n            \"treeClosure\",\n            entity,\n        )\n        FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options)\n\n        const entities = await qb.getRawAndEntities()\n        const relationMaps = TreeRepositoryUtils.createRelationMaps(\n            this.manager,\n            this.metadata,\n            \"treeEntity\",\n            entities.raw,\n        )\n        TreeRepositoryUtils.buildParentEntityTree(\n            this.metadata,\n            entity,\n            entities.entities,\n            relationMaps,\n        )\n        return entity\n    }\n\n    /**\n     * Gets number of ancestors of the entity.\n     */\n    countAncestors(entity: Entity): Promise<number> {\n        return this.createAncestorsQueryBuilder(\n            \"treeEntity\",\n            \"treeClosure\",\n            entity,\n        ).getCount()\n    }\n\n    /**\n     * Creates a query builder used to get ancestors of the entities in the tree.\n     */\n    createAncestorsQueryBuilder(\n        alias: string,\n        closureTableAlias: string,\n        entity: Entity,\n    ): SelectQueryBuilder<Entity> {\n        // create shortcuts for better readability\n        // const escape = (alias: string) => this.manager.connection.driver.escape(alias);\n\n        if (this.metadata.treeType === \"closure-table\") {\n            const joinCondition =\n                this.metadata.closureJunctionTable.ancestorColumns\n                    .map((column) => {\n                        return (\n                            closureTableAlias +\n                            \".\" +\n                            column.propertyPath +\n                            \" = \" +\n                            alias +\n                            \".\" +\n                            column.referencedColumn!.propertyPath\n                        )\n                    })\n                    .join(\" AND \")\n\n            const parameters: ObjectLiteral = {}\n            const whereCondition =\n                this.metadata.closureJunctionTable.descendantColumns\n                    .map((column) => {\n                        parameters[column.referencedColumn!.propertyName] =\n                            column.referencedColumn!.getEntityValue(entity)\n                        return (\n                            closureTableAlias +\n                            \".\" +\n                            column.propertyPath +\n                            \" = :\" +\n                            column.referencedColumn!.propertyName\n                        )\n                    })\n                    .join(\" AND \")\n\n            return this.createQueryBuilder(alias)\n                .innerJoin(\n                    this.metadata.closureJunctionTable.tableName,\n                    closureTableAlias,\n                    joinCondition,\n                )\n                .where(whereCondition)\n                .setParameters(parameters)\n        } else if (this.metadata.treeType === \"nested-set\") {\n            const joinCondition =\n                \"joined.\" +\n                this.metadata.nestedSetLeftColumn!.propertyPath +\n                \" BETWEEN \" +\n                alias +\n                \".\" +\n                this.metadata.nestedSetLeftColumn!.propertyPath +\n                \" AND \" +\n                alias +\n                \".\" +\n                this.metadata.nestedSetRightColumn!.propertyPath\n            const parameters: ObjectLiteral = {}\n            const whereCondition = this.metadata\n                .treeParentRelation!.joinColumns.map((joinColumn) => {\n                    const parameterName =\n                        joinColumn.referencedColumn!.propertyPath.replace(\n                            \".\",\n                            \"_\",\n                        )\n                    parameters[parameterName] =\n                        joinColumn.referencedColumn!.getEntityValue(entity)\n                    return (\n                        \"joined.\" +\n                        joinColumn.referencedColumn!.propertyPath +\n                        \" = :\" +\n                        parameterName\n                    )\n                })\n                .join(\" AND \")\n\n            return this.createQueryBuilder(alias)\n                .innerJoin(this.metadata.targetName, \"joined\", joinCondition)\n                .where(whereCondition, parameters)\n        } else if (this.metadata.treeType === \"materialized-path\") {\n            // example: SELECT * FROM category category WHERE (SELECT mpath FROM `category` WHERE id = 2) LIKE CONCAT(category.mpath, '%');\n            return this.createQueryBuilder(alias).where((qb) => {\n                const subQuery = qb\n                    .subQuery()\n                    .select(\n                        `${this.metadata.targetName}.${\n                            this.metadata.materializedPathColumn!.propertyPath\n                        }`,\n                        \"path\",\n                    )\n                    .from(this.metadata.target, this.metadata.targetName)\n                    .whereInIds(this.metadata.getEntityIdMap(entity))\n\n                if (\n                    DriverUtils.isSQLiteFamily(this.manager.connection.driver)\n                ) {\n                    return `${subQuery.getQuery()} LIKE ${alias}.${\n                        this.metadata.materializedPathColumn!.propertyPath\n                    } || '%'`\n                } else {\n                    return `${subQuery.getQuery()} LIKE CONCAT(${alias}.${\n                        this.metadata.materializedPathColumn!.propertyPath\n                    }, '%')`\n                }\n            })\n        }\n\n        throw new TypeORMError(`Supported only in tree entities`)\n    }\n\n    /**\n     * Extends tree repository with provided functions.\n     */\n    extend<CustomRepository>(\n        custom: CustomRepository &\n            ThisType<TreeRepository<Entity> & CustomRepository>,\n    ): TreeRepository<Entity> & CustomRepository {\n        const thisRepo = this.constructor as new (...args: any[]) => typeof this\n        const { target, manager, queryRunner } = this\n        const cls = new (class extends thisRepo {})(\n            target,\n            manager,\n            queryRunner,\n        )\n        Object.assign(cls, custom)\n        return cls as any\n    }\n\n    /**\n     * Moves entity to the children of then given entity.\n     *\n    move(entity: Entity, to: Entity): Promise<void> {\n        return Promise.resolve();\n    } */\n}\n"]},"metadata":{},"sourceType":"module"}