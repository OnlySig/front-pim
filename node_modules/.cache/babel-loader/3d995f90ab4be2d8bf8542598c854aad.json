{"ast":null,"code":"import { QueryBuilder } from \"./QueryBuilder\";\nimport { RelationUpdater } from \"./RelationUpdater\";\nimport { RelationRemover } from \"./RelationRemover\";\nimport { TypeORMError } from \"../error\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\n/**\n * Allows to work with entity relations and perform specific operations with those relations.\n *\n * todo: add transactions everywhere\n */\n\nexport class RelationQueryBuilder extends QueryBuilder {\n  constructor() {\n    super(...arguments);\n    this[\"@instanceof\"] = Symbol.for(\"RelationQueryBuilder\");\n  } // -------------------------------------------------------------------------\n  // Public Implemented Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Gets generated SQL query without parameters being replaced.\n   */\n\n\n  getQuery() {\n    return \"\";\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Sets entity (target) which relations will be updated.\n   */\n\n\n  of(entity) {\n    this.expressionMap.of = entity;\n    return this;\n  }\n  /**\n   * Sets entity relation's value.\n   * Value can be entity, entity id or entity id map (if entity has composite ids).\n   * Works only for many-to-one and one-to-one relations.\n   * For many-to-many and one-to-many relations use #add and #remove methods instead.\n   */\n\n\n  async set(value) {\n    const relation = this.expressionMap.relationMetadata;\n    if (!this.expressionMap.of) // todo: move this check before relation query builder creation?\n      throw new TypeORMError(`Entity whose relation needs to be set is not set. Use .of method to define whose relation you want to set.`);\n    if (relation.isManyToMany || relation.isOneToMany) throw new TypeORMError(`Set operation is only supported for many-to-one and one-to-one relations. ` + `However given \"${relation.propertyPath}\" has ${relation.relationType} relation. ` + `Use .add() method instead.`); // if there are multiple join columns then user must send id map as \"value\" argument. check if he really did it\n\n    if (relation.joinColumns && relation.joinColumns.length > 1 && (!ObjectUtils.isObject(value) || Object.keys(value).length < relation.joinColumns.length)) throw new TypeORMError(`Value to be set into the relation must be a map of relation ids, for example: .set({ firstName: \"...\", lastName: \"...\" })`);\n    const updater = new RelationUpdater(this, this.expressionMap);\n    return updater.update(value);\n  }\n  /**\n   * Adds (binds) given value to entity relation.\n   * Value can be entity, entity id or entity id map (if entity has composite ids).\n   * Value also can be array of entities, array of entity ids or array of entity id maps (if entity has composite ids).\n   * Works only for many-to-many and one-to-many relations.\n   * For many-to-one and one-to-one use #set method instead.\n   */\n\n\n  async add(value) {\n    if (Array.isArray(value) && value.length === 0) return;\n    const relation = this.expressionMap.relationMetadata;\n    if (!this.expressionMap.of) // todo: move this check before relation query builder creation?\n      throw new TypeORMError(`Entity whose relation needs to be set is not set. Use .of method to define whose relation you want to set.`);\n    if (relation.isManyToOne || relation.isOneToOne) throw new TypeORMError(`Add operation is only supported for many-to-many and one-to-many relations. ` + `However given \"${relation.propertyPath}\" has ${relation.relationType} relation. ` + `Use .set() method instead.`); // if there are multiple join columns then user must send id map as \"value\" argument. check if he really did it\n\n    if (relation.joinColumns && relation.joinColumns.length > 1 && (!ObjectUtils.isObject(value) || Object.keys(value).length < relation.joinColumns.length)) throw new TypeORMError(`Value to be set into the relation must be a map of relation ids, for example: .set({ firstName: \"...\", lastName: \"...\" })`);\n    const updater = new RelationUpdater(this, this.expressionMap);\n    return updater.update(value);\n  }\n  /**\n   * Removes (unbinds) given value from entity relation.\n   * Value can be entity, entity id or entity id map (if entity has composite ids).\n   * Value also can be array of entities, array of entity ids or array of entity id maps (if entity has composite ids).\n   * Works only for many-to-many and one-to-many relations.\n   * For many-to-one and one-to-one use #set method instead.\n   */\n\n\n  async remove(value) {\n    if (Array.isArray(value) && value.length === 0) return;\n    const relation = this.expressionMap.relationMetadata;\n    if (!this.expressionMap.of) // todo: move this check before relation query builder creation?\n      throw new TypeORMError(`Entity whose relation needs to be set is not set. Use .of method to define whose relation you want to set.`);\n    if (relation.isManyToOne || relation.isOneToOne) throw new TypeORMError(`Add operation is only supported for many-to-many and one-to-many relations. ` + `However given \"${relation.propertyPath}\" has ${relation.relationType} relation. ` + `Use .set(null) method instead.`);\n    const remover = new RelationRemover(this, this.expressionMap);\n    return remover.remove(value);\n  }\n  /**\n   * Adds (binds) and removes (unbinds) given values to/from entity relation.\n   * Value can be entity, entity id or entity id map (if entity has composite ids).\n   * Value also can be array of entities, array of entity ids or array of entity id maps (if entity has composite ids).\n   * Works only for many-to-many and one-to-many relations.\n   * For many-to-one and one-to-one use #set method instead.\n   */\n\n\n  async addAndRemove(added, removed) {\n    await this.remove(removed);\n    await this.add(added);\n  }\n  /**\n   * Gets entity's relation id.\n  async getId(): Promise<any> {\n   }*/\n\n  /**\n   * Gets entity's relation ids.\n  async getIds(): Promise<any[]> {\n      return [];\n  }*/\n\n  /**\n   * Loads a single entity (relational) from the relation.\n   * You can also provide id of relational entity to filter by.\n   */\n\n\n  async loadOne() {\n    return this.loadMany().then(results => results[0]);\n  }\n  /**\n   * Loads many entities (relational) from the relation.\n   * You can also provide ids of relational entities to filter by.\n   */\n\n\n  async loadMany() {\n    let of = this.expressionMap.of;\n\n    if (!ObjectUtils.isObject(of)) {\n      const metadata = this.expressionMap.mainAlias.metadata;\n      if (metadata.hasMultiplePrimaryKeys) throw new TypeORMError(`Cannot load entity because only one primary key was specified, however entity contains multiple primary keys`);\n      of = metadata.primaryColumns[0].createValueMap(of);\n    }\n\n    return this.connection.relationLoader.load(this.expressionMap.relationMetadata, of, this.queryRunner);\n  }\n\n}","map":{"version":3,"mappings":"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","names":["QueryBuilder","RelationUpdater","RelationRemover","TypeORMError","ObjectUtils","RelationQueryBuilder","constructor","Symbol","for","getQuery","of","entity","expressionMap","set","value","relation","relationMetadata","isManyToMany","isOneToMany","propertyPath","relationType","joinColumns","length","isObject","Object","keys","updater","update","add","Array","isArray","isManyToOne","isOneToOne","remove","remover","addAndRemove","added","removed","loadOne","loadMany","then","results","metadata","mainAlias","hasMultiplePrimaryKeys","primaryColumns","createValueMap","connection","relationLoader","load","queryRunner"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\query-builder\\RelationQueryBuilder.ts"],"sourcesContent":["import { QueryBuilder } from \"./QueryBuilder\"\nimport { RelationUpdater } from \"./RelationUpdater\"\nimport { RelationRemover } from \"./RelationRemover\"\nimport { TypeORMError } from \"../error\"\nimport { ObjectUtils } from \"../util/ObjectUtils\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\n\n/**\n * Allows to work with entity relations and perform specific operations with those relations.\n *\n * todo: add transactions everywhere\n */\nexport class RelationQueryBuilder<\n    Entity extends ObjectLiteral,\n> extends QueryBuilder<Entity> {\n    readonly \"@instanceof\" = Symbol.for(\"RelationQueryBuilder\")\n\n    // -------------------------------------------------------------------------\n    // Public Implemented Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets generated SQL query without parameters being replaced.\n     */\n    getQuery(): string {\n        return \"\"\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Sets entity (target) which relations will be updated.\n     */\n    of(entity: any | any[]): this {\n        this.expressionMap.of = entity\n        return this\n    }\n\n    /**\n     * Sets entity relation's value.\n     * Value can be entity, entity id or entity id map (if entity has composite ids).\n     * Works only for many-to-one and one-to-one relations.\n     * For many-to-many and one-to-many relations use #add and #remove methods instead.\n     */\n    async set(value: any): Promise<void> {\n        const relation = this.expressionMap.relationMetadata\n\n        if (!this.expressionMap.of)\n            // todo: move this check before relation query builder creation?\n            throw new TypeORMError(\n                `Entity whose relation needs to be set is not set. Use .of method to define whose relation you want to set.`,\n            )\n\n        if (relation.isManyToMany || relation.isOneToMany)\n            throw new TypeORMError(\n                `Set operation is only supported for many-to-one and one-to-one relations. ` +\n                    `However given \"${relation.propertyPath}\" has ${relation.relationType} relation. ` +\n                    `Use .add() method instead.`,\n            )\n\n        // if there are multiple join columns then user must send id map as \"value\" argument. check if he really did it\n        if (\n            relation.joinColumns &&\n            relation.joinColumns.length > 1 &&\n            (!ObjectUtils.isObject(value) ||\n                Object.keys(value).length < relation.joinColumns.length)\n        )\n            throw new TypeORMError(\n                `Value to be set into the relation must be a map of relation ids, for example: .set({ firstName: \"...\", lastName: \"...\" })`,\n            )\n\n        const updater = new RelationUpdater(this, this.expressionMap)\n        return updater.update(value)\n    }\n\n    /**\n     * Adds (binds) given value to entity relation.\n     * Value can be entity, entity id or entity id map (if entity has composite ids).\n     * Value also can be array of entities, array of entity ids or array of entity id maps (if entity has composite ids).\n     * Works only for many-to-many and one-to-many relations.\n     * For many-to-one and one-to-one use #set method instead.\n     */\n    async add(value: any | any[]): Promise<void> {\n        if (Array.isArray(value) && value.length === 0) return\n\n        const relation = this.expressionMap.relationMetadata\n\n        if (!this.expressionMap.of)\n            // todo: move this check before relation query builder creation?\n            throw new TypeORMError(\n                `Entity whose relation needs to be set is not set. Use .of method to define whose relation you want to set.`,\n            )\n\n        if (relation.isManyToOne || relation.isOneToOne)\n            throw new TypeORMError(\n                `Add operation is only supported for many-to-many and one-to-many relations. ` +\n                    `However given \"${relation.propertyPath}\" has ${relation.relationType} relation. ` +\n                    `Use .set() method instead.`,\n            )\n\n        // if there are multiple join columns then user must send id map as \"value\" argument. check if he really did it\n        if (\n            relation.joinColumns &&\n            relation.joinColumns.length > 1 &&\n            (!ObjectUtils.isObject(value) ||\n                Object.keys(value).length < relation.joinColumns.length)\n        )\n            throw new TypeORMError(\n                `Value to be set into the relation must be a map of relation ids, for example: .set({ firstName: \"...\", lastName: \"...\" })`,\n            )\n\n        const updater = new RelationUpdater(this, this.expressionMap)\n        return updater.update(value)\n    }\n\n    /**\n     * Removes (unbinds) given value from entity relation.\n     * Value can be entity, entity id or entity id map (if entity has composite ids).\n     * Value also can be array of entities, array of entity ids or array of entity id maps (if entity has composite ids).\n     * Works only for many-to-many and one-to-many relations.\n     * For many-to-one and one-to-one use #set method instead.\n     */\n    async remove(value: any | any[]): Promise<void> {\n        if (Array.isArray(value) && value.length === 0) return\n\n        const relation = this.expressionMap.relationMetadata\n\n        if (!this.expressionMap.of)\n            // todo: move this check before relation query builder creation?\n            throw new TypeORMError(\n                `Entity whose relation needs to be set is not set. Use .of method to define whose relation you want to set.`,\n            )\n\n        if (relation.isManyToOne || relation.isOneToOne)\n            throw new TypeORMError(\n                `Add operation is only supported for many-to-many and one-to-many relations. ` +\n                    `However given \"${relation.propertyPath}\" has ${relation.relationType} relation. ` +\n                    `Use .set(null) method instead.`,\n            )\n\n        const remover = new RelationRemover(this, this.expressionMap)\n        return remover.remove(value)\n    }\n\n    /**\n     * Adds (binds) and removes (unbinds) given values to/from entity relation.\n     * Value can be entity, entity id or entity id map (if entity has composite ids).\n     * Value also can be array of entities, array of entity ids or array of entity id maps (if entity has composite ids).\n     * Works only for many-to-many and one-to-many relations.\n     * For many-to-one and one-to-one use #set method instead.\n     */\n    async addAndRemove(\n        added: any | any[],\n        removed: any | any[],\n    ): Promise<void> {\n        await this.remove(removed)\n        await this.add(added)\n    }\n\n    /**\n     * Gets entity's relation id.\n    async getId(): Promise<any> {\n\n    }*/\n\n    /**\n     * Gets entity's relation ids.\n    async getIds(): Promise<any[]> {\n        return [];\n    }*/\n\n    /**\n     * Loads a single entity (relational) from the relation.\n     * You can also provide id of relational entity to filter by.\n     */\n    async loadOne<T = any>(): Promise<T | undefined> {\n        return this.loadMany<T>().then((results) => results[0])\n    }\n\n    /**\n     * Loads many entities (relational) from the relation.\n     * You can also provide ids of relational entities to filter by.\n     */\n    async loadMany<T = any>(): Promise<T[]> {\n        let of = this.expressionMap.of\n        if (!ObjectUtils.isObject(of)) {\n            const metadata = this.expressionMap.mainAlias!.metadata\n            if (metadata.hasMultiplePrimaryKeys)\n                throw new TypeORMError(\n                    `Cannot load entity because only one primary key was specified, however entity contains multiple primary keys`,\n                )\n\n            of = metadata.primaryColumns[0].createValueMap(of)\n        }\n\n        return this.connection.relationLoader.load(\n            this.expressionMap.relationMetadata,\n            of,\n            this.queryRunner,\n        )\n    }\n}\n"]},"metadata":{},"sourceType":"module"}