{"ast":null,"code":"import { MetadataArgsStorage } from \"../metadata-args/MetadataArgsStorage\";\nimport { EntitySchemaEmbeddedError } from \"./EntitySchemaEmbeddedError\";\n/**\n * Transforms entity schema into metadata args storage.\n * The result will be just like entities read from decorators.\n */\n\nexport class EntitySchemaTransformer {\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Transforms entity schema into new metadata args storage object.\n   */\n  transform(schemas) {\n    const metadataArgsStorage = new MetadataArgsStorage();\n    schemas.forEach(entitySchema => {\n      const options = entitySchema.options; // add table metadata args from the schema\n\n      const tableMetadata = {\n        target: options.target || options.name,\n        name: options.tableName,\n        database: options.database,\n        schema: options.schema,\n        type: options.type || \"regular\",\n        orderBy: options.orderBy,\n        synchronize: options.synchronize,\n        withoutRowid: !!options.withoutRowid,\n        expression: options.expression\n      };\n      metadataArgsStorage.tables.push(tableMetadata);\n      this.transformColumnsRecursive(options, metadataArgsStorage);\n    });\n    return metadataArgsStorage;\n  }\n\n  transformColumnsRecursive(options, metadataArgsStorage) {\n    // add columns metadata args from the schema\n    Object.keys(options.columns).forEach(columnName => {\n      const column = options.columns[columnName];\n      const regularColumn = column;\n      let mode = \"regular\";\n      if (regularColumn.createDate) mode = \"createDate\";\n      if (regularColumn.updateDate) mode = \"updateDate\";\n      if (regularColumn.deleteDate) mode = \"deleteDate\";\n      if (regularColumn.version) mode = \"version\";\n      if (regularColumn.treeChildrenCount) mode = \"treeChildrenCount\";\n      if (regularColumn.treeLevel) mode = \"treeLevel\";\n      if (regularColumn.objectId) mode = \"objectId\";\n      const columnArgs = {\n        target: options.target || options.name,\n        mode: mode,\n        propertyName: columnName,\n        options: {\n          type: regularColumn.type,\n          name: regularColumn.objectId ? \"_id\" : regularColumn.name,\n          primaryKeyConstraintName: regularColumn.primaryKeyConstraintName,\n          length: regularColumn.length,\n          width: regularColumn.width,\n          nullable: regularColumn.nullable,\n          readonly: regularColumn.readonly,\n          update: regularColumn.update,\n          select: regularColumn.select,\n          insert: regularColumn.insert,\n          primary: regularColumn.primary,\n          unique: regularColumn.unique,\n          comment: regularColumn.comment,\n          default: regularColumn.default,\n          onUpdate: regularColumn.onUpdate,\n          precision: regularColumn.precision,\n          scale: regularColumn.scale,\n          zerofill: regularColumn.zerofill,\n          unsigned: regularColumn.unsigned,\n          charset: regularColumn.charset,\n          collation: regularColumn.collation,\n          enum: regularColumn.enum,\n          enumName: regularColumn.enumName,\n          asExpression: regularColumn.asExpression,\n          generatedType: regularColumn.generatedType,\n          hstoreType: regularColumn.hstoreType,\n          array: regularColumn.array,\n          transformer: regularColumn.transformer,\n          spatialFeatureType: regularColumn.spatialFeatureType,\n          srid: regularColumn.srid\n        }\n      };\n      metadataArgsStorage.columns.push(columnArgs);\n\n      if (regularColumn.generated) {\n        const generationArgs = {\n          target: options.target || options.name,\n          propertyName: columnName,\n          strategy: typeof regularColumn.generated === \"string\" ? regularColumn.generated : \"increment\"\n        };\n        metadataArgsStorage.generations.push(generationArgs);\n      }\n\n      if (regularColumn.unique) metadataArgsStorage.uniques.push({\n        target: options.target || options.name,\n        columns: [columnName]\n      });\n    }); // add relation metadata args from the schema\n\n    if (options.relations) {\n      Object.keys(options.relations).forEach(relationName => {\n        const relationSchema = options.relations[relationName];\n        const relation = {\n          target: options.target || options.name,\n          propertyName: relationName,\n          relationType: relationSchema.type,\n          isLazy: relationSchema.lazy || false,\n          type: relationSchema.target,\n          inverseSideProperty: relationSchema.inverseSide,\n          isTreeParent: relationSchema.treeParent,\n          isTreeChildren: relationSchema.treeChildren,\n          options: {\n            eager: relationSchema.eager || false,\n            cascade: relationSchema.cascade,\n            nullable: relationSchema.nullable,\n            onDelete: relationSchema.onDelete,\n            onUpdate: relationSchema.onUpdate,\n            deferrable: relationSchema.deferrable,\n            // primary: relationSchema.primary,\n            createForeignKeyConstraints: relationSchema.createForeignKeyConstraints,\n            persistence: relationSchema.persistence,\n            orphanedRowAction: relationSchema.orphanedRowAction\n          }\n        };\n        metadataArgsStorage.relations.push(relation); // add join column\n\n        if (relationSchema.joinColumn) {\n          if (typeof relationSchema.joinColumn === \"boolean\") {\n            const joinColumn = {\n              target: options.target || options.name,\n              propertyName: relationName\n            };\n            metadataArgsStorage.joinColumns.push(joinColumn);\n          } else {\n            const joinColumnsOptions = Array.isArray(relationSchema.joinColumn) ? relationSchema.joinColumn : [relationSchema.joinColumn];\n\n            for (const joinColumnOption of joinColumnsOptions) {\n              const joinColumn = {\n                target: options.target || options.name,\n                propertyName: relationName,\n                name: joinColumnOption.name,\n                referencedColumnName: joinColumnOption.referencedColumnName,\n                foreignKeyConstraintName: joinColumnOption.foreignKeyConstraintName\n              };\n              metadataArgsStorage.joinColumns.push(joinColumn);\n            }\n          }\n        } // add join table\n\n\n        if (relationSchema.joinTable) {\n          if (typeof relationSchema.joinTable === \"boolean\") {\n            const joinTable = {\n              target: options.target || options.name,\n              propertyName: relationName\n            };\n            metadataArgsStorage.joinTables.push(joinTable);\n          } else {\n            const joinTable = {\n              target: options.target || options.name,\n              propertyName: relationName,\n              name: relationSchema.joinTable.name,\n              database: relationSchema.joinTable.database,\n              schema: relationSchema.joinTable.schema,\n              joinColumns: relationSchema.joinTable.joinColumn ? [relationSchema.joinTable.joinColumn] : relationSchema.joinTable.joinColumns,\n              inverseJoinColumns: relationSchema.joinTable.inverseJoinColumn ? [relationSchema.joinTable.inverseJoinColumn] : relationSchema.joinTable.inverseJoinColumns\n            };\n            metadataArgsStorage.joinTables.push(joinTable);\n          }\n        }\n      });\n    } // add relation id metadata args from the schema\n\n\n    if (options.relationIds) {\n      Object.keys(options.relationIds).forEach(relationIdName => {\n        const relationIdOptions = options.relationIds[relationIdName];\n        const relationId = {\n          propertyName: relationIdName,\n          relation: relationIdOptions.relationName,\n          target: options.target || options.name,\n          alias: relationIdOptions.alias,\n          queryBuilderFactory: relationIdOptions.queryBuilderFactory\n        };\n        metadataArgsStorage.relationIds.push(relationId);\n      });\n    } // add index metadata args from the schema\n\n\n    if (options.indices) {\n      options.indices.forEach(index => {\n        const indexArgs = {\n          target: options.target || options.name,\n          name: index.name,\n          unique: index.unique === true ? true : false,\n          spatial: index.spatial === true ? true : false,\n          fulltext: index.fulltext === true ? true : false,\n          nullFiltered: index.nullFiltered === true ? true : false,\n          parser: index.parser,\n          synchronize: index.synchronize === false ? false : true,\n          where: index.where,\n          sparse: index.sparse,\n          columns: index.columns\n        };\n        metadataArgsStorage.indices.push(indexArgs);\n      });\n    } // add unique metadata args from the schema\n\n\n    if (options.uniques) {\n      options.uniques.forEach(unique => {\n        const uniqueArgs = {\n          target: options.target || options.name,\n          name: unique.name,\n          columns: unique.columns,\n          deferrable: unique.deferrable\n        };\n        metadataArgsStorage.uniques.push(uniqueArgs);\n      });\n    } // add check metadata args from the schema\n\n\n    if (options.checks) {\n      options.checks.forEach(check => {\n        const checkArgs = {\n          target: options.target || options.name,\n          name: check.name,\n          expression: check.expression\n        };\n        metadataArgsStorage.checks.push(checkArgs);\n      });\n    } // add exclusion metadata args from the schema\n\n\n    if (options.exclusions) {\n      options.exclusions.forEach(exclusion => {\n        const exclusionArgs = {\n          target: options.target || options.name,\n          name: exclusion.name,\n          expression: exclusion.expression\n        };\n        metadataArgsStorage.exclusions.push(exclusionArgs);\n      });\n    }\n\n    if (options.embeddeds) {\n      Object.keys(options.embeddeds).forEach(columnName => {\n        const embeddedOptions = options.embeddeds[columnName];\n        if (!embeddedOptions.schema) throw EntitySchemaEmbeddedError.createEntitySchemaIsRequiredException(columnName);\n        const embeddedSchema = embeddedOptions.schema.options;\n        metadataArgsStorage.embeddeds.push({\n          target: options.target || options.name,\n          propertyName: columnName,\n          isArray: embeddedOptions.array === true,\n          prefix: embeddedOptions.prefix !== undefined ? embeddedOptions.prefix : undefined,\n          type: () => (embeddedSchema === null || embeddedSchema === void 0 ? void 0 : embeddedSchema.target) || embeddedSchema.name\n        });\n        this.transformColumnsRecursive(embeddedSchema, metadataArgsStorage);\n      });\n    }\n  }\n\n}","map":{"version":3,"mappings":"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","names":["MetadataArgsStorage","EntitySchemaEmbeddedError","EntitySchemaTransformer","transform","schemas","metadataArgsStorage","forEach","entitySchema","options","tableMetadata","target","name","tableName","database","schema","type","orderBy","synchronize","withoutRowid","expression","tables","push","transformColumnsRecursive","Object","keys","columns","columnName","column","regularColumn","mode","createDate","updateDate","deleteDate","version","treeChildrenCount","treeLevel","objectId","columnArgs","propertyName","primaryKeyConstraintName","length","width","nullable","readonly","update","select","insert","primary","unique","comment","default","onUpdate","precision","scale","zerofill","unsigned","charset","collation","enum","enumName","asExpression","generatedType","hstoreType","array","transformer","spatialFeatureType","srid","generated","generationArgs","strategy","generations","uniques","relations","relationName","relationSchema","relation","relationType","isLazy","lazy","inverseSideProperty","inverseSide","isTreeParent","treeParent","isTreeChildren","treeChildren","eager","cascade","onDelete","deferrable","createForeignKeyConstraints","persistence","orphanedRowAction","joinColumn","joinColumns","joinColumnsOptions","Array","isArray","joinColumnOption","referencedColumnName","foreignKeyConstraintName","joinTable","joinTables","inverseJoinColumns","inverseJoinColumn","relationIds","relationIdName","relationIdOptions","relationId","alias","queryBuilderFactory","indices","index","indexArgs","spatial","fulltext","nullFiltered","parser","where","sparse","uniqueArgs","checks","check","checkArgs","exclusions","exclusion","exclusionArgs","embeddeds","embeddedOptions","createEntitySchemaIsRequiredException","embeddedSchema","prefix","undefined"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\entity-schema\\EntitySchemaTransformer.ts"],"sourcesContent":["import { EntitySchema } from \"./EntitySchema\"\nimport { MetadataArgsStorage } from \"../metadata-args/MetadataArgsStorage\"\nimport { TableMetadataArgs } from \"../metadata-args/TableMetadataArgs\"\nimport { ColumnMetadataArgs } from \"../metadata-args/ColumnMetadataArgs\"\nimport { IndexMetadataArgs } from \"../metadata-args/IndexMetadataArgs\"\nimport { RelationMetadataArgs } from \"../metadata-args/RelationMetadataArgs\"\nimport { JoinColumnMetadataArgs } from \"../metadata-args/JoinColumnMetadataArgs\"\nimport { JoinTableMetadataArgs } from \"../metadata-args/JoinTableMetadataArgs\"\nimport { JoinTableOptions } from \"../decorator/options/JoinTableOptions\"\nimport { JoinTableMultipleColumnsOptions } from \"../decorator/options/JoinTableMultipleColumnsOptions\"\nimport { ColumnMode } from \"../metadata-args/types/ColumnMode\"\nimport { GeneratedMetadataArgs } from \"../metadata-args/GeneratedMetadataArgs\"\nimport { UniqueMetadataArgs } from \"../metadata-args/UniqueMetadataArgs\"\nimport { CheckMetadataArgs } from \"../metadata-args/CheckMetadataArgs\"\nimport { ExclusionMetadataArgs } from \"../metadata-args/ExclusionMetadataArgs\"\nimport { EntitySchemaColumnOptions } from \"./EntitySchemaColumnOptions\"\nimport { EntitySchemaOptions } from \"./EntitySchemaOptions\"\nimport { EntitySchemaEmbeddedError } from \"./EntitySchemaEmbeddedError\"\nimport { RelationIdMetadataArgs } from \"../metadata-args/RelationIdMetadataArgs\"\n\n/**\n * Transforms entity schema into metadata args storage.\n * The result will be just like entities read from decorators.\n */\nexport class EntitySchemaTransformer {\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Transforms entity schema into new metadata args storage object.\n     */\n    transform(schemas: EntitySchema<any>[]): MetadataArgsStorage {\n        const metadataArgsStorage = new MetadataArgsStorage()\n\n        schemas.forEach((entitySchema) => {\n            const options = entitySchema.options\n\n            // add table metadata args from the schema\n            const tableMetadata: TableMetadataArgs = {\n                target: options.target || options.name,\n                name: options.tableName,\n                database: options.database,\n                schema: options.schema,\n                type: options.type || \"regular\",\n                orderBy: options.orderBy,\n                synchronize: options.synchronize,\n                withoutRowid: !!options.withoutRowid,\n                expression: options.expression,\n            }\n            metadataArgsStorage.tables.push(tableMetadata)\n\n            this.transformColumnsRecursive(options, metadataArgsStorage)\n        })\n\n        return metadataArgsStorage\n    }\n\n    private transformColumnsRecursive(\n        options: EntitySchemaOptions<any>,\n        metadataArgsStorage: MetadataArgsStorage,\n    ): void {\n        // add columns metadata args from the schema\n        Object.keys(options.columns).forEach((columnName) => {\n            const column = options.columns[columnName]!\n\n            const regularColumn = column as EntitySchemaColumnOptions\n            let mode: ColumnMode = \"regular\"\n            if (regularColumn.createDate) mode = \"createDate\"\n            if (regularColumn.updateDate) mode = \"updateDate\"\n            if (regularColumn.deleteDate) mode = \"deleteDate\"\n            if (regularColumn.version) mode = \"version\"\n            if (regularColumn.treeChildrenCount) mode = \"treeChildrenCount\"\n            if (regularColumn.treeLevel) mode = \"treeLevel\"\n            if (regularColumn.objectId) mode = \"objectId\"\n\n            const columnArgs: ColumnMetadataArgs = {\n                target: options.target || options.name,\n                mode: mode,\n                propertyName: columnName,\n                options: {\n                    type: regularColumn.type,\n                    name: regularColumn.objectId ? \"_id\" : regularColumn.name,\n                    primaryKeyConstraintName:\n                        regularColumn.primaryKeyConstraintName,\n                    length: regularColumn.length,\n                    width: regularColumn.width,\n                    nullable: regularColumn.nullable,\n                    readonly: regularColumn.readonly,\n                    update: regularColumn.update,\n                    select: regularColumn.select,\n                    insert: regularColumn.insert,\n                    primary: regularColumn.primary,\n                    unique: regularColumn.unique,\n                    comment: regularColumn.comment,\n                    default: regularColumn.default,\n                    onUpdate: regularColumn.onUpdate,\n                    precision: regularColumn.precision,\n                    scale: regularColumn.scale,\n                    zerofill: regularColumn.zerofill,\n                    unsigned: regularColumn.unsigned,\n                    charset: regularColumn.charset,\n                    collation: regularColumn.collation,\n                    enum: regularColumn.enum,\n                    enumName: regularColumn.enumName,\n                    asExpression: regularColumn.asExpression,\n                    generatedType: regularColumn.generatedType,\n                    hstoreType: regularColumn.hstoreType,\n                    array: regularColumn.array,\n                    transformer: regularColumn.transformer,\n                    spatialFeatureType: regularColumn.spatialFeatureType,\n                    srid: regularColumn.srid,\n                },\n            }\n            metadataArgsStorage.columns.push(columnArgs)\n\n            if (regularColumn.generated) {\n                const generationArgs: GeneratedMetadataArgs = {\n                    target: options.target || options.name,\n                    propertyName: columnName,\n                    strategy:\n                        typeof regularColumn.generated === \"string\"\n                            ? regularColumn.generated\n                            : \"increment\",\n                }\n                metadataArgsStorage.generations.push(generationArgs)\n            }\n\n            if (regularColumn.unique)\n                metadataArgsStorage.uniques.push({\n                    target: options.target || options.name,\n                    columns: [columnName],\n                })\n        })\n\n        // add relation metadata args from the schema\n        if (options.relations) {\n            Object.keys(options.relations).forEach((relationName) => {\n                const relationSchema = options.relations![relationName]!\n                const relation: RelationMetadataArgs = {\n                    target: options.target || options.name,\n                    propertyName: relationName,\n                    relationType: relationSchema.type,\n                    isLazy: relationSchema.lazy || false,\n                    type: relationSchema.target,\n                    inverseSideProperty: relationSchema.inverseSide,\n                    isTreeParent: relationSchema.treeParent,\n                    isTreeChildren: relationSchema.treeChildren,\n                    options: {\n                        eager: relationSchema.eager || false,\n                        cascade: relationSchema.cascade,\n                        nullable: relationSchema.nullable,\n                        onDelete: relationSchema.onDelete,\n                        onUpdate: relationSchema.onUpdate,\n                        deferrable: relationSchema.deferrable,\n                        // primary: relationSchema.primary,\n                        createForeignKeyConstraints:\n                            relationSchema.createForeignKeyConstraints,\n                        persistence: relationSchema.persistence,\n                        orphanedRowAction: relationSchema.orphanedRowAction,\n                    },\n                }\n\n                metadataArgsStorage.relations.push(relation)\n\n                // add join column\n                if (relationSchema.joinColumn) {\n                    if (typeof relationSchema.joinColumn === \"boolean\") {\n                        const joinColumn: JoinColumnMetadataArgs = {\n                            target: options.target || options.name,\n                            propertyName: relationName,\n                        }\n                        metadataArgsStorage.joinColumns.push(joinColumn)\n                    } else {\n                        const joinColumnsOptions = Array.isArray(\n                            relationSchema.joinColumn,\n                        )\n                            ? relationSchema.joinColumn\n                            : [relationSchema.joinColumn]\n\n                        for (const joinColumnOption of joinColumnsOptions) {\n                            const joinColumn: JoinColumnMetadataArgs = {\n                                target: options.target || options.name,\n                                propertyName: relationName,\n                                name: joinColumnOption.name,\n                                referencedColumnName:\n                                    joinColumnOption.referencedColumnName,\n                                foreignKeyConstraintName:\n                                    joinColumnOption.foreignKeyConstraintName,\n                            }\n                            metadataArgsStorage.joinColumns.push(joinColumn)\n                        }\n                    }\n                }\n\n                // add join table\n                if (relationSchema.joinTable) {\n                    if (typeof relationSchema.joinTable === \"boolean\") {\n                        const joinTable: JoinTableMetadataArgs = {\n                            target: options.target || options.name,\n                            propertyName: relationName,\n                        }\n                        metadataArgsStorage.joinTables.push(joinTable)\n                    } else {\n                        const joinTable: JoinTableMetadataArgs = {\n                            target: options.target || options.name,\n                            propertyName: relationName,\n                            name: relationSchema.joinTable.name,\n                            database: relationSchema.joinTable.database,\n                            schema: relationSchema.joinTable.schema,\n                            joinColumns: ((\n                                relationSchema.joinTable as JoinTableOptions\n                            ).joinColumn\n                                ? [\n                                      (\n                                          relationSchema.joinTable as JoinTableOptions\n                                      ).joinColumn!,\n                                  ]\n                                : (\n                                      relationSchema.joinTable as JoinTableMultipleColumnsOptions\n                                  ).joinColumns) as any,\n                            inverseJoinColumns: ((\n                                relationSchema.joinTable as JoinTableOptions\n                            ).inverseJoinColumn\n                                ? [\n                                      (\n                                          relationSchema.joinTable as JoinTableOptions\n                                      ).inverseJoinColumn!,\n                                  ]\n                                : (\n                                      relationSchema.joinTable as JoinTableMultipleColumnsOptions\n                                  ).inverseJoinColumns) as any,\n                        }\n                        metadataArgsStorage.joinTables.push(joinTable)\n                    }\n                }\n            })\n        }\n\n        // add relation id metadata args from the schema\n        if (options.relationIds) {\n            Object.keys(options.relationIds).forEach((relationIdName) => {\n                const relationIdOptions = options.relationIds![relationIdName]!\n                const relationId: RelationIdMetadataArgs = {\n                    propertyName: relationIdName,\n                    relation: relationIdOptions.relationName,\n                    target: options.target || options.name,\n                    alias: relationIdOptions.alias,\n                    queryBuilderFactory: relationIdOptions.queryBuilderFactory,\n                }\n                metadataArgsStorage.relationIds.push(relationId)\n            })\n        }\n\n        // add index metadata args from the schema\n        if (options.indices) {\n            options.indices.forEach((index) => {\n                const indexArgs: IndexMetadataArgs = {\n                    target: options.target || options.name,\n                    name: index.name,\n                    unique: index.unique === true ? true : false,\n                    spatial: index.spatial === true ? true : false,\n                    fulltext: index.fulltext === true ? true : false,\n                    nullFiltered: index.nullFiltered === true ? true : false,\n                    parser: index.parser,\n                    synchronize: index.synchronize === false ? false : true,\n                    where: index.where,\n                    sparse: index.sparse,\n                    columns: index.columns,\n                }\n                metadataArgsStorage.indices.push(indexArgs)\n            })\n        }\n\n        // add unique metadata args from the schema\n        if (options.uniques) {\n            options.uniques.forEach((unique) => {\n                const uniqueArgs: UniqueMetadataArgs = {\n                    target: options.target || options.name,\n                    name: unique.name,\n                    columns: unique.columns,\n                    deferrable: unique.deferrable,\n                }\n                metadataArgsStorage.uniques.push(uniqueArgs)\n            })\n        }\n\n        // add check metadata args from the schema\n        if (options.checks) {\n            options.checks.forEach((check) => {\n                const checkArgs: CheckMetadataArgs = {\n                    target: options.target || options.name,\n                    name: check.name,\n                    expression: check.expression,\n                }\n                metadataArgsStorage.checks.push(checkArgs)\n            })\n        }\n\n        // add exclusion metadata args from the schema\n        if (options.exclusions) {\n            options.exclusions.forEach((exclusion) => {\n                const exclusionArgs: ExclusionMetadataArgs = {\n                    target: options.target || options.name,\n                    name: exclusion.name,\n                    expression: exclusion.expression,\n                }\n                metadataArgsStorage.exclusions.push(exclusionArgs)\n            })\n        }\n\n        if (options.embeddeds) {\n            Object.keys(options.embeddeds).forEach((columnName) => {\n                const embeddedOptions = options.embeddeds![columnName]\n\n                if (!embeddedOptions.schema)\n                    throw EntitySchemaEmbeddedError.createEntitySchemaIsRequiredException(\n                        columnName,\n                    )\n\n                const embeddedSchema = embeddedOptions.schema.options\n\n                metadataArgsStorage.embeddeds.push({\n                    target: options.target || options.name,\n                    propertyName: columnName,\n                    isArray: embeddedOptions.array === true,\n                    prefix:\n                        embeddedOptions.prefix !== undefined\n                            ? embeddedOptions.prefix\n                            : undefined,\n                    type: () => embeddedSchema?.target || embeddedSchema.name,\n                })\n\n                this.transformColumnsRecursive(\n                    embeddedSchema,\n                    metadataArgsStorage,\n                )\n            })\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}