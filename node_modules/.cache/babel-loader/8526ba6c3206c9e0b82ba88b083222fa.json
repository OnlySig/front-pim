{"ast":null,"code":"import { Alias } from \"./Alias\";\nimport { JoinAttribute } from \"./JoinAttribute\";\nimport { RelationIdAttribute } from \"./relation-id/RelationIdAttribute\";\nimport { RelationCountAttribute } from \"./relation-count/RelationCountAttribute\";\nimport { TypeORMError } from \"../error\";\n/**\n * Contains all properties of the QueryBuilder that needs to be build a final query.\n */\n\nexport class QueryExpressionMap {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection) {\n    this.connection = connection; // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Strategy to load relations.\n     */\n\n    this.relationLoadStrategy = \"join\";\n    /**\n     * Indicates if QueryBuilder used to select entities and not a raw results.\n     */\n\n    this.queryEntity = false;\n    /**\n     * All aliases (including main alias) used in the query.\n     */\n\n    this.aliases = [];\n    /**\n     * Represents query type. QueryBuilder is able to build SELECT, UPDATE and DELETE queries.\n     */\n\n    this.queryType = \"select\";\n    /**\n     * Data needs to be SELECT-ed.\n     */\n\n    this.selects = [];\n    /**\n     * Max execution time in millisecond.\n     */\n\n    this.maxExecutionTime = 0;\n    /**\n     * Whether SELECT is DISTINCT.\n     */\n\n    this.selectDistinct = false;\n    /**\n     * SELECT DISTINCT ON query (postgres).\n     */\n\n    this.selectDistinctOn = [];\n    /**\n     * Extra returning columns to be added to the returning statement if driver supports it.\n     */\n\n    this.extraReturningColumns = [];\n    /**\n     * Optional on conflict statement used in insertion query in postgres.\n     */\n\n    this.onConflict = \"\";\n    /**\n     * Optional on ignore statement used in insertion query in databases.\n     */\n\n    this.onIgnore = false;\n    /**\n     * JOIN queries.\n     */\n\n    this.joinAttributes = [];\n    /**\n     * RelationId queries.\n     */\n\n    this.relationIdAttributes = [];\n    /**\n     * Relation count queries.\n     */\n\n    this.relationCountAttributes = [];\n    /**\n     * WHERE queries.\n     */\n\n    this.wheres = [];\n    /**\n     * HAVING queries.\n     */\n\n    this.havings = [];\n    /**\n     * ORDER BY queries.\n     */\n\n    this.orderBys = {};\n    /**\n     * GROUP BY queries.\n     */\n\n    this.groupBys = [];\n    /**\n     * Indicates if soft-deleted rows should be included in entity result.\n     * By default the soft-deleted rows are not included.\n     */\n\n    this.withDeleted = false;\n    /**\n     * Parameters used to be escaped in final query.\n     */\n\n    this.parameters = {};\n    /**\n     * Indicates if alias, table names and column names will be escaped by driver, or not.\n     *\n     * todo: rename to isQuotingDisabled, also think if it should be named \"escaping\"\n     */\n\n    this.disableEscaping = true;\n    /**\n     * Indicates if virtual columns should be included in entity result.\n     *\n     * todo: what to do with it? is it properly used? what about persistence?\n     */\n\n    this.enableRelationIdValues = false;\n    /**\n     * Extra where condition appended to the end of original where conditions with AND keyword.\n     * Original condition will be wrapped into brackets.\n     */\n\n    this.extraAppendedAndWhereCondition = \"\";\n    /**\n     * Indicates if query builder creates a subquery.\n     */\n\n    this.subQuery = false;\n    /**\n     * Indicates if property names are prefixed with alias names during property replacement.\n     * By default this is enabled, however we need this because aliases are not supported in UPDATE and DELETE queries,\n     * but user can use them in WHERE expressions.\n     */\n\n    this.aliasNamePrefixingEnabled = true;\n    /**\n     * Indicates if query result cache is enabled or not.\n     */\n\n    this.cache = false;\n    /**\n     * Options that define QueryBuilder behaviour.\n     */\n\n    this.options = [];\n    /**\n     * List of columns where data should be inserted.\n     * Used in INSERT query.\n     */\n\n    this.insertColumns = [];\n    /**\n     * Used if user wants to update or delete a specific entities.\n     */\n\n    this.whereEntities = [];\n    /**\n     * Indicates if entity must be updated after insertion / updation.\n     * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).\n     */\n\n    this.updateEntity = true;\n    /**\n     * Indicates if listeners and subscribers must be called before and after query execution.\n     */\n\n    this.callListeners = true;\n    /**\n     * Indicates if query must be wrapped into transaction.\n     */\n\n    this.useTransaction = false;\n    /**\n     * Extra parameters.\n     *\n     * @deprecated Use standard parameters instead\n     */\n\n    this.nativeParameters = {};\n    /**\n     * Items from an entity that have been locally generated & are recorded here for later use.\n     * Examples include the UUID generation when the database does not natively support it.\n     * These are included in the entity index order.\n     */\n\n    this.locallyGenerated = {};\n    this.commonTableExpressions = [];\n\n    if (connection.options.relationLoadStrategy) {\n      this.relationLoadStrategy = connection.options.relationLoadStrategy;\n    }\n  } // -------------------------------------------------------------------------\n  // Accessors\n  // -------------------------------------------------------------------------\n\n  /**\n   * Get all ORDER BY queries - if order by is specified by user then it uses them,\n   * otherwise it uses default entity order by if it was set.\n   */\n\n\n  get allOrderBys() {\n    if (!Object.keys(this.orderBys).length && this.mainAlias.hasMetadata && this.options.indexOf(\"disable-global-order\") === -1) {\n      const entityOrderBy = this.mainAlias.metadata.orderBy || {};\n      return Object.keys(entityOrderBy).reduce((orderBy, key) => {\n        orderBy[this.mainAlias.name + \".\" + key] = entityOrderBy[key];\n        return orderBy;\n      }, {});\n    }\n\n    return this.orderBys;\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Creates a main alias and adds it to the current expression map.\n   */\n\n\n  setMainAlias(alias) {\n    // if main alias is already set then remove it from the array\n    // if (this.mainAlias)\n    //     this.aliases.splice(this.aliases.indexOf(this.mainAlias));\n    // set new main alias\n    this.mainAlias = alias;\n    return alias;\n  }\n  /**\n   * Creates a new alias and adds it to the current expression map.\n   */\n\n\n  createAlias(options) {\n    let aliasName = options.name;\n    if (!aliasName && options.tablePath) aliasName = options.tablePath;\n    if (!aliasName && typeof options.target === \"function\") aliasName = options.target.name;\n    if (!aliasName && typeof options.target === \"string\") aliasName = options.target;\n    const alias = new Alias();\n    alias.type = options.type;\n    if (aliasName) alias.name = aliasName;\n    if (options.metadata) alias.metadata = options.metadata;\n    if (options.target && !alias.hasMetadata) alias.metadata = this.connection.getMetadata(options.target);\n    if (options.tablePath) alias.tablePath = options.tablePath;\n    if (options.subQuery) alias.subQuery = options.subQuery;\n    this.aliases.push(alias);\n    return alias;\n  }\n  /**\n   * Finds alias with the given name.\n   * If alias was not found it throw an exception.\n   */\n\n\n  findAliasByName(aliasName) {\n    const alias = this.aliases.find(alias => alias.name === aliasName);\n    if (!alias) throw new TypeORMError(`\"${aliasName}\" alias was not found. Maybe you forgot to join it?`);\n    return alias;\n  }\n\n  findColumnByAliasExpression(aliasExpression) {\n    const [aliasName, propertyPath] = aliasExpression.split(\".\");\n    const alias = this.findAliasByName(aliasName);\n    return alias.metadata.findColumnWithPropertyName(propertyPath);\n  }\n  /**\n   * Gets relation metadata of the relation this query builder works with.\n   *\n   * todo: add proper exceptions\n   */\n\n\n  get relationMetadata() {\n    if (!this.mainAlias) throw new TypeORMError(`Entity to work with is not specified!`); // todo: better message\n\n    const relationMetadata = this.mainAlias.metadata.findRelationWithPropertyPath(this.relationPropertyPath);\n    if (!relationMetadata) throw new TypeORMError(`Relation ${this.relationPropertyPath} was not found in entity ${this.mainAlias.name}`); // todo: better message\n\n    return relationMetadata;\n  }\n  /**\n   * Copies all properties of the current QueryExpressionMap into a new one.\n   * Useful when QueryBuilder needs to create a copy of itself.\n   */\n\n\n  clone() {\n    const map = new QueryExpressionMap(this.connection);\n    map.queryType = this.queryType;\n    map.selects = this.selects.map(select => select);\n    map.maxExecutionTime = this.maxExecutionTime;\n    map.selectDistinct = this.selectDistinct;\n    map.selectDistinctOn = this.selectDistinctOn;\n    this.aliases.forEach(alias => map.aliases.push(new Alias(alias)));\n    map.relationLoadStrategy = this.relationLoadStrategy;\n    map.mainAlias = this.mainAlias;\n    map.valuesSet = this.valuesSet;\n    map.returning = this.returning;\n    map.onConflict = this.onConflict;\n    map.onIgnore = this.onIgnore;\n    map.onUpdate = this.onUpdate;\n    map.joinAttributes = this.joinAttributes.map(join => new JoinAttribute(this.connection, this, join));\n    map.relationIdAttributes = this.relationIdAttributes.map(relationId => new RelationIdAttribute(this, relationId));\n    map.relationCountAttributes = this.relationCountAttributes.map(relationCount => new RelationCountAttribute(this, relationCount));\n    map.wheres = this.wheres.map(where => ({ ...where\n    }));\n    map.havings = this.havings.map(having => ({ ...having\n    }));\n    map.orderBys = Object.assign({}, this.orderBys);\n    map.groupBys = this.groupBys.map(groupBy => groupBy);\n    map.limit = this.limit;\n    map.offset = this.offset;\n    map.skip = this.skip;\n    map.take = this.take;\n    map.lockMode = this.lockMode;\n    map.onLocked = this.onLocked;\n    map.lockVersion = this.lockVersion;\n    map.lockTables = this.lockTables;\n    map.withDeleted = this.withDeleted;\n    map.parameters = Object.assign({}, this.parameters);\n    map.disableEscaping = this.disableEscaping;\n    map.enableRelationIdValues = this.enableRelationIdValues;\n    map.extraAppendedAndWhereCondition = this.extraAppendedAndWhereCondition;\n    map.subQuery = this.subQuery;\n    map.aliasNamePrefixingEnabled = this.aliasNamePrefixingEnabled;\n    map.cache = this.cache;\n    map.cacheId = this.cacheId;\n    map.cacheDuration = this.cacheDuration;\n    map.relationPropertyPath = this.relationPropertyPath;\n    map.of = this.of;\n    map.insertColumns = this.insertColumns;\n    map.whereEntities = this.whereEntities;\n    map.updateEntity = this.updateEntity;\n    map.callListeners = this.callListeners;\n    map.useTransaction = this.useTransaction;\n    map.nativeParameters = Object.assign({}, this.nativeParameters);\n    map.comment = this.comment;\n    map.commonTableExpressions = this.commonTableExpressions.map(cteOptions => ({\n      alias: cteOptions.alias,\n      queryBuilder: typeof cteOptions.queryBuilder === \"string\" ? cteOptions.queryBuilder : cteOptions.queryBuilder.clone(),\n      options: cteOptions.options\n    }));\n    return map;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["Alias","JoinAttribute","RelationIdAttribute","RelationCountAttribute","TypeORMError","QueryExpressionMap","constructor","connection","options","relationLoadStrategy","allOrderBys","Object","keys","orderBys","length","mainAlias","hasMetadata","indexOf","entityOrderBy","metadata","orderBy","reduce","key","name","setMainAlias","alias","createAlias","aliasName","tablePath","target","type","getMetadata","subQuery","aliases","push","findAliasByName","find","findColumnByAliasExpression","aliasExpression","propertyPath","split","findColumnWithPropertyName","relationMetadata","findRelationWithPropertyPath","relationPropertyPath","clone","map","queryType","selects","select","maxExecutionTime","selectDistinct","selectDistinctOn","forEach","valuesSet","returning","onConflict","onIgnore","onUpdate","joinAttributes","join","relationIdAttributes","relationId","relationCountAttributes","relationCount","wheres","where","havings","having","assign","groupBys","groupBy","limit","offset","skip","take","lockMode","onLocked","lockVersion","lockTables","withDeleted","parameters","disableEscaping","enableRelationIdValues","extraAppendedAndWhereCondition","aliasNamePrefixingEnabled","cache","cacheId","cacheDuration","of","insertColumns","whereEntities","updateEntity","callListeners","useTransaction","nativeParameters","comment","commonTableExpressions","cteOptions","queryBuilder"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\query-builder\\QueryExpressionMap.ts"],"sourcesContent":["import { Alias } from \"./Alias\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { OrderByCondition } from \"../find-options/OrderByCondition\"\nimport { JoinAttribute } from \"./JoinAttribute\"\nimport { QueryBuilder } from \"./QueryBuilder\"\nimport { QueryBuilderCteOptions } from \"./QueryBuilderCte\"\nimport { RelationIdAttribute } from \"./relation-id/RelationIdAttribute\"\nimport { RelationCountAttribute } from \"./relation-count/RelationCountAttribute\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { EntityMetadata } from \"../metadata/EntityMetadata\"\nimport { SelectQuery } from \"./SelectQuery\"\nimport { ColumnMetadata } from \"../metadata/ColumnMetadata\"\nimport { RelationMetadata } from \"../metadata/RelationMetadata\"\nimport { SelectQueryBuilderOption } from \"./SelectQueryBuilderOption\"\nimport { TypeORMError } from \"../error\"\nimport { WhereClause } from \"./WhereClause\"\n\n/**\n * Contains all properties of the QueryBuilder that needs to be build a final query.\n */\nexport class QueryExpressionMap {\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Strategy to load relations.\n     */\n    relationLoadStrategy: \"join\" | \"query\" = \"join\"\n\n    /**\n     * Indicates if QueryBuilder used to select entities and not a raw results.\n     */\n    queryEntity: boolean = false\n\n    /**\n     * Main alias is a main selection object selected by QueryBuilder.\n     */\n    mainAlias?: Alias\n\n    /**\n     * All aliases (including main alias) used in the query.\n     */\n    aliases: Alias[] = []\n\n    /**\n     * Represents query type. QueryBuilder is able to build SELECT, UPDATE and DELETE queries.\n     */\n    queryType:\n        | \"select\"\n        | \"update\"\n        | \"delete\"\n        | \"insert\"\n        | \"relation\"\n        | \"soft-delete\"\n        | \"restore\" = \"select\"\n\n    /**\n     * Data needs to be SELECT-ed.\n     */\n    selects: SelectQuery[] = []\n\n    /**\n     * Max execution time in millisecond.\n     */\n    maxExecutionTime: number = 0\n\n    /**\n     * Whether SELECT is DISTINCT.\n     */\n    selectDistinct: boolean = false\n\n    /**\n     * SELECT DISTINCT ON query (postgres).\n     */\n    selectDistinctOn: string[] = []\n\n    /**\n     * FROM-s to be selected.\n     */\n    // froms: { target: string, alias: string }[] = [];\n\n    /**\n     * If update query was used, it needs \"update set\" - properties which will be updated by this query.\n     * If insert query was used, it needs \"insert set\" - values that needs to be inserted.\n     */\n    valuesSet?: ObjectLiteral | ObjectLiteral[]\n\n    /**\n     * Optional returning (or output) clause for insert, update or delete queries.\n     */\n    returning: string | string[]\n\n    /**\n     * Extra returning columns to be added to the returning statement if driver supports it.\n     */\n    extraReturningColumns: ColumnMetadata[] = []\n\n    /**\n     * Optional on conflict statement used in insertion query in postgres.\n     */\n    onConflict: string = \"\"\n\n    /**\n     * Optional on ignore statement used in insertion query in databases.\n     */\n    onIgnore: boolean = false\n\n    /**\n     * Optional on update statement used in insertion query in databases.\n     */\n    onUpdate: {\n        conflict?: string | string[]\n        columns?: string[]\n        overwrite?: string[]\n        skipUpdateIfNoValuesChanged?: boolean\n    }\n\n    /**\n     * JOIN queries.\n     */\n    joinAttributes: JoinAttribute[] = []\n\n    /**\n     * RelationId queries.\n     */\n    relationIdAttributes: RelationIdAttribute[] = []\n\n    /**\n     * Relation count queries.\n     */\n    relationCountAttributes: RelationCountAttribute[] = []\n\n    /**\n     * WHERE queries.\n     */\n    wheres: WhereClause[] = []\n\n    /**\n     * HAVING queries.\n     */\n    havings: { type: \"simple\" | \"and\" | \"or\"; condition: string }[] = []\n\n    /**\n     * ORDER BY queries.\n     */\n    orderBys: OrderByCondition = {}\n\n    /**\n     * GROUP BY queries.\n     */\n    groupBys: string[] = []\n\n    /**\n     * LIMIT query.\n     */\n    limit?: number\n\n    /**\n     * OFFSET query.\n     */\n    offset?: number\n\n    /**\n     * Number of rows to skip of result using pagination.\n     */\n    skip?: number\n\n    /**\n     * Number of rows to take using pagination.\n     */\n    take?: number\n\n    /**\n     * Use certain index for the query.\n     *\n     * SELECT * FROM table_name USE INDEX (col1_index, col2_index) WHERE col1=1 AND col2=2 AND col3=3;\n     */\n    useIndex?: string\n\n    /**\n     * Locking mode.\n     */\n    lockMode?:\n        | \"optimistic\"\n        | \"pessimistic_read\"\n        | \"pessimistic_write\"\n        | \"dirty_read\"\n        /*\n            \"pessimistic_partial_write\" and \"pessimistic_write_or_fail\" are deprecated and\n            will be removed in a future version.\n\n            Use onLocked instead.\n         */\n        | \"pessimistic_partial_write\"\n        | \"pessimistic_write_or_fail\"\n        | \"for_no_key_update\"\n        | \"for_key_share\"\n\n    /**\n     * Current version of the entity, used for locking.\n     */\n    lockVersion?: number | Date\n\n    /**\n     * Tables to be specified in the \"FOR UPDATE OF\" clause, referred by their alias\n     */\n    lockTables?: string[]\n\n    /**\n     * Modify behavior when encountering locked rows. NOWAIT or SKIP LOCKED\n     */\n    onLocked?: \"nowait\" | \"skip_locked\"\n\n    /**\n     * Indicates if soft-deleted rows should be included in entity result.\n     * By default the soft-deleted rows are not included.\n     */\n    withDeleted: boolean = false\n\n    /**\n     * Parameters used to be escaped in final query.\n     */\n    parameters: ObjectLiteral = {}\n\n    /**\n     * Indicates if alias, table names and column names will be escaped by driver, or not.\n     *\n     * todo: rename to isQuotingDisabled, also think if it should be named \"escaping\"\n     */\n    disableEscaping: boolean = true\n\n    /**\n     * Indicates if virtual columns should be included in entity result.\n     *\n     * todo: what to do with it? is it properly used? what about persistence?\n     */\n    enableRelationIdValues: boolean = false\n\n    /**\n     * Extra where condition appended to the end of original where conditions with AND keyword.\n     * Original condition will be wrapped into brackets.\n     */\n    extraAppendedAndWhereCondition: string = \"\"\n\n    /**\n     * Indicates if query builder creates a subquery.\n     */\n    subQuery: boolean = false\n\n    /**\n     * Indicates if property names are prefixed with alias names during property replacement.\n     * By default this is enabled, however we need this because aliases are not supported in UPDATE and DELETE queries,\n     * but user can use them in WHERE expressions.\n     */\n    aliasNamePrefixingEnabled: boolean = true\n\n    /**\n     * Indicates if query result cache is enabled or not.\n     */\n    cache: boolean = false\n\n    /**\n     * Time in milliseconds in which cache will expire.\n     * If not set then global caching time will be used.\n     */\n    cacheDuration: number\n\n    /**\n     * Cache id.\n     * Used to identifier your cache queries.\n     */\n    cacheId: string\n\n    /**\n     * Options that define QueryBuilder behaviour.\n     */\n    options: SelectQueryBuilderOption[] = []\n\n    /**\n     * Property path of relation to work with.\n     * Used in relational query builder.\n     */\n    relationPropertyPath: string\n\n    /**\n     * Entity (target) which relations will be updated.\n     */\n    of: any | any[]\n\n    /**\n     * List of columns where data should be inserted.\n     * Used in INSERT query.\n     */\n    insertColumns: string[] = []\n\n    /**\n     * Used if user wants to update or delete a specific entities.\n     */\n    whereEntities: ObjectLiteral[] = []\n\n    /**\n     * Indicates if entity must be updated after insertion / updation.\n     * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).\n     */\n    updateEntity: boolean = true\n\n    /**\n     * Indicates if listeners and subscribers must be called before and after query execution.\n     */\n    callListeners: boolean = true\n\n    /**\n     * Indicates if query must be wrapped into transaction.\n     */\n    useTransaction: boolean = false\n\n    /**\n     * Extra parameters.\n     *\n     * @deprecated Use standard parameters instead\n     */\n    nativeParameters: ObjectLiteral = {}\n\n    /**\n     * Query Comment to include extra information for debugging or other purposes.\n     */\n    comment?: string\n\n    /**\n     * Items from an entity that have been locally generated & are recorded here for later use.\n     * Examples include the UUID generation when the database does not natively support it.\n     * These are included in the entity index order.\n     */\n    locallyGenerated: { [key: number]: ObjectLiteral } = {}\n\n    commonTableExpressions: {\n        queryBuilder: QueryBuilder<any> | string\n        alias: string\n        options: QueryBuilderCteOptions\n    }[] = []\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(protected connection: DataSource) {\n        if (connection.options.relationLoadStrategy) {\n            this.relationLoadStrategy = connection.options.relationLoadStrategy\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Accessors\n    // -------------------------------------------------------------------------\n\n    /**\n     * Get all ORDER BY queries - if order by is specified by user then it uses them,\n     * otherwise it uses default entity order by if it was set.\n     */\n    get allOrderBys() {\n        if (\n            !Object.keys(this.orderBys).length &&\n            this.mainAlias!.hasMetadata &&\n            this.options.indexOf(\"disable-global-order\") === -1\n        ) {\n            const entityOrderBy = this.mainAlias!.metadata.orderBy || {}\n            return Object.keys(entityOrderBy).reduce((orderBy, key) => {\n                orderBy[this.mainAlias!.name + \".\" + key] = entityOrderBy[key]\n                return orderBy\n            }, {} as OrderByCondition)\n        }\n\n        return this.orderBys\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates a main alias and adds it to the current expression map.\n     */\n    setMainAlias(alias: Alias): Alias {\n        // if main alias is already set then remove it from the array\n        // if (this.mainAlias)\n        //     this.aliases.splice(this.aliases.indexOf(this.mainAlias));\n\n        // set new main alias\n        this.mainAlias = alias\n\n        return alias\n    }\n\n    /**\n     * Creates a new alias and adds it to the current expression map.\n     */\n    createAlias(options: {\n        type: \"from\" | \"select\" | \"join\" | \"other\"\n        name?: string\n        target?: Function | string\n        tablePath?: string\n        subQuery?: string\n        metadata?: EntityMetadata\n    }): Alias {\n        let aliasName = options.name\n        if (!aliasName && options.tablePath) aliasName = options.tablePath\n        if (!aliasName && typeof options.target === \"function\")\n            aliasName = options.target.name\n        if (!aliasName && typeof options.target === \"string\")\n            aliasName = options.target\n\n        const alias = new Alias()\n        alias.type = options.type\n        if (aliasName) alias.name = aliasName\n        if (options.metadata) alias.metadata = options.metadata\n        if (options.target && !alias.hasMetadata)\n            alias.metadata = this.connection.getMetadata(options.target)\n        if (options.tablePath) alias.tablePath = options.tablePath\n        if (options.subQuery) alias.subQuery = options.subQuery\n\n        this.aliases.push(alias)\n        return alias\n    }\n\n    /**\n     * Finds alias with the given name.\n     * If alias was not found it throw an exception.\n     */\n    findAliasByName(aliasName: string): Alias {\n        const alias = this.aliases.find((alias) => alias.name === aliasName)\n        if (!alias)\n            throw new TypeORMError(\n                `\"${aliasName}\" alias was not found. Maybe you forgot to join it?`,\n            )\n\n        return alias\n    }\n\n    findColumnByAliasExpression(\n        aliasExpression: string,\n    ): ColumnMetadata | undefined {\n        const [aliasName, propertyPath] = aliasExpression.split(\".\")\n        const alias = this.findAliasByName(aliasName)\n        return alias.metadata.findColumnWithPropertyName(propertyPath)\n    }\n\n    /**\n     * Gets relation metadata of the relation this query builder works with.\n     *\n     * todo: add proper exceptions\n     */\n    get relationMetadata(): RelationMetadata {\n        if (!this.mainAlias)\n            throw new TypeORMError(`Entity to work with is not specified!`) // todo: better message\n\n        const relationMetadata =\n            this.mainAlias.metadata.findRelationWithPropertyPath(\n                this.relationPropertyPath,\n            )\n        if (!relationMetadata)\n            throw new TypeORMError(\n                `Relation ${this.relationPropertyPath} was not found in entity ${this.mainAlias.name}`,\n            ) // todo: better message\n\n        return relationMetadata\n    }\n\n    /**\n     * Copies all properties of the current QueryExpressionMap into a new one.\n     * Useful when QueryBuilder needs to create a copy of itself.\n     */\n    clone(): QueryExpressionMap {\n        const map = new QueryExpressionMap(this.connection)\n        map.queryType = this.queryType\n        map.selects = this.selects.map((select) => select)\n        map.maxExecutionTime = this.maxExecutionTime\n        map.selectDistinct = this.selectDistinct\n        map.selectDistinctOn = this.selectDistinctOn\n        this.aliases.forEach((alias) => map.aliases.push(new Alias(alias)))\n        map.relationLoadStrategy = this.relationLoadStrategy\n        map.mainAlias = this.mainAlias\n        map.valuesSet = this.valuesSet\n        map.returning = this.returning\n        map.onConflict = this.onConflict\n        map.onIgnore = this.onIgnore\n        map.onUpdate = this.onUpdate\n        map.joinAttributes = this.joinAttributes.map(\n            (join) => new JoinAttribute(this.connection, this, join),\n        )\n        map.relationIdAttributes = this.relationIdAttributes.map(\n            (relationId) => new RelationIdAttribute(this, relationId),\n        )\n        map.relationCountAttributes = this.relationCountAttributes.map(\n            (relationCount) => new RelationCountAttribute(this, relationCount),\n        )\n        map.wheres = this.wheres.map((where) => ({ ...where }))\n        map.havings = this.havings.map((having) => ({ ...having }))\n        map.orderBys = Object.assign({}, this.orderBys)\n        map.groupBys = this.groupBys.map((groupBy) => groupBy)\n        map.limit = this.limit\n        map.offset = this.offset\n        map.skip = this.skip\n        map.take = this.take\n        map.lockMode = this.lockMode\n        map.onLocked = this.onLocked\n        map.lockVersion = this.lockVersion\n        map.lockTables = this.lockTables\n        map.withDeleted = this.withDeleted\n        map.parameters = Object.assign({}, this.parameters)\n        map.disableEscaping = this.disableEscaping\n        map.enableRelationIdValues = this.enableRelationIdValues\n        map.extraAppendedAndWhereCondition = this.extraAppendedAndWhereCondition\n        map.subQuery = this.subQuery\n        map.aliasNamePrefixingEnabled = this.aliasNamePrefixingEnabled\n        map.cache = this.cache\n        map.cacheId = this.cacheId\n        map.cacheDuration = this.cacheDuration\n        map.relationPropertyPath = this.relationPropertyPath\n        map.of = this.of\n        map.insertColumns = this.insertColumns\n        map.whereEntities = this.whereEntities\n        map.updateEntity = this.updateEntity\n        map.callListeners = this.callListeners\n        map.useTransaction = this.useTransaction\n        map.nativeParameters = Object.assign({}, this.nativeParameters)\n        map.comment = this.comment\n        map.commonTableExpressions = this.commonTableExpressions.map(\n            (cteOptions) => ({\n                alias: cteOptions.alias,\n                queryBuilder:\n                    typeof cteOptions.queryBuilder === \"string\"\n                        ? cteOptions.queryBuilder\n                        : cteOptions.queryBuilder.clone(),\n                options: cteOptions.options,\n            }),\n        )\n        return map\n    }\n}\n"]},"metadata":{},"sourceType":"module"}