{"ast":null,"code":"import { FindRelationsNotFoundError } from \"../error/FindRelationsNotFoundError\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\n/**\n * Utilities to work with FindOptions.\n */\n\nexport class FindOptionsUtils {\n  // -------------------------------------------------------------------------\n  // Public Static Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Checks if given object is really instance of FindOneOptions interface.\n   */\n  static isFindOneOptions(obj) {\n    const possibleOptions = obj;\n    return possibleOptions && (Array.isArray(possibleOptions.select) || Array.isArray(possibleOptions.relations) || typeof possibleOptions.select === \"object\" || typeof possibleOptions.relations === \"object\" || typeof possibleOptions.where === \"object\" || // typeof possibleOptions.where === \"string\" ||\n    typeof possibleOptions.join === \"object\" || typeof possibleOptions.order === \"object\" || typeof possibleOptions.cache === \"object\" || typeof possibleOptions.cache === \"boolean\" || typeof possibleOptions.cache === \"number\" || typeof possibleOptions.comment === \"string\" || typeof possibleOptions.lock === \"object\" || typeof possibleOptions.loadRelationIds === \"object\" || typeof possibleOptions.loadRelationIds === \"boolean\" || typeof possibleOptions.loadEagerRelations === \"boolean\" || typeof possibleOptions.withDeleted === \"boolean\" || typeof possibleOptions.relationLoadStrategy === \"string\" || typeof possibleOptions.transaction === \"boolean\");\n  }\n  /**\n   * Checks if given object is really instance of FindManyOptions interface.\n   */\n\n\n  static isFindManyOptions(obj) {\n    const possibleOptions = obj;\n    return possibleOptions && (this.isFindOneOptions(possibleOptions) || typeof possibleOptions.skip === \"number\" || typeof possibleOptions.take === \"number\" || typeof possibleOptions.skip === \"string\" || typeof possibleOptions.take === \"string\");\n  }\n  /**\n   * Checks if given object is really instance of FindOptions interface.\n   */\n\n\n  static extractFindManyOptionsAlias(object) {\n    if (this.isFindManyOptions(object) && object.join) return object.join.alias;\n    return undefined;\n  }\n  /**\n   * Applies give find many options to the given query builder.\n   static applyFindManyOptionsOrConditionsToQueryBuilder<T>(qb: SelectQueryBuilder<T>, options: FindManyOptions<T>|Partial<T>|undefined): SelectQueryBuilder<T> {\n      if (this.isFindManyOptions(options))\n          return this.applyOptionsToQueryBuilder(qb, options);\n       if (options)\n          return qb.where(options);\n       return qb;\n  }*/\n\n  /**\n   * Applies give find options to the given query builder.\n   static applyOptionsToQueryBuilder<T>(qb: SelectQueryBuilder<T>, options: FindOneOptions<T>|FindManyOptions<T>|undefined): SelectQueryBuilder<T> {\n       // if options are not set then simply return query builder. This is made for simplicity of usage.\n      if (!options || (!this.isFindOneOptions(options) && !this.isFindManyOptions(options)))\n          return qb;\n       if (options.transaction === true) {\n          qb.expressionMap.useTransaction = true;\n      }\n       if (!qb.expressionMap.mainAlias || !qb.expressionMap.mainAlias.hasMetadata)\n          return qb;\n       const metadata = qb.expressionMap.mainAlias!.metadata;\n       // apply all options from FindOptions\n      if (options.comment) {\n          qb.comment(options.comment);\n      }\n       if (options.withDeleted) {\n          qb.withDeleted();\n      }\n       if (options.select) {\n          qb.select([]);\n          options.select.forEach(select => {\n              if (!metadata.hasColumnWithPropertyPath(`${select}`))\n                  throw new TypeORMError(`${select} column was not found in the ${metadata.name} entity.`);\n               const columns = metadata.findColumnsWithPropertyPath(`${select}`);\n               for (const column of columns) {\n                  qb.addSelect(qb.alias + \".\" + column.propertyPath);\n              }\n          });\n      }\n       if (options.relations) {\n          // Copy because `applyRelationsRecursively` modifies it\n          const allRelations = [...options.relations];\n          this.applyRelationsRecursively(qb, allRelations, qb.expressionMap.mainAlias!.name, qb.expressionMap.mainAlias!.metadata, \"\");\n          // recursive removes found relations from allRelations array\n          // if there are relations left in this array it means those relations were not found in the entity structure\n          // so, we give an exception about not found relations\n          if (allRelations.length > 0)\n              throw new FindRelationsNotFoundError(allRelations);\n      }\n       if (options.join) {\n          if (options.join.leftJoin)\n              Object.keys(options.join.leftJoin).forEach(key => {\n                  qb.leftJoin(options.join!.leftJoin![key], key);\n              });\n           if (options.join.innerJoin)\n              Object.keys(options.join.innerJoin).forEach(key => {\n                  qb.innerJoin(options.join!.innerJoin![key], key);\n              });\n           if (options.join.leftJoinAndSelect)\n              Object.keys(options.join.leftJoinAndSelect).forEach(key => {\n                  qb.leftJoinAndSelect(options.join!.leftJoinAndSelect![key], key);\n              });\n           if (options.join.innerJoinAndSelect)\n              Object.keys(options.join.innerJoinAndSelect).forEach(key => {\n                  qb.innerJoinAndSelect(options.join!.innerJoinAndSelect![key], key);\n              });\n      }\n       if (options.cache) {\n          if (options.cache instanceof Object) {\n              const cache = options.cache as { id: any, milliseconds: number };\n              qb.cache(cache.id, cache.milliseconds);\n          } else {\n              qb.cache(options.cache);\n          }\n      }\n       if (options.lock) {\n          if (options.lock.mode === \"optimistic\") {\n              qb.setLock(options.lock.mode, options.lock.version);\n          } else if (\n              options.lock.mode === \"pessimistic_read\" ||\n              options.lock.mode === \"pessimistic_write\" ||\n              options.lock.mode === \"dirty_read\" ||\n              options.lock.mode === \"pessimistic_partial_write\" ||\n              options.lock.mode === \"pessimistic_write_or_fail\" ||\n              options.lock.mode === \"for_no_key_update\" ||\n              options.lock.mode === \"for_key_share\"\n          ) {\n              const tableNames = options.lock.tables ? options.lock.tables.map((table) => {\n                  const tableAlias = qb.expressionMap.aliases.find((alias) => {\n                      return alias.metadata.tableNameWithoutPrefix === table;\n                  });\n                  if (!tableAlias) {\n                      throw new TypeORMError(`\"${table}\" is not part of this query`);\n                  }\n                  return qb.escape(tableAlias.name);\n              }) : undefined;\n              qb.setLock(options.lock.mode, undefined, tableNames);\n          }\n      }\n       if (options.loadRelationIds === true) {\n          qb.loadAllRelationIds();\n       } else if (options.loadRelationIds instanceof Object) {\n          qb.loadAllRelationIds(options.loadRelationIds as any);\n      }\n       if (options.where)\n          qb.where(options.where);\n       if ((options as FindManyOptions<T>).skip)\n          qb.skip((options as FindManyOptions<T>).skip!);\n       if ((options as FindManyOptions<T>).take)\n          qb.take((options as FindManyOptions<T>).take!);\n       if (options.order)\n          Object.keys(options.order).forEach(key => {\n              const order = ((options as FindOneOptions<T>).order as any)[key as any];\n               if (!metadata.findColumnWithPropertyPath(key))\n                  throw new Error(`${key} column was not found in the ${metadata.name} entity.`);\n               switch (order) {\n                  case 1:\n                      qb.addOrderBy(qb.alias + \".\" + key, \"ASC\");\n                      break;\n                  case -1:\n                      qb.addOrderBy(qb.alias + \".\" + key, \"DESC\");\n                      break;\n                  case \"ASC\":\n                      qb.addOrderBy(qb.alias + \".\" + key, \"ASC\");\n                      break;\n                  case \"DESC\":\n                      qb.addOrderBy(qb.alias + \".\" + key, \"DESC\");\n                      break;\n              }\n          });\n       return qb;\n  }*/\n\n\n  static applyOptionsToTreeQueryBuilder(qb, options) {\n    if (options === null || options === void 0 ? void 0 : options.relations) {\n      // Copy because `applyRelationsRecursively` modifies it\n      const allRelations = [...options.relations];\n      FindOptionsUtils.applyRelationsRecursively(qb, allRelations, qb.expressionMap.mainAlias.name, qb.expressionMap.mainAlias.metadata, \"\"); // recursive removes found relations from allRelations array\n      // if there are relations left in this array it means those relations were not found in the entity structure\n      // so, we give an exception about not found relations\n\n      if (allRelations.length > 0) throw new FindRelationsNotFoundError(allRelations);\n    }\n\n    return qb;\n  } // -------------------------------------------------------------------------\n  // Protected Static Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Adds joins for all relations and sub-relations of the given relations provided in the find options.\n   */\n\n\n  static applyRelationsRecursively(qb, allRelations, alias, metadata, prefix) {\n    // find all relations that match given prefix\n    let matchedBaseRelations = [];\n\n    if (prefix) {\n      const regexp = new RegExp(\"^\" + prefix.replace(\".\", \"\\\\.\") + \"\\\\.\");\n      matchedBaseRelations = allRelations.filter(relation => relation.match(regexp)).map(relation => relation.replace(regexp, \"\")).filter(relation => metadata.findRelationWithPropertyPath(relation));\n    } else {\n      matchedBaseRelations = allRelations.filter(relation => metadata.findRelationWithPropertyPath(relation));\n    } // go through all matched relations and add join for them\n\n\n    matchedBaseRelations.forEach(relation => {\n      // generate a relation alias\n      let relationAlias = DriverUtils.buildAlias(qb.connection.driver, {\n        joiner: \"__\"\n      }, alias, relation); // add a join for the found relation\n\n      const selection = alias + \".\" + relation;\n      qb.leftJoinAndSelect(selection, relationAlias); // remove added relations from the allRelations array, this is needed to find all not found relations at the end\n\n      allRelations.splice(allRelations.indexOf(prefix ? prefix + \".\" + relation : relation), 1); // try to find sub-relations\n\n      const join = qb.expressionMap.joinAttributes.find(join => join.entityOrProperty === selection);\n      this.applyRelationsRecursively(qb, allRelations, join.alias.name, join.metadata, prefix ? prefix + \".\" + relation : relation); // join the eager relations of the found relation\n\n      const relMetadata = metadata.relations.find(metadata => metadata.propertyName === relation);\n\n      if (relMetadata) {\n        this.joinEagerRelations(qb, relationAlias, relMetadata.inverseEntityMetadata);\n      }\n    });\n  }\n\n  static joinEagerRelations(qb, alias, metadata) {\n    metadata.eagerRelations.forEach(relation => {\n      // generate a relation alias\n      let relationAlias = DriverUtils.buildAlias(qb.connection.driver, qb.connection.namingStrategy.eagerJoinRelationAlias(alias, relation.propertyPath)); // add a join for the relation\n      // Checking whether the relation wasn't joined yet.\n\n      let addJoin = true;\n\n      for (const join of qb.expressionMap.joinAttributes) {\n        if (join.condition !== undefined || join.mapToProperty !== undefined || join.isMappingMany !== undefined || join.direction !== \"LEFT\" || join.entityOrProperty !== `${alias}.${relation.propertyPath}`) {\n          continue;\n        }\n\n        addJoin = false;\n        relationAlias = join.alias.name;\n        break;\n      }\n\n      if (addJoin) {\n        qb.leftJoin(alias + \".\" + relation.propertyPath, relationAlias);\n      } // Checking whether the relation wasn't selected yet.\n      // This check shall be after the join check to detect relationAlias.\n\n\n      let addSelect = true;\n\n      for (const select of qb.expressionMap.selects) {\n        if (select.aliasName !== undefined || select.virtual !== undefined || select.selection !== relationAlias) {\n          continue;\n        }\n\n        addSelect = false;\n        break;\n      }\n\n      if (addSelect) {\n        qb.addSelect(relationAlias);\n      } // (recursive) join the eager relations\n\n\n      this.joinEagerRelations(qb, relationAlias, relation.inverseEntityMetadata);\n    });\n  }\n\n}","map":{"version":3,"mappings":"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","names":["FindRelationsNotFoundError","DriverUtils","FindOptionsUtils","isFindOneOptions","obj","possibleOptions","Array","isArray","select","relations","where","join","order","cache","comment","lock","loadRelationIds","loadEagerRelations","withDeleted","relationLoadStrategy","transaction","isFindManyOptions","skip","take","extractFindManyOptionsAlias","object","alias","undefined","applyOptionsToTreeQueryBuilder","qb","options","allRelations","applyRelationsRecursively","expressionMap","mainAlias","name","metadata","length","prefix","matchedBaseRelations","regexp","RegExp","replace","filter","relation","match","map","findRelationWithPropertyPath","forEach","relationAlias","buildAlias","connection","driver","joiner","selection","leftJoinAndSelect","splice","indexOf","joinAttributes","find","entityOrProperty","relMetadata","propertyName","joinEagerRelations","inverseEntityMetadata","eagerRelations","namingStrategy","eagerJoinRelationAlias","propertyPath","addJoin","condition","mapToProperty","isMappingMany","direction","leftJoin","addSelect","selects","aliasName","virtual"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\find-options\\FindOptionsUtils.ts"],"sourcesContent":["import { FindManyOptions } from \"./FindManyOptions\"\nimport { FindOneOptions } from \"./FindOneOptions\"\nimport { SelectQueryBuilder } from \"../query-builder/SelectQueryBuilder\"\nimport { FindRelationsNotFoundError } from \"../error/FindRelationsNotFoundError\"\nimport { EntityMetadata } from \"../metadata/EntityMetadata\"\nimport { DriverUtils } from \"../driver/DriverUtils\"\nimport { FindTreeOptions } from \"./FindTreeOptions\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\n\n/**\n * Utilities to work with FindOptions.\n */\nexport class FindOptionsUtils {\n    // -------------------------------------------------------------------------\n    // Public Static Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Checks if given object is really instance of FindOneOptions interface.\n     */\n    static isFindOneOptions<Entity = any>(\n        obj: any,\n    ): obj is FindOneOptions<Entity> {\n        const possibleOptions: FindOneOptions<Entity> = obj\n        return (\n            possibleOptions &&\n            (Array.isArray(possibleOptions.select) ||\n                Array.isArray(possibleOptions.relations) ||\n                typeof possibleOptions.select === \"object\" ||\n                typeof possibleOptions.relations === \"object\" ||\n                typeof possibleOptions.where === \"object\" ||\n                // typeof possibleOptions.where === \"string\" ||\n                typeof possibleOptions.join === \"object\" ||\n                typeof possibleOptions.order === \"object\" ||\n                typeof possibleOptions.cache === \"object\" ||\n                typeof possibleOptions.cache === \"boolean\" ||\n                typeof possibleOptions.cache === \"number\" ||\n                typeof possibleOptions.comment === \"string\" ||\n                typeof possibleOptions.lock === \"object\" ||\n                typeof possibleOptions.loadRelationIds === \"object\" ||\n                typeof possibleOptions.loadRelationIds === \"boolean\" ||\n                typeof possibleOptions.loadEagerRelations === \"boolean\" ||\n                typeof possibleOptions.withDeleted === \"boolean\" ||\n                typeof possibleOptions.relationLoadStrategy === \"string\" ||\n                typeof possibleOptions.transaction === \"boolean\")\n        )\n    }\n\n    /**\n     * Checks if given object is really instance of FindManyOptions interface.\n     */\n    static isFindManyOptions<Entity = any>(\n        obj: any,\n    ): obj is FindManyOptions<Entity> {\n        const possibleOptions: FindManyOptions<Entity> = obj\n        return (\n            possibleOptions &&\n            (this.isFindOneOptions(possibleOptions) ||\n                typeof (possibleOptions as FindManyOptions<any>).skip ===\n                    \"number\" ||\n                typeof (possibleOptions as FindManyOptions<any>).take ===\n                    \"number\" ||\n                typeof (possibleOptions as FindManyOptions<any>).skip ===\n                    \"string\" ||\n                typeof (possibleOptions as FindManyOptions<any>).take ===\n                    \"string\")\n        )\n    }\n\n    /**\n     * Checks if given object is really instance of FindOptions interface.\n     */\n    static extractFindManyOptionsAlias(object: any): string | undefined {\n        if (this.isFindManyOptions(object) && object.join)\n            return object.join.alias\n\n        return undefined\n    }\n\n    /**\n     * Applies give find many options to the given query builder.\n\n    static applyFindManyOptionsOrConditionsToQueryBuilder<T>(qb: SelectQueryBuilder<T>, options: FindManyOptions<T>|Partial<T>|undefined): SelectQueryBuilder<T> {\n        if (this.isFindManyOptions(options))\n            return this.applyOptionsToQueryBuilder(qb, options);\n\n        if (options)\n            return qb.where(options);\n\n        return qb;\n    }*/\n\n    /**\n     * Applies give find options to the given query builder.\n\n    static applyOptionsToQueryBuilder<T>(qb: SelectQueryBuilder<T>, options: FindOneOptions<T>|FindManyOptions<T>|undefined): SelectQueryBuilder<T> {\n\n        // if options are not set then simply return query builder. This is made for simplicity of usage.\n        if (!options || (!this.isFindOneOptions(options) && !this.isFindManyOptions(options)))\n            return qb;\n\n        if (options.transaction === true) {\n            qb.expressionMap.useTransaction = true;\n        }\n\n        if (!qb.expressionMap.mainAlias || !qb.expressionMap.mainAlias.hasMetadata)\n            return qb;\n\n        const metadata = qb.expressionMap.mainAlias!.metadata;\n\n        // apply all options from FindOptions\n        if (options.comment) {\n            qb.comment(options.comment);\n        }\n\n        if (options.withDeleted) {\n            qb.withDeleted();\n        }\n\n        if (options.select) {\n            qb.select([]);\n            options.select.forEach(select => {\n                if (!metadata.hasColumnWithPropertyPath(`${select}`))\n                    throw new TypeORMError(`${select} column was not found in the ${metadata.name} entity.`);\n\n                const columns = metadata.findColumnsWithPropertyPath(`${select}`);\n\n                for (const column of columns) {\n                    qb.addSelect(qb.alias + \".\" + column.propertyPath);\n                }\n            });\n        }\n\n        if (options.relations) {\n            // Copy because `applyRelationsRecursively` modifies it\n            const allRelations = [...options.relations];\n            this.applyRelationsRecursively(qb, allRelations, qb.expressionMap.mainAlias!.name, qb.expressionMap.mainAlias!.metadata, \"\");\n            // recursive removes found relations from allRelations array\n            // if there are relations left in this array it means those relations were not found in the entity structure\n            // so, we give an exception about not found relations\n            if (allRelations.length > 0)\n                throw new FindRelationsNotFoundError(allRelations);\n        }\n\n        if (options.join) {\n            if (options.join.leftJoin)\n                Object.keys(options.join.leftJoin).forEach(key => {\n                    qb.leftJoin(options.join!.leftJoin![key], key);\n                });\n\n            if (options.join.innerJoin)\n                Object.keys(options.join.innerJoin).forEach(key => {\n                    qb.innerJoin(options.join!.innerJoin![key], key);\n                });\n\n            if (options.join.leftJoinAndSelect)\n                Object.keys(options.join.leftJoinAndSelect).forEach(key => {\n                    qb.leftJoinAndSelect(options.join!.leftJoinAndSelect![key], key);\n                });\n\n            if (options.join.innerJoinAndSelect)\n                Object.keys(options.join.innerJoinAndSelect).forEach(key => {\n                    qb.innerJoinAndSelect(options.join!.innerJoinAndSelect![key], key);\n                });\n        }\n\n        if (options.cache) {\n            if (options.cache instanceof Object) {\n                const cache = options.cache as { id: any, milliseconds: number };\n                qb.cache(cache.id, cache.milliseconds);\n            } else {\n                qb.cache(options.cache);\n            }\n        }\n\n        if (options.lock) {\n            if (options.lock.mode === \"optimistic\") {\n                qb.setLock(options.lock.mode, options.lock.version);\n            } else if (\n                options.lock.mode === \"pessimistic_read\" ||\n                options.lock.mode === \"pessimistic_write\" ||\n                options.lock.mode === \"dirty_read\" ||\n                options.lock.mode === \"pessimistic_partial_write\" ||\n                options.lock.mode === \"pessimistic_write_or_fail\" ||\n                options.lock.mode === \"for_no_key_update\" ||\n                options.lock.mode === \"for_key_share\"\n            ) {\n                const tableNames = options.lock.tables ? options.lock.tables.map((table) => {\n                    const tableAlias = qb.expressionMap.aliases.find((alias) => {\n                        return alias.metadata.tableNameWithoutPrefix === table;\n                    });\n                    if (!tableAlias) {\n                        throw new TypeORMError(`\"${table}\" is not part of this query`);\n                    }\n                    return qb.escape(tableAlias.name);\n                }) : undefined;\n                qb.setLock(options.lock.mode, undefined, tableNames);\n            }\n        }\n\n        if (options.loadRelationIds === true) {\n            qb.loadAllRelationIds();\n\n        } else if (options.loadRelationIds instanceof Object) {\n            qb.loadAllRelationIds(options.loadRelationIds as any);\n        }\n\n        if (options.where)\n            qb.where(options.where);\n\n        if ((options as FindManyOptions<T>).skip)\n            qb.skip((options as FindManyOptions<T>).skip!);\n\n        if ((options as FindManyOptions<T>).take)\n            qb.take((options as FindManyOptions<T>).take!);\n\n        if (options.order)\n            Object.keys(options.order).forEach(key => {\n                const order = ((options as FindOneOptions<T>).order as any)[key as any];\n\n                if (!metadata.findColumnWithPropertyPath(key))\n                    throw new Error(`${key} column was not found in the ${metadata.name} entity.`);\n\n                switch (order) {\n                    case 1:\n                        qb.addOrderBy(qb.alias + \".\" + key, \"ASC\");\n                        break;\n                    case -1:\n                        qb.addOrderBy(qb.alias + \".\" + key, \"DESC\");\n                        break;\n                    case \"ASC\":\n                        qb.addOrderBy(qb.alias + \".\" + key, \"ASC\");\n                        break;\n                    case \"DESC\":\n                        qb.addOrderBy(qb.alias + \".\" + key, \"DESC\");\n                        break;\n                }\n            });\n\n        return qb;\n    }*/\n\n    static applyOptionsToTreeQueryBuilder<T extends ObjectLiteral>(\n        qb: SelectQueryBuilder<T>,\n        options?: FindTreeOptions,\n    ): SelectQueryBuilder<T> {\n        if (options?.relations) {\n            // Copy because `applyRelationsRecursively` modifies it\n            const allRelations = [...options.relations]\n\n            FindOptionsUtils.applyRelationsRecursively(\n                qb,\n                allRelations,\n                qb.expressionMap.mainAlias!.name,\n                qb.expressionMap.mainAlias!.metadata,\n                \"\",\n            )\n\n            // recursive removes found relations from allRelations array\n            // if there are relations left in this array it means those relations were not found in the entity structure\n            // so, we give an exception about not found relations\n            if (allRelations.length > 0)\n                throw new FindRelationsNotFoundError(allRelations)\n        }\n\n        return qb\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Static Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Adds joins for all relations and sub-relations of the given relations provided in the find options.\n     */\n    public static applyRelationsRecursively(\n        qb: SelectQueryBuilder<any>,\n        allRelations: string[],\n        alias: string,\n        metadata: EntityMetadata,\n        prefix: string,\n    ): void {\n        // find all relations that match given prefix\n        let matchedBaseRelations: string[] = []\n        if (prefix) {\n            const regexp = new RegExp(\"^\" + prefix.replace(\".\", \"\\\\.\") + \"\\\\.\")\n            matchedBaseRelations = allRelations\n                .filter((relation) => relation.match(regexp))\n                .map((relation) => relation.replace(regexp, \"\"))\n                .filter((relation) =>\n                    metadata.findRelationWithPropertyPath(relation),\n                )\n        } else {\n            matchedBaseRelations = allRelations.filter((relation) =>\n                metadata.findRelationWithPropertyPath(relation),\n            )\n        }\n\n        // go through all matched relations and add join for them\n        matchedBaseRelations.forEach((relation) => {\n            // generate a relation alias\n            let relationAlias: string = DriverUtils.buildAlias(\n                qb.connection.driver,\n                { joiner: \"__\" },\n                alias,\n                relation,\n            )\n\n            // add a join for the found relation\n            const selection = alias + \".\" + relation\n            qb.leftJoinAndSelect(selection, relationAlias)\n\n            // remove added relations from the allRelations array, this is needed to find all not found relations at the end\n            allRelations.splice(\n                allRelations.indexOf(\n                    prefix ? prefix + \".\" + relation : relation,\n                ),\n                1,\n            )\n\n            // try to find sub-relations\n            const join = qb.expressionMap.joinAttributes.find(\n                (join) => join.entityOrProperty === selection,\n            )\n            this.applyRelationsRecursively(\n                qb,\n                allRelations,\n                join!.alias.name,\n                join!.metadata!,\n                prefix ? prefix + \".\" + relation : relation,\n            )\n\n            // join the eager relations of the found relation\n            const relMetadata = metadata.relations.find(\n                (metadata) => metadata.propertyName === relation,\n            )\n            if (relMetadata) {\n                this.joinEagerRelations(\n                    qb,\n                    relationAlias,\n                    relMetadata.inverseEntityMetadata,\n                )\n            }\n        })\n    }\n\n    public static joinEagerRelations(\n        qb: SelectQueryBuilder<any>,\n        alias: string,\n        metadata: EntityMetadata,\n    ) {\n        metadata.eagerRelations.forEach((relation) => {\n            // generate a relation alias\n            let relationAlias = DriverUtils.buildAlias(\n                qb.connection.driver,\n                qb.connection.namingStrategy.eagerJoinRelationAlias(\n                    alias,\n                    relation.propertyPath,\n                ),\n            )\n\n            // add a join for the relation\n            // Checking whether the relation wasn't joined yet.\n            let addJoin = true\n            for (const join of qb.expressionMap.joinAttributes) {\n                if (\n                    join.condition !== undefined ||\n                    join.mapToProperty !== undefined ||\n                    join.isMappingMany !== undefined ||\n                    join.direction !== \"LEFT\" ||\n                    join.entityOrProperty !==\n                        `${alias}.${relation.propertyPath}`\n                ) {\n                    continue\n                }\n                addJoin = false\n                relationAlias = join.alias.name\n                break\n            }\n\n            if (addJoin) {\n                qb.leftJoin(alias + \".\" + relation.propertyPath, relationAlias)\n            }\n\n            // Checking whether the relation wasn't selected yet.\n            // This check shall be after the join check to detect relationAlias.\n            let addSelect = true\n            for (const select of qb.expressionMap.selects) {\n                if (\n                    select.aliasName !== undefined ||\n                    select.virtual !== undefined ||\n                    select.selection !== relationAlias\n                ) {\n                    continue\n                }\n                addSelect = false\n                break\n            }\n\n            if (addSelect) {\n                qb.addSelect(relationAlias)\n            }\n\n            // (recursive) join the eager relations\n            this.joinEagerRelations(\n                qb,\n                relationAlias,\n                relation.inverseEntityMetadata,\n            )\n        })\n    }\n}\n"]},"metadata":{},"sourceType":"module"}