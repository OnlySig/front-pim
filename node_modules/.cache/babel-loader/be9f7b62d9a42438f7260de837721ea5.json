{"ast":null,"code":"import { OrmUtils } from \"../../util/OrmUtils\";\nimport { NestedSetMultipleRootError } from \"../../error/NestedSetMultipleRootError\";\n\nclass NestedSetIds {}\n/**\n * Executes subject operations for nested set tree entities.\n */\n\n\nexport class NestedSetSubjectExecutor {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(queryRunner) {\n    this.queryRunner = queryRunner;\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Executes operations when subject is being inserted.\n   */\n\n\n  async insert(subject) {\n    const escape = alias => this.queryRunner.connection.driver.escape(alias);\n\n    const tableName = this.getTableName(subject.metadata.tablePath);\n    const leftColumnName = escape(subject.metadata.nestedSetLeftColumn.databaseName);\n    const rightColumnName = escape(subject.metadata.nestedSetRightColumn.databaseName);\n    let parent = subject.metadata.treeParentRelation.getEntityValue(subject.entity); // if entity was attached via parent\n\n    if (!parent && subject.parentSubject && subject.parentSubject.entity) // if entity was attached via children\n      parent = subject.parentSubject.insertedValueSet ? subject.parentSubject.insertedValueSet : subject.parentSubject.entity;\n    const parentId = subject.metadata.getEntityIdMap(parent);\n    let parentNsRight = undefined;\n\n    if (parentId) {\n      parentNsRight = await this.queryRunner.manager.createQueryBuilder().select(subject.metadata.targetName + \".\" + subject.metadata.nestedSetRightColumn.propertyPath, \"right\").from(subject.metadata.target, subject.metadata.targetName).whereInIds(parentId).getRawOne().then(result => {\n        const value = result ? result[\"right\"] : undefined; // CockroachDB returns numeric types as string\n\n        return typeof value === \"string\" ? parseInt(value) : value;\n      });\n    }\n\n    if (parentNsRight !== undefined) {\n      await this.queryRunner.query(`UPDATE ${tableName} SET ` + `${leftColumnName} = CASE WHEN ${leftColumnName} > ${parentNsRight} THEN ${leftColumnName} + 2 ELSE ${leftColumnName} END,` + `${rightColumnName} = ${rightColumnName} + 2 ` + `WHERE ${rightColumnName} >= ${parentNsRight}`);\n      OrmUtils.mergeDeep(subject.insertedValueSet, subject.metadata.nestedSetLeftColumn.createValueMap(parentNsRight), subject.metadata.nestedSetRightColumn.createValueMap(parentNsRight + 1));\n    } else {\n      const isUniqueRoot = await this.isUniqueRootEntity(subject, parent); // Validate if a root entity already exits and throw an exception\n\n      if (!isUniqueRoot) throw new NestedSetMultipleRootError();\n      OrmUtils.mergeDeep(subject.insertedValueSet, subject.metadata.nestedSetLeftColumn.createValueMap(1), subject.metadata.nestedSetRightColumn.createValueMap(2));\n    }\n  }\n  /**\n   * Executes operations when subject is being updated.\n   */\n\n\n  async update(subject) {\n    let parent = subject.metadata.treeParentRelation.getEntityValue(subject.entity); // if entity was attached via parent\n\n    if (!parent && subject.parentSubject && subject.parentSubject.entity) // if entity was attached via children\n      parent = subject.parentSubject.entity;\n    let entity = subject.databaseEntity; // if entity was attached via parent\n\n    if (!entity && parent) // if entity was attached via children\n      entity = subject.metadata.treeChildrenRelation.getEntityValue(parent).find(child => {\n        return Object.entries(subject.identifier).every(_ref => {\n          let [key, value] = _ref;\n          return child[key] === value;\n        });\n      }); // Exit if the parent or the entity where never set\n\n    if (entity === undefined || parent === undefined) {\n      return;\n    }\n\n    const oldParent = subject.metadata.treeParentRelation.getEntityValue(entity);\n    const oldParentId = subject.metadata.getEntityIdMap(oldParent);\n    const parentId = subject.metadata.getEntityIdMap(parent); // Exit if the new and old parents are the same\n\n    if (OrmUtils.compareIds(oldParentId, parentId)) {\n      return;\n    }\n\n    if (parent) {\n      const escape = alias => this.queryRunner.connection.driver.escape(alias);\n\n      const tableName = this.getTableName(subject.metadata.tablePath);\n      const leftColumnName = escape(subject.metadata.nestedSetLeftColumn.databaseName);\n      const rightColumnName = escape(subject.metadata.nestedSetRightColumn.databaseName);\n      const entityId = subject.metadata.getEntityIdMap(entity);\n      let entityNs = undefined;\n\n      if (entityId) {\n        entityNs = (await this.getNestedSetIds(subject.metadata, entityId))[0];\n      }\n\n      let parentNs = undefined;\n\n      if (parentId) {\n        parentNs = (await this.getNestedSetIds(subject.metadata, parentId))[0];\n      }\n\n      if (entityNs !== undefined && parentNs !== undefined) {\n        const isMovingUp = parentNs.left > entityNs.left;\n        const treeSize = entityNs.right - entityNs.left + 1;\n        let entitySize;\n\n        if (isMovingUp) {\n          entitySize = parentNs.left - entityNs.right;\n        } else {\n          entitySize = parentNs.right - entityNs.left;\n        } // Moved entity logic\n\n\n        const updateLeftSide = `WHEN ${leftColumnName} >= ${entityNs.left} AND ` + `${leftColumnName} < ${entityNs.right} ` + `THEN ${leftColumnName} + ${entitySize} `;\n        const updateRightSide = `WHEN ${rightColumnName} > ${entityNs.left} AND ` + `${rightColumnName} <= ${entityNs.right} ` + `THEN ${rightColumnName} + ${entitySize} `; // Update the surrounding entities\n\n        if (isMovingUp) {\n          await this.queryRunner.query(`UPDATE ${tableName} ` + `SET ${leftColumnName} = CASE ` + `WHEN ${leftColumnName} > ${entityNs.right} AND ` + `${leftColumnName} <= ${parentNs.left} ` + `THEN ${leftColumnName} - ${treeSize} ` + updateLeftSide + `ELSE ${leftColumnName} ` + `END, ` + `${rightColumnName} = CASE ` + `WHEN ${rightColumnName} > ${entityNs.right} AND ` + `${rightColumnName} < ${parentNs.left} ` + `THEN ${rightColumnName} - ${treeSize} ` + updateRightSide + `ELSE ${rightColumnName} ` + `END`);\n        } else {\n          await this.queryRunner.query(`UPDATE ${tableName} ` + `SET ${leftColumnName} = CASE ` + `WHEN ${leftColumnName} < ${entityNs.left} AND ` + `${leftColumnName} > ${parentNs.right} ` + `THEN ${leftColumnName} + ${treeSize} ` + updateLeftSide + `ELSE ${leftColumnName} ` + `END, ` + `${rightColumnName} = CASE ` + `WHEN ${rightColumnName} < ${entityNs.left} AND ` + `${rightColumnName} >= ${parentNs.right} ` + `THEN ${rightColumnName} + ${treeSize} ` + updateRightSide + `ELSE ${rightColumnName} ` + `END`);\n        }\n      }\n    } else {\n      const isUniqueRoot = await this.isUniqueRootEntity(subject, parent); // Validate if a root entity already exits and throw an exception\n\n      if (!isUniqueRoot) throw new NestedSetMultipleRootError();\n    }\n  }\n  /**\n   * Executes operations when subject is being removed.\n   */\n\n\n  async remove(subjects) {\n    if (!Array.isArray(subjects)) subjects = [subjects];\n    const metadata = subjects[0].metadata;\n\n    const escape = alias => this.queryRunner.connection.driver.escape(alias);\n\n    const tableName = this.getTableName(metadata.tablePath);\n    const leftColumnName = escape(metadata.nestedSetLeftColumn.databaseName);\n    const rightColumnName = escape(metadata.nestedSetRightColumn.databaseName);\n    let entitiesIds = [];\n\n    for (const subject of subjects) {\n      const entityId = metadata.getEntityIdMap(subject.entity);\n\n      if (entityId) {\n        entitiesIds.push(entityId);\n      }\n    }\n\n    let entitiesNs = await this.getNestedSetIds(metadata, entitiesIds);\n\n    for (const entity of entitiesNs) {\n      const treeSize = entity.right - entity.left + 1;\n      await this.queryRunner.query(`UPDATE ${tableName} ` + `SET ${leftColumnName} = CASE ` + `WHEN ${leftColumnName} > ${entity.left} THEN ${leftColumnName} - ${treeSize} ` + `ELSE ${leftColumnName} ` + `END, ` + `${rightColumnName} = CASE ` + `WHEN ${rightColumnName} > ${entity.right} THEN ${rightColumnName} - ${treeSize} ` + `ELSE ${rightColumnName} ` + `END`);\n    }\n  }\n  /**\n   * Get the nested set ids for a given entity\n   */\n\n\n  getNestedSetIds(metadata, ids) {\n    const select = {\n      left: `${metadata.targetName}.${metadata.nestedSetLeftColumn.propertyPath}`,\n      right: `${metadata.targetName}.${metadata.nestedSetRightColumn.propertyPath}`\n    };\n    const queryBuilder = this.queryRunner.manager.createQueryBuilder();\n    Object.entries(select).forEach(_ref2 => {\n      let [key, value] = _ref2;\n      queryBuilder.addSelect(value, key);\n    });\n    return queryBuilder.from(metadata.target, metadata.targetName).whereInIds(ids).orderBy(select.right, \"DESC\").getRawMany().then(results => {\n      const data = [];\n\n      for (const result of results) {\n        const entry = {};\n\n        for (const key of Object.keys(select)) {\n          const value = result ? result[key] : undefined; // CockroachDB returns numeric types as string\n\n          entry[key] = typeof value === \"string\" ? parseInt(value) : value;\n        }\n\n        data.push(entry);\n      }\n\n      return data;\n    });\n  }\n\n  async isUniqueRootEntity(subject, parent) {\n    const escape = alias => this.queryRunner.connection.driver.escape(alias);\n\n    const tableName = this.getTableName(subject.metadata.tablePath);\n    const parameters = [];\n    const whereCondition = subject.metadata.treeParentRelation.joinColumns.map(column => {\n      const columnName = escape(column.databaseName);\n      const parameter = column.getEntityValue(parent);\n\n      if (parameter == null) {\n        return `${columnName} IS NULL`;\n      }\n\n      parameters.push(parameter);\n      const parameterName = this.queryRunner.connection.driver.createParameter(\"entity_\" + column.databaseName, parameters.length - 1);\n      return `${columnName} = ${parameterName}`;\n    }).join(\" AND \");\n    const countAlias = \"count\";\n    const result = await this.queryRunner.query(`SELECT COUNT(1) AS ${escape(countAlias)} FROM ${tableName} WHERE ${whereCondition}`, parameters, true);\n    return parseInt(result.records[0][countAlias]) === 0;\n  }\n  /**\n   * Gets escaped table name with schema name if SqlServer or Postgres driver used with custom\n   * schema name, otherwise returns escaped table name.\n   */\n\n\n  getTableName(tablePath) {\n    return tablePath.split(\".\").map(i => {\n      // this condition need because in SQL Server driver when custom database name was specified and schema name was not, we got `dbName..tableName` string, and doesn't need to escape middle empty string\n      return i === \"\" ? i : this.queryRunner.connection.driver.escape(i);\n    }).join(\".\");\n  }\n\n}","map":{"version":3,"mappings":"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","names":["OrmUtils","NestedSetMultipleRootError","NestedSetIds","NestedSetSubjectExecutor","constructor","queryRunner","insert","subject","escape","alias","connection","driver","tableName","getTableName","metadata","tablePath","leftColumnName","nestedSetLeftColumn","databaseName","rightColumnName","nestedSetRightColumn","parent","treeParentRelation","getEntityValue","entity","parentSubject","insertedValueSet","parentId","getEntityIdMap","parentNsRight","undefined","manager","createQueryBuilder","select","targetName","propertyPath","from","target","whereInIds","getRawOne","then","result","value","parseInt","query","mergeDeep","createValueMap","isUniqueRoot","isUniqueRootEntity","update","databaseEntity","treeChildrenRelation","find","child","Object","entries","identifier","every","key","oldParent","oldParentId","compareIds","entityId","entityNs","getNestedSetIds","parentNs","isMovingUp","left","treeSize","right","entitySize","updateLeftSide","updateRightSide","remove","subjects","Array","isArray","entitiesIds","push","entitiesNs","ids","queryBuilder","forEach","addSelect","orderBy","getRawMany","results","data","entry","keys","parameters","whereCondition","joinColumns","map","column","columnName","parameter","parameterName","createParameter","length","join","countAlias","records","split","i"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\persistence\\tree\\NestedSetSubjectExecutor.ts"],"sourcesContent":["import { Subject } from \"../Subject\"\nimport { QueryRunner } from \"../../query-runner/QueryRunner\"\nimport { OrmUtils } from \"../../util/OrmUtils\"\nimport { NestedSetMultipleRootError } from \"../../error/NestedSetMultipleRootError\"\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { EntityMetadata } from \"../../metadata/EntityMetadata\"\n\nclass NestedSetIds {\n    left: number\n    right: number\n}\n\n/**\n * Executes subject operations for nested set tree entities.\n */\nexport class NestedSetSubjectExecutor {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(protected queryRunner: QueryRunner) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Executes operations when subject is being inserted.\n     */\n    async insert(subject: Subject): Promise<void> {\n        const escape = (alias: string) =>\n            this.queryRunner.connection.driver.escape(alias)\n        const tableName = this.getTableName(subject.metadata.tablePath)\n        const leftColumnName = escape(\n            subject.metadata.nestedSetLeftColumn!.databaseName,\n        )\n        const rightColumnName = escape(\n            subject.metadata.nestedSetRightColumn!.databaseName,\n        )\n\n        let parent = subject.metadata.treeParentRelation!.getEntityValue(\n            subject.entity!,\n        ) // if entity was attached via parent\n        if (!parent && subject.parentSubject && subject.parentSubject.entity)\n            // if entity was attached via children\n            parent = subject.parentSubject.insertedValueSet\n                ? subject.parentSubject.insertedValueSet\n                : subject.parentSubject.entity\n        const parentId = subject.metadata.getEntityIdMap(parent)\n\n        let parentNsRight: number | undefined = undefined\n        if (parentId) {\n            parentNsRight = await this.queryRunner.manager\n                .createQueryBuilder()\n                .select(\n                    subject.metadata.targetName +\n                        \".\" +\n                        subject.metadata.nestedSetRightColumn!.propertyPath,\n                    \"right\",\n                )\n                .from(subject.metadata.target, subject.metadata.targetName)\n                .whereInIds(parentId)\n                .getRawOne()\n                .then((result) => {\n                    const value: any = result ? result[\"right\"] : undefined\n                    // CockroachDB returns numeric types as string\n                    return typeof value === \"string\" ? parseInt(value) : value\n                })\n        }\n\n        if (parentNsRight !== undefined) {\n            await this.queryRunner.query(\n                `UPDATE ${tableName} SET ` +\n                    `${leftColumnName} = CASE WHEN ${leftColumnName} > ${parentNsRight} THEN ${leftColumnName} + 2 ELSE ${leftColumnName} END,` +\n                    `${rightColumnName} = ${rightColumnName} + 2 ` +\n                    `WHERE ${rightColumnName} >= ${parentNsRight}`,\n            )\n\n            OrmUtils.mergeDeep(\n                subject.insertedValueSet,\n                subject.metadata.nestedSetLeftColumn!.createValueMap(\n                    parentNsRight,\n                ),\n                subject.metadata.nestedSetRightColumn!.createValueMap(\n                    parentNsRight + 1,\n                ),\n            )\n        } else {\n            const isUniqueRoot = await this.isUniqueRootEntity(subject, parent)\n\n            // Validate if a root entity already exits and throw an exception\n            if (!isUniqueRoot) throw new NestedSetMultipleRootError()\n\n            OrmUtils.mergeDeep(\n                subject.insertedValueSet,\n                subject.metadata.nestedSetLeftColumn!.createValueMap(1),\n                subject.metadata.nestedSetRightColumn!.createValueMap(2),\n            )\n        }\n    }\n\n    /**\n     * Executes operations when subject is being updated.\n     */\n    async update(subject: Subject): Promise<void> {\n        let parent = subject.metadata.treeParentRelation!.getEntityValue(\n            subject.entity!,\n        ) // if entity was attached via parent\n        if (!parent && subject.parentSubject && subject.parentSubject.entity)\n            // if entity was attached via children\n            parent = subject.parentSubject.entity\n\n        let entity = subject.databaseEntity // if entity was attached via parent\n        if (!entity && parent)\n            // if entity was attached via children\n            entity = subject.metadata\n                .treeChildrenRelation!.getEntityValue(parent)\n                .find((child: any) => {\n                    return Object.entries(subject.identifier!).every(\n                        ([key, value]) => child[key] === value,\n                    )\n                })\n\n        // Exit if the parent or the entity where never set\n        if (entity === undefined || parent === undefined) {\n            return\n        }\n\n        const oldParent = subject.metadata.treeParentRelation!.getEntityValue(\n            entity!,\n        )\n        const oldParentId = subject.metadata.getEntityIdMap(oldParent)\n        const parentId = subject.metadata.getEntityIdMap(parent)\n\n        // Exit if the new and old parents are the same\n        if (OrmUtils.compareIds(oldParentId, parentId)) {\n            return\n        }\n\n        if (parent) {\n            const escape = (alias: string) =>\n                this.queryRunner.connection.driver.escape(alias)\n            const tableName = this.getTableName(subject.metadata.tablePath)\n            const leftColumnName = escape(\n                subject.metadata.nestedSetLeftColumn!.databaseName,\n            )\n            const rightColumnName = escape(\n                subject.metadata.nestedSetRightColumn!.databaseName,\n            )\n\n            const entityId = subject.metadata.getEntityIdMap(entity)\n\n            let entityNs: NestedSetIds | undefined = undefined\n            if (entityId) {\n                entityNs = (\n                    await this.getNestedSetIds(subject.metadata, entityId)\n                )[0]\n            }\n\n            let parentNs: NestedSetIds | undefined = undefined\n            if (parentId) {\n                parentNs = (\n                    await this.getNestedSetIds(subject.metadata, parentId)\n                )[0]\n            }\n\n            if (entityNs !== undefined && parentNs !== undefined) {\n                const isMovingUp = parentNs.left > entityNs.left\n                const treeSize = entityNs.right - entityNs.left + 1\n\n                let entitySize: number\n                if (isMovingUp) {\n                    entitySize = parentNs.left - entityNs.right\n                } else {\n                    entitySize = parentNs.right - entityNs.left\n                }\n\n                // Moved entity logic\n                const updateLeftSide =\n                    `WHEN ${leftColumnName} >= ${entityNs.left} AND ` +\n                    `${leftColumnName} < ${entityNs.right} ` +\n                    `THEN ${leftColumnName} + ${entitySize} `\n\n                const updateRightSide =\n                    `WHEN ${rightColumnName} > ${entityNs.left} AND ` +\n                    `${rightColumnName} <= ${entityNs.right} ` +\n                    `THEN ${rightColumnName} + ${entitySize} `\n\n                // Update the surrounding entities\n                if (isMovingUp) {\n                    await this.queryRunner.query(\n                        `UPDATE ${tableName} ` +\n                            `SET ${leftColumnName} = CASE ` +\n                            `WHEN ${leftColumnName} > ${entityNs.right} AND ` +\n                            `${leftColumnName} <= ${parentNs.left} ` +\n                            `THEN ${leftColumnName} - ${treeSize} ` +\n                            updateLeftSide +\n                            `ELSE ${leftColumnName} ` +\n                            `END, ` +\n                            `${rightColumnName} = CASE ` +\n                            `WHEN ${rightColumnName} > ${entityNs.right} AND ` +\n                            `${rightColumnName} < ${parentNs.left} ` +\n                            `THEN ${rightColumnName} - ${treeSize} ` +\n                            updateRightSide +\n                            `ELSE ${rightColumnName} ` +\n                            `END`,\n                    )\n                } else {\n                    await this.queryRunner.query(\n                        `UPDATE ${tableName} ` +\n                            `SET ${leftColumnName} = CASE ` +\n                            `WHEN ${leftColumnName} < ${entityNs.left} AND ` +\n                            `${leftColumnName} > ${parentNs.right} ` +\n                            `THEN ${leftColumnName} + ${treeSize} ` +\n                            updateLeftSide +\n                            `ELSE ${leftColumnName} ` +\n                            `END, ` +\n                            `${rightColumnName} = CASE ` +\n                            `WHEN ${rightColumnName} < ${entityNs.left} AND ` +\n                            `${rightColumnName} >= ${parentNs.right} ` +\n                            `THEN ${rightColumnName} + ${treeSize} ` +\n                            updateRightSide +\n                            `ELSE ${rightColumnName} ` +\n                            `END`,\n                    )\n                }\n            }\n        } else {\n            const isUniqueRoot = await this.isUniqueRootEntity(subject, parent)\n\n            // Validate if a root entity already exits and throw an exception\n            if (!isUniqueRoot) throw new NestedSetMultipleRootError()\n        }\n    }\n\n    /**\n     * Executes operations when subject is being removed.\n     */\n    async remove(subjects: Subject | Subject[]): Promise<void> {\n        if (!Array.isArray(subjects)) subjects = [subjects]\n\n        const metadata = subjects[0].metadata\n\n        const escape = (alias: string) =>\n            this.queryRunner.connection.driver.escape(alias)\n        const tableName = this.getTableName(metadata.tablePath)\n        const leftColumnName = escape(\n            metadata.nestedSetLeftColumn!.databaseName,\n        )\n        const rightColumnName = escape(\n            metadata.nestedSetRightColumn!.databaseName,\n        )\n\n        let entitiesIds: ObjectLiteral[] = []\n        for (const subject of subjects) {\n            const entityId = metadata.getEntityIdMap(subject.entity)\n\n            if (entityId) {\n                entitiesIds.push(entityId)\n            }\n        }\n\n        let entitiesNs = await this.getNestedSetIds(metadata, entitiesIds)\n\n        for (const entity of entitiesNs) {\n            const treeSize = entity.right - entity.left + 1\n\n            await this.queryRunner.query(\n                `UPDATE ${tableName} ` +\n                    `SET ${leftColumnName} = CASE ` +\n                    `WHEN ${leftColumnName} > ${entity.left} THEN ${leftColumnName} - ${treeSize} ` +\n                    `ELSE ${leftColumnName} ` +\n                    `END, ` +\n                    `${rightColumnName} = CASE ` +\n                    `WHEN ${rightColumnName} > ${entity.right} THEN ${rightColumnName} - ${treeSize} ` +\n                    `ELSE ${rightColumnName} ` +\n                    `END`,\n            )\n        }\n    }\n\n    /**\n     * Get the nested set ids for a given entity\n     */\n    protected getNestedSetIds(\n        metadata: EntityMetadata,\n        ids: ObjectLiteral | ObjectLiteral[],\n    ): Promise<NestedSetIds[]> {\n        const select = {\n            left: `${metadata.targetName}.${\n                metadata.nestedSetLeftColumn!.propertyPath\n            }`,\n            right: `${metadata.targetName}.${\n                metadata.nestedSetRightColumn!.propertyPath\n            }`,\n        }\n\n        const queryBuilder = this.queryRunner.manager.createQueryBuilder()\n\n        Object.entries(select).forEach(([key, value]) => {\n            queryBuilder.addSelect(value, key)\n        })\n\n        return queryBuilder\n            .from(metadata.target, metadata.targetName)\n            .whereInIds(ids)\n            .orderBy(select.right, \"DESC\")\n            .getRawMany()\n            .then((results) => {\n                const data: NestedSetIds[] = []\n\n                for (const result of results) {\n                    const entry: any = {}\n                    for (const key of Object.keys(select)) {\n                        const value = result ? result[key] : undefined\n\n                        // CockroachDB returns numeric types as string\n                        entry[key] =\n                            typeof value === \"string\" ? parseInt(value) : value\n                    }\n                    data.push(entry)\n                }\n\n                return data\n            })\n    }\n\n    private async isUniqueRootEntity(\n        subject: Subject,\n        parent: any,\n    ): Promise<boolean> {\n        const escape = (alias: string) =>\n            this.queryRunner.connection.driver.escape(alias)\n        const tableName = this.getTableName(subject.metadata.tablePath)\n        const parameters: any[] = []\n        const whereCondition = subject.metadata\n            .treeParentRelation!.joinColumns.map((column) => {\n                const columnName = escape(column.databaseName)\n                const parameter = column.getEntityValue(parent)\n\n                if (parameter == null) {\n                    return `${columnName} IS NULL`\n                }\n\n                parameters.push(parameter)\n                const parameterName =\n                    this.queryRunner.connection.driver.createParameter(\n                        \"entity_\" + column.databaseName,\n                        parameters.length - 1,\n                    )\n                return `${columnName} = ${parameterName}`\n            })\n            .join(\" AND \")\n\n        const countAlias = \"count\"\n        const result = await this.queryRunner.query(\n            `SELECT COUNT(1) AS ${escape(\n                countAlias,\n            )} FROM ${tableName} WHERE ${whereCondition}`,\n            parameters,\n            true,\n        )\n\n        return parseInt(result.records[0][countAlias]) === 0\n    }\n\n    /**\n     * Gets escaped table name with schema name if SqlServer or Postgres driver used with custom\n     * schema name, otherwise returns escaped table name.\n     */\n    protected getTableName(tablePath: string): string {\n        return tablePath\n            .split(\".\")\n            .map((i) => {\n                // this condition need because in SQL Server driver when custom database name was specified and schema name was not, we got `dbName..tableName` string, and doesn't need to escape middle empty string\n                return i === \"\"\n                    ? i\n                    : this.queryRunner.connection.driver.escape(i)\n            })\n            .join(\".\")\n    }\n}\n"]},"metadata":{},"sourceType":"module"}