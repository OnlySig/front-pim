{"ast":null,"code":"import { CannotAttachTreeChildrenEntityError } from \"../../error/CannotAttachTreeChildrenEntityError\";\nimport { OrmUtils } from \"../../util/OrmUtils\";\n/**\n * Executes subject operations for closure entities.\n */\n\nexport class ClosureSubjectExecutor {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(queryRunner) {\n    this.queryRunner = queryRunner;\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Executes operations when subject is being inserted.\n   */\n\n\n  async insert(subject) {\n    // create values to be inserted into the closure junction\n    const closureJunctionInsertMap = {};\n    subject.metadata.closureJunctionTable.ancestorColumns.forEach(column => {\n      closureJunctionInsertMap[column.databaseName] = subject.identifier;\n    });\n    subject.metadata.closureJunctionTable.descendantColumns.forEach(column => {\n      closureJunctionInsertMap[column.databaseName] = subject.identifier;\n    }); // insert values into the closure junction table\n\n    await this.queryRunner.manager.createQueryBuilder().insert().into(subject.metadata.closureJunctionTable.tablePath).values(closureJunctionInsertMap).updateEntity(false).callListeners(false).execute();\n    let parent = subject.metadata.treeParentRelation.getEntityValue(subject.entity); // if entity was attached via parent\n\n    if (!parent && subject.parentSubject && subject.parentSubject.entity) // if entity was attached via children\n      parent = subject.parentSubject.insertedValueSet ? subject.parentSubject.insertedValueSet : subject.parentSubject.entity;\n\n    if (parent) {\n      const escape = alias => this.queryRunner.connection.driver.escape(alias);\n\n      const tableName = this.getTableName(subject.metadata.closureJunctionTable.tablePath);\n      const queryParams = [];\n      const ancestorColumnNames = subject.metadata.closureJunctionTable.ancestorColumns.map(column => {\n        return escape(column.databaseName);\n      });\n      const descendantColumnNames = subject.metadata.closureJunctionTable.descendantColumns.map(column => {\n        return escape(column.databaseName);\n      });\n      const childEntityIds1 = subject.metadata.primaryColumns.map(column => {\n        queryParams.push(column.getEntityValue(subject.insertedValueSet ? subject.insertedValueSet : subject.entity));\n        return this.queryRunner.connection.driver.createParameter(\"child_entity_\" + column.databaseName, queryParams.length - 1);\n      });\n      const whereCondition = subject.metadata.closureJunctionTable.descendantColumns.map(column => {\n        const columnName = escape(column.databaseName);\n        const parentId = column.referencedColumn.getEntityValue(parent);\n        if (!parentId) throw new CannotAttachTreeChildrenEntityError(subject.metadata.name);\n        queryParams.push(parentId);\n        const parameterName = this.queryRunner.connection.driver.createParameter(\"parent_entity_\" + column.referencedColumn.databaseName, queryParams.length - 1);\n        return `${columnName} = ${parameterName}`;\n      });\n      await this.queryRunner.query(`INSERT INTO ${tableName} (${[...ancestorColumnNames, ...descendantColumnNames].join(\", \")}) ` + `SELECT ${ancestorColumnNames.join(\", \")}, ${childEntityIds1.join(\", \")} FROM ${tableName} WHERE ${whereCondition.join(\" AND \")}`, queryParams);\n    }\n  }\n  /**\n   * Executes operations when subject is being updated.\n   */\n\n\n  async update(subject) {\n    let parent = subject.metadata.treeParentRelation.getEntityValue(subject.entity); // if entity was attached via parent\n\n    if (!parent && subject.parentSubject && subject.parentSubject.entity) // if entity was attached via children\n      parent = subject.parentSubject.entity;\n    let entity = subject.databaseEntity; // if entity was attached via parent\n\n    if (!entity && parent) // if entity was attached via children\n      entity = subject.metadata.treeChildrenRelation.getEntityValue(parent).find(child => {\n        return Object.entries(subject.identifier).every(_ref => {\n          let [key, value] = _ref;\n          return child[key] === value;\n        });\n      }); // Exit if the parent or the entity where never set\n\n    if (entity === undefined || parent === undefined) {\n      return;\n    }\n\n    const oldParent = subject.metadata.treeParentRelation.getEntityValue(entity);\n    const oldParentId = subject.metadata.getEntityIdMap(oldParent);\n    const parentId = subject.metadata.getEntityIdMap(parent); // Exit if the new and old parents are the same\n\n    if (OrmUtils.compareIds(oldParentId, parentId)) {\n      return;\n    }\n\n    const escape = alias => this.queryRunner.connection.driver.escape(alias);\n\n    const closureTable = subject.metadata.closureJunctionTable;\n    const ancestorColumnNames = closureTable.ancestorColumns.map(column => {\n      return escape(column.databaseName);\n    });\n    const descendantColumnNames = closureTable.descendantColumns.map(column => {\n      return escape(column.databaseName);\n    }); // Delete logic\n\n    const createSubQuery = (qb, alias) => {\n      const subAlias = `sub${alias}`;\n      const subSelect = qb.createQueryBuilder().select(descendantColumnNames.join(\", \")).from(closureTable.tablePath, subAlias); // Create where conditions e.g. (WHERE \"subdescendant\".\"id_ancestor\" = :value_id)\n\n      for (const column of closureTable.ancestorColumns) {\n        subSelect.andWhere(`${escape(subAlias)}.${escape(column.databaseName)} = :value_${column.referencedColumn.databaseName}`);\n      }\n\n      return qb.createQueryBuilder().select(descendantColumnNames.join(\", \")).from(`(${subSelect.getQuery()})`, alias).setParameters(subSelect.getParameters()).getQuery();\n    };\n\n    const parameters = {};\n\n    for (const column of subject.metadata.primaryColumns) {\n      parameters[`value_${column.databaseName}`] = entity[column.databaseName];\n    }\n\n    await this.queryRunner.manager.createQueryBuilder().delete().from(closureTable.tablePath).where(qb => `(${descendantColumnNames.join(\", \")}) IN (${createSubQuery(qb, \"descendant\")})`).andWhere(qb => `(${ancestorColumnNames.join(\", \")}) NOT IN (${createSubQuery(qb, \"ancestor\")})`).setParameters(parameters).execute();\n    /**\n     * Only insert new parent if it exits\n     *\n     * This only happens if the entity doesn't become a root entity\n     */\n\n    if (parent) {\n      // Insert logic\n      const queryParams = [];\n      const tableName = this.getTableName(closureTable.tablePath);\n      const superAlias = escape(\"supertree\");\n      const subAlias = escape(\"subtree\");\n      const select = [...ancestorColumnNames.map(columnName => `${superAlias}.${columnName}`), ...descendantColumnNames.map(columnName => `${subAlias}.${columnName}`)];\n      const entityWhereCondition = subject.metadata.closureJunctionTable.ancestorColumns.map(column => {\n        const columnName = escape(column.databaseName);\n        const entityId = column.referencedColumn.getEntityValue(entity);\n        queryParams.push(entityId);\n        const parameterName = this.queryRunner.connection.driver.createParameter(\"entity_\" + column.referencedColumn.databaseName, queryParams.length - 1);\n        return `${subAlias}.${columnName} = ${parameterName}`;\n      });\n      const parentWhereCondition = subject.metadata.closureJunctionTable.descendantColumns.map(column => {\n        const columnName = escape(column.databaseName);\n        const parentId = column.referencedColumn.getEntityValue(parent);\n        if (!parentId) throw new CannotAttachTreeChildrenEntityError(subject.metadata.name);\n        queryParams.push(parentId);\n        const parameterName = this.queryRunner.connection.driver.createParameter(\"parent_entity_\" + column.referencedColumn.databaseName, queryParams.length - 1);\n        return `${superAlias}.${columnName} = ${parameterName}`;\n      });\n      await this.queryRunner.query(`INSERT INTO ${tableName} (${[...ancestorColumnNames, ...descendantColumnNames].join(\", \")}) ` + `SELECT ${select.join(\", \")} ` + `FROM ${tableName} AS ${superAlias}, ${tableName} AS ${subAlias} ` + `WHERE ${[...entityWhereCondition, ...parentWhereCondition].join(\" AND \")}`, queryParams);\n    }\n  }\n  /**\n   * Executes operations when subject is being removed.\n   */\n\n\n  async remove(subjects) {\n    // Only mssql need to execute deletes for the juntion table as it doesn't support multi cascade paths.\n    if (!(this.queryRunner.connection.driver.options.type === \"mssql\")) {\n      return;\n    }\n\n    if (!Array.isArray(subjects)) subjects = [subjects];\n\n    const escape = alias => this.queryRunner.connection.driver.escape(alias);\n\n    const identifiers = subjects.map(subject => subject.identifier);\n    const closureTable = subjects[0].metadata.closureJunctionTable;\n\n    const generateWheres = columns => {\n      return columns.map(column => {\n        const data = identifiers.map(identifier => identifier[column.referencedColumn.databaseName]);\n        return `${escape(column.databaseName)} IN (${data.join(\", \")})`;\n      }).join(\" AND \");\n    };\n\n    const ancestorWhere = generateWheres(closureTable.ancestorColumns);\n    const descendantWhere = generateWheres(closureTable.descendantColumns);\n    await this.queryRunner.manager.createQueryBuilder().delete().from(closureTable.tablePath).where(ancestorWhere).orWhere(descendantWhere).execute();\n  }\n  /**\n   * Gets escaped table name with schema name if SqlServer or Postgres driver used with custom\n   * schema name, otherwise returns escaped table name.\n   */\n\n\n  getTableName(tablePath) {\n    return tablePath.split(\".\").map(i => {\n      // this condition need because in SQL Server driver when custom database name was specified and schema name was not, we got `dbName..tableName` string, and doesn't need to escape middle empty string\n      return i === \"\" ? i : this.queryRunner.connection.driver.escape(i);\n    }).join(\".\");\n  }\n\n}","map":{"version":3,"mappings":"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","names":["CannotAttachTreeChildrenEntityError","OrmUtils","ClosureSubjectExecutor","constructor","queryRunner","insert","subject","closureJunctionInsertMap","metadata","closureJunctionTable","ancestorColumns","forEach","column","databaseName","identifier","descendantColumns","manager","createQueryBuilder","into","tablePath","values","updateEntity","callListeners","execute","parent","treeParentRelation","getEntityValue","entity","parentSubject","insertedValueSet","escape","alias","connection","driver","tableName","getTableName","queryParams","ancestorColumnNames","map","descendantColumnNames","childEntityIds1","primaryColumns","push","createParameter","length","whereCondition","columnName","parentId","referencedColumn","name","parameterName","query","join","update","databaseEntity","treeChildrenRelation","find","child","Object","entries","every","key","value","undefined","oldParent","oldParentId","getEntityIdMap","compareIds","closureTable","createSubQuery","qb","subAlias","subSelect","select","from","andWhere","getQuery","setParameters","getParameters","parameters","delete","where","superAlias","entityWhereCondition","entityId","parentWhereCondition","remove","subjects","options","type","Array","isArray","identifiers","generateWheres","columns","data","ancestorWhere","descendantWhere","orWhere","split","i"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\persistence\\tree\\ClosureSubjectExecutor.ts"],"sourcesContent":["import { Subject } from \"../Subject\"\nimport { QueryRunner } from \"../../query-runner/QueryRunner\"\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { CannotAttachTreeChildrenEntityError } from \"../../error/CannotAttachTreeChildrenEntityError\"\nimport { DeleteQueryBuilder } from \"../../query-builder/DeleteQueryBuilder\"\nimport { OrmUtils } from \"../../util/OrmUtils\"\nimport { ColumnMetadata } from \"../../metadata/ColumnMetadata\"\n\n/**\n * Executes subject operations for closure entities.\n */\nexport class ClosureSubjectExecutor {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(protected queryRunner: QueryRunner) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Executes operations when subject is being inserted.\n     */\n    async insert(subject: Subject): Promise<void> {\n        // create values to be inserted into the closure junction\n        const closureJunctionInsertMap: ObjectLiteral = {}\n        subject.metadata.closureJunctionTable.ancestorColumns.forEach(\n            (column) => {\n                closureJunctionInsertMap[column.databaseName] =\n                    subject.identifier\n            },\n        )\n        subject.metadata.closureJunctionTable.descendantColumns.forEach(\n            (column) => {\n                closureJunctionInsertMap[column.databaseName] =\n                    subject.identifier\n            },\n        )\n\n        // insert values into the closure junction table\n        await this.queryRunner.manager\n            .createQueryBuilder()\n            .insert()\n            .into(subject.metadata.closureJunctionTable.tablePath)\n            .values(closureJunctionInsertMap)\n            .updateEntity(false)\n            .callListeners(false)\n            .execute()\n\n        let parent = subject.metadata.treeParentRelation!.getEntityValue(\n            subject.entity!,\n        ) // if entity was attached via parent\n        if (!parent && subject.parentSubject && subject.parentSubject.entity)\n            // if entity was attached via children\n            parent = subject.parentSubject.insertedValueSet\n                ? subject.parentSubject.insertedValueSet\n                : subject.parentSubject.entity\n\n        if (parent) {\n            const escape = (alias: string) =>\n                this.queryRunner.connection.driver.escape(alias)\n            const tableName = this.getTableName(\n                subject.metadata.closureJunctionTable.tablePath,\n            )\n            const queryParams: any[] = []\n\n            const ancestorColumnNames =\n                subject.metadata.closureJunctionTable.ancestorColumns.map(\n                    (column) => {\n                        return escape(column.databaseName)\n                    },\n                )\n            const descendantColumnNames =\n                subject.metadata.closureJunctionTable.descendantColumns.map(\n                    (column) => {\n                        return escape(column.databaseName)\n                    },\n                )\n            const childEntityIds1 = subject.metadata.primaryColumns.map(\n                (column) => {\n                    queryParams.push(\n                        column.getEntityValue(\n                            subject.insertedValueSet\n                                ? subject.insertedValueSet\n                                : subject.entity!,\n                        ),\n                    )\n                    return this.queryRunner.connection.driver.createParameter(\n                        \"child_entity_\" + column.databaseName,\n                        queryParams.length - 1,\n                    )\n                },\n            )\n\n            const whereCondition =\n                subject.metadata.closureJunctionTable.descendantColumns.map(\n                    (column) => {\n                        const columnName = escape(column.databaseName)\n                        const parentId =\n                            column.referencedColumn!.getEntityValue(parent)\n\n                        if (!parentId)\n                            throw new CannotAttachTreeChildrenEntityError(\n                                subject.metadata.name,\n                            )\n\n                        queryParams.push(parentId)\n                        const parameterName =\n                            this.queryRunner.connection.driver.createParameter(\n                                \"parent_entity_\" +\n                                    column.referencedColumn!.databaseName,\n                                queryParams.length - 1,\n                            )\n                        return `${columnName} = ${parameterName}`\n                    },\n                )\n\n            await this.queryRunner.query(\n                `INSERT INTO ${tableName} (${[\n                    ...ancestorColumnNames,\n                    ...descendantColumnNames,\n                ].join(\", \")}) ` +\n                    `SELECT ${ancestorColumnNames.join(\n                        \", \",\n                    )}, ${childEntityIds1.join(\n                        \", \",\n                    )} FROM ${tableName} WHERE ${whereCondition.join(\" AND \")}`,\n                queryParams,\n            )\n        }\n    }\n\n    /**\n     * Executes operations when subject is being updated.\n     */\n    async update(subject: Subject): Promise<void> {\n        let parent = subject.metadata.treeParentRelation!.getEntityValue(\n            subject.entity!,\n        ) // if entity was attached via parent\n        if (!parent && subject.parentSubject && subject.parentSubject.entity)\n            // if entity was attached via children\n            parent = subject.parentSubject.entity\n\n        let entity = subject.databaseEntity // if entity was attached via parent\n        if (!entity && parent)\n            // if entity was attached via children\n            entity = subject.metadata\n                .treeChildrenRelation!.getEntityValue(parent)\n                .find((child: any) => {\n                    return Object.entries(subject.identifier!).every(\n                        ([key, value]) => child[key] === value,\n                    )\n                })\n\n        // Exit if the parent or the entity where never set\n        if (entity === undefined || parent === undefined) {\n            return\n        }\n\n        const oldParent = subject.metadata.treeParentRelation!.getEntityValue(\n            entity!,\n        )\n        const oldParentId = subject.metadata.getEntityIdMap(oldParent)\n        const parentId = subject.metadata.getEntityIdMap(parent)\n\n        // Exit if the new and old parents are the same\n        if (OrmUtils.compareIds(oldParentId, parentId)) {\n            return\n        }\n\n        const escape = (alias: string) =>\n            this.queryRunner.connection.driver.escape(alias)\n        const closureTable = subject.metadata.closureJunctionTable\n\n        const ancestorColumnNames = closureTable.ancestorColumns.map(\n            (column) => {\n                return escape(column.databaseName)\n            },\n        )\n\n        const descendantColumnNames = closureTable.descendantColumns.map(\n            (column) => {\n                return escape(column.databaseName)\n            },\n        )\n\n        // Delete logic\n        const createSubQuery = (qb: DeleteQueryBuilder<any>, alias: string) => {\n            const subAlias = `sub${alias}`\n\n            const subSelect = qb\n                .createQueryBuilder()\n                .select(descendantColumnNames.join(\", \"))\n                .from(closureTable.tablePath, subAlias)\n\n            // Create where conditions e.g. (WHERE \"subdescendant\".\"id_ancestor\" = :value_id)\n            for (const column of closureTable.ancestorColumns) {\n                subSelect.andWhere(\n                    `${escape(subAlias)}.${escape(\n                        column.databaseName,\n                    )} = :value_${column.referencedColumn!.databaseName}`,\n                )\n            }\n\n            return qb\n                .createQueryBuilder()\n                .select(descendantColumnNames.join(\", \"))\n                .from(`(${subSelect.getQuery()})`, alias)\n                .setParameters(subSelect.getParameters())\n                .getQuery()\n        }\n\n        const parameters: ObjectLiteral = {}\n        for (const column of subject.metadata.primaryColumns) {\n            parameters[`value_${column.databaseName}`] =\n                entity![column.databaseName]\n        }\n\n        await this.queryRunner.manager\n            .createQueryBuilder()\n            .delete()\n            .from(closureTable.tablePath)\n            .where(\n                (qb) =>\n                    `(${descendantColumnNames.join(\", \")}) IN (${createSubQuery(\n                        qb,\n                        \"descendant\",\n                    )})`,\n            )\n            .andWhere(\n                (qb) =>\n                    `(${ancestorColumnNames.join(\n                        \", \",\n                    )}) NOT IN (${createSubQuery(qb, \"ancestor\")})`,\n            )\n            .setParameters(parameters)\n            .execute()\n\n        /**\n         * Only insert new parent if it exits\n         *\n         * This only happens if the entity doesn't become a root entity\n         */\n        if (parent) {\n            // Insert logic\n            const queryParams: any[] = []\n\n            const tableName = this.getTableName(closureTable.tablePath)\n            const superAlias = escape(\"supertree\")\n            const subAlias = escape(\"subtree\")\n\n            const select = [\n                ...ancestorColumnNames.map(\n                    (columnName) => `${superAlias}.${columnName}`,\n                ),\n                ...descendantColumnNames.map(\n                    (columnName) => `${subAlias}.${columnName}`,\n                ),\n            ]\n\n            const entityWhereCondition =\n                subject.metadata.closureJunctionTable.ancestorColumns.map(\n                    (column) => {\n                        const columnName = escape(column.databaseName)\n                        const entityId =\n                            column.referencedColumn!.getEntityValue(entity!)\n\n                        queryParams.push(entityId)\n                        const parameterName =\n                            this.queryRunner.connection.driver.createParameter(\n                                \"entity_\" +\n                                    column.referencedColumn!.databaseName,\n                                queryParams.length - 1,\n                            )\n                        return `${subAlias}.${columnName} = ${parameterName}`\n                    },\n                )\n\n            const parentWhereCondition =\n                subject.metadata.closureJunctionTable.descendantColumns.map(\n                    (column) => {\n                        const columnName = escape(column.databaseName)\n                        const parentId =\n                            column.referencedColumn!.getEntityValue(parent)\n\n                        if (!parentId)\n                            throw new CannotAttachTreeChildrenEntityError(\n                                subject.metadata.name,\n                            )\n\n                        queryParams.push(parentId)\n                        const parameterName =\n                            this.queryRunner.connection.driver.createParameter(\n                                \"parent_entity_\" +\n                                    column.referencedColumn!.databaseName,\n                                queryParams.length - 1,\n                            )\n                        return `${superAlias}.${columnName} = ${parameterName}`\n                    },\n                )\n\n            await this.queryRunner.query(\n                `INSERT INTO ${tableName} (${[\n                    ...ancestorColumnNames,\n                    ...descendantColumnNames,\n                ].join(\", \")}) ` +\n                    `SELECT ${select.join(\", \")} ` +\n                    `FROM ${tableName} AS ${superAlias}, ${tableName} AS ${subAlias} ` +\n                    `WHERE ${[\n                        ...entityWhereCondition,\n                        ...parentWhereCondition,\n                    ].join(\" AND \")}`,\n                queryParams,\n            )\n        }\n    }\n\n    /**\n     * Executes operations when subject is being removed.\n     */\n    async remove(subjects: Subject | Subject[]): Promise<void> {\n        // Only mssql need to execute deletes for the juntion table as it doesn't support multi cascade paths.\n        if (!(this.queryRunner.connection.driver.options.type === \"mssql\")) {\n            return\n        }\n\n        if (!Array.isArray(subjects)) subjects = [subjects]\n\n        const escape = (alias: string) =>\n            this.queryRunner.connection.driver.escape(alias)\n        const identifiers = subjects.map((subject) => subject.identifier)\n        const closureTable = subjects[0].metadata.closureJunctionTable\n\n        const generateWheres = (columns: ColumnMetadata[]) => {\n            return columns\n                .map((column) => {\n                    const data = identifiers.map(\n                        (identifier) =>\n                            identifier![column.referencedColumn!.databaseName],\n                    )\n                    return `${escape(column.databaseName)} IN (${data.join(\n                        \", \",\n                    )})`\n                })\n                .join(\" AND \")\n        }\n\n        const ancestorWhere = generateWheres(closureTable.ancestorColumns)\n        const descendantWhere = generateWheres(closureTable.descendantColumns)\n\n        await this.queryRunner.manager\n            .createQueryBuilder()\n            .delete()\n            .from(closureTable.tablePath)\n            .where(ancestorWhere)\n            .orWhere(descendantWhere)\n            .execute()\n    }\n\n    /**\n     * Gets escaped table name with schema name if SqlServer or Postgres driver used with custom\n     * schema name, otherwise returns escaped table name.\n     */\n    protected getTableName(tablePath: string): string {\n        return tablePath\n            .split(\".\")\n            .map((i) => {\n                // this condition need because in SQL Server driver when custom database name was specified and schema name was not, we got `dbName..tableName` string, and doesn't need to escape middle empty string\n                return i === \"\"\n                    ? i\n                    : this.queryRunner.connection.driver.escape(i)\n            })\n            .join(\".\")\n    }\n}\n"]},"metadata":{},"sourceType":"module"}