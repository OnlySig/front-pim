{"ast":null,"code":"import { RawSqlResultsToEntityTransformer } from \"./transformer/RawSqlResultsToEntityTransformer\";\nimport { PessimisticLockTransactionRequiredError } from \"../error/PessimisticLockTransactionRequiredError\";\nimport { NoVersionOrUpdateDateColumnError } from \"../error/NoVersionOrUpdateDateColumnError\";\nimport { OptimisticLockVersionMismatchError } from \"../error/OptimisticLockVersionMismatchError\";\nimport { OptimisticLockCanNotBeUsedError } from \"../error/OptimisticLockCanNotBeUsedError\";\nimport { JoinAttribute } from \"./JoinAttribute\";\nimport { RelationIdAttribute } from \"./relation-id/RelationIdAttribute\";\nimport { RelationCountAttribute } from \"./relation-count/RelationCountAttribute\";\nimport { RelationIdLoader } from \"./relation-id/RelationIdLoader\";\nimport { RelationIdMetadataToAttributeTransformer } from \"./relation-id/RelationIdMetadataToAttributeTransformer\";\nimport { RelationCountLoader } from \"./relation-count/RelationCountLoader\";\nimport { RelationCountMetadataToAttributeTransformer } from \"./relation-count/RelationCountMetadataToAttributeTransformer\";\nimport { QueryBuilder } from \"./QueryBuilder\";\nimport { LockNotSupportedOnGivenDriverError } from \"../error/LockNotSupportedOnGivenDriverError\";\nimport { OffsetWithoutLimitNotSupportedError } from \"../error/OffsetWithoutLimitNotSupportedError\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\nimport { EntityNotFoundError } from \"../error/EntityNotFoundError\";\nimport { TypeORMError } from \"../error\";\nimport { FindOptionsUtils } from \"../find-options/FindOptionsUtils\";\nimport { ApplyValueTransformers } from \"../util/ApplyValueTransformers\";\nimport { OrmUtils } from \"../util/OrmUtils\";\nimport { EntityPropertyNotFoundError } from \"../error/EntityPropertyNotFoundError\";\nimport { InstanceChecker } from \"../util/InstanceChecker\";\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n */\n\nexport class SelectQueryBuilder extends QueryBuilder {\n  constructor() {\n    super(...arguments);\n    this[\"@instanceof\"] = Symbol.for(\"SelectQueryBuilder\");\n    this.findOptions = {};\n    this.selects = [];\n    this.joins = [];\n    this.conditions = \"\";\n    this.orderBys = [];\n    this.relationMetadatas = [];\n  } // -------------------------------------------------------------------------\n  // Public Implemented Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Gets generated SQL query without parameters being replaced.\n   */\n\n\n  getQuery() {\n    let sql = this.createComment();\n    sql += this.createCteExpression();\n    sql += this.createSelectExpression();\n    sql += this.createJoinExpression();\n    sql += this.createWhereExpression();\n    sql += this.createGroupByExpression();\n    sql += this.createHavingExpression();\n    sql += this.createOrderByExpression();\n    sql += this.createLimitOffsetExpression();\n    sql += this.createLockExpression();\n    sql = sql.trim();\n    if (this.expressionMap.subQuery) sql = \"(\" + sql + \")\";\n    return sql;\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n\n  setFindOptions(findOptions) {\n    this.findOptions = findOptions;\n    this.applyFindOptions();\n    return this;\n  }\n  /**\n   * Creates a subquery - query that can be used inside other queries.\n   */\n\n\n  subQuery() {\n    const qb = this.createQueryBuilder();\n    qb.expressionMap.subQuery = true;\n    qb.parentQueryBuilder = this;\n    return qb;\n  }\n  /**\n   * Creates SELECT query and selects given data.\n   * Replaces all previous selections if they exist.\n   */\n\n\n  select(selection, selectionAliasName) {\n    this.expressionMap.queryType = \"select\";\n\n    if (Array.isArray(selection)) {\n      this.expressionMap.selects = selection.map(selection => ({\n        selection: selection\n      }));\n    } else if (typeof selection === \"function\") {\n      const subQueryBuilder = selection(this.subQuery());\n      this.setParameters(subQueryBuilder.getParameters());\n      this.expressionMap.selects.push({\n        selection: subQueryBuilder.getQuery(),\n        aliasName: selectionAliasName\n      });\n    } else if (selection) {\n      this.expressionMap.selects = [{\n        selection: selection,\n        aliasName: selectionAliasName\n      }];\n    }\n\n    return this;\n  }\n  /**\n   * Adds new selection to the SELECT query.\n   */\n\n\n  addSelect(selection, selectionAliasName) {\n    if (!selection) return this;\n\n    if (Array.isArray(selection)) {\n      this.expressionMap.selects = this.expressionMap.selects.concat(selection.map(selection => ({\n        selection: selection\n      })));\n    } else if (typeof selection === \"function\") {\n      const subQueryBuilder = selection(this.subQuery());\n      this.setParameters(subQueryBuilder.getParameters());\n      this.expressionMap.selects.push({\n        selection: subQueryBuilder.getQuery(),\n        aliasName: selectionAliasName\n      });\n    } else if (selection) {\n      this.expressionMap.selects.push({\n        selection: selection,\n        aliasName: selectionAliasName\n      });\n    }\n\n    return this;\n  }\n  /**\n   * Set max execution time.\n   * @param milliseconds\n   */\n\n\n  maxExecutionTime(milliseconds) {\n    this.expressionMap.maxExecutionTime = milliseconds;\n    return this;\n  }\n  /**\n   * Sets whether the selection is DISTINCT.\n   */\n\n\n  distinct() {\n    let distinct = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    this.expressionMap.selectDistinct = distinct;\n    return this;\n  }\n  /**\n   * Sets the distinct on clause for Postgres.\n   */\n\n\n  distinctOn(distinctOn) {\n    this.expressionMap.selectDistinctOn = distinctOn;\n    return this;\n  }\n  /**\n   * Specifies FROM which entity's table select/update/delete will be executed.\n   * Also sets a main string alias of the selection data.\n   * Removes all previously set from-s.\n   */\n\n\n  from(entityTarget, aliasName) {\n    const mainAlias = this.createFromAlias(entityTarget, aliasName);\n    this.expressionMap.setMainAlias(mainAlias);\n    return this;\n  }\n  /**\n   * Specifies FROM which entity's table select/update/delete will be executed.\n   * Also sets a main string alias of the selection data.\n   */\n\n\n  addFrom(entityTarget, aliasName) {\n    const alias = this.createFromAlias(entityTarget, aliasName);\n    if (!this.expressionMap.mainAlias) this.expressionMap.setMainAlias(alias);\n    return this;\n  }\n  /**\n   * INNER JOINs (without selection).\n   * You also need to specify an alias of the joined data.\n   * Optionally, you can add condition and parameters used in condition.\n   */\n\n\n  innerJoin(entityOrProperty, alias, condition, parameters) {\n    this.join(\"INNER\", entityOrProperty, alias, condition, parameters);\n    return this;\n  }\n  /**\n   * LEFT JOINs (without selection).\n   * You also need to specify an alias of the joined data.\n   * Optionally, you can add condition and parameters used in condition.\n   */\n\n\n  leftJoin(entityOrProperty, alias, condition, parameters) {\n    this.join(\"LEFT\", entityOrProperty, alias, condition, parameters);\n    return this;\n  }\n  /**\n   * INNER JOINs and adds all selection properties to SELECT.\n   * You also need to specify an alias of the joined data.\n   * Optionally, you can add condition and parameters used in condition.\n   */\n\n\n  innerJoinAndSelect(entityOrProperty, alias, condition, parameters) {\n    this.addSelect(alias);\n    this.innerJoin(entityOrProperty, alias, condition, parameters);\n    return this;\n  }\n  /**\n   * LEFT JOINs and adds all selection properties to SELECT.\n   * You also need to specify an alias of the joined data.\n   * Optionally, you can add condition and parameters used in condition.\n   */\n\n\n  leftJoinAndSelect(entityOrProperty, alias, condition, parameters) {\n    this.addSelect(alias);\n    this.leftJoin(entityOrProperty, alias, condition, parameters);\n    return this;\n  }\n  /**\n   * INNER JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n   * This is extremely useful when you want to select some data and map it to some virtual property.\n   * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n   * You also need to specify an alias of the joined data.\n   * Optionally, you can add condition and parameters used in condition.\n   */\n\n\n  innerJoinAndMapMany(mapToProperty, entityOrProperty, alias, condition, parameters) {\n    this.addSelect(alias);\n    this.join(\"INNER\", entityOrProperty, alias, condition, parameters, mapToProperty, true);\n    return this;\n  }\n  /**\n   * INNER JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n   * This is extremely useful when you want to select some data and map it to some virtual property.\n   * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n   * You also need to specify an alias of the joined data.\n   * Optionally, you can add condition and parameters used in condition.\n   */\n\n\n  innerJoinAndMapOne(mapToProperty, entityOrProperty, alias, condition, parameters) {\n    this.addSelect(alias);\n    this.join(\"INNER\", entityOrProperty, alias, condition, parameters, mapToProperty, false);\n    return this;\n  }\n  /**\n   * LEFT JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n   * This is extremely useful when you want to select some data and map it to some virtual property.\n   * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n   * You also need to specify an alias of the joined data.\n   * Optionally, you can add condition and parameters used in condition.\n   */\n\n\n  leftJoinAndMapMany(mapToProperty, entityOrProperty, alias, condition, parameters) {\n    this.addSelect(alias);\n    this.join(\"LEFT\", entityOrProperty, alias, condition, parameters, mapToProperty, true);\n    return this;\n  }\n  /**\n   * LEFT JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n   * This is extremely useful when you want to select some data and map it to some virtual property.\n   * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n   * You also need to specify an alias of the joined data.\n   * Optionally, you can add condition and parameters used in condition.\n   */\n\n\n  leftJoinAndMapOne(mapToProperty, entityOrProperty, alias, condition, parameters) {\n    this.addSelect(alias);\n    this.join(\"LEFT\", entityOrProperty, alias, condition, parameters, mapToProperty, false);\n    return this;\n  }\n  /**\n   * LEFT JOINs relation id and maps it into some entity's property.\n   * Optionally, you can add condition and parameters used in condition.\n   */\n\n\n  loadRelationIdAndMap(mapToProperty, relationName, aliasNameOrOptions, queryBuilderFactory) {\n    const relationIdAttribute = new RelationIdAttribute(this.expressionMap);\n    relationIdAttribute.mapToProperty = mapToProperty;\n    relationIdAttribute.relationName = relationName;\n    if (typeof aliasNameOrOptions === \"string\") relationIdAttribute.alias = aliasNameOrOptions;\n    if (typeof aliasNameOrOptions === \"object\" && aliasNameOrOptions.disableMixedMap) relationIdAttribute.disableMixedMap = true;\n    relationIdAttribute.queryBuilderFactory = queryBuilderFactory;\n    this.expressionMap.relationIdAttributes.push(relationIdAttribute);\n\n    if (relationIdAttribute.relation.junctionEntityMetadata) {\n      this.expressionMap.createAlias({\n        type: \"other\",\n        name: relationIdAttribute.junctionAlias,\n        metadata: relationIdAttribute.relation.junctionEntityMetadata\n      });\n    }\n\n    return this;\n  }\n  /**\n   * Counts number of entities of entity's relation and maps the value into some entity's property.\n   * Optionally, you can add condition and parameters used in condition.\n   */\n\n\n  loadRelationCountAndMap(mapToProperty, relationName, aliasName, queryBuilderFactory) {\n    const relationCountAttribute = new RelationCountAttribute(this.expressionMap);\n    relationCountAttribute.mapToProperty = mapToProperty;\n    relationCountAttribute.relationName = relationName;\n    relationCountAttribute.alias = aliasName;\n    relationCountAttribute.queryBuilderFactory = queryBuilderFactory;\n    this.expressionMap.relationCountAttributes.push(relationCountAttribute);\n    this.expressionMap.createAlias({\n      type: \"other\",\n      name: relationCountAttribute.junctionAlias\n    });\n\n    if (relationCountAttribute.relation.junctionEntityMetadata) {\n      this.expressionMap.createAlias({\n        type: \"other\",\n        name: relationCountAttribute.junctionAlias,\n        metadata: relationCountAttribute.relation.junctionEntityMetadata\n      });\n    }\n\n    return this;\n  }\n  /**\n   * Loads all relation ids for all relations of the selected entity.\n   * All relation ids will be mapped to relation property themself.\n   * If array of strings is given then loads only relation ids of the given properties.\n   */\n\n\n  loadAllRelationIds(options) {\n    // todo: add skip relations\n    this.expressionMap.mainAlias.metadata.relations.forEach(relation => {\n      if (options !== undefined && options.relations !== undefined && options.relations.indexOf(relation.propertyPath) === -1) return;\n      this.loadRelationIdAndMap(this.expressionMap.mainAlias.name + \".\" + relation.propertyPath, this.expressionMap.mainAlias.name + \".\" + relation.propertyPath, options);\n    });\n    return this;\n  }\n  /**\n   * Sets WHERE condition in the query builder.\n   * If you had previously WHERE expression defined,\n   * calling this function will override previously set WHERE conditions.\n   * Additionally you can add parameters used in where expression.\n   */\n\n\n  where(where, parameters) {\n    this.expressionMap.wheres = []; // don't move this block below since computeWhereParameter can add where expressions\n\n    const condition = this.getWhereCondition(where);\n    if (condition) this.expressionMap.wheres = [{\n      type: \"simple\",\n      condition: condition\n    }];\n    if (parameters) this.setParameters(parameters);\n    return this;\n  }\n  /**\n   * Adds new AND WHERE condition in the query builder.\n   * Additionally you can add parameters used in where expression.\n   */\n\n\n  andWhere(where, parameters) {\n    this.expressionMap.wheres.push({\n      type: \"and\",\n      condition: this.getWhereCondition(where)\n    });\n    if (parameters) this.setParameters(parameters);\n    return this;\n  }\n  /**\n   * Adds new OR WHERE condition in the query builder.\n   * Additionally you can add parameters used in where expression.\n   */\n\n\n  orWhere(where, parameters) {\n    this.expressionMap.wheres.push({\n      type: \"or\",\n      condition: this.getWhereCondition(where)\n    });\n    if (parameters) this.setParameters(parameters);\n    return this;\n  }\n  /**\n   * Adds new AND WHERE with conditions for the given ids.\n   *\n   * Ids are mixed.\n   * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].\n   * If you have multiple primary keys you need to pass object with property names and values specified,\n   * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]\n   */\n\n\n  whereInIds(ids) {\n    return this.where(this.getWhereInIdsCondition(ids));\n  }\n  /**\n   * Adds new AND WHERE with conditions for the given ids.\n   *\n   * Ids are mixed.\n   * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].\n   * If you have multiple primary keys you need to pass object with property names and values specified,\n   * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]\n   */\n\n\n  andWhereInIds(ids) {\n    return this.andWhere(this.getWhereInIdsCondition(ids));\n  }\n  /**\n   * Adds new OR WHERE with conditions for the given ids.\n   *\n   * Ids are mixed.\n   * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].\n   * If you have multiple primary keys you need to pass object with property names and values specified,\n   * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]\n   */\n\n\n  orWhereInIds(ids) {\n    return this.orWhere(this.getWhereInIdsCondition(ids));\n  }\n  /**\n   * Sets HAVING condition in the query builder.\n   * If you had previously HAVING expression defined,\n   * calling this function will override previously set HAVING conditions.\n   * Additionally you can add parameters used in where expression.\n   */\n\n\n  having(having, parameters) {\n    this.expressionMap.havings.push({\n      type: \"simple\",\n      condition: having\n    });\n    if (parameters) this.setParameters(parameters);\n    return this;\n  }\n  /**\n   * Adds new AND HAVING condition in the query builder.\n   * Additionally you can add parameters used in where expression.\n   */\n\n\n  andHaving(having, parameters) {\n    this.expressionMap.havings.push({\n      type: \"and\",\n      condition: having\n    });\n    if (parameters) this.setParameters(parameters);\n    return this;\n  }\n  /**\n   * Adds new OR HAVING condition in the query builder.\n   * Additionally you can add parameters used in where expression.\n   */\n\n\n  orHaving(having, parameters) {\n    this.expressionMap.havings.push({\n      type: \"or\",\n      condition: having\n    });\n    if (parameters) this.setParameters(parameters);\n    return this;\n  }\n  /**\n   * Sets GROUP BY condition in the query builder.\n   * If you had previously GROUP BY expression defined,\n   * calling this function will override previously set GROUP BY conditions.\n   */\n\n\n  groupBy(groupBy) {\n    if (groupBy) {\n      this.expressionMap.groupBys = [groupBy];\n    } else {\n      this.expressionMap.groupBys = [];\n    }\n\n    return this;\n  }\n  /**\n   * Adds GROUP BY condition in the query builder.\n   */\n\n\n  addGroupBy(groupBy) {\n    this.expressionMap.groupBys.push(groupBy);\n    return this;\n  }\n  /**\n   * Sets ORDER BY condition in the query builder.\n   * If you had previously ORDER BY expression defined,\n   * calling this function will override previously set ORDER BY conditions.\n   */\n\n\n  orderBy(sort) {\n    let order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"ASC\";\n    let nulls = arguments.length > 2 ? arguments[2] : undefined;\n    if (order !== undefined && order !== \"ASC\" && order !== \"DESC\") throw new TypeORMError(`SelectQueryBuilder.addOrderBy \"order\" can accept only \"ASC\" and \"DESC\" values.`);\n    if (nulls !== undefined && nulls !== \"NULLS FIRST\" && nulls !== \"NULLS LAST\") throw new TypeORMError(`SelectQueryBuilder.addOrderBy \"nulls\" can accept only \"NULLS FIRST\" and \"NULLS LAST\" values.`);\n\n    if (sort) {\n      if (typeof sort === \"object\") {\n        this.expressionMap.orderBys = sort;\n      } else {\n        if (nulls) {\n          this.expressionMap.orderBys = {\n            [sort]: {\n              order,\n              nulls\n            }\n          };\n        } else {\n          this.expressionMap.orderBys = {\n            [sort]: order\n          };\n        }\n      }\n    } else {\n      this.expressionMap.orderBys = {};\n    }\n\n    return this;\n  }\n  /**\n   * Adds ORDER BY condition in the query builder.\n   */\n\n\n  addOrderBy(sort) {\n    let order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"ASC\";\n    let nulls = arguments.length > 2 ? arguments[2] : undefined;\n    if (order !== undefined && order !== \"ASC\" && order !== \"DESC\") throw new TypeORMError(`SelectQueryBuilder.addOrderBy \"order\" can accept only \"ASC\" and \"DESC\" values.`);\n    if (nulls !== undefined && nulls !== \"NULLS FIRST\" && nulls !== \"NULLS LAST\") throw new TypeORMError(`SelectQueryBuilder.addOrderBy \"nulls\" can accept only \"NULLS FIRST\" and \"NULLS LAST\" values.`);\n\n    if (nulls) {\n      this.expressionMap.orderBys[sort] = {\n        order,\n        nulls\n      };\n    } else {\n      this.expressionMap.orderBys[sort] = order;\n    }\n\n    return this;\n  }\n  /**\n   * Set's LIMIT - maximum number of rows to be selected.\n   * NOTE that it may not work as you expect if you are using joins.\n   * If you want to implement pagination, and you are having join in your query,\n   * then use instead take method instead.\n   */\n\n\n  limit(limit) {\n    this.expressionMap.limit = this.normalizeNumber(limit);\n    if (this.expressionMap.limit !== undefined && isNaN(this.expressionMap.limit)) throw new TypeORMError(`Provided \"limit\" value is not a number. Please provide a numeric value.`);\n    return this;\n  }\n  /**\n   * Set's OFFSET - selection offset.\n   * NOTE that it may not work as you expect if you are using joins.\n   * If you want to implement pagination, and you are having join in your query,\n   * then use instead skip method instead.\n   */\n\n\n  offset(offset) {\n    this.expressionMap.offset = this.normalizeNumber(offset);\n    if (this.expressionMap.offset !== undefined && isNaN(this.expressionMap.offset)) throw new TypeORMError(`Provided \"offset\" value is not a number. Please provide a numeric value.`);\n    return this;\n  }\n  /**\n   * Sets maximal number of entities to take.\n   */\n\n\n  take(take) {\n    this.expressionMap.take = this.normalizeNumber(take);\n    if (this.expressionMap.take !== undefined && isNaN(this.expressionMap.take)) throw new TypeORMError(`Provided \"take\" value is not a number. Please provide a numeric value.`);\n    return this;\n  }\n  /**\n   * Sets number of entities to skip.\n   */\n\n\n  skip(skip) {\n    this.expressionMap.skip = this.normalizeNumber(skip);\n    if (this.expressionMap.skip !== undefined && isNaN(this.expressionMap.skip)) throw new TypeORMError(`Provided \"skip\" value is not a number. Please provide a numeric value.`);\n    return this;\n  }\n  /**\n   * Set certain index to be used by the query.\n   *\n   * @param index Name of index to be used.\n   */\n\n\n  useIndex(index) {\n    this.expressionMap.useIndex = index;\n    return this;\n  }\n  /**\n   * Sets locking mode.\n   */\n\n\n  setLock(lockMode, lockVersion, lockTables) {\n    this.expressionMap.lockMode = lockMode;\n    this.expressionMap.lockVersion = lockVersion;\n    this.expressionMap.lockTables = lockTables;\n    return this;\n  }\n  /**\n   * Sets lock handling by adding NO WAIT or SKIP LOCKED.\n   */\n\n\n  setOnLocked(onLocked) {\n    this.expressionMap.onLocked = onLocked;\n    return this;\n  }\n  /**\n   * Disables the global condition of \"non-deleted\" for the entity with delete date columns.\n   */\n\n\n  withDeleted() {\n    this.expressionMap.withDeleted = true;\n    return this;\n  }\n  /**\n   * Gets first raw result returned by execution of generated query builder sql.\n   */\n\n\n  async getRawOne() {\n    return (await this.getRawMany())[0];\n  }\n  /**\n   * Gets all raw results returned by execution of generated query builder sql.\n   */\n\n\n  async getRawMany() {\n    if (this.expressionMap.lockMode === \"optimistic\") throw new OptimisticLockCanNotBeUsedError();\n    this.expressionMap.queryEntity = false;\n    const queryRunner = this.obtainQueryRunner();\n    let transactionStartedByUs = false;\n\n    try {\n      // start transaction if it was enabled\n      if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {\n        await queryRunner.startTransaction();\n        transactionStartedByUs = true;\n      }\n\n      const results = await this.loadRawResults(queryRunner); // close transaction if we started it\n\n      if (transactionStartedByUs) {\n        await queryRunner.commitTransaction();\n      }\n\n      return results;\n    } catch (error) {\n      // rollback transaction if we started it\n      if (transactionStartedByUs) {\n        try {\n          await queryRunner.rollbackTransaction();\n        } catch (rollbackError) {}\n      }\n\n      throw error;\n    } finally {\n      if (queryRunner !== this.queryRunner) {\n        // means we created our own query runner\n        await queryRunner.release();\n      }\n    }\n  }\n  /**\n   * Executes sql generated by query builder and returns object with raw results and entities created from them.\n   */\n\n\n  async getRawAndEntities() {\n    const queryRunner = this.obtainQueryRunner();\n    let transactionStartedByUs = false;\n\n    try {\n      // start transaction if it was enabled\n      if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {\n        await queryRunner.startTransaction();\n        transactionStartedByUs = true;\n      }\n\n      this.expressionMap.queryEntity = true;\n      const results = await this.executeEntitiesAndRawResults(queryRunner); // close transaction if we started it\n\n      if (transactionStartedByUs) {\n        await queryRunner.commitTransaction();\n      }\n\n      return results;\n    } catch (error) {\n      // rollback transaction if we started it\n      if (transactionStartedByUs) {\n        try {\n          await queryRunner.rollbackTransaction();\n        } catch (rollbackError) {}\n      }\n\n      throw error;\n    } finally {\n      if (queryRunner !== this.queryRunner) // means we created our own query runner\n        await queryRunner.release();\n    }\n  }\n  /**\n   * Gets single entity returned by execution of generated query builder sql.\n   */\n\n\n  async getOne() {\n    const results = await this.getRawAndEntities();\n    const result = results.entities[0];\n\n    if (result && this.expressionMap.lockMode === \"optimistic\" && this.expressionMap.lockVersion) {\n      const metadata = this.expressionMap.mainAlias.metadata;\n\n      if (this.expressionMap.lockVersion instanceof Date) {\n        const actualVersion = metadata.updateDateColumn.getEntityValue(result); // what if columns arent set?\n\n        if (actualVersion.getTime() !== this.expressionMap.lockVersion.getTime()) throw new OptimisticLockVersionMismatchError(metadata.name, this.expressionMap.lockVersion, actualVersion);\n      } else {\n        const actualVersion = metadata.versionColumn.getEntityValue(result); // what if columns arent set?\n\n        if (actualVersion !== this.expressionMap.lockVersion) throw new OptimisticLockVersionMismatchError(metadata.name, this.expressionMap.lockVersion, actualVersion);\n      }\n    }\n\n    if (result === undefined) {\n      return null;\n    }\n\n    return result;\n  }\n  /**\n   * Gets the first entity returned by execution of generated query builder sql or rejects the returned promise on error.\n   */\n\n\n  async getOneOrFail() {\n    const entity = await this.getOne();\n\n    if (!entity) {\n      throw new EntityNotFoundError(this.expressionMap.mainAlias.target, this);\n    }\n\n    return entity;\n  }\n  /**\n   * Gets entities returned by execution of generated query builder sql.\n   */\n\n\n  async getMany() {\n    if (this.expressionMap.lockMode === \"optimistic\") throw new OptimisticLockCanNotBeUsedError();\n    const results = await this.getRawAndEntities();\n    return results.entities;\n  }\n  /**\n   * Gets count - number of entities selected by sql generated by this query builder.\n   * Count excludes all limitations set by setFirstResult and setMaxResults methods call.\n   */\n\n\n  async getCount() {\n    if (this.expressionMap.lockMode === \"optimistic\") throw new OptimisticLockCanNotBeUsedError();\n    const queryRunner = this.obtainQueryRunner();\n    let transactionStartedByUs = false;\n\n    try {\n      // start transaction if it was enabled\n      if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {\n        await queryRunner.startTransaction();\n        transactionStartedByUs = true;\n      }\n\n      this.expressionMap.queryEntity = false;\n      const results = await this.executeCountQuery(queryRunner); // close transaction if we started it\n\n      if (transactionStartedByUs) {\n        await queryRunner.commitTransaction();\n      }\n\n      return results;\n    } catch (error) {\n      // rollback transaction if we started it\n      if (transactionStartedByUs) {\n        try {\n          await queryRunner.rollbackTransaction();\n        } catch (rollbackError) {}\n      }\n\n      throw error;\n    } finally {\n      if (queryRunner !== this.queryRunner) // means we created our own query runner\n        await queryRunner.release();\n    }\n  }\n  /**\n   * Executes built SQL query and returns entities and overall entities count (without limitation).\n   * This method is useful to build pagination.\n   */\n\n\n  async getManyAndCount() {\n    if (this.expressionMap.lockMode === \"optimistic\") throw new OptimisticLockCanNotBeUsedError();\n    const queryRunner = this.obtainQueryRunner();\n    let transactionStartedByUs = false;\n\n    try {\n      // start transaction if it was enabled\n      if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {\n        await queryRunner.startTransaction();\n        transactionStartedByUs = true;\n      }\n\n      this.expressionMap.queryEntity = true;\n      const entitiesAndRaw = await this.executeEntitiesAndRawResults(queryRunner);\n      this.expressionMap.queryEntity = false;\n      const cacheId = this.expressionMap.cacheId; // Creates a new cacheId for the count query, or it will retreive the above query results\n      // and count will return 0.\n\n      this.expressionMap.cacheId = cacheId ? `${cacheId}-count` : cacheId;\n      const count = await this.executeCountQuery(queryRunner);\n      const results = [entitiesAndRaw.entities, count]; // close transaction if we started it\n\n      if (transactionStartedByUs) {\n        await queryRunner.commitTransaction();\n      }\n\n      return results;\n    } catch (error) {\n      // rollback transaction if we started it\n      if (transactionStartedByUs) {\n        try {\n          await queryRunner.rollbackTransaction();\n        } catch (rollbackError) {}\n      }\n\n      throw error;\n    } finally {\n      if (queryRunner !== this.queryRunner) // means we created our own query runner\n        await queryRunner.release();\n    }\n  }\n  /**\n   * Executes built SQL query and returns raw data stream.\n   */\n\n\n  async stream() {\n    this.expressionMap.queryEntity = false;\n    const [sql, parameters] = this.getQueryAndParameters();\n    const queryRunner = this.obtainQueryRunner();\n    let transactionStartedByUs = false;\n\n    try {\n      // start transaction if it was enabled\n      if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {\n        await queryRunner.startTransaction();\n        transactionStartedByUs = true;\n      }\n\n      const releaseFn = () => {\n        if (queryRunner !== this.queryRunner) // means we created our own query runner\n          return queryRunner.release();\n        return;\n      };\n\n      const results = queryRunner.stream(sql, parameters, releaseFn, releaseFn); // close transaction if we started it\n\n      if (transactionStartedByUs) {\n        await queryRunner.commitTransaction();\n      }\n\n      return results;\n    } catch (error) {\n      // rollback transaction if we started it\n      if (transactionStartedByUs) {\n        try {\n          await queryRunner.rollbackTransaction();\n        } catch (rollbackError) {}\n      }\n\n      throw error;\n    }\n  }\n  /**\n   * Enables or disables query result caching.\n   */\n\n\n  cache(enabledOrMillisecondsOrId, maybeMilliseconds) {\n    if (typeof enabledOrMillisecondsOrId === \"boolean\") {\n      this.expressionMap.cache = enabledOrMillisecondsOrId;\n    } else if (typeof enabledOrMillisecondsOrId === \"number\") {\n      this.expressionMap.cache = true;\n      this.expressionMap.cacheDuration = enabledOrMillisecondsOrId;\n    } else if (typeof enabledOrMillisecondsOrId === \"string\" || typeof enabledOrMillisecondsOrId === \"number\") {\n      this.expressionMap.cache = true;\n      this.expressionMap.cacheId = enabledOrMillisecondsOrId;\n    }\n\n    if (maybeMilliseconds) {\n      this.expressionMap.cacheDuration = maybeMilliseconds;\n    }\n\n    return this;\n  }\n  /**\n   * Sets extra options that can be used to configure how query builder works.\n   */\n\n\n  setOption(option) {\n    this.expressionMap.options.push(option);\n    return this;\n  } // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n\n  join(direction, entityOrProperty, aliasName, condition, parameters, mapToProperty, isMappingMany) {\n    this.setParameters(parameters || {});\n    const joinAttribute = new JoinAttribute(this.connection, this.expressionMap);\n    joinAttribute.direction = direction;\n    joinAttribute.mapToProperty = mapToProperty;\n    joinAttribute.isMappingMany = isMappingMany;\n    joinAttribute.entityOrProperty = entityOrProperty; // relationName\n\n    joinAttribute.condition = condition ? condition : undefined; // joinInverseSideCondition\n    // joinAttribute.junctionAlias = joinAttribute.relation.isOwning ? parentAlias + \"_\" + destinationTableAlias : destinationTableAlias + \"_\" + parentAlias;\n\n    this.expressionMap.joinAttributes.push(joinAttribute);\n\n    if (joinAttribute.metadata) {\n      if (joinAttribute.metadata.deleteDateColumn && !this.expressionMap.withDeleted) {\n        const conditionDeleteColumn = `${aliasName}.${joinAttribute.metadata.deleteDateColumn.propertyName} IS NULL`;\n        joinAttribute.condition = joinAttribute.condition ? ` ${joinAttribute.condition} AND ${conditionDeleteColumn}` : `${conditionDeleteColumn}`;\n      } // todo: find and set metadata right there?\n\n\n      joinAttribute.alias = this.expressionMap.createAlias({\n        type: \"join\",\n        name: aliasName,\n        metadata: joinAttribute.metadata\n      });\n\n      if (joinAttribute.relation && joinAttribute.relation.junctionEntityMetadata) {\n        this.expressionMap.createAlias({\n          type: \"join\",\n          name: joinAttribute.junctionAlias,\n          metadata: joinAttribute.relation.junctionEntityMetadata\n        });\n      }\n    } else {\n      let subQuery = \"\";\n\n      if (typeof entityOrProperty === \"function\") {\n        const subQueryBuilder = entityOrProperty(this.subQuery());\n        this.setParameters(subQueryBuilder.getParameters());\n        subQuery = subQueryBuilder.getQuery();\n      } else {\n        subQuery = entityOrProperty;\n      }\n\n      const isSubQuery = typeof entityOrProperty === \"function\" || entityOrProperty.substr(0, 1) === \"(\" && entityOrProperty.substr(-1) === \")\";\n      joinAttribute.alias = this.expressionMap.createAlias({\n        type: \"join\",\n        name: aliasName,\n        tablePath: isSubQuery === false ? entityOrProperty : undefined,\n        subQuery: isSubQuery === true ? subQuery : undefined\n      });\n    }\n  }\n  /**\n   * Creates \"SELECT FROM\" part of SQL query.\n   */\n\n\n  createSelectExpression() {\n    if (!this.expressionMap.mainAlias) throw new TypeORMError(\"Cannot build query because main alias is not set (call qb#from method)\"); // todo throw exception if selects or from is missing\n\n    const allSelects = [];\n    const excludedSelects = [];\n\n    if (this.expressionMap.mainAlias.hasMetadata) {\n      const metadata = this.expressionMap.mainAlias.metadata;\n      allSelects.push(...this.buildEscapedEntityColumnSelects(this.expressionMap.mainAlias.name, metadata));\n      excludedSelects.push(...this.findEntityColumnSelects(this.expressionMap.mainAlias.name, metadata));\n    } // add selects from joins\n\n\n    this.expressionMap.joinAttributes.forEach(join => {\n      if (join.metadata) {\n        allSelects.push(...this.buildEscapedEntityColumnSelects(join.alias.name, join.metadata));\n        excludedSelects.push(...this.findEntityColumnSelects(join.alias.name, join.metadata));\n      } else {\n        const hasMainAlias = this.expressionMap.selects.some(select => select.selection === join.alias.name);\n\n        if (hasMainAlias) {\n          allSelects.push({\n            selection: this.escape(join.alias.name) + \".*\"\n          });\n          const excludedSelect = this.expressionMap.selects.find(select => select.selection === join.alias.name);\n          excludedSelects.push(excludedSelect);\n        }\n      }\n    }); // add all other selects\n\n    this.expressionMap.selects.filter(select => excludedSelects.indexOf(select) === -1).forEach(select => allSelects.push({\n      selection: this.replacePropertyNames(select.selection),\n      aliasName: select.aliasName\n    })); // if still selection is empty, then simply set it to all (*)\n\n    if (allSelects.length === 0) allSelects.push({\n      selection: \"*\"\n    }); // Use certain index\n\n    let useIndex = \"\";\n\n    if (this.expressionMap.useIndex) {\n      if (DriverUtils.isMySQLFamily(this.connection.driver)) {\n        useIndex = ` USE INDEX (${this.expressionMap.useIndex})`;\n      }\n    } // create a selection query\n\n\n    const froms = this.expressionMap.aliases.filter(alias => alias.type === \"from\" && (alias.tablePath || alias.subQuery)).map(alias => {\n      if (alias.subQuery) return alias.subQuery + \" \" + this.escape(alias.name);\n      return this.getTableName(alias.tablePath) + \" \" + this.escape(alias.name);\n    });\n    const select = this.createSelectDistinctExpression();\n    const selection = allSelects.map(select => select.selection + (select.aliasName ? \" AS \" + this.escape(select.aliasName) : \"\")).join(\", \");\n    return select + selection + \" FROM \" + froms.join(\", \") + this.createTableLockExpression() + useIndex;\n  }\n  /**\n   * Creates select | select distinct part of SQL query.\n   */\n\n\n  createSelectDistinctExpression() {\n    const {\n      selectDistinct,\n      selectDistinctOn,\n      maxExecutionTime\n    } = this.expressionMap;\n    const {\n      driver\n    } = this.connection;\n    let select = \"SELECT \";\n\n    if (maxExecutionTime > 0) {\n      if (DriverUtils.isMySQLFamily(driver)) {\n        select += `/*+ MAX_EXECUTION_TIME(${this.expressionMap.maxExecutionTime}) */ `;\n      }\n    }\n\n    if (DriverUtils.isPostgresFamily(driver) && selectDistinctOn.length > 0) {\n      const selectDistinctOnMap = selectDistinctOn.map(on => this.replacePropertyNames(on)).join(\", \");\n      select = `SELECT DISTINCT ON (${selectDistinctOnMap}) `;\n    } else if (selectDistinct) {\n      select = \"SELECT DISTINCT \";\n    }\n\n    return select;\n  }\n  /**\n   * Creates \"JOIN\" part of SQL query.\n   */\n\n\n  createJoinExpression() {\n    // examples:\n    // select from owning side\n    // qb.select(\"post\")\n    //     .leftJoinAndSelect(\"post.category\", \"category\");\n    // select from non-owning side\n    // qb.select(\"category\")\n    //     .leftJoinAndSelect(\"category.post\", \"post\");\n    const joins = this.expressionMap.joinAttributes.map(joinAttr => {\n      const relation = joinAttr.relation;\n      const destinationTableName = joinAttr.tablePath;\n      const destinationTableAlias = joinAttr.alias.name;\n      let appendedCondition = joinAttr.condition ? \" AND (\" + joinAttr.condition + \")\" : \"\";\n      const parentAlias = joinAttr.parentAlias; // if join was build without relation (e.g. without \"post.category\") then it means that we have direct\n      // table to join, without junction table involved. This means we simply join direct table.\n\n      if (!parentAlias || !relation) {\n        const destinationJoin = joinAttr.alias.subQuery ? joinAttr.alias.subQuery : this.getTableName(destinationTableName);\n        return \" \" + joinAttr.direction + \" JOIN \" + destinationJoin + \" \" + this.escape(destinationTableAlias) + this.createTableLockExpression() + (joinAttr.condition ? \" ON \" + this.replacePropertyNames(joinAttr.condition) : \"\");\n      } // if real entity relation is involved\n\n\n      if (relation.isManyToOne || relation.isOneToOneOwner) {\n        // JOIN `category` `category` ON `category`.`id` = `post`.`categoryId`\n        const condition = relation.joinColumns.map(joinColumn => {\n          return destinationTableAlias + \".\" + joinColumn.referencedColumn.propertyPath + \"=\" + parentAlias + \".\" + relation.propertyPath + \".\" + joinColumn.referencedColumn.propertyPath;\n        }).join(\" AND \");\n        return \" \" + joinAttr.direction + \" JOIN \" + this.getTableName(destinationTableName) + \" \" + this.escape(destinationTableAlias) + this.createTableLockExpression() + \" ON \" + this.replacePropertyNames(condition + appendedCondition);\n      } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n        // JOIN `post` `post` ON `post`.`categoryId` = `category`.`id`\n        const condition = relation.inverseRelation.joinColumns.map(joinColumn => {\n          if (relation.inverseEntityMetadata.tableType === \"entity-child\" && relation.inverseEntityMetadata.discriminatorColumn) {\n            appendedCondition += \" AND \" + destinationTableAlias + \".\" + relation.inverseEntityMetadata.discriminatorColumn.databaseName + \"='\" + relation.inverseEntityMetadata.discriminatorValue + \"'\";\n          }\n\n          return destinationTableAlias + \".\" + relation.inverseRelation.propertyPath + \".\" + joinColumn.referencedColumn.propertyPath + \"=\" + parentAlias + \".\" + joinColumn.referencedColumn.propertyPath;\n        }).join(\" AND \");\n        return \" \" + joinAttr.direction + \" JOIN \" + this.getTableName(destinationTableName) + \" \" + this.escape(destinationTableAlias) + this.createTableLockExpression() + \" ON \" + this.replacePropertyNames(condition + appendedCondition);\n      } else {\n        // means many-to-many\n        const junctionTableName = relation.junctionEntityMetadata.tablePath;\n        const junctionAlias = joinAttr.junctionAlias;\n        let junctionCondition = \"\",\n            destinationCondition = \"\";\n\n        if (relation.isOwning) {\n          junctionCondition = relation.joinColumns.map(joinColumn => {\n            // `post_category`.`postId` = `post`.`id`\n            return junctionAlias + \".\" + joinColumn.propertyPath + \"=\" + parentAlias + \".\" + joinColumn.referencedColumn.propertyPath;\n          }).join(\" AND \");\n          destinationCondition = relation.inverseJoinColumns.map(joinColumn => {\n            // `category`.`id` = `post_category`.`categoryId`\n            return destinationTableAlias + \".\" + joinColumn.referencedColumn.propertyPath + \"=\" + junctionAlias + \".\" + joinColumn.propertyPath;\n          }).join(\" AND \");\n        } else {\n          junctionCondition = relation.inverseRelation.inverseJoinColumns.map(joinColumn => {\n            // `post_category`.`categoryId` = `category`.`id`\n            return junctionAlias + \".\" + joinColumn.propertyPath + \"=\" + parentAlias + \".\" + joinColumn.referencedColumn.propertyPath;\n          }).join(\" AND \");\n          destinationCondition = relation.inverseRelation.joinColumns.map(joinColumn => {\n            // `post`.`id` = `post_category`.`postId`\n            return destinationTableAlias + \".\" + joinColumn.referencedColumn.propertyPath + \"=\" + junctionAlias + \".\" + joinColumn.propertyPath;\n          }).join(\" AND \");\n        }\n\n        return \" \" + joinAttr.direction + \" JOIN \" + this.getTableName(junctionTableName) + \" \" + this.escape(junctionAlias) + this.createTableLockExpression() + \" ON \" + this.replacePropertyNames(junctionCondition) + \" \" + joinAttr.direction + \" JOIN \" + this.getTableName(destinationTableName) + \" \" + this.escape(destinationTableAlias) + this.createTableLockExpression() + \" ON \" + this.replacePropertyNames(destinationCondition + appendedCondition);\n      }\n    });\n    return joins.join(\" \");\n  }\n  /**\n   * Creates \"GROUP BY\" part of SQL query.\n   */\n\n\n  createGroupByExpression() {\n    if (!this.expressionMap.groupBys || !this.expressionMap.groupBys.length) return \"\";\n    return \" GROUP BY \" + this.replacePropertyNames(this.expressionMap.groupBys.join(\", \"));\n  }\n  /**\n   * Creates \"ORDER BY\" part of SQL query.\n   */\n\n\n  createOrderByExpression() {\n    const orderBys = this.expressionMap.allOrderBys;\n    if (Object.keys(orderBys).length > 0) return \" ORDER BY \" + Object.keys(orderBys).map(columnName => {\n      if (typeof orderBys[columnName] === \"string\") {\n        return this.replacePropertyNames(columnName) + \" \" + orderBys[columnName];\n      } else {\n        return this.replacePropertyNames(columnName) + \" \" + orderBys[columnName].order + \" \" + orderBys[columnName].nulls;\n      }\n    }).join(\", \");\n    return \"\";\n  }\n  /**\n   * Creates \"LIMIT\" and \"OFFSET\" parts of SQL query.\n   */\n\n\n  createLimitOffsetExpression() {\n    // in the case if nothing is joined in the query builder we don't need to make two requests to get paginated results\n    // we can use regular limit / offset, that's why we add offset and limit construction here based on skip and take values\n    let offset = this.expressionMap.offset,\n        limit = this.expressionMap.limit;\n\n    if (!offset && !limit && this.expressionMap.joinAttributes.length === 0) {\n      offset = this.expressionMap.skip;\n      limit = this.expressionMap.take;\n    }\n\n    if (this.connection.driver.options.type === \"mssql\") {\n      // Due to a limitation in SQL Server's parser implementation it does not support using\n      // OFFSET or FETCH NEXT without an ORDER BY clause being provided. In cases where the\n      // user does not request one we insert a dummy ORDER BY that does nothing and should\n      // have no effect on the query planner or on the order of the results returned.\n      // https://dba.stackexchange.com/a/193799\n      let prefix = \"\";\n\n      if ((limit || offset) && Object.keys(this.expressionMap.allOrderBys).length <= 0) {\n        prefix = \" ORDER BY (SELECT NULL)\";\n      }\n\n      if (limit && offset) return prefix + \" OFFSET \" + offset + \" ROWS FETCH NEXT \" + limit + \" ROWS ONLY\";\n      if (limit) return prefix + \" OFFSET 0 ROWS FETCH NEXT \" + limit + \" ROWS ONLY\";\n      if (offset) return prefix + \" OFFSET \" + offset + \" ROWS\";\n    } else if (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === \"aurora-mysql\" || this.connection.driver.options.type === \"sap\" || this.connection.driver.options.type === \"spanner\") {\n      if (limit && offset) return \" LIMIT \" + limit + \" OFFSET \" + offset;\n      if (limit) return \" LIMIT \" + limit;\n      if (offset) throw new OffsetWithoutLimitNotSupportedError();\n    } else if (DriverUtils.isSQLiteFamily(this.connection.driver)) {\n      if (limit && offset) return \" LIMIT \" + limit + \" OFFSET \" + offset;\n      if (limit) return \" LIMIT \" + limit;\n      if (offset) return \" LIMIT -1 OFFSET \" + offset;\n    } else if (this.connection.driver.options.type === \"oracle\") {\n      if (limit && offset) return \" OFFSET \" + offset + \" ROWS FETCH NEXT \" + limit + \" ROWS ONLY\";\n      if (limit) return \" FETCH NEXT \" + limit + \" ROWS ONLY\";\n      if (offset) return \" OFFSET \" + offset + \" ROWS\";\n    } else {\n      if (limit && offset) return \" LIMIT \" + limit + \" OFFSET \" + offset;\n      if (limit) return \" LIMIT \" + limit;\n      if (offset) return \" OFFSET \" + offset;\n    }\n\n    return \"\";\n  }\n  /**\n   * Creates \"LOCK\" part of SELECT Query after table Clause\n   * ex.\n   *  SELECT 1\n   *  FROM USER U WITH (NOLOCK)\n   *  JOIN ORDER O WITH (NOLOCK)\n   *      ON U.ID=O.OrderID\n   */\n\n\n  createTableLockExpression() {\n    if (this.connection.driver.options.type === \"mssql\") {\n      switch (this.expressionMap.lockMode) {\n        case \"pessimistic_read\":\n          return \" WITH (HOLDLOCK, ROWLOCK)\";\n\n        case \"pessimistic_write\":\n          return \" WITH (UPDLOCK, ROWLOCK)\";\n\n        case \"dirty_read\":\n          return \" WITH (NOLOCK)\";\n      }\n    }\n\n    return \"\";\n  }\n  /**\n   * Creates \"LOCK\" part of SQL query.\n   */\n\n\n  createLockExpression() {\n    const driver = this.connection.driver;\n    let lockTablesClause = \"\";\n\n    if (this.expressionMap.lockTables) {\n      if (!(DriverUtils.isPostgresFamily(driver) || driver.options.type === \"cockroachdb\")) {\n        throw new TypeORMError(\"Lock tables not supported in selected driver\");\n      }\n\n      if (this.expressionMap.lockTables.length < 1) {\n        throw new TypeORMError(\"lockTables cannot be an empty array\");\n      }\n\n      lockTablesClause = \" OF \" + this.expressionMap.lockTables.join(\", \");\n    }\n\n    let onLockExpression = \"\";\n\n    if (this.expressionMap.onLocked === \"nowait\") {\n      onLockExpression = \" NOWAIT\";\n    } else if (this.expressionMap.onLocked === \"skip_locked\") {\n      onLockExpression = \" SKIP LOCKED\";\n    }\n\n    switch (this.expressionMap.lockMode) {\n      case \"pessimistic_read\":\n        if (driver.options.type === \"mysql\" || driver.options.type === \"aurora-mysql\") {\n          if (DriverUtils.isReleaseVersionOrGreater(driver, \"8.0.0\")) {\n            return \" FOR SHARE\" + lockTablesClause + onLockExpression;\n          } else {\n            return \" LOCK IN SHARE MODE\";\n          }\n        } else if (driver.options.type === \"mariadb\") {\n          return \" LOCK IN SHARE MODE\";\n        } else if (DriverUtils.isPostgresFamily(driver)) {\n          return \" FOR SHARE\" + lockTablesClause + onLockExpression;\n        } else if (driver.options.type === \"oracle\") {\n          return \" FOR UPDATE\";\n        } else if (driver.options.type === \"mssql\") {\n          return \"\";\n        } else {\n          throw new LockNotSupportedOnGivenDriverError();\n        }\n\n      case \"pessimistic_write\":\n        if (DriverUtils.isMySQLFamily(driver) || driver.options.type === \"aurora-mysql\" || driver.options.type === \"oracle\") {\n          return \" FOR UPDATE\" + onLockExpression;\n        } else if (DriverUtils.isPostgresFamily(driver) || driver.options.type === \"cockroachdb\") {\n          return \" FOR UPDATE\" + lockTablesClause + onLockExpression;\n        } else if (driver.options.type === \"mssql\") {\n          return \"\";\n        } else {\n          throw new LockNotSupportedOnGivenDriverError();\n        }\n\n      case \"pessimistic_partial_write\":\n        if (DriverUtils.isPostgresFamily(driver)) {\n          return \" FOR UPDATE\" + lockTablesClause + \" SKIP LOCKED\";\n        } else if (DriverUtils.isMySQLFamily(driver)) {\n          return \" FOR UPDATE SKIP LOCKED\";\n        } else {\n          throw new LockNotSupportedOnGivenDriverError();\n        }\n\n      case \"pessimistic_write_or_fail\":\n        if (DriverUtils.isPostgresFamily(driver) || driver.options.type === \"cockroachdb\") {\n          return \" FOR UPDATE\" + lockTablesClause + \" NOWAIT\";\n        } else if (DriverUtils.isMySQLFamily(driver)) {\n          return \" FOR UPDATE NOWAIT\";\n        } else {\n          throw new LockNotSupportedOnGivenDriverError();\n        }\n\n      case \"for_no_key_update\":\n        if (DriverUtils.isPostgresFamily(driver) || driver.options.type === \"cockroachdb\") {\n          return \" FOR NO KEY UPDATE\" + lockTablesClause + onLockExpression;\n        } else {\n          throw new LockNotSupportedOnGivenDriverError();\n        }\n\n      case \"for_key_share\":\n        if (DriverUtils.isPostgresFamily(driver)) {\n          return \" FOR KEY SHARE\" + lockTablesClause + onLockExpression;\n        } else {\n          throw new LockNotSupportedOnGivenDriverError();\n        }\n\n      default:\n        return \"\";\n    }\n  }\n  /**\n   * Creates \"HAVING\" part of SQL query.\n   */\n\n\n  createHavingExpression() {\n    if (!this.expressionMap.havings || !this.expressionMap.havings.length) return \"\";\n    const conditions = this.expressionMap.havings.map((having, index) => {\n      switch (having.type) {\n        case \"and\":\n          return (index > 0 ? \"AND \" : \"\") + this.replacePropertyNames(having.condition);\n\n        case \"or\":\n          return (index > 0 ? \"OR \" : \"\") + this.replacePropertyNames(having.condition);\n\n        default:\n          return this.replacePropertyNames(having.condition);\n      }\n    }).join(\" \");\n    if (!conditions.length) return \"\";\n    return \" HAVING \" + conditions;\n  }\n\n  buildEscapedEntityColumnSelects(aliasName, metadata) {\n    const hasMainAlias = this.expressionMap.selects.some(select => select.selection === aliasName);\n    const columns = [];\n\n    if (hasMainAlias) {\n      columns.push(...metadata.columns.filter(column => column.isSelect === true));\n    }\n\n    columns.push(...metadata.columns.filter(column => {\n      return this.expressionMap.selects.some(select => select.selection === aliasName + \".\" + column.propertyPath);\n    })); // if user used partial selection and did not select some primary columns which are required to be selected\n    // we select those primary columns and mark them as \"virtual\". Later virtual column values will be removed from final entity\n    // to make entity contain exactly what user selected\n\n    if (columns.length === 0) // however not in the case when nothing (even partial) was selected from this target (for example joins without selection)\n      return [];\n    const nonSelectedPrimaryColumns = this.expressionMap.queryEntity ? metadata.primaryColumns.filter(primaryColumn => columns.indexOf(primaryColumn) === -1) : [];\n    const allColumns = [...columns, ...nonSelectedPrimaryColumns];\n    const finalSelects = [];\n    allColumns.forEach(column => {\n      let selectionPath = this.escape(aliasName) + \".\" + this.escape(column.databaseName);\n\n      if (this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {\n        if (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === \"aurora-mysql\") {\n          const useLegacy = this.connection.driver.options.legacySpatialSupport;\n          const asText = useLegacy ? \"AsText\" : \"ST_AsText\";\n          selectionPath = `${asText}(${selectionPath})`;\n        }\n\n        if (DriverUtils.isPostgresFamily(this.connection.driver)) if (column.precision) {\n          // cast to JSON to trigger parsing in the driver\n          selectionPath = `ST_AsGeoJSON(${selectionPath}, ${column.precision})::json`;\n        } else {\n          selectionPath = `ST_AsGeoJSON(${selectionPath})::json`;\n        }\n        if (this.connection.driver.options.type === \"mssql\") selectionPath = `${selectionPath}.ToString()`;\n      }\n\n      const selections = this.expressionMap.selects.filter(select => select.selection === aliasName + \".\" + column.propertyPath);\n\n      if (selections.length) {\n        selections.forEach(selection => {\n          finalSelects.push({\n            selection: selectionPath,\n            aliasName: selection.aliasName ? selection.aliasName : DriverUtils.buildAlias(this.connection.driver, aliasName, column.databaseName),\n            // todo: need to keep in mind that custom selection.aliasName breaks hydrator. fix it later!\n            virtual: selection.virtual\n          });\n        });\n      } else {\n        finalSelects.push({\n          selection: selectionPath,\n          aliasName: DriverUtils.buildAlias(this.connection.driver, aliasName, column.databaseName),\n          // todo: need to keep in mind that custom selection.aliasName breaks hydrator. fix it later!\n          virtual: hasMainAlias\n        });\n      }\n    });\n    return finalSelects;\n  }\n\n  findEntityColumnSelects(aliasName, metadata) {\n    const mainSelect = this.expressionMap.selects.find(select => select.selection === aliasName);\n    if (mainSelect) return [mainSelect];\n    return this.expressionMap.selects.filter(select => {\n      return metadata.columns.some(column => select.selection === aliasName + \".\" + column.propertyPath);\n    });\n  }\n\n  computeCountExpression() {\n    const mainAlias = this.expressionMap.mainAlias.name; // todo: will this work with \"fromTableName\"?\n\n    const metadata = this.expressionMap.mainAlias.metadata;\n    const primaryColumns = metadata.primaryColumns;\n    const distinctAlias = this.escape(mainAlias); // If we aren't doing anything that will create a join, we can use a simpler `COUNT` instead\n    // so we prevent poor query patterns in the most likely cases\n\n    if (this.expressionMap.joinAttributes.length === 0 && this.expressionMap.relationIdAttributes.length === 0 && this.expressionMap.relationCountAttributes.length === 0) {\n      return \"COUNT(1)\";\n    } // For everything else, we'll need to do some hackery to get the correct count values.\n\n\n    if (this.connection.driver.options.type === \"cockroachdb\" || DriverUtils.isPostgresFamily(this.connection.driver)) {\n      // Postgres and CockroachDB can pass multiple parameters to the `DISTINCT` function\n      // https://www.postgresql.org/docs/9.5/sql-select.html#SQL-DISTINCT\n      return \"COUNT(DISTINCT(\" + primaryColumns.map(c => `${distinctAlias}.${this.escape(c.databaseName)}`).join(\", \") + \"))\";\n    }\n\n    if (DriverUtils.isMySQLFamily(this.connection.driver)) {\n      // MySQL & MariaDB can pass multiple parameters to the `DISTINCT` language construct\n      // https://mariadb.com/kb/en/count-distinct/\n      return \"COUNT(DISTINCT \" + primaryColumns.map(c => `${distinctAlias}.${this.escape(c.databaseName)}`).join(\", \") + \")\";\n    }\n\n    if (this.connection.driver.options.type === \"mssql\") {\n      // SQL Server has gotta be different from everyone else.  They don't support\n      // distinct counting multiple columns & they don't have the same operator\n      // characteristic for concatenating, so we gotta use the `CONCAT` function.\n      // However, If it's exactly 1 column we can omit the `CONCAT` for better performance.\n      const columnsExpression = primaryColumns.map(primaryColumn => `${distinctAlias}.${this.escape(primaryColumn.databaseName)}`).join(\", '|;|', \");\n\n      if (primaryColumns.length === 1) {\n        return `COUNT(DISTINCT(${columnsExpression}))`;\n      }\n\n      return `COUNT(DISTINCT(CONCAT(${columnsExpression})))`;\n    }\n\n    if (this.connection.driver.options.type === \"spanner\") {\n      // spanner also has gotta be different from everyone else.\n      // they do not support concatenation of different column types without casting them to string\n      if (primaryColumns.length === 1) {\n        return `COUNT(DISTINCT(${distinctAlias}.${this.escape(primaryColumns[0].databaseName)}))`;\n      }\n\n      const columnsExpression = primaryColumns.map(primaryColumn => `CAST(${distinctAlias}.${this.escape(primaryColumn.databaseName)} AS STRING)`).join(\", '|;|', \");\n      return `COUNT(DISTINCT(CONCAT(${columnsExpression})))`;\n    } // If all else fails, fall back to a `COUNT` and `DISTINCT` across all the primary columns concatenated.\n    // Per the SQL spec, this is the canonical string concatenation mechanism which is most\n    // likely to work across servers implementing the SQL standard.\n    // Please note, if there is only one primary column that the concatenation does not occur in this\n    // query and the query is a standard `COUNT DISTINCT` in that case.\n\n\n    return `COUNT(DISTINCT(` + primaryColumns.map(c => `${distinctAlias}.${this.escape(c.databaseName)}`).join(\" || '|;|' || \") + \"))\";\n  }\n\n  async executeCountQuery(queryRunner) {\n    const countSql = this.computeCountExpression();\n    const results = await this.clone().orderBy().groupBy().offset(undefined).limit(undefined).skip(undefined).take(undefined).select(countSql, \"cnt\").setOption(\"disable-global-order\").loadRawResults(queryRunner);\n    if (!results || !results[0] || !results[0][\"cnt\"]) return 0;\n    return parseInt(results[0][\"cnt\"]);\n  }\n\n  applyFindOptions() {\n    // todo: convert relations: string[] to object map to simplify code\n    // todo: same with selects\n    if (this.expressionMap.mainAlias.metadata) {\n      if (this.findOptions.relationLoadStrategy) {\n        this.expressionMap.relationLoadStrategy = this.findOptions.relationLoadStrategy;\n      }\n\n      if (this.findOptions.comment) {\n        this.comment(this.findOptions.comment);\n      }\n\n      if (this.findOptions.withDeleted) {\n        this.withDeleted();\n      }\n\n      if (this.findOptions.select) {\n        const select = Array.isArray(this.findOptions.select) ? OrmUtils.propertyPathsToTruthyObject(this.findOptions.select) : this.findOptions.select;\n        this.buildSelect(select, this.expressionMap.mainAlias.metadata, this.expressionMap.mainAlias.name);\n      }\n\n      if (this.selects.length) {\n        this.select(this.selects);\n      }\n\n      this.selects = [];\n\n      if (this.findOptions.relations) {\n        const relations = Array.isArray(this.findOptions.relations) ? OrmUtils.propertyPathsToTruthyObject(this.findOptions.relations) : this.findOptions.relations;\n        this.buildRelations(relations, typeof this.findOptions.select === \"object\" ? this.findOptions.select : undefined, this.expressionMap.mainAlias.metadata, this.expressionMap.mainAlias.name);\n\n        if (this.findOptions.loadEagerRelations !== false && this.expressionMap.relationLoadStrategy === \"join\") {\n          this.buildEagerRelations(relations, typeof this.findOptions.select === \"object\" ? this.findOptions.select : undefined, this.expressionMap.mainAlias.metadata, this.expressionMap.mainAlias.name);\n        }\n      }\n\n      if (this.selects.length) {\n        this.addSelect(this.selects);\n      }\n\n      if (this.findOptions.where) {\n        this.conditions = this.buildWhere(this.findOptions.where, this.expressionMap.mainAlias.metadata, this.expressionMap.mainAlias.name);\n        if (this.conditions.length) this.andWhere(this.conditions.substr(0, 1) !== \"(\" ? \"(\" + this.conditions + \")\" : this.conditions); // temporary and where and braces\n      }\n\n      if (this.findOptions.order) {\n        this.buildOrder(this.findOptions.order, this.expressionMap.mainAlias.metadata, this.expressionMap.mainAlias.name);\n      } // apply joins\n\n\n      if (this.joins.length) {\n        this.joins.forEach(join => {\n          if (join.select && !join.selection) {\n            // if (join.selection) {\n            //\n            // } else {\n            if (join.type === \"inner\") {\n              this.innerJoinAndSelect(`${join.parentAlias}.${join.relationMetadata.propertyPath}`, join.alias);\n            } else {\n              this.leftJoinAndSelect(`${join.parentAlias}.${join.relationMetadata.propertyPath}`, join.alias);\n            } // }\n\n          } else {\n            if (join.type === \"inner\") {\n              this.innerJoin(`${join.parentAlias}.${join.relationMetadata.propertyPath}`, join.alias);\n            } else {\n              this.leftJoin(`${join.parentAlias}.${join.relationMetadata.propertyPath}`, join.alias);\n            }\n          } // if (join.select) {\n          //     if (this.findOptions.loadEagerRelations !== false) {\n          //         FindOptionsUtils.joinEagerRelations(\n          //             this,\n          //             join.alias,\n          //             join.relationMetadata.inverseEntityMetadata\n          //         );\n          //     }\n          // }\n\n        });\n      } // if (this.conditions.length) {\n      //     this.where(this.conditions.join(\" AND \"));\n      // }\n      // apply offset\n\n\n      if (this.findOptions.skip !== undefined) {\n        // if (this.findOptions.options && this.findOptions.options.pagination === false) {\n        //     this.offset(this.findOptions.skip);\n        // } else {\n        this.skip(this.findOptions.skip); // }\n      } // apply limit\n\n\n      if (this.findOptions.take !== undefined) {\n        // if (this.findOptions.options && this.findOptions.options.pagination === false) {\n        //     this.limit(this.findOptions.take);\n        // } else {\n        this.take(this.findOptions.take); // }\n      } // apply caching options\n\n\n      if (typeof this.findOptions.cache === \"number\") {\n        this.cache(this.findOptions.cache);\n      } else if (typeof this.findOptions.cache === \"boolean\") {\n        this.cache(this.findOptions.cache);\n      } else if (typeof this.findOptions.cache === \"object\") {\n        this.cache(this.findOptions.cache.id, this.findOptions.cache.milliseconds);\n      }\n\n      if (this.findOptions.join) {\n        if (this.findOptions.join.leftJoin) Object.keys(this.findOptions.join.leftJoin).forEach(key => {\n          this.leftJoin(this.findOptions.join.leftJoin[key], key);\n        });\n        if (this.findOptions.join.innerJoin) Object.keys(this.findOptions.join.innerJoin).forEach(key => {\n          this.innerJoin(this.findOptions.join.innerJoin[key], key);\n        });\n        if (this.findOptions.join.leftJoinAndSelect) Object.keys(this.findOptions.join.leftJoinAndSelect).forEach(key => {\n          this.leftJoinAndSelect(this.findOptions.join.leftJoinAndSelect[key], key);\n        });\n        if (this.findOptions.join.innerJoinAndSelect) Object.keys(this.findOptions.join.innerJoinAndSelect).forEach(key => {\n          this.innerJoinAndSelect(this.findOptions.join.innerJoinAndSelect[key], key);\n        });\n      }\n\n      if (this.findOptions.lock) {\n        if (this.findOptions.lock.mode === \"optimistic\") {\n          this.setLock(this.findOptions.lock.mode, this.findOptions.lock.version);\n        } else if (this.findOptions.lock.mode === \"pessimistic_read\" || this.findOptions.lock.mode === \"pessimistic_write\" || this.findOptions.lock.mode === \"dirty_read\" || this.findOptions.lock.mode === \"pessimistic_partial_write\" || this.findOptions.lock.mode === \"pessimistic_write_or_fail\" || this.findOptions.lock.mode === \"for_no_key_update\" || this.findOptions.lock.mode === \"for_key_share\") {\n          const tableNames = this.findOptions.lock.tables ? this.findOptions.lock.tables.map(table => {\n            const tableAlias = this.expressionMap.aliases.find(alias => {\n              return alias.metadata.tableNameWithoutPrefix === table;\n            });\n\n            if (!tableAlias) {\n              throw new TypeORMError(`\"${table}\" is not part of this query`);\n            }\n\n            return this.escape(tableAlias.name);\n          }) : undefined;\n          this.setLock(this.findOptions.lock.mode, undefined, tableNames);\n\n          if (this.findOptions.lock.onLocked) {\n            this.setOnLocked(this.findOptions.lock.onLocked);\n          }\n        }\n      }\n\n      if (this.findOptions.loadRelationIds === true) {\n        this.loadAllRelationIds();\n      } else if (typeof this.findOptions.loadRelationIds === \"object\") {\n        this.loadAllRelationIds(this.findOptions.loadRelationIds);\n      }\n\n      if (this.findOptions.loadEagerRelations !== false) {\n        FindOptionsUtils.joinEagerRelations(this, this.expressionMap.mainAlias.name, this.expressionMap.mainAlias.metadata);\n      }\n\n      if (this.findOptions.transaction === true) {\n        this.expressionMap.useTransaction = true;\n      } // if (this.orderBys.length) {\n      //     this.orderBys.forEach(orderBy => {\n      //         this.addOrderBy(orderBy.alias, orderBy.direction, orderBy.nulls);\n      //     });\n      // }\n      // todo\n      // if (this.options.options && this.options.options.eagerRelations) {\n      //     this.queryBuilder\n      // }\n      // todo\n      // if (this.findOptions.options && this.findOptions.listeners === false) {\n      //     this.callListeners(false);\n      // }\n\n    }\n  }\n  /**\n   * Executes sql generated by query builder and returns object with raw results and entities created from them.\n   */\n\n\n  async executeEntitiesAndRawResults(queryRunner) {\n    if (!this.expressionMap.mainAlias) throw new TypeORMError(`Alias is not set. Use \"from\" method to set an alias.`);\n    if ((this.expressionMap.lockMode === \"pessimistic_read\" || this.expressionMap.lockMode === \"pessimistic_write\" || this.expressionMap.lockMode === \"pessimistic_partial_write\" || this.expressionMap.lockMode === \"pessimistic_write_or_fail\" || this.expressionMap.lockMode === \"for_no_key_update\" || this.expressionMap.lockMode === \"for_key_share\") && !queryRunner.isTransactionActive) throw new PessimisticLockTransactionRequiredError();\n\n    if (this.expressionMap.lockMode === \"optimistic\") {\n      const metadata = this.expressionMap.mainAlias.metadata;\n      if (!metadata.versionColumn && !metadata.updateDateColumn) throw new NoVersionOrUpdateDateColumnError(metadata.name);\n    }\n\n    const relationIdLoader = new RelationIdLoader(this.connection, queryRunner, this.expressionMap.relationIdAttributes);\n    const relationCountLoader = new RelationCountLoader(this.connection, queryRunner, this.expressionMap.relationCountAttributes);\n    const relationIdMetadataTransformer = new RelationIdMetadataToAttributeTransformer(this.expressionMap);\n    relationIdMetadataTransformer.transform();\n    const relationCountMetadataTransformer = new RelationCountMetadataToAttributeTransformer(this.expressionMap);\n    relationCountMetadataTransformer.transform();\n    let rawResults = [],\n        entities = []; // for pagination enabled (e.g. skip and take) its much more complicated - its a special process\n    // where we make two queries to find the data we need\n    // first query find ids in skip and take range\n    // and second query loads the actual data in given ids range\n\n    if ((this.expressionMap.skip || this.expressionMap.take) && this.expressionMap.joinAttributes.length > 0) {\n      // we are skipping order by here because its not working in subqueries anyway\n      // to make order by working we need to apply it on a distinct query\n      const [selects, orderBys] = this.createOrderByCombinedWithSelectExpression(\"distinctAlias\");\n      const metadata = this.expressionMap.mainAlias.metadata;\n      const mainAliasName = this.expressionMap.mainAlias.name;\n      const querySelects = metadata.primaryColumns.map(primaryColumn => {\n        const distinctAlias = this.escape(\"distinctAlias\");\n        const columnAlias = this.escape(DriverUtils.buildAlias(this.connection.driver, mainAliasName, primaryColumn.databaseName));\n        if (!orderBys[columnAlias]) // make sure we aren't overriding user-defined order in inverse direction\n          orderBys[columnAlias] = \"ASC\";\n        const alias = DriverUtils.buildAlias(this.connection.driver, \"ids_\" + mainAliasName, primaryColumn.databaseName);\n        return `${distinctAlias}.${columnAlias} AS ${this.escape(alias)}`;\n      });\n      rawResults = await new SelectQueryBuilder(this.connection, queryRunner).select(`DISTINCT ${querySelects.join(\", \")}`).addSelect(selects).from(`(${this.clone().orderBy().getQuery()})`, \"distinctAlias\").offset(this.expressionMap.skip).limit(this.expressionMap.take).orderBy(orderBys).cache(this.expressionMap.cache ? this.expressionMap.cache : this.expressionMap.cacheId, this.expressionMap.cacheDuration).setParameters(this.getParameters()).setNativeParameters(this.expressionMap.nativeParameters).getRawMany();\n\n      if (rawResults.length > 0) {\n        let condition = \"\";\n        const parameters = {};\n\n        if (metadata.hasMultiplePrimaryKeys) {\n          condition = rawResults.map((result, index) => {\n            return metadata.primaryColumns.map(primaryColumn => {\n              const paramKey = `orm_distinct_ids_${index}_${primaryColumn.databaseName}`;\n              parameters[paramKey] = result[`ids_${mainAliasName}_${primaryColumn.databaseName}`];\n              return `${mainAliasName}.${primaryColumn.propertyPath}=:${paramKey}`;\n            }).join(\" AND \");\n          }).join(\" OR \");\n        } else {\n          const alias = DriverUtils.buildAlias(this.connection.driver, \"ids_\" + mainAliasName, metadata.primaryColumns[0].databaseName);\n          const ids = rawResults.map(result => result[alias]);\n          const areAllNumbers = ids.every(id => typeof id === \"number\");\n\n          if (areAllNumbers) {\n            // fixes #190. if all numbers then its safe to perform query without parameter\n            condition = `${mainAliasName}.${metadata.primaryColumns[0].propertyPath} IN (${ids.join(\", \")})`;\n          } else {\n            parameters[\"orm_distinct_ids\"] = ids;\n            condition = mainAliasName + \".\" + metadata.primaryColumns[0].propertyPath + \" IN (:...orm_distinct_ids)\";\n          }\n        }\n\n        rawResults = await this.clone().mergeExpressionMap({\n          extraAppendedAndWhereCondition: condition\n        }).setParameters(parameters).loadRawResults(queryRunner);\n      }\n    } else {\n      rawResults = await this.loadRawResults(queryRunner);\n    }\n\n    if (rawResults.length > 0) {\n      // transform raw results into entities\n      const rawRelationIdResults = await relationIdLoader.load(rawResults);\n      const rawRelationCountResults = await relationCountLoader.load(rawResults);\n      const transformer = new RawSqlResultsToEntityTransformer(this.expressionMap, this.connection.driver, rawRelationIdResults, rawRelationCountResults, this.queryRunner);\n      entities = transformer.transform(rawResults, this.expressionMap.mainAlias); // broadcast all \"after load\" events\n\n      if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata) {\n        await queryRunner.broadcaster.broadcast(\"Load\", this.expressionMap.mainAlias.metadata, entities);\n      }\n    }\n\n    if (this.expressionMap.relationLoadStrategy === \"query\") {\n      await Promise.all(this.relationMetadatas.map(async relation => {\n        const relationTarget = relation.inverseEntityMetadata.target;\n        const relationAlias = relation.inverseEntityMetadata.targetName;\n        const select = Array.isArray(this.findOptions.select) ? OrmUtils.propertyPathsToTruthyObject(this.findOptions.select) : this.findOptions.select;\n        const relations = Array.isArray(this.findOptions.relations) ? OrmUtils.propertyPathsToTruthyObject(this.findOptions.relations) : this.findOptions.relations;\n        const queryBuilder = this.createQueryBuilder().select(relationAlias).from(relationTarget, relationAlias).setFindOptions({\n          select: select ? OrmUtils.deepValue(select, relation.propertyPath) : undefined,\n          order: this.findOptions.order ? OrmUtils.deepValue(this.findOptions.order, relation.propertyPath) : undefined,\n          relations: relations ? OrmUtils.deepValue(relations, relation.propertyPath) : undefined,\n          withDeleted: this.findOptions.withDeleted,\n          relationLoadStrategy: this.findOptions.relationLoadStrategy\n        });\n\n        if (entities.length > 0) {\n          const relatedEntityGroups = await this.connection.relationIdLoader.loadManyToManyRelationIdsAndGroup(relation, entities, undefined, queryBuilder);\n          entities.forEach(entity => {\n            const relatedEntityGroup = relatedEntityGroups.find(group => group.entity === entity);\n\n            if (relatedEntityGroup) {\n              const value = relatedEntityGroup.related === undefined ? null : relatedEntityGroup.related;\n              relation.setEntityValue(entity, value);\n            }\n          });\n        }\n      }));\n    }\n\n    return {\n      raw: rawResults,\n      entities: entities\n    };\n  }\n\n  createOrderByCombinedWithSelectExpression(parentAlias) {\n    // if table has a default order then apply it\n    const orderBys = this.expressionMap.allOrderBys;\n    const selectString = Object.keys(orderBys).map(orderCriteria => {\n      if (orderCriteria.indexOf(\".\") !== -1) {\n        const criteriaParts = orderCriteria.split(\".\");\n        const aliasName = criteriaParts[0];\n        const propertyPath = criteriaParts.slice(1).join(\".\");\n        const alias = this.expressionMap.findAliasByName(aliasName);\n        const column = alias.metadata.findColumnWithPropertyPath(propertyPath);\n        return this.escape(parentAlias) + \".\" + this.escape(DriverUtils.buildAlias(this.connection.driver, aliasName, column.databaseName));\n      } else {\n        if (this.expressionMap.selects.find(select => select.selection === orderCriteria || select.aliasName === orderCriteria)) return this.escape(parentAlias) + \".\" + orderCriteria;\n        return \"\";\n      }\n    }).join(\", \");\n    const orderByObject = {};\n    Object.keys(orderBys).forEach(orderCriteria => {\n      if (orderCriteria.indexOf(\".\") !== -1) {\n        const criteriaParts = orderCriteria.split(\".\");\n        const aliasName = criteriaParts[0];\n        const propertyPath = criteriaParts.slice(1).join(\".\");\n        const alias = this.expressionMap.findAliasByName(aliasName);\n        const column = alias.metadata.findColumnWithPropertyPath(propertyPath);\n        orderByObject[this.escape(parentAlias) + \".\" + this.escape(DriverUtils.buildAlias(this.connection.driver, aliasName, column.databaseName))] = orderBys[orderCriteria];\n      } else {\n        if (this.expressionMap.selects.find(select => select.selection === orderCriteria || select.aliasName === orderCriteria)) {\n          orderByObject[this.escape(parentAlias) + \".\" + orderCriteria] = orderBys[orderCriteria];\n        } else {\n          orderByObject[orderCriteria] = orderBys[orderCriteria];\n        }\n      }\n    });\n    return [selectString, orderByObject];\n  }\n  /**\n   * Loads raw results from the database.\n   */\n\n\n  async loadRawResults(queryRunner) {\n    const [sql, parameters] = this.getQueryAndParameters();\n    const queryId = sql + \" -- PARAMETERS: \" + JSON.stringify(parameters);\n    const cacheOptions = typeof this.connection.options.cache === \"object\" ? this.connection.options.cache : {};\n    let savedQueryResultCacheOptions = undefined;\n    let cacheError = false;\n\n    if (this.connection.queryResultCache && (this.expressionMap.cache || cacheOptions.alwaysEnabled)) {\n      try {\n        savedQueryResultCacheOptions = await this.connection.queryResultCache.getFromCache({\n          identifier: this.expressionMap.cacheId,\n          query: queryId,\n          duration: this.expressionMap.cacheDuration || cacheOptions.duration || 1000\n        }, queryRunner);\n\n        if (savedQueryResultCacheOptions && !this.connection.queryResultCache.isExpired(savedQueryResultCacheOptions)) {\n          return JSON.parse(savedQueryResultCacheOptions.result);\n        }\n      } catch (error) {\n        if (!cacheOptions.ignoreErrors) {\n          throw error;\n        }\n\n        cacheError = true;\n      }\n    }\n\n    const results = await queryRunner.query(sql, parameters, true);\n\n    if (!cacheError && this.connection.queryResultCache && (this.expressionMap.cache || cacheOptions.alwaysEnabled)) {\n      try {\n        await this.connection.queryResultCache.storeInCache({\n          identifier: this.expressionMap.cacheId,\n          query: queryId,\n          time: new Date().getTime(),\n          duration: this.expressionMap.cacheDuration || cacheOptions.duration || 1000,\n          result: JSON.stringify(results.records)\n        }, savedQueryResultCacheOptions, queryRunner);\n      } catch (error) {\n        if (!cacheOptions.ignoreErrors) {\n          throw error;\n        }\n      }\n    }\n\n    return results.records;\n  }\n  /**\n   * Merges into expression map given expression map properties.\n   */\n\n\n  mergeExpressionMap(expressionMap) {\n    ObjectUtils.assign(this.expressionMap, expressionMap);\n    return this;\n  }\n  /**\n   * Normalizes a give number - converts to int if possible.\n   */\n\n\n  normalizeNumber(num) {\n    if (typeof num === \"number\" || num === undefined || num === null) return num;\n    return Number(num);\n  }\n  /**\n   * Creates a query builder used to execute sql queries inside this query builder.\n   */\n\n\n  obtainQueryRunner() {\n    return this.queryRunner || this.connection.createQueryRunner(\"slave\");\n  }\n\n  buildSelect(select, metadata, alias, embedPrefix) {\n    for (let key in select) {\n      if (select[key] === undefined || select[key] === false) continue;\n      const propertyPath = embedPrefix ? embedPrefix + \".\" + key : key;\n      const column = metadata.findColumnWithPropertyPathStrict(propertyPath);\n      const embed = metadata.findEmbeddedWithPropertyPath(propertyPath);\n      const relation = metadata.findRelationWithPropertyPath(propertyPath);\n      if (!embed && !column && !relation) throw new EntityPropertyNotFoundError(propertyPath, metadata);\n\n      if (column) {\n        this.selects.push(alias + \".\" + propertyPath); // this.addSelect(alias + \".\" + propertyPath);\n      } else if (embed) {\n        this.buildSelect(select[key], metadata, alias, propertyPath); // } else if (relation) {\n        //     const joinAlias = alias + \"_\" + relation.propertyName;\n        //     const existJoin = this.joins.find(join => join.alias === joinAlias);\n        //     if (!existJoin) {\n        //         this.joins.push({\n        //             type: \"left\",\n        //             select: false,\n        //             alias: joinAlias,\n        //             parentAlias: alias,\n        //             relationMetadata: relation\n        //         });\n        //     }\n        //     this.buildOrder(select[key] as FindOptionsOrder<any>, relation.inverseEntityMetadata, joinAlias);\n      }\n    }\n  }\n\n  buildRelations(relations, selection, metadata, alias, embedPrefix) {\n    if (!relations) return;\n    Object.keys(relations).forEach(relationName => {\n      const relationValue = relations[relationName];\n      const propertyPath = embedPrefix ? embedPrefix + \".\" + relationName : relationName;\n      const embed = metadata.findEmbeddedWithPropertyPath(propertyPath);\n      const relation = metadata.findRelationWithPropertyPath(propertyPath);\n      if (!embed && !relation) throw new EntityPropertyNotFoundError(propertyPath, metadata);\n\n      if (embed) {\n        this.buildRelations(relationValue, typeof selection === \"object\" ? OrmUtils.deepValue(selection, embed.propertyPath) : undefined, metadata, alias, propertyPath);\n      } else if (relation) {\n        let joinAlias = alias + \"_\" + propertyPath.replace(\".\", \"_\");\n        joinAlias = DriverUtils.buildAlias(this.connection.driver, {\n          joiner: \"__\"\n        }, alias, joinAlias);\n\n        if (relationValue === true || typeof relationValue === \"object\") {\n          if (this.expressionMap.relationLoadStrategy === \"query\") {\n            this.relationMetadatas.push(relation);\n          } else {\n            // join\n            this.joins.push({\n              type: \"left\",\n              select: true,\n              selection: selection && typeof selection[relationName] === \"object\" ? selection[relationName] : undefined,\n              alias: joinAlias,\n              parentAlias: alias,\n              relationMetadata: relation\n            });\n\n            if (selection && typeof selection[relationName] === \"object\") {\n              this.buildSelect(selection[relationName], relation.inverseEntityMetadata, joinAlias);\n            }\n          }\n        }\n\n        if (typeof relationValue === \"object\" && this.expressionMap.relationLoadStrategy === \"join\") {\n          this.buildRelations(relationValue, typeof selection === \"object\" ? OrmUtils.deepValue(selection, relation.propertyPath) : undefined, relation.inverseEntityMetadata, joinAlias, undefined);\n        }\n      }\n    });\n  }\n\n  buildEagerRelations(relations, selection, metadata, alias, embedPrefix) {\n    if (!relations) return;\n    Object.keys(relations).forEach(relationName => {\n      const relationValue = relations[relationName];\n      const propertyPath = embedPrefix ? embedPrefix + \".\" + relationName : relationName;\n      const embed = metadata.findEmbeddedWithPropertyPath(propertyPath);\n      const relation = metadata.findRelationWithPropertyPath(propertyPath);\n      if (!embed && !relation) throw new EntityPropertyNotFoundError(propertyPath, metadata);\n\n      if (embed) {\n        this.buildEagerRelations(relationValue, typeof selection === \"object\" ? OrmUtils.deepValue(selection, embed.propertyPath) : undefined, metadata, alias, propertyPath);\n      } else if (relation) {\n        let joinAlias = alias + \"_\" + propertyPath.replace(\".\", \"_\");\n        joinAlias = DriverUtils.buildAlias(this.connection.driver, {\n          joiner: \"__\"\n        }, alias, joinAlias);\n\n        if (relationValue === true || typeof relationValue === \"object\") {\n          relation.inverseEntityMetadata.eagerRelations.forEach(eagerRelation => {\n            let eagerRelationJoinAlias = joinAlias + \"_\" + eagerRelation.propertyPath.replace(\".\", \"_\");\n            eagerRelationJoinAlias = DriverUtils.buildAlias(this.connection.driver, {\n              joiner: \"__\"\n            }, joinAlias, eagerRelationJoinAlias);\n            const existJoin = this.joins.find(join => join.alias === eagerRelationJoinAlias);\n\n            if (!existJoin) {\n              this.joins.push({\n                type: \"left\",\n                select: true,\n                alias: eagerRelationJoinAlias,\n                parentAlias: joinAlias,\n                selection: undefined,\n                relationMetadata: eagerRelation\n              });\n            }\n\n            if (selection && typeof selection[relationName] === \"object\") {\n              this.buildSelect(selection[relationName], relation.inverseEntityMetadata, joinAlias);\n            }\n          });\n        }\n\n        if (typeof relationValue === \"object\") {\n          this.buildEagerRelations(relationValue, typeof selection === \"object\" ? OrmUtils.deepValue(selection, relation.propertyPath) : undefined, relation.inverseEntityMetadata, joinAlias, undefined);\n        }\n      }\n    });\n  }\n\n  buildOrder(order, metadata, alias, embedPrefix) {\n    for (let key in order) {\n      if (order[key] === undefined) continue;\n      const propertyPath = embedPrefix ? embedPrefix + \".\" + key : key;\n      const column = metadata.findColumnWithPropertyPathStrict(propertyPath);\n      const embed = metadata.findEmbeddedWithPropertyPath(propertyPath);\n      const relation = metadata.findRelationWithPropertyPath(propertyPath);\n      if (!embed && !column && !relation) throw new EntityPropertyNotFoundError(propertyPath, metadata);\n\n      if (column) {\n        let direction = typeof order[key] === \"object\" ? order[key].direction : order[key];\n        direction = direction === \"DESC\" || direction === \"desc\" || direction === -1 ? \"DESC\" : \"ASC\";\n        let nulls = typeof order[key] === \"object\" ? order[key].nulls : undefined;\n        nulls = (nulls === null || nulls === void 0 ? void 0 : nulls.toLowerCase()) === \"first\" ? \"NULLS FIRST\" : (nulls === null || nulls === void 0 ? void 0 : nulls.toLowerCase()) === \"last\" ? \"NULLS LAST\" : undefined;\n        this.addOrderBy(`${alias}.${propertyPath}`, direction, nulls); // this.orderBys.push({ alias: alias + \".\" + propertyPath, direction, nulls });\n      } else if (embed) {\n        this.buildOrder(order[key], metadata, alias, propertyPath);\n      } else if (relation) {\n        let joinAlias = alias + \"_\" + propertyPath.replace(\".\", \"_\");\n        joinAlias = DriverUtils.buildAlias(this.connection.driver, {\n          joiner: \"__\"\n        }, alias, joinAlias); // console.log(\"joinAlias\", joinAlias, joinAlias.length, this.connection.driver.maxAliasLength)\n        // todo: use expressionMap.joinAttributes, and create a new one using\n        //  const joinAttribute = new JoinAttribute(this.connection, this.expressionMap);\n\n        const existJoin = this.joins.find(join => join.alias === joinAlias);\n\n        if (!existJoin) {\n          this.joins.push({\n            type: \"left\",\n            select: false,\n            alias: joinAlias,\n            parentAlias: alias,\n            selection: undefined,\n            relationMetadata: relation\n          });\n        }\n\n        this.buildOrder(order[key], relation.inverseEntityMetadata, joinAlias);\n      }\n    }\n  }\n\n  buildWhere(where, metadata, alias, embedPrefix) {\n    let condition = \"\"; // let parameterIndex = Object.keys(this.expressionMap.nativeParameters).length;\n\n    if (Array.isArray(where)) {\n      condition = \"(\" + where.map(whereItem => {\n        return this.buildWhere(whereItem, metadata, alias, embedPrefix);\n      }).filter(condition => !!condition).map(condition => \"(\" + condition + \")\").join(\" OR \") + \")\";\n    } else {\n      let andConditions = [];\n\n      for (let key in where) {\n        if (where[key] === undefined || where[key] === null) continue;\n        const propertyPath = embedPrefix ? embedPrefix + \".\" + key : key;\n        const column = metadata.findColumnWithPropertyPathStrict(propertyPath);\n        const embed = metadata.findEmbeddedWithPropertyPath(propertyPath);\n        const relation = metadata.findRelationWithPropertyPath(propertyPath);\n        if (!embed && !column && !relation) throw new EntityPropertyNotFoundError(propertyPath, metadata);\n\n        if (column) {\n          const aliasPath = `${alias}.${propertyPath}`; // const parameterName = alias + \"_\" + propertyPath.split(\".\").join(\"_\") + \"_\" + parameterIndex;\n          // todo: we need to handle other operators as well?\n\n          let parameterValue = where[key];\n\n          if (InstanceChecker.isEqualOperator(where[key])) {\n            parameterValue = where[key].value;\n          }\n\n          if (column.transformer) {\n            parameterValue = ApplyValueTransformers.transformTo(column.transformer, parameterValue);\n          } // if (parameterValue === null) {\n          //     andConditions.push(`${aliasPath} IS NULL`);\n          //\n          // } else if (parameterValue instanceof FindOperator) {\n          //     // let parameters: any[] = [];\n          //     // if (parameterValue.useParameter) {\n          //     //     const realParameterValues: any[] = parameterValue.multipleParameters ? parameterValue.value : [parameterValue.value];\n          //     //     realParameterValues.forEach((realParameterValue, realParameterValueIndex) => {\n          //     //\n          //     //         // don't create parameters for number to prevent max number of variables issues as much as possible\n          //     //         if (typeof realParameterValue === \"number\") {\n          //     //             parameters.push(realParameterValue);\n          //     //\n          //     //         } else {\n          //     //             this.expressionMap.nativeParameters[parameterName + realParameterValueIndex] = realParameterValue;\n          //     //             parameterIndex++;\n          //     //             parameters.push(this.connection.driver.createParameter(parameterName + realParameterValueIndex, parameterIndex - 1));\n          //     //         }\n          //     //     });\n          //     // }\n          //     andConditions.push(\n          //         this.createWhereConditionExpression(this.getWherePredicateCondition(aliasPath, parameterValue))\n          //         // parameterValue.toSql(this.connection, aliasPath, parameters));\n          //     )\n          //\n          // } else {\n          //     this.expressionMap.nativeParameters[parameterName] = parameterValue;\n          //     parameterIndex++;\n          //     const parameter = this.connection.driver.createParameter(parameterName, parameterIndex - 1);\n          //     andConditions.push(`${aliasPath} = ${parameter}`);\n          // }\n\n\n          andConditions.push(this.createWhereConditionExpression(this.getWherePredicateCondition(aliasPath, parameterValue))); // this.conditions.push(`${alias}.${propertyPath} = :${paramName}`);\n          // this.expressionMap.parameters[paramName] = where[key]; // todo: handle functions and other edge cases\n        } else if (embed) {\n          const condition = this.buildWhere(where[key], metadata, alias, propertyPath);\n          if (condition) andConditions.push(condition);\n        } else if (relation) {\n          // if all properties of where are undefined we don't need to join anything\n          // this can happen when user defines map with conditional queries inside\n          if (typeof where[key] === \"object\") {\n            const allAllUndefined = Object.keys(where[key]).every(k => where[key][k] === undefined);\n\n            if (allAllUndefined) {\n              continue;\n            }\n          }\n\n          if (InstanceChecker.isFindOperator(where[key])) {\n            if (where[key].type === \"moreThan\" || where[key].type === \"lessThan\") {\n              const sqlOperator = where[key].type === \"moreThan\" ? \">\" : \"<\"; // basically relation count functionality\n\n              const qb = this.subQuery();\n\n              if (relation.isManyToManyOwner) {\n                qb.select(\"COUNT(*)\").from(relation.joinTableName, relation.joinTableName).where(relation.joinColumns.map(column => {\n                  return `${relation.joinTableName}.${column.propertyName} = ${alias}.${column.referencedColumn.propertyName}`;\n                }).join(\" AND \"));\n              } else if (relation.isManyToManyNotOwner) {\n                qb.select(\"COUNT(*)\").from(relation.inverseRelation.joinTableName, relation.inverseRelation.joinTableName).where(relation.inverseRelation.inverseJoinColumns.map(column => {\n                  return `${relation.inverseRelation.joinTableName}.${column.propertyName} = ${alias}.${column.referencedColumn.propertyName}`;\n                }).join(\" AND \"));\n              } else if (relation.isOneToMany) {\n                qb.select(\"COUNT(*)\").from(relation.inverseEntityMetadata.target, relation.inverseEntityMetadata.tableName).where(relation.inverseRelation.joinColumns.map(column => {\n                  return `${relation.inverseEntityMetadata.tableName}.${column.propertyName} = ${alias}.${column.referencedColumn.propertyName}`;\n                }).join(\" AND \"));\n              } else {\n                throw new Error(`This relation isn't supported by given find operator`);\n              } // this\n              //     .addSelect(qb.getSql(), relation.propertyAliasName + \"_cnt\")\n              //     .andWhere(this.escape(relation.propertyAliasName + \"_cnt\") + \" \" + sqlOperator + \" \" + parseInt(where[key].value));\n\n\n              this.andWhere(qb.getSql() + \" \" + sqlOperator + \" \" + parseInt(where[key].value));\n            } else {\n              if (relation.isManyToOne || relation.isOneToOne && relation.isOneToOneOwner) {\n                const aliasPath = `${alias}.${propertyPath}`;\n                andConditions.push(this.createWhereConditionExpression(this.getWherePredicateCondition(aliasPath, where[key])));\n              } else {\n                throw new Error(`This relation isn't supported by given find operator`);\n              }\n            }\n          } else {\n            // const joinAlias = alias + \"_\" + relation.propertyName;\n            let joinAlias = alias + \"_\" + relation.propertyPath.replace(\".\", \"_\");\n            joinAlias = DriverUtils.buildAlias(this.connection.driver, {\n              joiner: \"__\"\n            }, alias, joinAlias);\n            const existJoin = this.joins.find(join => join.alias === joinAlias);\n\n            if (!existJoin) {\n              this.joins.push({\n                type: \"inner\",\n                select: false,\n                selection: undefined,\n                alias: joinAlias,\n                parentAlias: alias,\n                relationMetadata: relation\n              });\n            } else {\n              if (existJoin.type === \"left\") existJoin.type = \"inner\";\n            }\n\n            const condition = this.buildWhere(where[key], relation.inverseEntityMetadata, joinAlias);\n\n            if (condition) {\n              andConditions.push(condition); // parameterIndex = Object.keys(this.expressionMap.nativeParameters).length;\n            }\n          }\n        }\n      }\n\n      condition = andConditions.join(\" AND \");\n    }\n\n    return condition;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["RawSqlResultsToEntityTransformer","PessimisticLockTransactionRequiredError","NoVersionOrUpdateDateColumnError","OptimisticLockVersionMismatchError","OptimisticLockCanNotBeUsedError","JoinAttribute","RelationIdAttribute","RelationCountAttribute","RelationIdLoader","RelationIdMetadataToAttributeTransformer","RelationCountLoader","RelationCountMetadataToAttributeTransformer","QueryBuilder","LockNotSupportedOnGivenDriverError","OffsetWithoutLimitNotSupportedError","ObjectUtils","DriverUtils","EntityNotFoundError","TypeORMError","FindOptionsUtils","ApplyValueTransformers","OrmUtils","EntityPropertyNotFoundError","InstanceChecker","SelectQueryBuilder","constructor","Symbol","for","getQuery","sql","createComment","createCteExpression","createSelectExpression","createJoinExpression","createWhereExpression","createGroupByExpression","createHavingExpression","createOrderByExpression","createLimitOffsetExpression","createLockExpression","trim","expressionMap","subQuery","setFindOptions","findOptions","applyFindOptions","qb","createQueryBuilder","parentQueryBuilder","select","selection","selectionAliasName","queryType","Array","isArray","selects","map","subQueryBuilder","setParameters","getParameters","push","aliasName","addSelect","concat","maxExecutionTime","milliseconds","distinct","selectDistinct","distinctOn","selectDistinctOn","from","entityTarget","mainAlias","createFromAlias","setMainAlias","addFrom","alias","innerJoin","entityOrProperty","condition","parameters","join","leftJoin","innerJoinAndSelect","leftJoinAndSelect","innerJoinAndMapMany","mapToProperty","innerJoinAndMapOne","leftJoinAndMapMany","leftJoinAndMapOne","loadRelationIdAndMap","relationName","aliasNameOrOptions","queryBuilderFactory","relationIdAttribute","disableMixedMap","relationIdAttributes","relation","junctionEntityMetadata","createAlias","type","name","junctionAlias","metadata","loadRelationCountAndMap","relationCountAttribute","relationCountAttributes","loadAllRelationIds","options","relations","forEach","undefined","indexOf","propertyPath","where","wheres","getWhereCondition","andWhere","orWhere","whereInIds","ids","getWhereInIdsCondition","andWhereInIds","orWhereInIds","having","havings","andHaving","orHaving","groupBy","groupBys","addGroupBy","orderBy","sort","order","nulls","orderBys","addOrderBy","limit","normalizeNumber","isNaN","offset","take","skip","useIndex","index","setLock","lockMode","lockVersion","lockTables","setOnLocked","onLocked","withDeleted","getRawOne","getRawMany","queryEntity","queryRunner","obtainQueryRunner","transactionStartedByUs","useTransaction","isTransactionActive","startTransaction","results","loadRawResults","commitTransaction","error","rollbackTransaction","rollbackError","release","getRawAndEntities","executeEntitiesAndRawResults","getOne","result","entities","Date","actualVersion","updateDateColumn","getEntityValue","getTime","versionColumn","getOneOrFail","entity","target","getMany","getCount","executeCountQuery","getManyAndCount","entitiesAndRaw","cacheId","count","stream","getQueryAndParameters","releaseFn","cache","enabledOrMillisecondsOrId","maybeMilliseconds","cacheDuration","setOption","option","direction","isMappingMany","joinAttribute","connection","joinAttributes","deleteDateColumn","conditionDeleteColumn","propertyName","isSubQuery","substr","tablePath","allSelects","excludedSelects","hasMetadata","buildEscapedEntityColumnSelects","findEntityColumnSelects","hasMainAlias","some","escape","excludedSelect","find","filter","replacePropertyNames","length","isMySQLFamily","driver","froms","aliases","getTableName","createSelectDistinctExpression","createTableLockExpression","isPostgresFamily","selectDistinctOnMap","on","joins","joinAttr","destinationTableName","destinationTableAlias","appendedCondition","parentAlias","destinationJoin","isManyToOne","isOneToOneOwner","joinColumns","joinColumn","referencedColumn","isOneToMany","isOneToOneNotOwner","inverseRelation","inverseEntityMetadata","tableType","discriminatorColumn","databaseName","discriminatorValue","junctionTableName","junctionCondition","destinationCondition","isOwning","inverseJoinColumns","allOrderBys","Object","keys","columnName","prefix","isSQLiteFamily","lockTablesClause","onLockExpression","isReleaseVersionOrGreater","conditions","columns","column","isSelect","nonSelectedPrimaryColumns","primaryColumns","primaryColumn","allColumns","finalSelects","selectionPath","spatialTypes","useLegacy","legacySpatialSupport","asText","precision","selections","buildAlias","virtual","mainSelect","computeCountExpression","distinctAlias","c","columnsExpression","countSql","clone","parseInt","relationLoadStrategy","comment","propertyPathsToTruthyObject","buildSelect","buildRelations","loadEagerRelations","buildEagerRelations","buildWhere","buildOrder","relationMetadata","id","key","lock","mode","version","tableNames","tables","table","tableAlias","tableNameWithoutPrefix","loadRelationIds","joinEagerRelations","transaction","relationIdLoader","relationCountLoader","relationIdMetadataTransformer","transform","relationCountMetadataTransformer","rawResults","createOrderByCombinedWithSelectExpression","mainAliasName","querySelects","columnAlias","setNativeParameters","nativeParameters","hasMultiplePrimaryKeys","paramKey","areAllNumbers","every","mergeExpressionMap","extraAppendedAndWhereCondition","rawRelationIdResults","load","rawRelationCountResults","transformer","callListeners","broadcaster","broadcast","Promise","all","relationMetadatas","relationTarget","relationAlias","targetName","queryBuilder","deepValue","relatedEntityGroups","loadManyToManyRelationIdsAndGroup","relatedEntityGroup","group","value","related","setEntityValue","raw","selectString","orderCriteria","criteriaParts","split","slice","findAliasByName","findColumnWithPropertyPath","orderByObject","queryId","JSON","stringify","cacheOptions","savedQueryResultCacheOptions","cacheError","queryResultCache","alwaysEnabled","getFromCache","identifier","query","duration","isExpired","parse","ignoreErrors","storeInCache","time","records","assign","num","Number","createQueryRunner","embedPrefix","findColumnWithPropertyPathStrict","embed","findEmbeddedWithPropertyPath","findRelationWithPropertyPath","relationValue","joinAlias","replace","joiner","eagerRelations","eagerRelation","eagerRelationJoinAlias","existJoin","toLowerCase","whereItem","andConditions","aliasPath","parameterValue","isEqualOperator","transformTo","createWhereConditionExpression","getWherePredicateCondition","allAllUndefined","k","isFindOperator","sqlOperator","isManyToManyOwner","joinTableName","isManyToManyNotOwner","tableName","Error","getSql","isOneToOne"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\query-builder\\SelectQueryBuilder.ts"],"sourcesContent":["import { RawSqlResultsToEntityTransformer } from \"./transformer/RawSqlResultsToEntityTransformer\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { PessimisticLockTransactionRequiredError } from \"../error/PessimisticLockTransactionRequiredError\"\nimport { NoVersionOrUpdateDateColumnError } from \"../error/NoVersionOrUpdateDateColumnError\"\nimport { OptimisticLockVersionMismatchError } from \"../error/OptimisticLockVersionMismatchError\"\nimport { OptimisticLockCanNotBeUsedError } from \"../error/OptimisticLockCanNotBeUsedError\"\nimport { JoinAttribute } from \"./JoinAttribute\"\nimport { RelationIdAttribute } from \"./relation-id/RelationIdAttribute\"\nimport { RelationCountAttribute } from \"./relation-count/RelationCountAttribute\"\nimport { RelationIdLoader } from \"./relation-id/RelationIdLoader\"\nimport { RelationIdMetadataToAttributeTransformer } from \"./relation-id/RelationIdMetadataToAttributeTransformer\"\nimport { RelationCountLoader } from \"./relation-count/RelationCountLoader\"\nimport { RelationCountMetadataToAttributeTransformer } from \"./relation-count/RelationCountMetadataToAttributeTransformer\"\nimport { QueryBuilder } from \"./QueryBuilder\"\nimport { ReadStream } from \"../platform/PlatformTools\"\nimport { LockNotSupportedOnGivenDriverError } from \"../error/LockNotSupportedOnGivenDriverError\"\nimport { MysqlDriver } from \"../driver/mysql/MysqlDriver\"\nimport { SelectQuery } from \"./SelectQuery\"\nimport { EntityMetadata } from \"../metadata/EntityMetadata\"\nimport { ColumnMetadata } from \"../metadata/ColumnMetadata\"\nimport { OrderByCondition } from \"../find-options/OrderByCondition\"\nimport { QueryExpressionMap } from \"./QueryExpressionMap\"\nimport { EntityTarget } from \"../common/EntityTarget\"\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\nimport { WhereExpressionBuilder } from \"./WhereExpressionBuilder\"\nimport { Brackets } from \"./Brackets\"\nimport { QueryResultCacheOptions } from \"../cache/QueryResultCacheOptions\"\nimport { OffsetWithoutLimitNotSupportedError } from \"../error/OffsetWithoutLimitNotSupportedError\"\nimport { SelectQueryBuilderOption } from \"./SelectQueryBuilderOption\"\nimport { ObjectUtils } from \"../util/ObjectUtils\"\nimport { DriverUtils } from \"../driver/DriverUtils\"\nimport { EntityNotFoundError } from \"../error/EntityNotFoundError\"\nimport { TypeORMError } from \"../error\"\nimport { FindManyOptions } from \"../find-options/FindManyOptions\"\nimport { FindOptionsSelect } from \"../find-options/FindOptionsSelect\"\nimport { RelationMetadata } from \"../metadata/RelationMetadata\"\nimport { FindOptionsOrder } from \"../find-options/FindOptionsOrder\"\nimport { FindOptionsWhere } from \"../find-options/FindOptionsWhere\"\nimport { FindOptionsUtils } from \"../find-options/FindOptionsUtils\"\nimport { FindOptionsRelations } from \"../find-options/FindOptionsRelations\"\nimport { ApplyValueTransformers } from \"../util/ApplyValueTransformers\"\nimport { OrmUtils } from \"../util/OrmUtils\"\nimport { EntityPropertyNotFoundError } from \"../error/EntityPropertyNotFoundError\"\nimport { AuroraMysqlDriver } from \"../driver/aurora-mysql/AuroraMysqlDriver\"\nimport { InstanceChecker } from \"../util/InstanceChecker\"\n\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n */\nexport class SelectQueryBuilder<Entity extends ObjectLiteral>\n    extends QueryBuilder<Entity>\n    implements WhereExpressionBuilder\n{\n    readonly \"@instanceof\" = Symbol.for(\"SelectQueryBuilder\")\n\n    protected findOptions: FindManyOptions = {}\n    protected selects: string[] = []\n    protected joins: {\n        type: \"inner\" | \"left\"\n        alias: string\n        parentAlias: string\n        relationMetadata: RelationMetadata\n        select: boolean\n        selection: FindOptionsSelect<any> | undefined\n    }[] = []\n    protected conditions: string = \"\"\n    protected orderBys: {\n        alias: string\n        direction: \"ASC\" | \"DESC\"\n        nulls?: \"NULLS FIRST\" | \"NULLS LAST\"\n    }[] = []\n    protected relationMetadatas: RelationMetadata[] = []\n\n    // -------------------------------------------------------------------------\n    // Public Implemented Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets generated SQL query without parameters being replaced.\n     */\n    getQuery(): string {\n        let sql = this.createComment()\n        sql += this.createCteExpression()\n        sql += this.createSelectExpression()\n        sql += this.createJoinExpression()\n        sql += this.createWhereExpression()\n        sql += this.createGroupByExpression()\n        sql += this.createHavingExpression()\n        sql += this.createOrderByExpression()\n        sql += this.createLimitOffsetExpression()\n        sql += this.createLockExpression()\n        sql = sql.trim()\n        if (this.expressionMap.subQuery) sql = \"(\" + sql + \")\"\n        return sql\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    setFindOptions(findOptions: FindManyOptions<Entity>) {\n        this.findOptions = findOptions\n        this.applyFindOptions()\n        return this\n    }\n\n    /**\n     * Creates a subquery - query that can be used inside other queries.\n     */\n    subQuery(): SelectQueryBuilder<any> {\n        const qb = this.createQueryBuilder()\n        qb.expressionMap.subQuery = true\n        qb.parentQueryBuilder = this\n        return qb\n    }\n\n    /**\n     * Creates SELECT query.\n     * Replaces all previous selections if they exist.\n     */\n    select(): this\n\n    /**\n     * Creates SELECT query.\n     * Replaces all previous selections if they exist.\n     */\n    select(\n        selection: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>,\n        selectionAliasName?: string,\n    ): this\n\n    /**\n     * Creates SELECT query and selects given data.\n     * Replaces all previous selections if they exist.\n     */\n    select(selection: string, selectionAliasName?: string): this\n\n    /**\n     * Creates SELECT query and selects given data.\n     * Replaces all previous selections if they exist.\n     */\n    select(selection: string[]): this\n\n    /**\n     * Creates SELECT query and selects given data.\n     * Replaces all previous selections if they exist.\n     */\n    select(\n        selection?:\n            | string\n            | string[]\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        selectionAliasName?: string,\n    ): SelectQueryBuilder<Entity> {\n        this.expressionMap.queryType = \"select\"\n        if (Array.isArray(selection)) {\n            this.expressionMap.selects = selection.map((selection) => ({\n                selection: selection,\n            }))\n        } else if (typeof selection === \"function\") {\n            const subQueryBuilder = selection(this.subQuery())\n            this.setParameters(subQueryBuilder.getParameters())\n            this.expressionMap.selects.push({\n                selection: subQueryBuilder.getQuery(),\n                aliasName: selectionAliasName,\n            })\n        } else if (selection) {\n            this.expressionMap.selects = [\n                { selection: selection, aliasName: selectionAliasName },\n            ]\n        }\n\n        return this\n    }\n\n    /**\n     * Adds new selection to the SELECT query.\n     */\n    addSelect(\n        selection: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>,\n        selectionAliasName?: string,\n    ): this\n\n    /**\n     * Adds new selection to the SELECT query.\n     */\n    addSelect(selection: string, selectionAliasName?: string): this\n\n    /**\n     * Adds new selection to the SELECT query.\n     */\n    addSelect(selection: string[]): this\n\n    /**\n     * Adds new selection to the SELECT query.\n     */\n    addSelect(\n        selection:\n            | string\n            | string[]\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        selectionAliasName?: string,\n    ): this {\n        if (!selection) return this\n\n        if (Array.isArray(selection)) {\n            this.expressionMap.selects = this.expressionMap.selects.concat(\n                selection.map((selection) => ({ selection: selection })),\n            )\n        } else if (typeof selection === \"function\") {\n            const subQueryBuilder = selection(this.subQuery())\n            this.setParameters(subQueryBuilder.getParameters())\n            this.expressionMap.selects.push({\n                selection: subQueryBuilder.getQuery(),\n                aliasName: selectionAliasName,\n            })\n        } else if (selection) {\n            this.expressionMap.selects.push({\n                selection: selection,\n                aliasName: selectionAliasName,\n            })\n        }\n\n        return this\n    }\n\n    /**\n     * Set max execution time.\n     * @param milliseconds\n     */\n    maxExecutionTime(milliseconds: number): this {\n        this.expressionMap.maxExecutionTime = milliseconds\n        return this\n    }\n\n    /**\n     * Sets whether the selection is DISTINCT.\n     */\n    distinct(distinct: boolean = true): this {\n        this.expressionMap.selectDistinct = distinct\n        return this\n    }\n\n    /**\n     * Sets the distinct on clause for Postgres.\n     */\n    distinctOn(distinctOn: string[]): this {\n        this.expressionMap.selectDistinctOn = distinctOn\n        return this\n    }\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     * Removes all previously set from-s.\n     */\n    from<T extends ObjectLiteral>(\n        entityTarget: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>,\n        aliasName: string,\n    ): SelectQueryBuilder<T>\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     * Removes all previously set from-s.\n     */\n    from<T extends ObjectLiteral>(\n        entityTarget: EntityTarget<T>,\n        aliasName: string,\n    ): SelectQueryBuilder<T>\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     * Removes all previously set from-s.\n     */\n    from<T extends ObjectLiteral>(\n        entityTarget:\n            | EntityTarget<T>\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        aliasName: string,\n    ): SelectQueryBuilder<T> {\n        const mainAlias = this.createFromAlias(entityTarget, aliasName)\n        this.expressionMap.setMainAlias(mainAlias)\n        return this as any as SelectQueryBuilder<T>\n    }\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     */\n    addFrom<T extends ObjectLiteral>(\n        entityTarget: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>,\n        aliasName: string,\n    ): SelectQueryBuilder<T>\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     */\n    addFrom<T extends ObjectLiteral>(\n        entityTarget: EntityTarget<T>,\n        aliasName: string,\n    ): SelectQueryBuilder<T>\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     */\n    addFrom<T extends ObjectLiteral>(\n        entityTarget:\n            | EntityTarget<T>\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        aliasName: string,\n    ): SelectQueryBuilder<T> {\n        const alias = this.createFromAlias(entityTarget, aliasName)\n        if (!this.expressionMap.mainAlias)\n            this.expressionMap.setMainAlias(alias)\n\n        return this as any as SelectQueryBuilder<T>\n    }\n\n    /**\n     * INNER JOINs (without selection) given subquery.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoin(\n        subQueryFactory: (\n            qb: SelectQueryBuilder<any>,\n        ) => SelectQueryBuilder<any>,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs (without selection) entity's property.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoin(\n        property: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs (without selection) given entity's table.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoin(\n        entity: Function | string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs (without selection) given table.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoin(\n        tableName: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs (without selection).\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoin(\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this {\n        this.join(\"INNER\", entityOrProperty, alias, condition, parameters)\n        return this\n    }\n\n    /**\n     * LEFT JOINs (without selection) given subquery.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoin(\n        subQueryFactory: (\n            qb: SelectQueryBuilder<any>,\n        ) => SelectQueryBuilder<any>,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs (without selection) entity's property.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoin(\n        property: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs (without selection) entity's table.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoin(\n        entity: Function | string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs (without selection) given table.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoin(\n        tableName: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs (without selection).\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoin(\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this {\n        this.join(\"LEFT\", entityOrProperty, alias, condition, parameters)\n        return this\n    }\n\n    /**\n     * INNER JOINs given subquery and adds all selection properties to SELECT..\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndSelect(\n        subQueryFactory: (\n            qb: SelectQueryBuilder<any>,\n        ) => SelectQueryBuilder<any>,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs entity's property and adds all selection properties to SELECT.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndSelect(\n        property: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs entity and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndSelect(\n        entity: Function | string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs table and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndSelect(\n        tableName: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndSelect(\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this {\n        this.addSelect(alias)\n        this.innerJoin(entityOrProperty, alias, condition, parameters)\n        return this\n    }\n\n    /**\n     * LEFT JOINs given subquery and adds all selection properties to SELECT..\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndSelect(\n        subQueryFactory: (\n            qb: SelectQueryBuilder<any>,\n        ) => SelectQueryBuilder<any>,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs entity's property and adds all selection properties to SELECT.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndSelect(\n        property: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs entity and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndSelect(\n        entity: Function | string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs table and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndSelect(\n        tableName: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndSelect(\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this {\n        this.addSelect(alias)\n        this.leftJoin(entityOrProperty, alias, condition, parameters)\n        return this\n    }\n\n    /**\n     * INNER JOINs given subquery, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapMany(\n        mapToProperty: string,\n        subQueryFactory: (\n            qb: SelectQueryBuilder<any>,\n        ) => SelectQueryBuilder<any>,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs entity's property, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapMany(\n        mapToProperty: string,\n        property: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs entity's table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapMany(\n        mapToProperty: string,\n        entity: Function | string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapMany(\n        mapToProperty: string,\n        tableName: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapMany(\n        mapToProperty: string,\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this {\n        this.addSelect(alias)\n        this.join(\n            \"INNER\",\n            entityOrProperty,\n            alias,\n            condition,\n            parameters,\n            mapToProperty,\n            true,\n        )\n        return this\n    }\n\n    /**\n     * INNER JOINs given subquery, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapOne(\n        mapToProperty: string,\n        subQueryFactory: (\n            qb: SelectQueryBuilder<any>,\n        ) => SelectQueryBuilder<any>,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs entity's property, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapOne(\n        mapToProperty: string,\n        property: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs entity's table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapOne(\n        mapToProperty: string,\n        entity: Function | string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapOne(\n        mapToProperty: string,\n        tableName: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapOne(\n        mapToProperty: string,\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this {\n        this.addSelect(alias)\n        this.join(\n            \"INNER\",\n            entityOrProperty,\n            alias,\n            condition,\n            parameters,\n            mapToProperty,\n            false,\n        )\n        return this\n    }\n\n    /**\n     * LEFT JOINs given subquery, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapMany(\n        mapToProperty: string,\n        subQueryFactory: (\n            qb: SelectQueryBuilder<any>,\n        ) => SelectQueryBuilder<any>,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs entity's property, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapMany(\n        mapToProperty: string,\n        property: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs entity's table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapMany(\n        mapToProperty: string,\n        entity: Function | string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapMany(\n        mapToProperty: string,\n        tableName: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapMany(\n        mapToProperty: string,\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this {\n        this.addSelect(alias)\n        this.join(\n            \"LEFT\",\n            entityOrProperty,\n            alias,\n            condition,\n            parameters,\n            mapToProperty,\n            true,\n        )\n        return this\n    }\n\n    /**\n     * LEFT JOINs given subquery, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapOne(\n        mapToProperty: string,\n        subQueryFactory: (\n            qb: SelectQueryBuilder<any>,\n        ) => SelectQueryBuilder<any>,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs entity's property, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapOne(\n        mapToProperty: string,\n        property: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs entity's table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapOne(\n        mapToProperty: string,\n        entity: Function | string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapOne(\n        mapToProperty: string,\n        tableName: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapOne(\n        mapToProperty: string,\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this {\n        this.addSelect(alias)\n        this.join(\n            \"LEFT\",\n            entityOrProperty,\n            alias,\n            condition,\n            parameters,\n            mapToProperty,\n            false,\n        )\n        return this\n    }\n\n    /**\n     */\n    // selectAndMap(mapToProperty: string, property: string, aliasName: string, qbFactory: ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>)): this;\n\n    /**\n     */\n    // selectAndMap(mapToProperty: string, entity: Function|string, aliasName: string, qbFactory: ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>)): this;\n\n    /**\n     */\n    // selectAndMap(mapToProperty: string, tableName: string, aliasName: string, qbFactory: ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>)): this;\n\n    /**\n     */\n    // selectAndMap(mapToProperty: string, entityOrProperty: Function|string, aliasName: string, qbFactory: ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>)): this {\n    //     const select = new SelectAttribute(this.expressionMap);\n    //     select.mapToProperty = mapToProperty;\n    //     select.entityOrProperty = entityOrProperty;\n    //     select.aliasName = aliasName;\n    //     select.qbFactory = qbFactory;\n    //     return this;\n    // }\n\n    /**\n     * LEFT JOINs relation id and maps it into some entity's property.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    loadRelationIdAndMap(\n        mapToProperty: string,\n        relationName: string,\n        options?: { disableMixedMap?: boolean },\n    ): this\n\n    /**\n     * LEFT JOINs relation id and maps it into some entity's property.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    loadRelationIdAndMap(\n        mapToProperty: string,\n        relationName: string,\n        alias: string,\n        queryBuilderFactory: (\n            qb: SelectQueryBuilder<any>,\n        ) => SelectQueryBuilder<any>,\n    ): this\n\n    /**\n     * LEFT JOINs relation id and maps it into some entity's property.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    loadRelationIdAndMap(\n        mapToProperty: string,\n        relationName: string,\n        aliasNameOrOptions?: string | { disableMixedMap?: boolean },\n        queryBuilderFactory?: (\n            qb: SelectQueryBuilder<any>,\n        ) => SelectQueryBuilder<any>,\n    ): this {\n        const relationIdAttribute = new RelationIdAttribute(this.expressionMap)\n        relationIdAttribute.mapToProperty = mapToProperty\n        relationIdAttribute.relationName = relationName\n        if (typeof aliasNameOrOptions === \"string\")\n            relationIdAttribute.alias = aliasNameOrOptions\n        if (\n            typeof aliasNameOrOptions === \"object\" &&\n            (aliasNameOrOptions as any).disableMixedMap\n        )\n            relationIdAttribute.disableMixedMap = true\n\n        relationIdAttribute.queryBuilderFactory = queryBuilderFactory\n        this.expressionMap.relationIdAttributes.push(relationIdAttribute)\n\n        if (relationIdAttribute.relation.junctionEntityMetadata) {\n            this.expressionMap.createAlias({\n                type: \"other\",\n                name: relationIdAttribute.junctionAlias,\n                metadata: relationIdAttribute.relation.junctionEntityMetadata,\n            })\n        }\n        return this\n    }\n\n    /**\n     * Counts number of entities of entity's relation and maps the value into some entity's property.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    loadRelationCountAndMap(\n        mapToProperty: string,\n        relationName: string,\n        aliasName?: string,\n        queryBuilderFactory?: (\n            qb: SelectQueryBuilder<any>,\n        ) => SelectQueryBuilder<any>,\n    ): this {\n        const relationCountAttribute = new RelationCountAttribute(\n            this.expressionMap,\n        )\n        relationCountAttribute.mapToProperty = mapToProperty\n        relationCountAttribute.relationName = relationName\n        relationCountAttribute.alias = aliasName\n        relationCountAttribute.queryBuilderFactory = queryBuilderFactory\n        this.expressionMap.relationCountAttributes.push(relationCountAttribute)\n\n        this.expressionMap.createAlias({\n            type: \"other\",\n            name: relationCountAttribute.junctionAlias,\n        })\n        if (relationCountAttribute.relation.junctionEntityMetadata) {\n            this.expressionMap.createAlias({\n                type: \"other\",\n                name: relationCountAttribute.junctionAlias,\n                metadata:\n                    relationCountAttribute.relation.junctionEntityMetadata,\n            })\n        }\n        return this\n    }\n\n    /**\n     * Loads all relation ids for all relations of the selected entity.\n     * All relation ids will be mapped to relation property themself.\n     * If array of strings is given then loads only relation ids of the given properties.\n     */\n    loadAllRelationIds(options?: {\n        relations?: string[]\n        disableMixedMap?: boolean\n    }): this {\n        // todo: add skip relations\n        this.expressionMap.mainAlias!.metadata.relations.forEach((relation) => {\n            if (\n                options !== undefined &&\n                options.relations !== undefined &&\n                options.relations.indexOf(relation.propertyPath) === -1\n            )\n                return\n\n            this.loadRelationIdAndMap(\n                this.expressionMap.mainAlias!.name +\n                    \".\" +\n                    relation.propertyPath,\n                this.expressionMap.mainAlias!.name +\n                    \".\" +\n                    relation.propertyPath,\n                options,\n            )\n        })\n        return this\n    }\n\n    /**\n     * Sets WHERE condition in the query builder.\n     * If you had previously WHERE expression defined,\n     * calling this function will override previously set WHERE conditions.\n     * Additionally you can add parameters used in where expression.\n     */\n    where(\n        where:\n            | Brackets\n            | string\n            | ((qb: this) => string)\n            | ObjectLiteral\n            | ObjectLiteral[],\n        parameters?: ObjectLiteral,\n    ): this {\n        this.expressionMap.wheres = [] // don't move this block below since computeWhereParameter can add where expressions\n        const condition = this.getWhereCondition(where)\n        if (condition)\n            this.expressionMap.wheres = [\n                { type: \"simple\", condition: condition },\n            ]\n        if (parameters) this.setParameters(parameters)\n        return this\n    }\n\n    /**\n     * Adds new AND WHERE condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    andWhere(\n        where:\n            | string\n            | Brackets\n            | ((qb: this) => string)\n            | ObjectLiteral\n            | ObjectLiteral[],\n        parameters?: ObjectLiteral,\n    ): this {\n        this.expressionMap.wheres.push({\n            type: \"and\",\n            condition: this.getWhereCondition(where),\n        })\n        if (parameters) this.setParameters(parameters)\n        return this\n    }\n\n    /**\n     * Adds new OR WHERE condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    orWhere(\n        where:\n            | Brackets\n            | string\n            | ((qb: this) => string)\n            | ObjectLiteral\n            | ObjectLiteral[],\n        parameters?: ObjectLiteral,\n    ): this {\n        this.expressionMap.wheres.push({\n            type: \"or\",\n            condition: this.getWhereCondition(where),\n        })\n        if (parameters) this.setParameters(parameters)\n        return this\n    }\n\n    /**\n     * Adds new AND WHERE with conditions for the given ids.\n     *\n     * Ids are mixed.\n     * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].\n     * If you have multiple primary keys you need to pass object with property names and values specified,\n     * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]\n     */\n    whereInIds(ids: any | any[]): this {\n        return this.where(this.getWhereInIdsCondition(ids))\n    }\n\n    /**\n     * Adds new AND WHERE with conditions for the given ids.\n     *\n     * Ids are mixed.\n     * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].\n     * If you have multiple primary keys you need to pass object with property names and values specified,\n     * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]\n     */\n    andWhereInIds(ids: any | any[]): this {\n        return this.andWhere(this.getWhereInIdsCondition(ids))\n    }\n\n    /**\n     * Adds new OR WHERE with conditions for the given ids.\n     *\n     * Ids are mixed.\n     * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].\n     * If you have multiple primary keys you need to pass object with property names and values specified,\n     * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]\n     */\n    orWhereInIds(ids: any | any[]): this {\n        return this.orWhere(this.getWhereInIdsCondition(ids))\n    }\n\n    /**\n     * Sets HAVING condition in the query builder.\n     * If you had previously HAVING expression defined,\n     * calling this function will override previously set HAVING conditions.\n     * Additionally you can add parameters used in where expression.\n     */\n    having(having: string, parameters?: ObjectLiteral): this {\n        this.expressionMap.havings.push({ type: \"simple\", condition: having })\n        if (parameters) this.setParameters(parameters)\n        return this\n    }\n\n    /**\n     * Adds new AND HAVING condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    andHaving(having: string, parameters?: ObjectLiteral): this {\n        this.expressionMap.havings.push({ type: \"and\", condition: having })\n        if (parameters) this.setParameters(parameters)\n        return this\n    }\n\n    /**\n     * Adds new OR HAVING condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    orHaving(having: string, parameters?: ObjectLiteral): this {\n        this.expressionMap.havings.push({ type: \"or\", condition: having })\n        if (parameters) this.setParameters(parameters)\n        return this\n    }\n\n    /**\n     * Sets GROUP BY condition in the query builder.\n     * If you had previously GROUP BY expression defined,\n     * calling this function will override previously set GROUP BY conditions.\n     */\n    groupBy(): this\n\n    /**\n     * Sets GROUP BY condition in the query builder.\n     * If you had previously GROUP BY expression defined,\n     * calling this function will override previously set GROUP BY conditions.\n     */\n    groupBy(groupBy: string): this\n\n    /**\n     * Sets GROUP BY condition in the query builder.\n     * If you had previously GROUP BY expression defined,\n     * calling this function will override previously set GROUP BY conditions.\n     */\n    groupBy(groupBy?: string): this {\n        if (groupBy) {\n            this.expressionMap.groupBys = [groupBy]\n        } else {\n            this.expressionMap.groupBys = []\n        }\n        return this\n    }\n\n    /**\n     * Adds GROUP BY condition in the query builder.\n     */\n    addGroupBy(groupBy: string): this {\n        this.expressionMap.groupBys.push(groupBy)\n        return this\n    }\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     *\n     * Calling order by without order set will remove all previously set order bys.\n     */\n    orderBy(): this\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(\n        sort: string,\n        order?: \"ASC\" | \"DESC\",\n        nulls?: \"NULLS FIRST\" | \"NULLS LAST\",\n    ): this\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(order: OrderByCondition): this\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(\n        sort?: string | OrderByCondition,\n        order: \"ASC\" | \"DESC\" = \"ASC\",\n        nulls?: \"NULLS FIRST\" | \"NULLS LAST\",\n    ): this {\n        if (order !== undefined && order !== \"ASC\" && order !== \"DESC\")\n            throw new TypeORMError(\n                `SelectQueryBuilder.addOrderBy \"order\" can accept only \"ASC\" and \"DESC\" values.`,\n            )\n        if (\n            nulls !== undefined &&\n            nulls !== \"NULLS FIRST\" &&\n            nulls !== \"NULLS LAST\"\n        )\n            throw new TypeORMError(\n                `SelectQueryBuilder.addOrderBy \"nulls\" can accept only \"NULLS FIRST\" and \"NULLS LAST\" values.`,\n            )\n\n        if (sort) {\n            if (typeof sort === \"object\") {\n                this.expressionMap.orderBys = sort as OrderByCondition\n            } else {\n                if (nulls) {\n                    this.expressionMap.orderBys = {\n                        [sort as string]: { order, nulls },\n                    }\n                } else {\n                    this.expressionMap.orderBys = { [sort as string]: order }\n                }\n            }\n        } else {\n            this.expressionMap.orderBys = {}\n        }\n        return this\n    }\n\n    /**\n     * Adds ORDER BY condition in the query builder.\n     */\n    addOrderBy(\n        sort: string,\n        order: \"ASC\" | \"DESC\" = \"ASC\",\n        nulls?: \"NULLS FIRST\" | \"NULLS LAST\",\n    ): this {\n        if (order !== undefined && order !== \"ASC\" && order !== \"DESC\")\n            throw new TypeORMError(\n                `SelectQueryBuilder.addOrderBy \"order\" can accept only \"ASC\" and \"DESC\" values.`,\n            )\n        if (\n            nulls !== undefined &&\n            nulls !== \"NULLS FIRST\" &&\n            nulls !== \"NULLS LAST\"\n        )\n            throw new TypeORMError(\n                `SelectQueryBuilder.addOrderBy \"nulls\" can accept only \"NULLS FIRST\" and \"NULLS LAST\" values.`,\n            )\n\n        if (nulls) {\n            this.expressionMap.orderBys[sort] = { order, nulls }\n        } else {\n            this.expressionMap.orderBys[sort] = order\n        }\n        return this\n    }\n\n    /**\n     * Set's LIMIT - maximum number of rows to be selected.\n     * NOTE that it may not work as you expect if you are using joins.\n     * If you want to implement pagination, and you are having join in your query,\n     * then use instead take method instead.\n     */\n    limit(limit?: number): this {\n        this.expressionMap.limit = this.normalizeNumber(limit)\n        if (\n            this.expressionMap.limit !== undefined &&\n            isNaN(this.expressionMap.limit)\n        )\n            throw new TypeORMError(\n                `Provided \"limit\" value is not a number. Please provide a numeric value.`,\n            )\n\n        return this\n    }\n\n    /**\n     * Set's OFFSET - selection offset.\n     * NOTE that it may not work as you expect if you are using joins.\n     * If you want to implement pagination, and you are having join in your query,\n     * then use instead skip method instead.\n     */\n    offset(offset?: number): this {\n        this.expressionMap.offset = this.normalizeNumber(offset)\n        if (\n            this.expressionMap.offset !== undefined &&\n            isNaN(this.expressionMap.offset)\n        )\n            throw new TypeORMError(\n                `Provided \"offset\" value is not a number. Please provide a numeric value.`,\n            )\n\n        return this\n    }\n\n    /**\n     * Sets maximal number of entities to take.\n     */\n    take(take?: number): this {\n        this.expressionMap.take = this.normalizeNumber(take)\n        if (\n            this.expressionMap.take !== undefined &&\n            isNaN(this.expressionMap.take)\n        )\n            throw new TypeORMError(\n                `Provided \"take\" value is not a number. Please provide a numeric value.`,\n            )\n\n        return this\n    }\n\n    /**\n     * Sets number of entities to skip.\n     */\n    skip(skip?: number): this {\n        this.expressionMap.skip = this.normalizeNumber(skip)\n        if (\n            this.expressionMap.skip !== undefined &&\n            isNaN(this.expressionMap.skip)\n        )\n            throw new TypeORMError(\n                `Provided \"skip\" value is not a number. Please provide a numeric value.`,\n            )\n\n        return this\n    }\n\n    /**\n     * Set certain index to be used by the query.\n     *\n     * @param index Name of index to be used.\n     */\n    useIndex(index: string): this {\n        this.expressionMap.useIndex = index\n\n        return this\n    }\n\n    /**\n     * Sets locking mode.\n     */\n    setLock(lockMode: \"optimistic\", lockVersion: number | Date): this\n\n    /**\n     * Sets locking mode.\n     */\n    setLock(\n        lockMode:\n            | \"pessimistic_read\"\n            | \"pessimistic_write\"\n            | \"dirty_read\"\n            /*\n                \"pessimistic_partial_write\" and \"pessimistic_write_or_fail\" are deprecated and\n                will be removed in a future version.\n\n                Use setOnLocked instead.\n             */\n            | \"pessimistic_partial_write\"\n            | \"pessimistic_write_or_fail\"\n            | \"for_no_key_update\"\n            | \"for_key_share\",\n        lockVersion?: undefined,\n        lockTables?: string[],\n    ): this\n\n    /**\n     * Sets locking mode.\n     */\n    setLock(\n        lockMode:\n            | \"optimistic\"\n            | \"pessimistic_read\"\n            | \"pessimistic_write\"\n            | \"dirty_read\"\n            /*\n                \"pessimistic_partial_write\" and \"pessimistic_write_or_fail\" are deprecated and\n                will be removed in a future version.\n\n                Use setOnLocked instead.\n             */\n            | \"pessimistic_partial_write\"\n            | \"pessimistic_write_or_fail\"\n            | \"for_no_key_update\"\n            | \"for_key_share\",\n        lockVersion?: number | Date,\n        lockTables?: string[],\n    ): this {\n        this.expressionMap.lockMode = lockMode\n        this.expressionMap.lockVersion = lockVersion\n        this.expressionMap.lockTables = lockTables\n        return this\n    }\n\n    /**\n     * Sets lock handling by adding NO WAIT or SKIP LOCKED.\n     */\n    setOnLocked(onLocked: \"nowait\" | \"skip_locked\"): this {\n        this.expressionMap.onLocked = onLocked\n        return this\n    }\n\n    /**\n     * Disables the global condition of \"non-deleted\" for the entity with delete date columns.\n     */\n    withDeleted(): this {\n        this.expressionMap.withDeleted = true\n        return this\n    }\n\n    /**\n     * Gets first raw result returned by execution of generated query builder sql.\n     */\n    async getRawOne<T = any>(): Promise<T | undefined> {\n        return (await this.getRawMany())[0]\n    }\n\n    /**\n     * Gets all raw results returned by execution of generated query builder sql.\n     */\n    async getRawMany<T = any>(): Promise<T[]> {\n        if (this.expressionMap.lockMode === \"optimistic\")\n            throw new OptimisticLockCanNotBeUsedError()\n\n        this.expressionMap.queryEntity = false\n        const queryRunner = this.obtainQueryRunner()\n        let transactionStartedByUs: boolean = false\n        try {\n            // start transaction if it was enabled\n            if (\n                this.expressionMap.useTransaction === true &&\n                queryRunner.isTransactionActive === false\n            ) {\n                await queryRunner.startTransaction()\n                transactionStartedByUs = true\n            }\n\n            const results = await this.loadRawResults(queryRunner)\n\n            // close transaction if we started it\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction()\n            }\n\n            return results\n        } catch (error) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction()\n                } catch (rollbackError) {}\n            }\n            throw error\n        } finally {\n            if (queryRunner !== this.queryRunner) {\n                // means we created our own query runner\n                await queryRunner.release()\n            }\n        }\n    }\n\n    /**\n     * Executes sql generated by query builder and returns object with raw results and entities created from them.\n     */\n    async getRawAndEntities<T = any>(): Promise<{\n        entities: Entity[]\n        raw: T[]\n    }> {\n        const queryRunner = this.obtainQueryRunner()\n        let transactionStartedByUs: boolean = false\n        try {\n            // start transaction if it was enabled\n            if (\n                this.expressionMap.useTransaction === true &&\n                queryRunner.isTransactionActive === false\n            ) {\n                await queryRunner.startTransaction()\n                transactionStartedByUs = true\n            }\n\n            this.expressionMap.queryEntity = true\n            const results = await this.executeEntitiesAndRawResults(queryRunner)\n\n            // close transaction if we started it\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction()\n            }\n\n            return results\n        } catch (error) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction()\n                } catch (rollbackError) {}\n            }\n            throw error\n        } finally {\n            if (queryRunner !== this.queryRunner)\n                // means we created our own query runner\n                await queryRunner.release()\n        }\n    }\n\n    /**\n     * Gets single entity returned by execution of generated query builder sql.\n     */\n    async getOne(): Promise<Entity | null> {\n        const results = await this.getRawAndEntities()\n        const result = results.entities[0] as any\n\n        if (\n            result &&\n            this.expressionMap.lockMode === \"optimistic\" &&\n            this.expressionMap.lockVersion\n        ) {\n            const metadata = this.expressionMap.mainAlias!.metadata\n\n            if (this.expressionMap.lockVersion instanceof Date) {\n                const actualVersion =\n                    metadata.updateDateColumn!.getEntityValue(result) // what if columns arent set?\n                if (\n                    actualVersion.getTime() !==\n                    this.expressionMap.lockVersion.getTime()\n                )\n                    throw new OptimisticLockVersionMismatchError(\n                        metadata.name,\n                        this.expressionMap.lockVersion,\n                        actualVersion,\n                    )\n            } else {\n                const actualVersion =\n                    metadata.versionColumn!.getEntityValue(result) // what if columns arent set?\n                if (actualVersion !== this.expressionMap.lockVersion)\n                    throw new OptimisticLockVersionMismatchError(\n                        metadata.name,\n                        this.expressionMap.lockVersion,\n                        actualVersion,\n                    )\n            }\n        }\n\n        if (result === undefined) {\n            return null\n        }\n        return result\n    }\n\n    /**\n     * Gets the first entity returned by execution of generated query builder sql or rejects the returned promise on error.\n     */\n    async getOneOrFail(): Promise<Entity> {\n        const entity = await this.getOne()\n\n        if (!entity) {\n            throw new EntityNotFoundError(\n                this.expressionMap.mainAlias!.target,\n                this,\n            )\n        }\n\n        return entity\n    }\n\n    /**\n     * Gets entities returned by execution of generated query builder sql.\n     */\n    async getMany(): Promise<Entity[]> {\n        if (this.expressionMap.lockMode === \"optimistic\")\n            throw new OptimisticLockCanNotBeUsedError()\n\n        const results = await this.getRawAndEntities()\n        return results.entities\n    }\n\n    /**\n     * Gets count - number of entities selected by sql generated by this query builder.\n     * Count excludes all limitations set by setFirstResult and setMaxResults methods call.\n     */\n    async getCount(): Promise<number> {\n        if (this.expressionMap.lockMode === \"optimistic\")\n            throw new OptimisticLockCanNotBeUsedError()\n\n        const queryRunner = this.obtainQueryRunner()\n        let transactionStartedByUs: boolean = false\n        try {\n            // start transaction if it was enabled\n            if (\n                this.expressionMap.useTransaction === true &&\n                queryRunner.isTransactionActive === false\n            ) {\n                await queryRunner.startTransaction()\n                transactionStartedByUs = true\n            }\n\n            this.expressionMap.queryEntity = false\n            const results = await this.executeCountQuery(queryRunner)\n\n            // close transaction if we started it\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction()\n            }\n\n            return results\n        } catch (error) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction()\n                } catch (rollbackError) {}\n            }\n            throw error\n        } finally {\n            if (queryRunner !== this.queryRunner)\n                // means we created our own query runner\n                await queryRunner.release()\n        }\n    }\n\n    /**\n     * Executes built SQL query and returns entities and overall entities count (without limitation).\n     * This method is useful to build pagination.\n     */\n    async getManyAndCount(): Promise<[Entity[], number]> {\n        if (this.expressionMap.lockMode === \"optimistic\")\n            throw new OptimisticLockCanNotBeUsedError()\n\n        const queryRunner = this.obtainQueryRunner()\n        let transactionStartedByUs: boolean = false\n        try {\n            // start transaction if it was enabled\n            if (\n                this.expressionMap.useTransaction === true &&\n                queryRunner.isTransactionActive === false\n            ) {\n                await queryRunner.startTransaction()\n                transactionStartedByUs = true\n            }\n\n            this.expressionMap.queryEntity = true\n            const entitiesAndRaw = await this.executeEntitiesAndRawResults(\n                queryRunner,\n            )\n            this.expressionMap.queryEntity = false\n            const cacheId = this.expressionMap.cacheId\n            // Creates a new cacheId for the count query, or it will retreive the above query results\n            // and count will return 0.\n            this.expressionMap.cacheId = cacheId ? `${cacheId}-count` : cacheId\n            const count = await this.executeCountQuery(queryRunner)\n            const results: [Entity[], number] = [entitiesAndRaw.entities, count]\n\n            // close transaction if we started it\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction()\n            }\n\n            return results\n        } catch (error) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction()\n                } catch (rollbackError) {}\n            }\n            throw error\n        } finally {\n            if (queryRunner !== this.queryRunner)\n                // means we created our own query runner\n                await queryRunner.release()\n        }\n    }\n\n    /**\n     * Executes built SQL query and returns raw data stream.\n     */\n    async stream(): Promise<ReadStream> {\n        this.expressionMap.queryEntity = false\n        const [sql, parameters] = this.getQueryAndParameters()\n        const queryRunner = this.obtainQueryRunner()\n        let transactionStartedByUs: boolean = false\n        try {\n            // start transaction if it was enabled\n            if (\n                this.expressionMap.useTransaction === true &&\n                queryRunner.isTransactionActive === false\n            ) {\n                await queryRunner.startTransaction()\n                transactionStartedByUs = true\n            }\n\n            const releaseFn = () => {\n                if (queryRunner !== this.queryRunner)\n                    // means we created our own query runner\n                    return queryRunner.release()\n                return\n            }\n            const results = queryRunner.stream(\n                sql,\n                parameters,\n                releaseFn,\n                releaseFn,\n            )\n\n            // close transaction if we started it\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction()\n            }\n\n            return results\n        } catch (error) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction()\n                } catch (rollbackError) {}\n            }\n            throw error\n        }\n    }\n\n    /**\n     * Enables or disables query result caching.\n     */\n    cache(enabled: boolean): this\n\n    /**\n     * Enables query result caching and sets in milliseconds in which cache will expire.\n     * If not set then global caching time will be used.\n     */\n    cache(milliseconds: number): this\n\n    /**\n     * Enables query result caching and sets cache id and milliseconds in which cache will expire.\n     */\n    cache(id: any, milliseconds?: number): this\n\n    /**\n     * Enables or disables query result caching.\n     */\n    cache(\n        enabledOrMillisecondsOrId: boolean | number | string,\n        maybeMilliseconds?: number,\n    ): this {\n        if (typeof enabledOrMillisecondsOrId === \"boolean\") {\n            this.expressionMap.cache = enabledOrMillisecondsOrId\n        } else if (typeof enabledOrMillisecondsOrId === \"number\") {\n            this.expressionMap.cache = true\n            this.expressionMap.cacheDuration = enabledOrMillisecondsOrId\n        } else if (\n            typeof enabledOrMillisecondsOrId === \"string\" ||\n            typeof enabledOrMillisecondsOrId === \"number\"\n        ) {\n            this.expressionMap.cache = true\n            this.expressionMap.cacheId = enabledOrMillisecondsOrId\n        }\n\n        if (maybeMilliseconds) {\n            this.expressionMap.cacheDuration = maybeMilliseconds\n        }\n\n        return this\n    }\n\n    /**\n     * Sets extra options that can be used to configure how query builder works.\n     */\n    setOption(option: SelectQueryBuilderOption): this {\n        this.expressionMap.options.push(option)\n        return this\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    protected join(\n        direction: \"INNER\" | \"LEFT\",\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        aliasName: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n        mapToProperty?: string,\n        isMappingMany?: boolean,\n    ): void {\n        this.setParameters(parameters || {})\n\n        const joinAttribute = new JoinAttribute(\n            this.connection,\n            this.expressionMap,\n        )\n        joinAttribute.direction = direction\n        joinAttribute.mapToProperty = mapToProperty\n        joinAttribute.isMappingMany = isMappingMany\n        joinAttribute.entityOrProperty = entityOrProperty // relationName\n        joinAttribute.condition = condition ? condition : undefined // joinInverseSideCondition\n        // joinAttribute.junctionAlias = joinAttribute.relation.isOwning ? parentAlias + \"_\" + destinationTableAlias : destinationTableAlias + \"_\" + parentAlias;\n        this.expressionMap.joinAttributes.push(joinAttribute)\n\n        if (joinAttribute.metadata) {\n            if (\n                joinAttribute.metadata.deleteDateColumn &&\n                !this.expressionMap.withDeleted\n            ) {\n                const conditionDeleteColumn = `${aliasName}.${joinAttribute.metadata.deleteDateColumn.propertyName} IS NULL`\n                joinAttribute.condition = joinAttribute.condition\n                    ? ` ${joinAttribute.condition} AND ${conditionDeleteColumn}`\n                    : `${conditionDeleteColumn}`\n            }\n            // todo: find and set metadata right there?\n            joinAttribute.alias = this.expressionMap.createAlias({\n                type: \"join\",\n                name: aliasName,\n                metadata: joinAttribute.metadata,\n            })\n            if (\n                joinAttribute.relation &&\n                joinAttribute.relation.junctionEntityMetadata\n            ) {\n                this.expressionMap.createAlias({\n                    type: \"join\",\n                    name: joinAttribute.junctionAlias,\n                    metadata: joinAttribute.relation.junctionEntityMetadata,\n                })\n            }\n        } else {\n            let subQuery: string = \"\"\n            if (typeof entityOrProperty === \"function\") {\n                const subQueryBuilder: SelectQueryBuilder<any> = (\n                    entityOrProperty as any\n                )((this as any as SelectQueryBuilder<any>).subQuery())\n                this.setParameters(subQueryBuilder.getParameters())\n                subQuery = subQueryBuilder.getQuery()\n            } else {\n                subQuery = entityOrProperty\n            }\n            const isSubQuery =\n                typeof entityOrProperty === \"function\" ||\n                (entityOrProperty.substr(0, 1) === \"(\" &&\n                    entityOrProperty.substr(-1) === \")\")\n            joinAttribute.alias = this.expressionMap.createAlias({\n                type: \"join\",\n                name: aliasName,\n                tablePath:\n                    isSubQuery === false\n                        ? (entityOrProperty as string)\n                        : undefined,\n                subQuery: isSubQuery === true ? subQuery : undefined,\n            })\n        }\n    }\n\n    /**\n     * Creates \"SELECT FROM\" part of SQL query.\n     */\n    protected createSelectExpression() {\n        if (!this.expressionMap.mainAlias)\n            throw new TypeORMError(\n                \"Cannot build query because main alias is not set (call qb#from method)\",\n            )\n\n        // todo throw exception if selects or from is missing\n\n        const allSelects: SelectQuery[] = []\n        const excludedSelects: SelectQuery[] = []\n\n        if (this.expressionMap.mainAlias.hasMetadata) {\n            const metadata = this.expressionMap.mainAlias.metadata\n            allSelects.push(\n                ...this.buildEscapedEntityColumnSelects(\n                    this.expressionMap.mainAlias.name,\n                    metadata,\n                ),\n            )\n            excludedSelects.push(\n                ...this.findEntityColumnSelects(\n                    this.expressionMap.mainAlias.name,\n                    metadata,\n                ),\n            )\n        }\n\n        // add selects from joins\n        this.expressionMap.joinAttributes.forEach((join) => {\n            if (join.metadata) {\n                allSelects.push(\n                    ...this.buildEscapedEntityColumnSelects(\n                        join.alias.name!,\n                        join.metadata,\n                    ),\n                )\n                excludedSelects.push(\n                    ...this.findEntityColumnSelects(\n                        join.alias.name!,\n                        join.metadata,\n                    ),\n                )\n            } else {\n                const hasMainAlias = this.expressionMap.selects.some(\n                    (select) => select.selection === join.alias.name,\n                )\n                if (hasMainAlias) {\n                    allSelects.push({\n                        selection: this.escape(join.alias.name!) + \".*\",\n                    })\n                    const excludedSelect = this.expressionMap.selects.find(\n                        (select) => select.selection === join.alias.name,\n                    )\n                    excludedSelects.push(excludedSelect!)\n                }\n            }\n        })\n\n        // add all other selects\n        this.expressionMap.selects\n            .filter((select) => excludedSelects.indexOf(select) === -1)\n            .forEach((select) =>\n                allSelects.push({\n                    selection: this.replacePropertyNames(select.selection),\n                    aliasName: select.aliasName,\n                }),\n            )\n\n        // if still selection is empty, then simply set it to all (*)\n        if (allSelects.length === 0) allSelects.push({ selection: \"*\" })\n\n        // Use certain index\n        let useIndex: string = \"\"\n        if (this.expressionMap.useIndex) {\n            if (DriverUtils.isMySQLFamily(this.connection.driver)) {\n                useIndex = ` USE INDEX (${this.expressionMap.useIndex})`\n            }\n        }\n\n        // create a selection query\n        const froms = this.expressionMap.aliases\n            .filter(\n                (alias) =>\n                    alias.type === \"from\" &&\n                    (alias.tablePath || alias.subQuery),\n            )\n            .map((alias) => {\n                if (alias.subQuery)\n                    return alias.subQuery + \" \" + this.escape(alias.name)\n\n                return (\n                    this.getTableName(alias.tablePath!) +\n                    \" \" +\n                    this.escape(alias.name)\n                )\n            })\n\n        const select = this.createSelectDistinctExpression()\n        const selection = allSelects\n            .map(\n                (select) =>\n                    select.selection +\n                    (select.aliasName\n                        ? \" AS \" + this.escape(select.aliasName)\n                        : \"\"),\n            )\n            .join(\", \")\n\n        return (\n            select +\n            selection +\n            \" FROM \" +\n            froms.join(\", \") +\n            this.createTableLockExpression() +\n            useIndex\n        )\n    }\n\n    /**\n     * Creates select | select distinct part of SQL query.\n     */\n    protected createSelectDistinctExpression(): string {\n        const { selectDistinct, selectDistinctOn, maxExecutionTime } =\n            this.expressionMap\n        const { driver } = this.connection\n\n        let select = \"SELECT \"\n\n        if (maxExecutionTime > 0) {\n            if (DriverUtils.isMySQLFamily(driver)) {\n                select += `/*+ MAX_EXECUTION_TIME(${this.expressionMap.maxExecutionTime}) */ `\n            }\n        }\n\n        if (\n            DriverUtils.isPostgresFamily(driver) &&\n            selectDistinctOn.length > 0\n        ) {\n            const selectDistinctOnMap = selectDistinctOn\n                .map((on) => this.replacePropertyNames(on))\n                .join(\", \")\n\n            select = `SELECT DISTINCT ON (${selectDistinctOnMap}) `\n        } else if (selectDistinct) {\n            select = \"SELECT DISTINCT \"\n        }\n\n        return select\n    }\n\n    /**\n     * Creates \"JOIN\" part of SQL query.\n     */\n    protected createJoinExpression(): string {\n        // examples:\n        // select from owning side\n        // qb.select(\"post\")\n        //     .leftJoinAndSelect(\"post.category\", \"category\");\n        // select from non-owning side\n        // qb.select(\"category\")\n        //     .leftJoinAndSelect(\"category.post\", \"post\");\n\n        const joins = this.expressionMap.joinAttributes.map((joinAttr) => {\n            const relation = joinAttr.relation\n            const destinationTableName = joinAttr.tablePath\n            const destinationTableAlias = joinAttr.alias.name\n            let appendedCondition = joinAttr.condition\n                ? \" AND (\" + joinAttr.condition + \")\"\n                : \"\"\n            const parentAlias = joinAttr.parentAlias\n\n            // if join was build without relation (e.g. without \"post.category\") then it means that we have direct\n            // table to join, without junction table involved. This means we simply join direct table.\n            if (!parentAlias || !relation) {\n                const destinationJoin = joinAttr.alias.subQuery\n                    ? joinAttr.alias.subQuery\n                    : this.getTableName(destinationTableName)\n                return (\n                    \" \" +\n                    joinAttr.direction +\n                    \" JOIN \" +\n                    destinationJoin +\n                    \" \" +\n                    this.escape(destinationTableAlias) +\n                    this.createTableLockExpression() +\n                    (joinAttr.condition\n                        ? \" ON \" + this.replacePropertyNames(joinAttr.condition)\n                        : \"\")\n                )\n            }\n\n            // if real entity relation is involved\n            if (relation.isManyToOne || relation.isOneToOneOwner) {\n                // JOIN `category` `category` ON `category`.`id` = `post`.`categoryId`\n                const condition = relation.joinColumns\n                    .map((joinColumn) => {\n                        return (\n                            destinationTableAlias +\n                            \".\" +\n                            joinColumn.referencedColumn!.propertyPath +\n                            \"=\" +\n                            parentAlias +\n                            \".\" +\n                            relation.propertyPath +\n                            \".\" +\n                            joinColumn.referencedColumn!.propertyPath\n                        )\n                    })\n                    .join(\" AND \")\n\n                return (\n                    \" \" +\n                    joinAttr.direction +\n                    \" JOIN \" +\n                    this.getTableName(destinationTableName) +\n                    \" \" +\n                    this.escape(destinationTableAlias) +\n                    this.createTableLockExpression() +\n                    \" ON \" +\n                    this.replacePropertyNames(condition + appendedCondition)\n                )\n            } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n                // JOIN `post` `post` ON `post`.`categoryId` = `category`.`id`\n                const condition = relation\n                    .inverseRelation!.joinColumns.map((joinColumn) => {\n                        if (\n                            relation.inverseEntityMetadata.tableType ===\n                                \"entity-child\" &&\n                            relation.inverseEntityMetadata.discriminatorColumn\n                        ) {\n                            appendedCondition +=\n                                \" AND \" +\n                                destinationTableAlias +\n                                \".\" +\n                                relation.inverseEntityMetadata\n                                    .discriminatorColumn.databaseName +\n                                \"='\" +\n                                relation.inverseEntityMetadata\n                                    .discriminatorValue +\n                                \"'\"\n                        }\n\n                        return (\n                            destinationTableAlias +\n                            \".\" +\n                            relation.inverseRelation!.propertyPath +\n                            \".\" +\n                            joinColumn.referencedColumn!.propertyPath +\n                            \"=\" +\n                            parentAlias +\n                            \".\" +\n                            joinColumn.referencedColumn!.propertyPath\n                        )\n                    })\n                    .join(\" AND \")\n\n                return (\n                    \" \" +\n                    joinAttr.direction +\n                    \" JOIN \" +\n                    this.getTableName(destinationTableName) +\n                    \" \" +\n                    this.escape(destinationTableAlias) +\n                    this.createTableLockExpression() +\n                    \" ON \" +\n                    this.replacePropertyNames(condition + appendedCondition)\n                )\n            } else {\n                // means many-to-many\n                const junctionTableName =\n                    relation.junctionEntityMetadata!.tablePath\n\n                const junctionAlias = joinAttr.junctionAlias\n                let junctionCondition = \"\",\n                    destinationCondition = \"\"\n\n                if (relation.isOwning) {\n                    junctionCondition = relation.joinColumns\n                        .map((joinColumn) => {\n                            // `post_category`.`postId` = `post`.`id`\n                            return (\n                                junctionAlias +\n                                \".\" +\n                                joinColumn.propertyPath +\n                                \"=\" +\n                                parentAlias +\n                                \".\" +\n                                joinColumn.referencedColumn!.propertyPath\n                            )\n                        })\n                        .join(\" AND \")\n\n                    destinationCondition = relation.inverseJoinColumns\n                        .map((joinColumn) => {\n                            // `category`.`id` = `post_category`.`categoryId`\n                            return (\n                                destinationTableAlias +\n                                \".\" +\n                                joinColumn.referencedColumn!.propertyPath +\n                                \"=\" +\n                                junctionAlias +\n                                \".\" +\n                                joinColumn.propertyPath\n                            )\n                        })\n                        .join(\" AND \")\n                } else {\n                    junctionCondition = relation\n                        .inverseRelation!.inverseJoinColumns.map(\n                            (joinColumn) => {\n                                // `post_category`.`categoryId` = `category`.`id`\n                                return (\n                                    junctionAlias +\n                                    \".\" +\n                                    joinColumn.propertyPath +\n                                    \"=\" +\n                                    parentAlias +\n                                    \".\" +\n                                    joinColumn.referencedColumn!.propertyPath\n                                )\n                            },\n                        )\n                        .join(\" AND \")\n\n                    destinationCondition = relation\n                        .inverseRelation!.joinColumns.map((joinColumn) => {\n                            // `post`.`id` = `post_category`.`postId`\n                            return (\n                                destinationTableAlias +\n                                \".\" +\n                                joinColumn.referencedColumn!.propertyPath +\n                                \"=\" +\n                                junctionAlias +\n                                \".\" +\n                                joinColumn.propertyPath\n                            )\n                        })\n                        .join(\" AND \")\n                }\n\n                return (\n                    \" \" +\n                    joinAttr.direction +\n                    \" JOIN \" +\n                    this.getTableName(junctionTableName) +\n                    \" \" +\n                    this.escape(junctionAlias) +\n                    this.createTableLockExpression() +\n                    \" ON \" +\n                    this.replacePropertyNames(junctionCondition) +\n                    \" \" +\n                    joinAttr.direction +\n                    \" JOIN \" +\n                    this.getTableName(destinationTableName) +\n                    \" \" +\n                    this.escape(destinationTableAlias) +\n                    this.createTableLockExpression() +\n                    \" ON \" +\n                    this.replacePropertyNames(\n                        destinationCondition + appendedCondition,\n                    )\n                )\n            }\n        })\n\n        return joins.join(\" \")\n    }\n\n    /**\n     * Creates \"GROUP BY\" part of SQL query.\n     */\n    protected createGroupByExpression() {\n        if (!this.expressionMap.groupBys || !this.expressionMap.groupBys.length)\n            return \"\"\n        return (\n            \" GROUP BY \" +\n            this.replacePropertyNames(this.expressionMap.groupBys.join(\", \"))\n        )\n    }\n\n    /**\n     * Creates \"ORDER BY\" part of SQL query.\n     */\n    protected createOrderByExpression() {\n        const orderBys = this.expressionMap.allOrderBys\n        if (Object.keys(orderBys).length > 0)\n            return (\n                \" ORDER BY \" +\n                Object.keys(orderBys)\n                    .map((columnName) => {\n                        if (typeof orderBys[columnName] === \"string\") {\n                            return (\n                                this.replacePropertyNames(columnName) +\n                                \" \" +\n                                orderBys[columnName]\n                            )\n                        } else {\n                            return (\n                                this.replacePropertyNames(columnName) +\n                                \" \" +\n                                (orderBys[columnName] as any).order +\n                                \" \" +\n                                (orderBys[columnName] as any).nulls\n                            )\n                        }\n                    })\n                    .join(\", \")\n            )\n\n        return \"\"\n    }\n\n    /**\n     * Creates \"LIMIT\" and \"OFFSET\" parts of SQL query.\n     */\n    protected createLimitOffsetExpression(): string {\n        // in the case if nothing is joined in the query builder we don't need to make two requests to get paginated results\n        // we can use regular limit / offset, that's why we add offset and limit construction here based on skip and take values\n        let offset: number | undefined = this.expressionMap.offset,\n            limit: number | undefined = this.expressionMap.limit\n        if (\n            !offset &&\n            !limit &&\n            this.expressionMap.joinAttributes.length === 0\n        ) {\n            offset = this.expressionMap.skip\n            limit = this.expressionMap.take\n        }\n\n        if (this.connection.driver.options.type === \"mssql\") {\n            // Due to a limitation in SQL Server's parser implementation it does not support using\n            // OFFSET or FETCH NEXT without an ORDER BY clause being provided. In cases where the\n            // user does not request one we insert a dummy ORDER BY that does nothing and should\n            // have no effect on the query planner or on the order of the results returned.\n            // https://dba.stackexchange.com/a/193799\n            let prefix = \"\"\n            if (\n                (limit || offset) &&\n                Object.keys(this.expressionMap.allOrderBys).length <= 0\n            ) {\n                prefix = \" ORDER BY (SELECT NULL)\"\n            }\n\n            if (limit && offset)\n                return (\n                    prefix +\n                    \" OFFSET \" +\n                    offset +\n                    \" ROWS FETCH NEXT \" +\n                    limit +\n                    \" ROWS ONLY\"\n                )\n            if (limit)\n                return (\n                    prefix + \" OFFSET 0 ROWS FETCH NEXT \" + limit + \" ROWS ONLY\"\n                )\n            if (offset) return prefix + \" OFFSET \" + offset + \" ROWS\"\n        } else if (\n            DriverUtils.isMySQLFamily(this.connection.driver) ||\n            this.connection.driver.options.type === \"aurora-mysql\" ||\n            this.connection.driver.options.type === \"sap\" ||\n            this.connection.driver.options.type === \"spanner\"\n        ) {\n            if (limit && offset) return \" LIMIT \" + limit + \" OFFSET \" + offset\n            if (limit) return \" LIMIT \" + limit\n            if (offset) throw new OffsetWithoutLimitNotSupportedError()\n        } else if (DriverUtils.isSQLiteFamily(this.connection.driver)) {\n            if (limit && offset) return \" LIMIT \" + limit + \" OFFSET \" + offset\n            if (limit) return \" LIMIT \" + limit\n            if (offset) return \" LIMIT -1 OFFSET \" + offset\n        } else if (this.connection.driver.options.type === \"oracle\") {\n            if (limit && offset)\n                return (\n                    \" OFFSET \" +\n                    offset +\n                    \" ROWS FETCH NEXT \" +\n                    limit +\n                    \" ROWS ONLY\"\n                )\n            if (limit) return \" FETCH NEXT \" + limit + \" ROWS ONLY\"\n            if (offset) return \" OFFSET \" + offset + \" ROWS\"\n        } else {\n            if (limit && offset) return \" LIMIT \" + limit + \" OFFSET \" + offset\n            if (limit) return \" LIMIT \" + limit\n            if (offset) return \" OFFSET \" + offset\n        }\n\n        return \"\"\n    }\n\n    /**\n     * Creates \"LOCK\" part of SELECT Query after table Clause\n     * ex.\n     *  SELECT 1\n     *  FROM USER U WITH (NOLOCK)\n     *  JOIN ORDER O WITH (NOLOCK)\n     *      ON U.ID=O.OrderID\n     */\n    private createTableLockExpression(): string {\n        if (this.connection.driver.options.type === \"mssql\") {\n            switch (this.expressionMap.lockMode) {\n                case \"pessimistic_read\":\n                    return \" WITH (HOLDLOCK, ROWLOCK)\"\n                case \"pessimistic_write\":\n                    return \" WITH (UPDLOCK, ROWLOCK)\"\n                case \"dirty_read\":\n                    return \" WITH (NOLOCK)\"\n            }\n        }\n\n        return \"\"\n    }\n\n    /**\n     * Creates \"LOCK\" part of SQL query.\n     */\n    protected createLockExpression(): string {\n        const driver = this.connection.driver\n\n        let lockTablesClause = \"\"\n\n        if (this.expressionMap.lockTables) {\n            if (\n                !(\n                    DriverUtils.isPostgresFamily(driver) ||\n                    driver.options.type === \"cockroachdb\"\n                )\n            ) {\n                throw new TypeORMError(\n                    \"Lock tables not supported in selected driver\",\n                )\n            }\n            if (this.expressionMap.lockTables.length < 1) {\n                throw new TypeORMError(\"lockTables cannot be an empty array\")\n            }\n            lockTablesClause = \" OF \" + this.expressionMap.lockTables.join(\", \")\n        }\n\n        let onLockExpression = \"\"\n        if (this.expressionMap.onLocked === \"nowait\") {\n            onLockExpression = \" NOWAIT\"\n        } else if (this.expressionMap.onLocked === \"skip_locked\") {\n            onLockExpression = \" SKIP LOCKED\"\n        }\n        switch (this.expressionMap.lockMode) {\n            case \"pessimistic_read\":\n                if (\n                    driver.options.type === \"mysql\" ||\n                    driver.options.type === \"aurora-mysql\"\n                ) {\n                    if (\n                        DriverUtils.isReleaseVersionOrGreater(driver, \"8.0.0\")\n                    ) {\n                        return (\n                            \" FOR SHARE\" + lockTablesClause + onLockExpression\n                        )\n                    } else {\n                        return \" LOCK IN SHARE MODE\"\n                    }\n                } else if (driver.options.type === \"mariadb\") {\n                    return \" LOCK IN SHARE MODE\"\n                } else if (DriverUtils.isPostgresFamily(driver)) {\n                    return \" FOR SHARE\" + lockTablesClause + onLockExpression\n                } else if (driver.options.type === \"oracle\") {\n                    return \" FOR UPDATE\"\n                } else if (driver.options.type === \"mssql\") {\n                    return \"\"\n                } else {\n                    throw new LockNotSupportedOnGivenDriverError()\n                }\n            case \"pessimistic_write\":\n                if (\n                    DriverUtils.isMySQLFamily(driver) ||\n                    driver.options.type === \"aurora-mysql\" ||\n                    driver.options.type === \"oracle\"\n                ) {\n                    return \" FOR UPDATE\" + onLockExpression\n                } else if (\n                    DriverUtils.isPostgresFamily(driver) ||\n                    driver.options.type === \"cockroachdb\"\n                ) {\n                    return \" FOR UPDATE\" + lockTablesClause + onLockExpression\n                } else if (driver.options.type === \"mssql\") {\n                    return \"\"\n                } else {\n                    throw new LockNotSupportedOnGivenDriverError()\n                }\n            case \"pessimistic_partial_write\":\n                if (DriverUtils.isPostgresFamily(driver)) {\n                    return \" FOR UPDATE\" + lockTablesClause + \" SKIP LOCKED\"\n                } else if (DriverUtils.isMySQLFamily(driver)) {\n                    return \" FOR UPDATE SKIP LOCKED\"\n                } else {\n                    throw new LockNotSupportedOnGivenDriverError()\n                }\n            case \"pessimistic_write_or_fail\":\n                if (\n                    DriverUtils.isPostgresFamily(driver) ||\n                    driver.options.type === \"cockroachdb\"\n                ) {\n                    return \" FOR UPDATE\" + lockTablesClause + \" NOWAIT\"\n                } else if (DriverUtils.isMySQLFamily(driver)) {\n                    return \" FOR UPDATE NOWAIT\"\n                } else {\n                    throw new LockNotSupportedOnGivenDriverError()\n                }\n            case \"for_no_key_update\":\n                if (\n                    DriverUtils.isPostgresFamily(driver) ||\n                    driver.options.type === \"cockroachdb\"\n                ) {\n                    return (\n                        \" FOR NO KEY UPDATE\" +\n                        lockTablesClause +\n                        onLockExpression\n                    )\n                } else {\n                    throw new LockNotSupportedOnGivenDriverError()\n                }\n            case \"for_key_share\":\n                if (DriverUtils.isPostgresFamily(driver)) {\n                    return (\n                        \" FOR KEY SHARE\" + lockTablesClause + onLockExpression\n                    )\n                } else {\n                    throw new LockNotSupportedOnGivenDriverError()\n                }\n            default:\n                return \"\"\n        }\n    }\n\n    /**\n     * Creates \"HAVING\" part of SQL query.\n     */\n    protected createHavingExpression() {\n        if (!this.expressionMap.havings || !this.expressionMap.havings.length)\n            return \"\"\n        const conditions = this.expressionMap.havings\n            .map((having, index) => {\n                switch (having.type) {\n                    case \"and\":\n                        return (\n                            (index > 0 ? \"AND \" : \"\") +\n                            this.replacePropertyNames(having.condition)\n                        )\n                    case \"or\":\n                        return (\n                            (index > 0 ? \"OR \" : \"\") +\n                            this.replacePropertyNames(having.condition)\n                        )\n                    default:\n                        return this.replacePropertyNames(having.condition)\n                }\n            })\n            .join(\" \")\n\n        if (!conditions.length) return \"\"\n        return \" HAVING \" + conditions\n    }\n\n    protected buildEscapedEntityColumnSelects(\n        aliasName: string,\n        metadata: EntityMetadata,\n    ): SelectQuery[] {\n        const hasMainAlias = this.expressionMap.selects.some(\n            (select) => select.selection === aliasName,\n        )\n\n        const columns: ColumnMetadata[] = []\n        if (hasMainAlias) {\n            columns.push(\n                ...metadata.columns.filter(\n                    (column) => column.isSelect === true,\n                ),\n            )\n        }\n        columns.push(\n            ...metadata.columns.filter((column) => {\n                return this.expressionMap.selects.some(\n                    (select) =>\n                        select.selection ===\n                        aliasName + \".\" + column.propertyPath,\n                )\n            }),\n        )\n\n        // if user used partial selection and did not select some primary columns which are required to be selected\n        // we select those primary columns and mark them as \"virtual\". Later virtual column values will be removed from final entity\n        // to make entity contain exactly what user selected\n        if (columns.length === 0)\n            // however not in the case when nothing (even partial) was selected from this target (for example joins without selection)\n            return []\n\n        const nonSelectedPrimaryColumns = this.expressionMap.queryEntity\n            ? metadata.primaryColumns.filter(\n                  (primaryColumn) => columns.indexOf(primaryColumn) === -1,\n              )\n            : []\n        const allColumns = [...columns, ...nonSelectedPrimaryColumns]\n\n        const finalSelects: SelectQuery[] = []\n        allColumns.forEach((column) => {\n            let selectionPath =\n                this.escape(aliasName) + \".\" + this.escape(column.databaseName)\n            if (\n                this.connection.driver.spatialTypes.indexOf(column.type) !== -1\n            ) {\n                if (\n                    DriverUtils.isMySQLFamily(this.connection.driver) ||\n                    this.connection.driver.options.type === \"aurora-mysql\"\n                ) {\n                    const useLegacy = (\n                        this.connection.driver as\n                            | MysqlDriver\n                            | AuroraMysqlDriver\n                    ).options.legacySpatialSupport\n                    const asText = useLegacy ? \"AsText\" : \"ST_AsText\"\n                    selectionPath = `${asText}(${selectionPath})`\n                }\n\n                if (DriverUtils.isPostgresFamily(this.connection.driver))\n                    if (column.precision) {\n                        // cast to JSON to trigger parsing in the driver\n                        selectionPath = `ST_AsGeoJSON(${selectionPath}, ${column.precision})::json`\n                    } else {\n                        selectionPath = `ST_AsGeoJSON(${selectionPath})::json`\n                    }\n                if (this.connection.driver.options.type === \"mssql\")\n                    selectionPath = `${selectionPath}.ToString()`\n            }\n\n            const selections = this.expressionMap.selects.filter(\n                (select) =>\n                    select.selection === aliasName + \".\" + column.propertyPath,\n            )\n            if (selections.length) {\n                selections.forEach((selection) => {\n                    finalSelects.push({\n                        selection: selectionPath,\n                        aliasName: selection.aliasName\n                            ? selection.aliasName\n                            : DriverUtils.buildAlias(\n                                  this.connection.driver,\n                                  aliasName,\n                                  column.databaseName,\n                              ),\n                        // todo: need to keep in mind that custom selection.aliasName breaks hydrator. fix it later!\n                        virtual: selection.virtual,\n                    })\n                })\n            } else {\n                finalSelects.push({\n                    selection: selectionPath,\n                    aliasName: DriverUtils.buildAlias(\n                        this.connection.driver,\n                        aliasName,\n                        column.databaseName,\n                    ),\n                    // todo: need to keep in mind that custom selection.aliasName breaks hydrator. fix it later!\n                    virtual: hasMainAlias,\n                })\n            }\n        })\n        return finalSelects\n    }\n\n    protected findEntityColumnSelects(\n        aliasName: string,\n        metadata: EntityMetadata,\n    ): SelectQuery[] {\n        const mainSelect = this.expressionMap.selects.find(\n            (select) => select.selection === aliasName,\n        )\n        if (mainSelect) return [mainSelect]\n\n        return this.expressionMap.selects.filter((select) => {\n            return metadata.columns.some(\n                (column) =>\n                    select.selection === aliasName + \".\" + column.propertyPath,\n            )\n        })\n    }\n\n    private computeCountExpression() {\n        const mainAlias = this.expressionMap.mainAlias!.name // todo: will this work with \"fromTableName\"?\n        const metadata = this.expressionMap.mainAlias!.metadata\n\n        const primaryColumns = metadata.primaryColumns\n        const distinctAlias = this.escape(mainAlias)\n\n        // If we aren't doing anything that will create a join, we can use a simpler `COUNT` instead\n        // so we prevent poor query patterns in the most likely cases\n        if (\n            this.expressionMap.joinAttributes.length === 0 &&\n            this.expressionMap.relationIdAttributes.length === 0 &&\n            this.expressionMap.relationCountAttributes.length === 0\n        ) {\n            return \"COUNT(1)\"\n        }\n\n        // For everything else, we'll need to do some hackery to get the correct count values.\n\n        if (\n            this.connection.driver.options.type === \"cockroachdb\" ||\n            DriverUtils.isPostgresFamily(this.connection.driver)\n        ) {\n            // Postgres and CockroachDB can pass multiple parameters to the `DISTINCT` function\n            // https://www.postgresql.org/docs/9.5/sql-select.html#SQL-DISTINCT\n            return (\n                \"COUNT(DISTINCT(\" +\n                primaryColumns\n                    .map(\n                        (c) =>\n                            `${distinctAlias}.${this.escape(c.databaseName)}`,\n                    )\n                    .join(\", \") +\n                \"))\"\n            )\n        }\n\n        if (DriverUtils.isMySQLFamily(this.connection.driver)) {\n            // MySQL & MariaDB can pass multiple parameters to the `DISTINCT` language construct\n            // https://mariadb.com/kb/en/count-distinct/\n            return (\n                \"COUNT(DISTINCT \" +\n                primaryColumns\n                    .map(\n                        (c) =>\n                            `${distinctAlias}.${this.escape(c.databaseName)}`,\n                    )\n                    .join(\", \") +\n                \")\"\n            )\n        }\n\n        if (this.connection.driver.options.type === \"mssql\") {\n            // SQL Server has gotta be different from everyone else.  They don't support\n            // distinct counting multiple columns & they don't have the same operator\n            // characteristic for concatenating, so we gotta use the `CONCAT` function.\n            // However, If it's exactly 1 column we can omit the `CONCAT` for better performance.\n\n            const columnsExpression = primaryColumns\n                .map(\n                    (primaryColumn) =>\n                        `${distinctAlias}.${this.escape(\n                            primaryColumn.databaseName,\n                        )}`,\n                )\n                .join(\", '|;|', \")\n\n            if (primaryColumns.length === 1) {\n                return `COUNT(DISTINCT(${columnsExpression}))`\n            }\n\n            return `COUNT(DISTINCT(CONCAT(${columnsExpression})))`\n        }\n\n        if (this.connection.driver.options.type === \"spanner\") {\n            // spanner also has gotta be different from everyone else.\n            // they do not support concatenation of different column types without casting them to string\n\n            if (primaryColumns.length === 1) {\n                return `COUNT(DISTINCT(${distinctAlias}.${this.escape(\n                    primaryColumns[0].databaseName,\n                )}))`\n            }\n\n            const columnsExpression = primaryColumns\n                .map(\n                    (primaryColumn) =>\n                        `CAST(${distinctAlias}.${this.escape(\n                            primaryColumn.databaseName,\n                        )} AS STRING)`,\n                )\n                .join(\", '|;|', \")\n            return `COUNT(DISTINCT(CONCAT(${columnsExpression})))`\n        }\n\n        // If all else fails, fall back to a `COUNT` and `DISTINCT` across all the primary columns concatenated.\n        // Per the SQL spec, this is the canonical string concatenation mechanism which is most\n        // likely to work across servers implementing the SQL standard.\n\n        // Please note, if there is only one primary column that the concatenation does not occur in this\n        // query and the query is a standard `COUNT DISTINCT` in that case.\n\n        return (\n            `COUNT(DISTINCT(` +\n            primaryColumns\n                .map((c) => `${distinctAlias}.${this.escape(c.databaseName)}`)\n                .join(\" || '|;|' || \") +\n            \"))\"\n        )\n    }\n\n    protected async executeCountQuery(\n        queryRunner: QueryRunner,\n    ): Promise<number> {\n        const countSql = this.computeCountExpression()\n\n        const results = await this.clone()\n            .orderBy()\n            .groupBy()\n            .offset(undefined)\n            .limit(undefined)\n            .skip(undefined)\n            .take(undefined)\n            .select(countSql, \"cnt\")\n            .setOption(\"disable-global-order\")\n            .loadRawResults(queryRunner)\n\n        if (!results || !results[0] || !results[0][\"cnt\"]) return 0\n\n        return parseInt(results[0][\"cnt\"])\n    }\n\n    protected applyFindOptions() {\n        // todo: convert relations: string[] to object map to simplify code\n        // todo: same with selects\n\n        if (this.expressionMap.mainAlias!.metadata) {\n            if (this.findOptions.relationLoadStrategy) {\n                this.expressionMap.relationLoadStrategy =\n                    this.findOptions.relationLoadStrategy\n            }\n\n            if (this.findOptions.comment) {\n                this.comment(this.findOptions.comment)\n            }\n\n            if (this.findOptions.withDeleted) {\n                this.withDeleted()\n            }\n\n            if (this.findOptions.select) {\n                const select = Array.isArray(this.findOptions.select)\n                    ? OrmUtils.propertyPathsToTruthyObject(\n                          this.findOptions.select as string[],\n                      )\n                    : this.findOptions.select\n\n                this.buildSelect(\n                    select,\n                    this.expressionMap.mainAlias!.metadata,\n                    this.expressionMap.mainAlias!.name,\n                )\n            }\n\n            if (this.selects.length) {\n                this.select(this.selects)\n            }\n\n            this.selects = []\n            if (this.findOptions.relations) {\n                const relations = Array.isArray(this.findOptions.relations)\n                    ? OrmUtils.propertyPathsToTruthyObject(\n                          this.findOptions.relations,\n                      )\n                    : this.findOptions.relations\n\n                this.buildRelations(\n                    relations,\n                    typeof this.findOptions.select === \"object\"\n                        ? (this.findOptions.select as FindOptionsSelect<any>)\n                        : undefined,\n                    this.expressionMap.mainAlias!.metadata,\n                    this.expressionMap.mainAlias!.name,\n                )\n                if (\n                    this.findOptions.loadEagerRelations !== false &&\n                    this.expressionMap.relationLoadStrategy === \"join\"\n                ) {\n                    this.buildEagerRelations(\n                        relations,\n                        typeof this.findOptions.select === \"object\"\n                            ? (this.findOptions\n                                  .select as FindOptionsSelect<any>)\n                            : undefined,\n                        this.expressionMap.mainAlias!.metadata,\n                        this.expressionMap.mainAlias!.name,\n                    )\n                }\n            }\n            if (this.selects.length) {\n                this.addSelect(this.selects)\n            }\n\n            if (this.findOptions.where) {\n                this.conditions = this.buildWhere(\n                    this.findOptions.where,\n                    this.expressionMap.mainAlias!.metadata,\n                    this.expressionMap.mainAlias!.name,\n                )\n\n                if (this.conditions.length)\n                    this.andWhere(\n                        this.conditions.substr(0, 1) !== \"(\"\n                            ? \"(\" + this.conditions + \")\"\n                            : this.conditions,\n                    ) // temporary and where and braces\n            }\n\n            if (this.findOptions.order) {\n                this.buildOrder(\n                    this.findOptions.order,\n                    this.expressionMap.mainAlias!.metadata,\n                    this.expressionMap.mainAlias!.name,\n                )\n            }\n\n            // apply joins\n            if (this.joins.length) {\n                this.joins.forEach((join) => {\n                    if (join.select && !join.selection) {\n                        // if (join.selection) {\n                        //\n                        // } else {\n                        if (join.type === \"inner\") {\n                            this.innerJoinAndSelect(\n                                `${join.parentAlias}.${join.relationMetadata.propertyPath}`,\n                                join.alias,\n                            )\n                        } else {\n                            this.leftJoinAndSelect(\n                                `${join.parentAlias}.${join.relationMetadata.propertyPath}`,\n                                join.alias,\n                            )\n                        }\n                        // }\n                    } else {\n                        if (join.type === \"inner\") {\n                            this.innerJoin(\n                                `${join.parentAlias}.${join.relationMetadata.propertyPath}`,\n                                join.alias,\n                            )\n                        } else {\n                            this.leftJoin(\n                                `${join.parentAlias}.${join.relationMetadata.propertyPath}`,\n                                join.alias,\n                            )\n                        }\n                    }\n\n                    // if (join.select) {\n                    //     if (this.findOptions.loadEagerRelations !== false) {\n                    //         FindOptionsUtils.joinEagerRelations(\n                    //             this,\n                    //             join.alias,\n                    //             join.relationMetadata.inverseEntityMetadata\n                    //         );\n                    //     }\n                    // }\n                })\n            }\n\n            // if (this.conditions.length) {\n            //     this.where(this.conditions.join(\" AND \"));\n            // }\n\n            // apply offset\n            if (this.findOptions.skip !== undefined) {\n                // if (this.findOptions.options && this.findOptions.options.pagination === false) {\n                //     this.offset(this.findOptions.skip);\n                // } else {\n                this.skip(this.findOptions.skip)\n                // }\n            }\n\n            // apply limit\n            if (this.findOptions.take !== undefined) {\n                // if (this.findOptions.options && this.findOptions.options.pagination === false) {\n                //     this.limit(this.findOptions.take);\n                // } else {\n                this.take(this.findOptions.take)\n                // }\n            }\n\n            // apply caching options\n            if (typeof this.findOptions.cache === \"number\") {\n                this.cache(this.findOptions.cache)\n            } else if (typeof this.findOptions.cache === \"boolean\") {\n                this.cache(this.findOptions.cache)\n            } else if (typeof this.findOptions.cache === \"object\") {\n                this.cache(\n                    this.findOptions.cache.id,\n                    this.findOptions.cache.milliseconds,\n                )\n            }\n\n            if (this.findOptions.join) {\n                if (this.findOptions.join.leftJoin)\n                    Object.keys(this.findOptions.join.leftJoin).forEach(\n                        (key) => {\n                            this.leftJoin(\n                                this.findOptions.join!.leftJoin![key],\n                                key,\n                            )\n                        },\n                    )\n\n                if (this.findOptions.join.innerJoin)\n                    Object.keys(this.findOptions.join.innerJoin).forEach(\n                        (key) => {\n                            this.innerJoin(\n                                this.findOptions.join!.innerJoin![key],\n                                key,\n                            )\n                        },\n                    )\n\n                if (this.findOptions.join.leftJoinAndSelect)\n                    Object.keys(\n                        this.findOptions.join.leftJoinAndSelect,\n                    ).forEach((key) => {\n                        this.leftJoinAndSelect(\n                            this.findOptions.join!.leftJoinAndSelect![key],\n                            key,\n                        )\n                    })\n\n                if (this.findOptions.join.innerJoinAndSelect)\n                    Object.keys(\n                        this.findOptions.join.innerJoinAndSelect,\n                    ).forEach((key) => {\n                        this.innerJoinAndSelect(\n                            this.findOptions.join!.innerJoinAndSelect![key],\n                            key,\n                        )\n                    })\n            }\n\n            if (this.findOptions.lock) {\n                if (this.findOptions.lock.mode === \"optimistic\") {\n                    this.setLock(\n                        this.findOptions.lock.mode,\n                        this.findOptions.lock.version,\n                    )\n                } else if (\n                    this.findOptions.lock.mode === \"pessimistic_read\" ||\n                    this.findOptions.lock.mode === \"pessimistic_write\" ||\n                    this.findOptions.lock.mode === \"dirty_read\" ||\n                    this.findOptions.lock.mode ===\n                        \"pessimistic_partial_write\" ||\n                    this.findOptions.lock.mode ===\n                        \"pessimistic_write_or_fail\" ||\n                    this.findOptions.lock.mode === \"for_no_key_update\" ||\n                    this.findOptions.lock.mode === \"for_key_share\"\n                ) {\n                    const tableNames = this.findOptions.lock.tables\n                        ? this.findOptions.lock.tables.map((table) => {\n                              const tableAlias =\n                                  this.expressionMap.aliases.find((alias) => {\n                                      return (\n                                          alias.metadata\n                                              .tableNameWithoutPrefix === table\n                                      )\n                                  })\n                              if (!tableAlias) {\n                                  throw new TypeORMError(\n                                      `\"${table}\" is not part of this query`,\n                                  )\n                              }\n                              return this.escape(tableAlias.name)\n                          })\n                        : undefined\n                    this.setLock(\n                        this.findOptions.lock.mode,\n                        undefined,\n                        tableNames,\n                    )\n\n                    if (this.findOptions.lock.onLocked) {\n                        this.setOnLocked(this.findOptions.lock.onLocked)\n                    }\n                }\n            }\n\n            if (this.findOptions.loadRelationIds === true) {\n                this.loadAllRelationIds()\n            } else if (typeof this.findOptions.loadRelationIds === \"object\") {\n                this.loadAllRelationIds(this.findOptions.loadRelationIds as any)\n            }\n\n            if (this.findOptions.loadEagerRelations !== false) {\n                FindOptionsUtils.joinEagerRelations(\n                    this,\n                    this.expressionMap.mainAlias!.name,\n                    this.expressionMap.mainAlias!.metadata,\n                )\n            }\n\n            if (this.findOptions.transaction === true) {\n                this.expressionMap.useTransaction = true\n            }\n\n            // if (this.orderBys.length) {\n            //     this.orderBys.forEach(orderBy => {\n            //         this.addOrderBy(orderBy.alias, orderBy.direction, orderBy.nulls);\n            //     });\n            // }\n\n            // todo\n            // if (this.options.options && this.options.options.eagerRelations) {\n            //     this.queryBuilder\n            // }\n\n            // todo\n            // if (this.findOptions.options && this.findOptions.listeners === false) {\n            //     this.callListeners(false);\n            // }\n        }\n    }\n\n    /**\n     * Executes sql generated by query builder and returns object with raw results and entities created from them.\n     */\n    protected async executeEntitiesAndRawResults(\n        queryRunner: QueryRunner,\n    ): Promise<{ entities: Entity[]; raw: any[] }> {\n        if (!this.expressionMap.mainAlias)\n            throw new TypeORMError(\n                `Alias is not set. Use \"from\" method to set an alias.`,\n            )\n\n        if (\n            (this.expressionMap.lockMode === \"pessimistic_read\" ||\n                this.expressionMap.lockMode === \"pessimistic_write\" ||\n                this.expressionMap.lockMode === \"pessimistic_partial_write\" ||\n                this.expressionMap.lockMode === \"pessimistic_write_or_fail\" ||\n                this.expressionMap.lockMode === \"for_no_key_update\" ||\n                this.expressionMap.lockMode === \"for_key_share\") &&\n            !queryRunner.isTransactionActive\n        )\n            throw new PessimisticLockTransactionRequiredError()\n\n        if (this.expressionMap.lockMode === \"optimistic\") {\n            const metadata = this.expressionMap.mainAlias.metadata\n            if (!metadata.versionColumn && !metadata.updateDateColumn)\n                throw new NoVersionOrUpdateDateColumnError(metadata.name)\n        }\n\n        const relationIdLoader = new RelationIdLoader(\n            this.connection,\n            queryRunner,\n            this.expressionMap.relationIdAttributes,\n        )\n        const relationCountLoader = new RelationCountLoader(\n            this.connection,\n            queryRunner,\n            this.expressionMap.relationCountAttributes,\n        )\n        const relationIdMetadataTransformer =\n            new RelationIdMetadataToAttributeTransformer(this.expressionMap)\n        relationIdMetadataTransformer.transform()\n        const relationCountMetadataTransformer =\n            new RelationCountMetadataToAttributeTransformer(this.expressionMap)\n        relationCountMetadataTransformer.transform()\n\n        let rawResults: any[] = [],\n            entities: any[] = []\n\n        // for pagination enabled (e.g. skip and take) its much more complicated - its a special process\n        // where we make two queries to find the data we need\n        // first query find ids in skip and take range\n        // and second query loads the actual data in given ids range\n        if (\n            (this.expressionMap.skip || this.expressionMap.take) &&\n            this.expressionMap.joinAttributes.length > 0\n        ) {\n            // we are skipping order by here because its not working in subqueries anyway\n            // to make order by working we need to apply it on a distinct query\n            const [selects, orderBys] =\n                this.createOrderByCombinedWithSelectExpression(\"distinctAlias\")\n            const metadata = this.expressionMap.mainAlias.metadata\n            const mainAliasName = this.expressionMap.mainAlias.name\n\n            const querySelects = metadata.primaryColumns.map(\n                (primaryColumn) => {\n                    const distinctAlias = this.escape(\"distinctAlias\")\n                    const columnAlias = this.escape(\n                        DriverUtils.buildAlias(\n                            this.connection.driver,\n                            mainAliasName,\n                            primaryColumn.databaseName,\n                        ),\n                    )\n                    if (!orderBys[columnAlias])\n                        // make sure we aren't overriding user-defined order in inverse direction\n                        orderBys[columnAlias] = \"ASC\"\n\n                    const alias = DriverUtils.buildAlias(\n                        this.connection.driver,\n                        \"ids_\" + mainAliasName,\n                        primaryColumn.databaseName,\n                    )\n\n                    return `${distinctAlias}.${columnAlias} AS ${this.escape(\n                        alias,\n                    )}`\n                },\n            )\n\n            rawResults = await new SelectQueryBuilder(\n                this.connection,\n                queryRunner,\n            )\n                .select(`DISTINCT ${querySelects.join(\", \")}`)\n                .addSelect(selects)\n                .from(`(${this.clone().orderBy().getQuery()})`, \"distinctAlias\")\n                .offset(this.expressionMap.skip)\n                .limit(this.expressionMap.take)\n                .orderBy(orderBys)\n                .cache(\n                    this.expressionMap.cache\n                        ? this.expressionMap.cache\n                        : this.expressionMap.cacheId,\n                    this.expressionMap.cacheDuration,\n                )\n                .setParameters(this.getParameters())\n                .setNativeParameters(this.expressionMap.nativeParameters)\n                .getRawMany()\n\n            if (rawResults.length > 0) {\n                let condition = \"\"\n                const parameters: ObjectLiteral = {}\n                if (metadata.hasMultiplePrimaryKeys) {\n                    condition = rawResults\n                        .map((result, index) => {\n                            return metadata.primaryColumns\n                                .map((primaryColumn) => {\n                                    const paramKey = `orm_distinct_ids_${index}_${primaryColumn.databaseName}`\n                                    parameters[paramKey] =\n                                        result[\n                                            `ids_${mainAliasName}_${primaryColumn.databaseName}`\n                                        ]\n                                    return `${mainAliasName}.${primaryColumn.propertyPath}=:${paramKey}`\n                                })\n                                .join(\" AND \")\n                        })\n                        .join(\" OR \")\n                } else {\n                    const alias = DriverUtils.buildAlias(\n                        this.connection.driver,\n                        \"ids_\" + mainAliasName,\n                        metadata.primaryColumns[0].databaseName,\n                    )\n\n                    const ids = rawResults.map((result) => result[alias])\n                    const areAllNumbers = ids.every(\n                        (id: any) => typeof id === \"number\",\n                    )\n                    if (areAllNumbers) {\n                        // fixes #190. if all numbers then its safe to perform query without parameter\n                        condition = `${mainAliasName}.${\n                            metadata.primaryColumns[0].propertyPath\n                        } IN (${ids.join(\", \")})`\n                    } else {\n                        parameters[\"orm_distinct_ids\"] = ids\n                        condition =\n                            mainAliasName +\n                            \".\" +\n                            metadata.primaryColumns[0].propertyPath +\n                            \" IN (:...orm_distinct_ids)\"\n                    }\n                }\n                rawResults = await this.clone()\n                    .mergeExpressionMap({\n                        extraAppendedAndWhereCondition: condition,\n                    })\n                    .setParameters(parameters)\n                    .loadRawResults(queryRunner)\n            }\n        } else {\n            rawResults = await this.loadRawResults(queryRunner)\n        }\n\n        if (rawResults.length > 0) {\n            // transform raw results into entities\n            const rawRelationIdResults = await relationIdLoader.load(rawResults)\n            const rawRelationCountResults = await relationCountLoader.load(\n                rawResults,\n            )\n            const transformer = new RawSqlResultsToEntityTransformer(\n                this.expressionMap,\n                this.connection.driver,\n                rawRelationIdResults,\n                rawRelationCountResults,\n                this.queryRunner,\n            )\n            entities = transformer.transform(\n                rawResults,\n                this.expressionMap.mainAlias!,\n            )\n\n            // broadcast all \"after load\" events\n            if (\n                this.expressionMap.callListeners === true &&\n                this.expressionMap.mainAlias.hasMetadata\n            ) {\n                await queryRunner.broadcaster.broadcast(\n                    \"Load\",\n                    this.expressionMap.mainAlias.metadata,\n                    entities,\n                )\n            }\n        }\n\n        if (this.expressionMap.relationLoadStrategy === \"query\") {\n            await Promise.all(\n                this.relationMetadatas.map(async (relation) => {\n                    const relationTarget = relation.inverseEntityMetadata.target\n                    const relationAlias =\n                        relation.inverseEntityMetadata.targetName\n\n                    const select = Array.isArray(this.findOptions.select)\n                        ? OrmUtils.propertyPathsToTruthyObject(\n                              this.findOptions.select as string[],\n                          )\n                        : this.findOptions.select\n                    const relations = Array.isArray(this.findOptions.relations)\n                        ? OrmUtils.propertyPathsToTruthyObject(\n                              this.findOptions.relations,\n                          )\n                        : this.findOptions.relations\n\n                    const queryBuilder = this.createQueryBuilder()\n                        .select(relationAlias)\n                        .from(relationTarget, relationAlias)\n                        .setFindOptions({\n                            select: select\n                                ? OrmUtils.deepValue(\n                                      select,\n                                      relation.propertyPath,\n                                  )\n                                : undefined,\n                            order: this.findOptions.order\n                                ? OrmUtils.deepValue(\n                                      this.findOptions.order,\n                                      relation.propertyPath,\n                                  )\n                                : undefined,\n                            relations: relations\n                                ? OrmUtils.deepValue(\n                                      relations,\n                                      relation.propertyPath,\n                                  )\n                                : undefined,\n                            withDeleted: this.findOptions.withDeleted,\n                            relationLoadStrategy:\n                                this.findOptions.relationLoadStrategy,\n                        })\n                    if (entities.length > 0) {\n                        const relatedEntityGroups: any[] =\n                            await this.connection.relationIdLoader.loadManyToManyRelationIdsAndGroup(\n                                relation,\n                                entities,\n                                undefined,\n                                queryBuilder,\n                            )\n                        entities.forEach((entity) => {\n                            const relatedEntityGroup = relatedEntityGroups.find(\n                                (group) => group.entity === entity,\n                            )\n                            if (relatedEntityGroup) {\n                                const value =\n                                    relatedEntityGroup.related === undefined\n                                        ? null\n                                        : relatedEntityGroup.related\n                                relation.setEntityValue(entity, value)\n                            }\n                        })\n                    }\n                }),\n            )\n        }\n\n        return {\n            raw: rawResults,\n            entities: entities,\n        }\n    }\n\n    protected createOrderByCombinedWithSelectExpression(\n        parentAlias: string,\n    ): [string, OrderByCondition] {\n        // if table has a default order then apply it\n        const orderBys = this.expressionMap.allOrderBys\n        const selectString = Object.keys(orderBys)\n            .map((orderCriteria) => {\n                if (orderCriteria.indexOf(\".\") !== -1) {\n                    const criteriaParts = orderCriteria.split(\".\")\n                    const aliasName = criteriaParts[0]\n                    const propertyPath = criteriaParts.slice(1).join(\".\")\n                    const alias = this.expressionMap.findAliasByName(aliasName)\n                    const column =\n                        alias.metadata.findColumnWithPropertyPath(propertyPath)\n                    return (\n                        this.escape(parentAlias) +\n                        \".\" +\n                        this.escape(\n                            DriverUtils.buildAlias(\n                                this.connection.driver,\n                                aliasName,\n                                column!.databaseName,\n                            ),\n                        )\n                    )\n                } else {\n                    if (\n                        this.expressionMap.selects.find(\n                            (select) =>\n                                select.selection === orderCriteria ||\n                                select.aliasName === orderCriteria,\n                        )\n                    )\n                        return this.escape(parentAlias) + \".\" + orderCriteria\n\n                    return \"\"\n                }\n            })\n            .join(\", \")\n\n        const orderByObject: OrderByCondition = {}\n        Object.keys(orderBys).forEach((orderCriteria) => {\n            if (orderCriteria.indexOf(\".\") !== -1) {\n                const criteriaParts = orderCriteria.split(\".\")\n                const aliasName = criteriaParts[0]\n                const propertyPath = criteriaParts.slice(1).join(\".\")\n                const alias = this.expressionMap.findAliasByName(aliasName)\n                const column =\n                    alias.metadata.findColumnWithPropertyPath(propertyPath)\n                orderByObject[\n                    this.escape(parentAlias) +\n                        \".\" +\n                        this.escape(\n                            DriverUtils.buildAlias(\n                                this.connection.driver,\n                                aliasName,\n                                column!.databaseName,\n                            ),\n                        )\n                ] = orderBys[orderCriteria]\n            } else {\n                if (\n                    this.expressionMap.selects.find(\n                        (select) =>\n                            select.selection === orderCriteria ||\n                            select.aliasName === orderCriteria,\n                    )\n                ) {\n                    orderByObject[\n                        this.escape(parentAlias) + \".\" + orderCriteria\n                    ] = orderBys[orderCriteria]\n                } else {\n                    orderByObject[orderCriteria] = orderBys[orderCriteria]\n                }\n            }\n        })\n\n        return [selectString, orderByObject]\n    }\n\n    /**\n     * Loads raw results from the database.\n     */\n    protected async loadRawResults(queryRunner: QueryRunner) {\n        const [sql, parameters] = this.getQueryAndParameters()\n        const queryId = sql + \" -- PARAMETERS: \" + JSON.stringify(parameters)\n        const cacheOptions =\n            typeof this.connection.options.cache === \"object\"\n                ? this.connection.options.cache\n                : {}\n        let savedQueryResultCacheOptions: QueryResultCacheOptions | undefined =\n            undefined\n        let cacheError = false\n        if (\n            this.connection.queryResultCache &&\n            (this.expressionMap.cache || cacheOptions.alwaysEnabled)\n        ) {\n            try {\n                savedQueryResultCacheOptions =\n                    await this.connection.queryResultCache.getFromCache(\n                        {\n                            identifier: this.expressionMap.cacheId,\n                            query: queryId,\n                            duration:\n                                this.expressionMap.cacheDuration ||\n                                cacheOptions.duration ||\n                                1000,\n                        },\n                        queryRunner,\n                    )\n                if (\n                    savedQueryResultCacheOptions &&\n                    !this.connection.queryResultCache.isExpired(\n                        savedQueryResultCacheOptions,\n                    )\n                ) {\n                    return JSON.parse(savedQueryResultCacheOptions.result)\n                }\n            } catch (error) {\n                if (!cacheOptions.ignoreErrors) {\n                    throw error\n                }\n                cacheError = true\n            }\n        }\n\n        const results = await queryRunner.query(sql, parameters, true)\n\n        if (\n            !cacheError &&\n            this.connection.queryResultCache &&\n            (this.expressionMap.cache || cacheOptions.alwaysEnabled)\n        ) {\n            try {\n                await this.connection.queryResultCache.storeInCache(\n                    {\n                        identifier: this.expressionMap.cacheId,\n                        query: queryId,\n                        time: new Date().getTime(),\n                        duration:\n                            this.expressionMap.cacheDuration ||\n                            cacheOptions.duration ||\n                            1000,\n                        result: JSON.stringify(results.records),\n                    },\n                    savedQueryResultCacheOptions,\n                    queryRunner,\n                )\n            } catch (error) {\n                if (!cacheOptions.ignoreErrors) {\n                    throw error\n                }\n            }\n        }\n\n        return results.records\n    }\n\n    /**\n     * Merges into expression map given expression map properties.\n     */\n    protected mergeExpressionMap(\n        expressionMap: Partial<QueryExpressionMap>,\n    ): this {\n        ObjectUtils.assign(this.expressionMap, expressionMap)\n        return this\n    }\n\n    /**\n     * Normalizes a give number - converts to int if possible.\n     */\n    protected normalizeNumber(num: any) {\n        if (typeof num === \"number\" || num === undefined || num === null)\n            return num\n\n        return Number(num)\n    }\n\n    /**\n     * Creates a query builder used to execute sql queries inside this query builder.\n     */\n    protected obtainQueryRunner() {\n        return this.queryRunner || this.connection.createQueryRunner(\"slave\")\n    }\n\n    protected buildSelect(\n        select: FindOptionsSelect<any>,\n        metadata: EntityMetadata,\n        alias: string,\n        embedPrefix?: string,\n    ) {\n        for (let key in select) {\n            if (select[key] === undefined || select[key] === false) continue\n\n            const propertyPath = embedPrefix ? embedPrefix + \".\" + key : key\n            const column =\n                metadata.findColumnWithPropertyPathStrict(propertyPath)\n            const embed = metadata.findEmbeddedWithPropertyPath(propertyPath)\n            const relation = metadata.findRelationWithPropertyPath(propertyPath)\n\n            if (!embed && !column && !relation)\n                throw new EntityPropertyNotFoundError(propertyPath, metadata)\n\n            if (column) {\n                this.selects.push(alias + \".\" + propertyPath)\n                // this.addSelect(alias + \".\" + propertyPath);\n            } else if (embed) {\n                this.buildSelect(\n                    select[key] as FindOptionsSelect<any>,\n                    metadata,\n                    alias,\n                    propertyPath,\n                )\n\n                // } else if (relation) {\n                //     const joinAlias = alias + \"_\" + relation.propertyName;\n                //     const existJoin = this.joins.find(join => join.alias === joinAlias);\n                //     if (!existJoin) {\n                //         this.joins.push({\n                //             type: \"left\",\n                //             select: false,\n                //             alias: joinAlias,\n                //             parentAlias: alias,\n                //             relationMetadata: relation\n                //         });\n                //     }\n                //     this.buildOrder(select[key] as FindOptionsOrder<any>, relation.inverseEntityMetadata, joinAlias);\n            }\n        }\n    }\n\n    protected buildRelations(\n        relations: FindOptionsRelations<any>,\n        selection: FindOptionsSelect<any> | undefined,\n        metadata: EntityMetadata,\n        alias: string,\n        embedPrefix?: string,\n    ) {\n        if (!relations) return\n\n        Object.keys(relations).forEach((relationName) => {\n            const relationValue = (relations as any)[relationName]\n            const propertyPath = embedPrefix\n                ? embedPrefix + \".\" + relationName\n                : relationName\n            const embed = metadata.findEmbeddedWithPropertyPath(propertyPath)\n            const relation = metadata.findRelationWithPropertyPath(propertyPath)\n            if (!embed && !relation)\n                throw new EntityPropertyNotFoundError(propertyPath, metadata)\n\n            if (embed) {\n                this.buildRelations(\n                    relationValue,\n                    typeof selection === \"object\"\n                        ? OrmUtils.deepValue(selection, embed.propertyPath)\n                        : undefined,\n                    metadata,\n                    alias,\n                    propertyPath,\n                )\n            } else if (relation) {\n                let joinAlias = alias + \"_\" + propertyPath.replace(\".\", \"_\")\n                joinAlias = DriverUtils.buildAlias(\n                    this.connection.driver,\n                    { joiner: \"__\" },\n                    alias,\n                    joinAlias,\n                )\n                if (\n                    relationValue === true ||\n                    typeof relationValue === \"object\"\n                ) {\n                    if (this.expressionMap.relationLoadStrategy === \"query\") {\n                        this.relationMetadatas.push(relation)\n                    } else {\n                        // join\n                        this.joins.push({\n                            type: \"left\",\n                            select: true,\n                            selection:\n                                selection &&\n                                typeof selection[relationName] === \"object\"\n                                    ? (selection[\n                                          relationName\n                                      ] as FindOptionsSelect<any>)\n                                    : undefined,\n                            alias: joinAlias,\n                            parentAlias: alias,\n                            relationMetadata: relation,\n                        })\n\n                        if (\n                            selection &&\n                            typeof selection[relationName] === \"object\"\n                        ) {\n                            this.buildSelect(\n                                selection[\n                                    relationName\n                                ] as FindOptionsSelect<any>,\n                                relation.inverseEntityMetadata,\n                                joinAlias,\n                            )\n                        }\n                    }\n                }\n\n                if (\n                    typeof relationValue === \"object\" &&\n                    this.expressionMap.relationLoadStrategy === \"join\"\n                ) {\n                    this.buildRelations(\n                        relationValue,\n                        typeof selection === \"object\"\n                            ? OrmUtils.deepValue(\n                                  selection,\n                                  relation.propertyPath,\n                              )\n                            : undefined,\n                        relation.inverseEntityMetadata,\n                        joinAlias,\n                        undefined,\n                    )\n                }\n            }\n        })\n    }\n\n    protected buildEagerRelations(\n        relations: FindOptionsRelations<any>,\n        selection: FindOptionsSelect<any> | undefined,\n        metadata: EntityMetadata,\n        alias: string,\n        embedPrefix?: string,\n    ) {\n        if (!relations) return\n\n        Object.keys(relations).forEach((relationName) => {\n            const relationValue = (relations as any)[relationName]\n            const propertyPath = embedPrefix\n                ? embedPrefix + \".\" + relationName\n                : relationName\n            const embed = metadata.findEmbeddedWithPropertyPath(propertyPath)\n            const relation = metadata.findRelationWithPropertyPath(propertyPath)\n            if (!embed && !relation)\n                throw new EntityPropertyNotFoundError(propertyPath, metadata)\n\n            if (embed) {\n                this.buildEagerRelations(\n                    relationValue,\n                    typeof selection === \"object\"\n                        ? OrmUtils.deepValue(selection, embed.propertyPath)\n                        : undefined,\n                    metadata,\n                    alias,\n                    propertyPath,\n                )\n            } else if (relation) {\n                let joinAlias = alias + \"_\" + propertyPath.replace(\".\", \"_\")\n                joinAlias = DriverUtils.buildAlias(\n                    this.connection.driver,\n                    { joiner: \"__\" },\n                    alias,\n                    joinAlias,\n                )\n\n                if (\n                    relationValue === true ||\n                    typeof relationValue === \"object\"\n                ) {\n                    relation.inverseEntityMetadata.eagerRelations.forEach(\n                        (eagerRelation) => {\n                            let eagerRelationJoinAlias =\n                                joinAlias +\n                                \"_\" +\n                                eagerRelation.propertyPath.replace(\".\", \"_\")\n                            eagerRelationJoinAlias = DriverUtils.buildAlias(\n                                this.connection.driver,\n                                { joiner: \"__\" },\n                                joinAlias,\n                                eagerRelationJoinAlias,\n                            )\n\n                            const existJoin = this.joins.find(\n                                (join) => join.alias === eagerRelationJoinAlias,\n                            )\n                            if (!existJoin) {\n                                this.joins.push({\n                                    type: \"left\",\n                                    select: true,\n                                    alias: eagerRelationJoinAlias,\n                                    parentAlias: joinAlias,\n                                    selection: undefined,\n                                    relationMetadata: eagerRelation,\n                                })\n                            }\n\n                            if (\n                                selection &&\n                                typeof selection[relationName] === \"object\"\n                            ) {\n                                this.buildSelect(\n                                    selection[\n                                        relationName\n                                    ] as FindOptionsSelect<any>,\n                                    relation.inverseEntityMetadata,\n                                    joinAlias,\n                                )\n                            }\n                        },\n                    )\n                }\n\n                if (typeof relationValue === \"object\") {\n                    this.buildEagerRelations(\n                        relationValue,\n                        typeof selection === \"object\"\n                            ? OrmUtils.deepValue(\n                                  selection,\n                                  relation.propertyPath,\n                              )\n                            : undefined,\n                        relation.inverseEntityMetadata,\n                        joinAlias,\n                        undefined,\n                    )\n                }\n            }\n        })\n    }\n\n    protected buildOrder(\n        order: FindOptionsOrder<any>,\n        metadata: EntityMetadata,\n        alias: string,\n        embedPrefix?: string,\n    ) {\n        for (let key in order) {\n            if (order[key] === undefined) continue\n\n            const propertyPath = embedPrefix ? embedPrefix + \".\" + key : key\n            const column =\n                metadata.findColumnWithPropertyPathStrict(propertyPath)\n            const embed = metadata.findEmbeddedWithPropertyPath(propertyPath)\n            const relation = metadata.findRelationWithPropertyPath(propertyPath)\n\n            if (!embed && !column && !relation)\n                throw new EntityPropertyNotFoundError(propertyPath, metadata)\n\n            if (column) {\n                let direction =\n                    typeof order[key] === \"object\"\n                        ? (order[key] as any).direction\n                        : order[key]\n                direction =\n                    direction === \"DESC\" ||\n                    direction === \"desc\" ||\n                    direction === -1\n                        ? \"DESC\"\n                        : \"ASC\"\n                let nulls =\n                    typeof order[key] === \"object\"\n                        ? (order[key] as any).nulls\n                        : undefined\n                nulls =\n                    nulls?.toLowerCase() === \"first\"\n                        ? \"NULLS FIRST\"\n                        : nulls?.toLowerCase() === \"last\"\n                        ? \"NULLS LAST\"\n                        : undefined\n\n                this.addOrderBy(`${alias}.${propertyPath}`, direction, nulls)\n                // this.orderBys.push({ alias: alias + \".\" + propertyPath, direction, nulls });\n            } else if (embed) {\n                this.buildOrder(\n                    order[key] as FindOptionsOrder<any>,\n                    metadata,\n                    alias,\n                    propertyPath,\n                )\n            } else if (relation) {\n                let joinAlias = alias + \"_\" + propertyPath.replace(\".\", \"_\")\n                joinAlias = DriverUtils.buildAlias(\n                    this.connection.driver,\n                    { joiner: \"__\" },\n                    alias,\n                    joinAlias,\n                )\n                // console.log(\"joinAlias\", joinAlias, joinAlias.length, this.connection.driver.maxAliasLength)\n                // todo: use expressionMap.joinAttributes, and create a new one using\n                //  const joinAttribute = new JoinAttribute(this.connection, this.expressionMap);\n\n                const existJoin = this.joins.find(\n                    (join) => join.alias === joinAlias,\n                )\n                if (!existJoin) {\n                    this.joins.push({\n                        type: \"left\",\n                        select: false,\n                        alias: joinAlias,\n                        parentAlias: alias,\n                        selection: undefined,\n                        relationMetadata: relation,\n                    })\n                }\n                this.buildOrder(\n                    order[key] as FindOptionsOrder<any>,\n                    relation.inverseEntityMetadata,\n                    joinAlias,\n                )\n            }\n        }\n    }\n\n    protected buildWhere(\n        where: FindOptionsWhere<any>,\n        metadata: EntityMetadata,\n        alias: string,\n        embedPrefix?: string,\n    ) {\n        let condition: string = \"\"\n        // let parameterIndex = Object.keys(this.expressionMap.nativeParameters).length;\n        if (Array.isArray(where)) {\n            condition =\n                \"(\" +\n                where\n                    .map((whereItem) => {\n                        return this.buildWhere(\n                            whereItem,\n                            metadata,\n                            alias,\n                            embedPrefix,\n                        )\n                    })\n                    .filter((condition) => !!condition)\n                    .map((condition) => \"(\" + condition + \")\")\n                    .join(\" OR \") +\n                \")\"\n        } else {\n            let andConditions: string[] = []\n            for (let key in where) {\n                if (where[key] === undefined || where[key] === null) continue\n\n                const propertyPath = embedPrefix ? embedPrefix + \".\" + key : key\n                const column =\n                    metadata.findColumnWithPropertyPathStrict(propertyPath)\n                const embed =\n                    metadata.findEmbeddedWithPropertyPath(propertyPath)\n                const relation =\n                    metadata.findRelationWithPropertyPath(propertyPath)\n\n                if (!embed && !column && !relation)\n                    throw new EntityPropertyNotFoundError(\n                        propertyPath,\n                        metadata,\n                    )\n\n                if (column) {\n                    const aliasPath = `${alias}.${propertyPath}`\n                    // const parameterName = alias + \"_\" + propertyPath.split(\".\").join(\"_\") + \"_\" + parameterIndex;\n\n                    // todo: we need to handle other operators as well?\n                    let parameterValue = where[key]\n                    if (InstanceChecker.isEqualOperator(where[key])) {\n                        parameterValue = where[key].value\n                    }\n                    if (column.transformer) {\n                        parameterValue = ApplyValueTransformers.transformTo(\n                            column.transformer,\n                            parameterValue,\n                        )\n                    }\n\n                    // if (parameterValue === null) {\n                    //     andConditions.push(`${aliasPath} IS NULL`);\n                    //\n                    // } else if (parameterValue instanceof FindOperator) {\n                    //     // let parameters: any[] = [];\n                    //     // if (parameterValue.useParameter) {\n                    //     //     const realParameterValues: any[] = parameterValue.multipleParameters ? parameterValue.value : [parameterValue.value];\n                    //     //     realParameterValues.forEach((realParameterValue, realParameterValueIndex) => {\n                    //     //\n                    //     //         // don't create parameters for number to prevent max number of variables issues as much as possible\n                    //     //         if (typeof realParameterValue === \"number\") {\n                    //     //             parameters.push(realParameterValue);\n                    //     //\n                    //     //         } else {\n                    //     //             this.expressionMap.nativeParameters[parameterName + realParameterValueIndex] = realParameterValue;\n                    //     //             parameterIndex++;\n                    //     //             parameters.push(this.connection.driver.createParameter(parameterName + realParameterValueIndex, parameterIndex - 1));\n                    //     //         }\n                    //     //     });\n                    //     // }\n                    //     andConditions.push(\n                    //         this.createWhereConditionExpression(this.getWherePredicateCondition(aliasPath, parameterValue))\n                    //         // parameterValue.toSql(this.connection, aliasPath, parameters));\n                    //     )\n                    //\n                    // } else {\n                    //     this.expressionMap.nativeParameters[parameterName] = parameterValue;\n                    //     parameterIndex++;\n                    //     const parameter = this.connection.driver.createParameter(parameterName, parameterIndex - 1);\n                    //     andConditions.push(`${aliasPath} = ${parameter}`);\n                    // }\n\n                    andConditions.push(\n                        this.createWhereConditionExpression(\n                            this.getWherePredicateCondition(\n                                aliasPath,\n                                parameterValue,\n                            ),\n                        ),\n                        // parameterValue.toSql(this.connection, aliasPath, parameters));\n                    )\n\n                    // this.conditions.push(`${alias}.${propertyPath} = :${paramName}`);\n                    // this.expressionMap.parameters[paramName] = where[key]; // todo: handle functions and other edge cases\n                } else if (embed) {\n                    const condition = this.buildWhere(\n                        where[key],\n                        metadata,\n                        alias,\n                        propertyPath,\n                    )\n                    if (condition) andConditions.push(condition)\n                } else if (relation) {\n                    // if all properties of where are undefined we don't need to join anything\n                    // this can happen when user defines map with conditional queries inside\n                    if (typeof where[key] === \"object\") {\n                        const allAllUndefined = Object.keys(where[key]).every(\n                            (k) => where[key][k] === undefined,\n                        )\n                        if (allAllUndefined) {\n                            continue\n                        }\n                    }\n\n                    if (InstanceChecker.isFindOperator(where[key])) {\n                        if (\n                            where[key].type === \"moreThan\" ||\n                            where[key].type === \"lessThan\"\n                        ) {\n                            const sqlOperator =\n                                where[key].type === \"moreThan\" ? \">\" : \"<\"\n                            // basically relation count functionality\n                            const qb: QueryBuilder<any> = this.subQuery()\n                            if (relation.isManyToManyOwner) {\n                                qb.select(\"COUNT(*)\")\n                                    .from(\n                                        relation.joinTableName,\n                                        relation.joinTableName,\n                                    )\n                                    .where(\n                                        relation.joinColumns\n                                            .map((column) => {\n                                                return `${\n                                                    relation.joinTableName\n                                                }.${\n                                                    column.propertyName\n                                                } = ${alias}.${\n                                                    column.referencedColumn!\n                                                        .propertyName\n                                                }`\n                                            })\n                                            .join(\" AND \"),\n                                    )\n                            } else if (relation.isManyToManyNotOwner) {\n                                qb.select(\"COUNT(*)\")\n                                    .from(\n                                        relation.inverseRelation!.joinTableName,\n                                        relation.inverseRelation!.joinTableName,\n                                    )\n                                    .where(\n                                        relation\n                                            .inverseRelation!.inverseJoinColumns.map(\n                                                (column) => {\n                                                    return `${\n                                                        relation.inverseRelation!\n                                                            .joinTableName\n                                                    }.${\n                                                        column.propertyName\n                                                    } = ${alias}.${\n                                                        column.referencedColumn!\n                                                            .propertyName\n                                                    }`\n                                                },\n                                            )\n                                            .join(\" AND \"),\n                                    )\n                            } else if (relation.isOneToMany) {\n                                qb.select(\"COUNT(*)\")\n                                    .from(\n                                        relation.inverseEntityMetadata.target,\n                                        relation.inverseEntityMetadata\n                                            .tableName,\n                                    )\n                                    .where(\n                                        relation\n                                            .inverseRelation!.joinColumns.map(\n                                                (column) => {\n                                                    return `${\n                                                        relation\n                                                            .inverseEntityMetadata\n                                                            .tableName\n                                                    }.${\n                                                        column.propertyName\n                                                    } = ${alias}.${\n                                                        column.referencedColumn!\n                                                            .propertyName\n                                                    }`\n                                                },\n                                            )\n                                            .join(\" AND \"),\n                                    )\n                            } else {\n                                throw new Error(\n                                    `This relation isn't supported by given find operator`,\n                                )\n                            }\n                            // this\n                            //     .addSelect(qb.getSql(), relation.propertyAliasName + \"_cnt\")\n                            //     .andWhere(this.escape(relation.propertyAliasName + \"_cnt\") + \" \" + sqlOperator + \" \" + parseInt(where[key].value));\n                            this.andWhere(\n                                qb.getSql() +\n                                    \" \" +\n                                    sqlOperator +\n                                    \" \" +\n                                    parseInt(where[key].value),\n                            )\n                        } else {\n                            if (\n                                relation.isManyToOne ||\n                                (relation.isOneToOne &&\n                                    relation.isOneToOneOwner)\n                            ) {\n                                const aliasPath = `${alias}.${propertyPath}`\n\n                                andConditions.push(\n                                    this.createWhereConditionExpression(\n                                        this.getWherePredicateCondition(\n                                            aliasPath,\n                                            where[key],\n                                        ),\n                                    ),\n                                )\n                            } else {\n                                throw new Error(\n                                    `This relation isn't supported by given find operator`,\n                                )\n                            }\n                        }\n                    } else {\n                        // const joinAlias = alias + \"_\" + relation.propertyName;\n                        let joinAlias =\n                            alias +\n                            \"_\" +\n                            relation.propertyPath.replace(\".\", \"_\")\n                        joinAlias = DriverUtils.buildAlias(\n                            this.connection.driver,\n                            { joiner: \"__\" },\n                            alias,\n                            joinAlias,\n                        )\n\n                        const existJoin = this.joins.find(\n                            (join) => join.alias === joinAlias,\n                        )\n                        if (!existJoin) {\n                            this.joins.push({\n                                type: \"inner\",\n                                select: false,\n                                selection: undefined,\n                                alias: joinAlias,\n                                parentAlias: alias,\n                                relationMetadata: relation,\n                            })\n                        } else {\n                            if (existJoin.type === \"left\")\n                                existJoin.type = \"inner\"\n                        }\n\n                        const condition = this.buildWhere(\n                            where[key],\n                            relation.inverseEntityMetadata,\n                            joinAlias,\n                        )\n                        if (condition) {\n                            andConditions.push(condition)\n                            // parameterIndex = Object.keys(this.expressionMap.nativeParameters).length;\n                        }\n                    }\n                }\n            }\n            condition = andConditions.join(\" AND \")\n        }\n        return condition\n    }\n}\n"]},"metadata":{},"sourceType":"module"}