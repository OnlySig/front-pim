{"ast":null,"code":"import { DriverUtils } from \"../driver/DriverUtils\";\n/**\n * Loads relation ids for the given entities.\n */\n\nexport class RelationIdLoader {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection) {\n    this.connection = connection;\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Loads relation ids of the given entity or entities.\n   */\n\n\n  load(relation, entityOrEntities, relatedEntityOrRelatedEntities) {\n    const entities = Array.isArray(entityOrEntities) ? entityOrEntities : [entityOrEntities];\n    const relatedEntities = Array.isArray(relatedEntityOrRelatedEntities) ? relatedEntityOrRelatedEntities : relatedEntityOrRelatedEntities ? [relatedEntityOrRelatedEntities] : undefined; // load relation ids depend of relation type\n\n    if (relation.isManyToMany) {\n      return this.loadForManyToMany(relation, entities, relatedEntities);\n    } else if (relation.isManyToOne || relation.isOneToOneOwner) {\n      return this.loadForManyToOneAndOneToOneOwner(relation, entities, relatedEntities);\n    } else {\n      // if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n      return this.loadForOneToManyAndOneToOneNotOwner(relation, entities, relatedEntities);\n    }\n  }\n  /**\n   * Loads relation ids of the given entities and groups them into the object with parent and children.\n   *\n   * todo: extract this method?\n   */\n\n\n  async loadManyToManyRelationIdsAndGroup(relation, entitiesOrEntities, relatedEntityOrEntities, queryBuilder) {\n    // console.log(\"relation:\", relation.propertyName);\n    // console.log(\"entitiesOrEntities\", entitiesOrEntities);\n    const isMany = relation.isManyToMany || relation.isOneToMany;\n    const entities = Array.isArray(entitiesOrEntities) ? entitiesOrEntities : [entitiesOrEntities];\n\n    if (!relatedEntityOrEntities) {\n      relatedEntityOrEntities = await this.connection.relationLoader.load(relation, entitiesOrEntities, undefined, queryBuilder);\n      if (!relatedEntityOrEntities.length) return entities.map(entity => ({\n        entity: entity,\n        related: isMany ? [] : undefined\n      }));\n    } // const relationIds = await this.load(relation, relatedEntityOrEntities!, entitiesOrEntities);\n\n\n    const relationIds = await this.load(relation, entitiesOrEntities, relatedEntityOrEntities); // console.log(\"entities\", entities);\n    // console.log(\"relatedEntityOrEntities\", relatedEntityOrEntities);\n    // console.log(\"relationIds\", relationIds);\n\n    const relatedEntities = Array.isArray(relatedEntityOrEntities) ? relatedEntityOrEntities : [relatedEntityOrEntities];\n    let columns = [],\n        inverseColumns = [];\n\n    if (relation.isManyToManyOwner) {\n      columns = relation.junctionEntityMetadata.inverseColumns.map(column => column.referencedColumn);\n      inverseColumns = relation.junctionEntityMetadata.ownerColumns.map(column => column.referencedColumn);\n    } else if (relation.isManyToManyNotOwner) {\n      columns = relation.junctionEntityMetadata.ownerColumns.map(column => column.referencedColumn);\n      inverseColumns = relation.junctionEntityMetadata.inverseColumns.map(column => column.referencedColumn);\n    } else if (relation.isManyToOne || relation.isOneToOneOwner) {\n      columns = relation.joinColumns.map(column => column.referencedColumn);\n      inverseColumns = relation.entityMetadata.primaryColumns;\n    } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n      columns = relation.inverseRelation.entityMetadata.primaryColumns;\n      inverseColumns = relation.inverseRelation.joinColumns.map(column => column.referencedColumn);\n    } else {}\n\n    return entities.map(entity => {\n      const group = {\n        entity: entity,\n        related: isMany ? [] : undefined\n      };\n      const entityRelationIds = relationIds.filter(relationId => {\n        return inverseColumns.every(column => {\n          return column.compareEntityValue(entity, relationId[column.entityMetadata.name + \"_\" + column.propertyAliasName]);\n        });\n      });\n      if (!entityRelationIds.length) return group;\n      relatedEntities.forEach(relatedEntity => {\n        entityRelationIds.forEach(relationId => {\n          const relatedEntityMatched = columns.every(column => {\n            return column.compareEntityValue(relatedEntity, relationId[DriverUtils.buildAlias(this.connection.driver, column.entityMetadata.name + \"_\" + relation.propertyPath.replace(\".\", \"_\") + \"_\" + column.propertyPath.replace(\".\", \"_\"))]);\n          });\n\n          if (relatedEntityMatched) {\n            if (isMany) {\n              ;\n              group.related.push(relatedEntity);\n            } else {\n              group.related = relatedEntity;\n            }\n          }\n        });\n      });\n      return group;\n    });\n  }\n  /**\n   * Loads relation ids of the given entities and maps them into the given entity property.\n   async loadManyToManyRelationIdsAndMap(\n   relation: RelationMetadata,\n   entityOrEntities: ObjectLiteral|ObjectLiteral[],\n   mapToEntityOrEntities: ObjectLiteral|ObjectLiteral[],\n   propertyName: string\n   ): Promise<void> {\n      const relationIds = await this.loadManyToManyRelationIds(relation, entityOrEntities, mapToEntityOrEntities);\n      const mapToEntities = mapToEntityOrEntities instanceof Array ? mapToEntityOrEntities : [mapToEntityOrEntities];\n      const junctionMetadata = relation.junctionEntityMetadata!;\n      const mainAlias = junctionMetadata.name;\n      const columns = relation.isOwning ? junctionMetadata.inverseColumns : junctionMetadata.ownerColumns;\n      const inverseColumns = relation.isOwning ? junctionMetadata.ownerColumns : junctionMetadata.inverseColumns;\n      mapToEntities.forEach(mapToEntity => {\n          mapToEntity[propertyName] = [];\n          relationIds.forEach(relationId => {\n              const match = inverseColumns.every(column => {\n                  return column.referencedColumn!.getEntityValue(mapToEntity) === relationId[mainAlias + \"_\" + column.propertyName];\n              });\n              if (match) {\n                  if (columns.length === 1) {\n                      mapToEntity[propertyName].push(relationId[mainAlias + \"_\" + columns[0].propertyName]);\n                  } else {\n                      const value = {};\n                      columns.forEach(column => {\n                          column.referencedColumn!.setEntityValue(value, relationId[mainAlias + \"_\" + column.propertyName]);\n                      });\n                      mapToEntity[propertyName].push(value);\n                  }\n              }\n          });\n      });\n  }*/\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Loads relation ids for the many-to-many relation.\n   */\n\n\n  loadForManyToMany(relation, entities, relatedEntities) {\n    const junctionMetadata = relation.junctionEntityMetadata;\n    const mainAlias = junctionMetadata.name;\n    const columns = relation.isOwning ? junctionMetadata.ownerColumns : junctionMetadata.inverseColumns;\n    const inverseColumns = relation.isOwning ? junctionMetadata.inverseColumns : junctionMetadata.ownerColumns;\n    const qb = this.connection.createQueryBuilder(); // select all columns from junction table\n\n    columns.forEach(column => {\n      const columnName = DriverUtils.buildAlias(this.connection.driver, column.referencedColumn.entityMetadata.name + \"_\" + column.referencedColumn.propertyPath.replace(\".\", \"_\"));\n      qb.addSelect(mainAlias + \".\" + column.propertyPath, columnName);\n    });\n    inverseColumns.forEach(column => {\n      const columnName = DriverUtils.buildAlias(this.connection.driver, column.referencedColumn.entityMetadata.name + \"_\" + relation.propertyPath.replace(\".\", \"_\") + \"_\" + column.referencedColumn.propertyPath.replace(\".\", \"_\"));\n      qb.addSelect(mainAlias + \".\" + column.propertyPath, columnName);\n    }); // add conditions for the given entities\n\n    let condition1 = \"\";\n\n    if (columns.length === 1) {\n      const values = entities.map(entity => columns[0].referencedColumn.getEntityValue(entity));\n      const areAllNumbers = values.every(value => typeof value === \"number\");\n\n      if (areAllNumbers) {\n        condition1 = `${mainAlias}.${columns[0].propertyPath} IN (${values.join(\", \")})`;\n      } else {\n        qb.setParameter(\"values1\", values);\n        condition1 = mainAlias + \".\" + columns[0].propertyPath + \" IN (:...values1)\"; // todo: use ANY for postgres\n      }\n    } else {\n      condition1 = \"(\" + entities.map((entity, entityIndex) => {\n        return columns.map(column => {\n          const paramName = \"entity1_\" + entityIndex + \"_\" + column.propertyName;\n          qb.setParameter(paramName, column.referencedColumn.getEntityValue(entity));\n          return mainAlias + \".\" + column.propertyPath + \" = :\" + paramName;\n        }).join(\" AND \");\n      }).map(condition => \"(\" + condition + \")\").join(\" OR \") + \")\";\n    } // add conditions for the given inverse entities\n\n\n    let condition2 = \"\";\n\n    if (relatedEntities) {\n      if (inverseColumns.length === 1) {\n        const values = relatedEntities.map(entity => inverseColumns[0].referencedColumn.getEntityValue(entity));\n        const areAllNumbers = values.every(value => typeof value === \"number\");\n\n        if (areAllNumbers) {\n          condition2 = `${mainAlias}.${inverseColumns[0].propertyPath} IN (${values.join(\", \")})`;\n        } else {\n          qb.setParameter(\"values2\", values);\n          condition2 = mainAlias + \".\" + inverseColumns[0].propertyPath + \" IN (:...values2)\"; // todo: use ANY for postgres\n        }\n      } else {\n        condition2 = \"(\" + relatedEntities.map((entity, entityIndex) => {\n          return inverseColumns.map(column => {\n            const paramName = \"entity2_\" + entityIndex + \"_\" + column.propertyName;\n            qb.setParameter(paramName, column.referencedColumn.getEntityValue(entity));\n            return mainAlias + \".\" + column.propertyPath + \" = :\" + paramName;\n          }).join(\" AND \");\n        }).map(condition => \"(\" + condition + \")\").join(\" OR \") + \")\";\n      }\n    } // qb.from(junctionMetadata.target, mainAlias)\n    //     .where(condition1 + (condition2 ? \" AND \" + condition2 : \"\"));\n    //\n    // // execute query\n    // const { values1, values2 } = qb.getParameters();\n    // console.log(`I can do it`, { values1, values2 });\n    // if (inverseColumns.length === 1 &&\n    //     columns.length === 1 &&\n    //     this.connection.driver instanceof SqliteDriver &&\n    //     (values1.length + values2.length) > 500 &&\n    //     values1.length === values2.length) {\n    //     console.log(`I can do it`);\n    //     return qb.getRawMany();\n    //\n    // } else {\n    //     return qb.getRawMany();\n    // }\n    // execute query\n\n\n    const condition = [condition1, condition2].filter(v => v.length > 0).join(\" AND \");\n    return qb.from(junctionMetadata.target, mainAlias).where(condition).getRawMany();\n  }\n  /**\n   * Loads relation ids for the many-to-one and one-to-one owner relations.\n   */\n\n\n  loadForManyToOneAndOneToOneOwner(relation, entities, relatedEntities) {\n    const mainAlias = relation.entityMetadata.targetName; // console.log(\"entitiesx\", entities);\n    // console.log(\"relatedEntitiesx\", relatedEntities);\n\n    const hasAllJoinColumnsInEntity = relation.joinColumns.every(joinColumn => {\n      return !!relation.entityMetadata.nonVirtualColumns.find(column => column === joinColumn);\n    });\n\n    if (relatedEntities && hasAllJoinColumnsInEntity) {\n      let relationIdMaps = [];\n      entities.forEach(entity => {\n        let relationIdMap = {};\n        relation.entityMetadata.primaryColumns.forEach(primaryColumn => {\n          const key = primaryColumn.entityMetadata.name + \"_\" + primaryColumn.propertyPath.replace(\".\", \"_\");\n          relationIdMap[key] = primaryColumn.getEntityValue(entity);\n        });\n        relatedEntities.forEach(relatedEntity => {\n          relation.joinColumns.forEach(joinColumn => {\n            const entityColumnValue = joinColumn.getEntityValue(entity);\n            const relatedEntityColumnValue = joinColumn.referencedColumn.getEntityValue(relatedEntity);\n            if (entityColumnValue === undefined || relatedEntityColumnValue === undefined) return;\n\n            if (entityColumnValue === relatedEntityColumnValue) {\n              const key = joinColumn.referencedColumn.entityMetadata.name + \"_\" + relation.propertyPath.replace(\".\", \"_\") + \"_\" + joinColumn.referencedColumn.propertyPath.replace(\".\", \"_\");\n              relationIdMap[key] = relatedEntityColumnValue;\n            }\n          });\n        });\n\n        if (Object.keys(relationIdMap).length === relation.entityMetadata.primaryColumns.length + relation.joinColumns.length) {\n          relationIdMaps.push(relationIdMap);\n        }\n      }); // console.log(\"relationIdMap\", relationIdMaps);\n      // console.log(\"entities.length\", entities.length);\n\n      if (relationIdMaps.length === entities.length) return Promise.resolve(relationIdMaps);\n    } // select all columns we need\n\n\n    const qb = this.connection.createQueryBuilder();\n    relation.entityMetadata.primaryColumns.forEach(primaryColumn => {\n      const columnName = DriverUtils.buildAlias(this.connection.driver, primaryColumn.entityMetadata.name + \"_\" + primaryColumn.propertyPath.replace(\".\", \"_\"));\n      qb.addSelect(mainAlias + \".\" + primaryColumn.propertyPath, columnName);\n    });\n    relation.joinColumns.forEach(column => {\n      const columnName = DriverUtils.buildAlias(this.connection.driver, column.referencedColumn.entityMetadata.name + \"_\" + relation.propertyPath.replace(\".\", \"_\") + \"_\" + column.referencedColumn.propertyPath.replace(\".\", \"_\"));\n      qb.addSelect(mainAlias + \".\" + column.propertyPath, columnName);\n    }); // add condition for entities\n\n    let condition = \"\";\n\n    if (relation.entityMetadata.primaryColumns.length === 1) {\n      const values = entities.map(entity => relation.entityMetadata.primaryColumns[0].getEntityValue(entity));\n      const areAllNumbers = values.every(value => typeof value === \"number\");\n\n      if (areAllNumbers) {\n        condition = `${mainAlias}.${relation.entityMetadata.primaryColumns[0].propertyPath} IN (${values.join(\", \")})`;\n      } else {\n        qb.setParameter(\"values\", values);\n        condition = mainAlias + \".\" + relation.entityMetadata.primaryColumns[0].propertyPath + \" IN (:...values)\"; // todo: use ANY for postgres\n      }\n    } else {\n      condition = entities.map((entity, entityIndex) => {\n        return relation.entityMetadata.primaryColumns.map((column, columnIndex) => {\n          const paramName = \"entity\" + entityIndex + \"_\" + columnIndex;\n          qb.setParameter(paramName, column.getEntityValue(entity));\n          return mainAlias + \".\" + column.propertyPath + \" = :\" + paramName;\n        }).join(\" AND \");\n      }).map(condition => \"(\" + condition + \")\").join(\" OR \");\n    } // execute query\n\n\n    return qb.from(relation.entityMetadata.target, mainAlias).where(condition).getRawMany();\n  }\n  /**\n   * Loads relation ids for the one-to-many and one-to-one not owner relations.\n   */\n\n\n  loadForOneToManyAndOneToOneNotOwner(relation, entities, relatedEntities) {\n    relation = relation.inverseRelation;\n\n    if (relation.entityMetadata.primaryColumns.length === relation.joinColumns.length) {\n      const sameReferencedColumns = relation.entityMetadata.primaryColumns.every(column => {\n        return relation.joinColumns.indexOf(column) !== -1;\n      });\n\n      if (sameReferencedColumns) {\n        return Promise.resolve(entities.map(entity => {\n          const result = {};\n          relation.joinColumns.forEach(function (joinColumn) {\n            const value = joinColumn.referencedColumn.getEntityValue(entity);\n            const joinColumnName = joinColumn.referencedColumn.entityMetadata.name + \"_\" + joinColumn.referencedColumn.propertyPath.replace(\".\", \"_\");\n            const primaryColumnName = joinColumn.entityMetadata.name + \"_\" + relation.inverseRelation.propertyPath.replace(\".\", \"_\") + \"_\" + joinColumn.propertyPath.replace(\".\", \"_\");\n            result[joinColumnName] = value;\n            result[primaryColumnName] = value;\n          });\n          return result;\n        }));\n      }\n    }\n\n    const mainAlias = relation.entityMetadata.targetName; // select all columns we need\n\n    const qb = this.connection.createQueryBuilder();\n    relation.entityMetadata.primaryColumns.forEach(primaryColumn => {\n      const columnName = DriverUtils.buildAlias(this.connection.driver, primaryColumn.entityMetadata.name + \"_\" + relation.inverseRelation.propertyPath.replace(\".\", \"_\") + \"_\" + primaryColumn.propertyPath.replace(\".\", \"_\"));\n      qb.addSelect(mainAlias + \".\" + primaryColumn.propertyPath, columnName);\n    });\n    relation.joinColumns.forEach(column => {\n      const columnName = DriverUtils.buildAlias(this.connection.driver, column.referencedColumn.entityMetadata.name + \"_\" + column.referencedColumn.propertyPath.replace(\".\", \"_\"));\n      qb.addSelect(mainAlias + \".\" + column.propertyPath, columnName);\n    }); // add condition for entities\n\n    let condition = \"\";\n\n    if (relation.joinColumns.length === 1) {\n      const values = entities.map(entity => relation.joinColumns[0].referencedColumn.getEntityValue(entity));\n      const areAllNumbers = values.every(value => typeof value === \"number\");\n\n      if (areAllNumbers) {\n        condition = `${mainAlias}.${relation.joinColumns[0].propertyPath} IN (${values.join(\", \")})`;\n      } else {\n        qb.setParameter(\"values\", values);\n        condition = mainAlias + \".\" + relation.joinColumns[0].propertyPath + \" IN (:...values)\"; // todo: use ANY for postgres\n      }\n    } else {\n      condition = entities.map((entity, entityIndex) => {\n        return relation.joinColumns.map((joinColumn, joinColumnIndex) => {\n          const paramName = \"entity\" + entityIndex + \"_\" + joinColumnIndex;\n          qb.setParameter(paramName, joinColumn.referencedColumn.getEntityValue(entity));\n          return mainAlias + \".\" + joinColumn.propertyPath + \" = :\" + paramName;\n        }).join(\" AND \");\n      }).map(condition => \"(\" + condition + \")\").join(\" OR \");\n    } // execute query\n\n\n    return qb.from(relation.entityMetadata.target, mainAlias).where(condition).getRawMany();\n  }\n\n}","map":{"version":3,"mappings":"AAKA,SAASA,WAAT,QAA4B,uBAA5B;AAEA;;;;AAGA,OAAM,MAAOC,gBAAP,CAAuB;EACzB;EACA;EACA;EAEAC,YAAoBC,UAApB,EAA0C;IAAtB;EAA0B,CALrB,CAOzB;EACA;EACA;;EAEA;;;;;EAGAC,IAAI,CACAC,QADA,EAEAC,gBAFA,EAGAC,8BAHA,EAGgE;IAEhE,MAAMC,QAAQ,GAAGC,KAAK,CAACC,OAAN,CAAcJ,gBAAd,IACXA,gBADW,GAEX,CAACA,gBAAD,CAFN;IAGA,MAAMK,eAAe,GAAGF,KAAK,CAACC,OAAN,CAAcH,8BAAd,IAClBA,8BADkB,GAElBA,8BAA8B,GAC9B,CAACA,8BAAD,CAD8B,GAE9BK,SAJN,CALgE,CAWhE;;IACA,IAAIP,QAAQ,CAACQ,YAAb,EAA2B;MACvB,OAAO,KAAKC,iBAAL,CAAuBT,QAAvB,EAAiCG,QAAjC,EAA2CG,eAA3C,CAAP;IACH,CAFD,MAEO,IAAIN,QAAQ,CAACU,WAAT,IAAwBV,QAAQ,CAACW,eAArC,EAAsD;MACzD,OAAO,KAAKC,gCAAL,CACHZ,QADG,EAEHG,QAFG,EAGHG,eAHG,CAAP;IAKH,CANM,MAMA;MACH;MACA,OAAO,KAAKO,mCAAL,CACHb,QADG,EAEHG,QAFG,EAGHG,eAHG,CAAP;IAKH;EACJ;EAED;;;;;;;EAKuC,MAAjCQ,iCAAiC,CAInCd,QAJmC,EAKnCe,kBALmC,EAMnCC,uBANmC,EAOnCC,YAPmC,EAOG;IAEtC;IACA;IACA,MAAMC,MAAM,GAAGlB,QAAQ,CAACQ,YAAT,IAAyBR,QAAQ,CAACmB,WAAjD;IACA,MAAMhB,QAAQ,GAASC,KAAK,CAACC,OAAN,CAAcU,kBAAd,IACjBA,kBADiB,GAEjB,CAACA,kBAAD,CAFN;;IAIA,IAAI,CAACC,uBAAL,EAA8B;MAC1BA,uBAAuB,GAAG,MAAM,KAAKlB,UAAL,CAAgBsB,cAAhB,CAA+BrB,IAA/B,CAC5BC,QAD4B,EAE5Be,kBAF4B,EAG5BR,SAH4B,EAI5BU,YAJ4B,CAAhC;MAMA,IAAI,CAACD,uBAAuB,CAACK,MAA7B,EACI,OAAOlB,QAAQ,CAACmB,GAAT,CAAcC,MAAD,KAAa;QAC7BA,MAAM,EAAEA,MADqB;QAE7BC,OAAO,EAAEN,MAAM,GAAG,EAAH,GAAQX;MAFM,CAAb,CAAb,CAAP;IAIP,CArBqC,CAsBtC;;;IACA,MAAMkB,WAAW,GAAG,MAAM,KAAK1B,IAAL,CACtBC,QADsB,EAEtBe,kBAFsB,EAGtBC,uBAHsB,CAA1B,CAvBsC,CA4BtC;IACA;IACA;;IAEA,MAAMV,eAAe,GAASF,KAAK,CAACC,OAAN,CAAcW,uBAAd,IACxBA,uBADwB,GAExB,CAACA,uBAAD,CAFN;IAIA,IAAIU,OAAO,GAAqB,EAAhC;IAAA,IACIC,cAAc,GAAqB,EADvC;;IAEA,IAAI3B,QAAQ,CAAC4B,iBAAb,EAAgC;MAC5BF,OAAO,GAAG1B,QAAQ,CAAC6B,sBAAT,CAAiCF,cAAjC,CAAgDL,GAAhD,CACLQ,MAAD,IAAYA,MAAM,CAACC,gBADb,CAAV;MAGAJ,cAAc,GAAG3B,QAAQ,CAAC6B,sBAAT,CAAiCG,YAAjC,CAA8CV,GAA9C,CACZQ,MAAD,IAAYA,MAAM,CAACC,gBADN,CAAjB;IAGH,CAPD,MAOO,IAAI/B,QAAQ,CAACiC,oBAAb,EAAmC;MACtCP,OAAO,GAAG1B,QAAQ,CAAC6B,sBAAT,CAAiCG,YAAjC,CAA8CV,GAA9C,CACLQ,MAAD,IAAYA,MAAM,CAACC,gBADb,CAAV;MAGAJ,cAAc,GACV3B,QAAQ,CAAC6B,sBAAT,CAAiCF,cAAjC,CAAgDL,GAAhD,CACKQ,MAAD,IAAYA,MAAM,CAACC,gBADvB,CADJ;IAIH,CARM,MAQA,IAAI/B,QAAQ,CAACU,WAAT,IAAwBV,QAAQ,CAACW,eAArC,EAAsD;MACzDe,OAAO,GAAG1B,QAAQ,CAACkC,WAAT,CAAqBZ,GAArB,CACLQ,MAAD,IAAYA,MAAM,CAACC,gBADb,CAAV;MAGAJ,cAAc,GAAG3B,QAAQ,CAACmC,cAAT,CAAwBC,cAAzC;IACH,CALM,MAKA,IAAIpC,QAAQ,CAACmB,WAAT,IAAwBnB,QAAQ,CAACqC,kBAArC,EAAyD;MAC5DX,OAAO,GAAG1B,QAAQ,CAACsC,eAAT,CAA0BH,cAA1B,CAAyCC,cAAnD;MACAT,cAAc,GAAG3B,QAAQ,CAACsC,eAAT,CAA0BJ,WAA1B,CAAsCZ,GAAtC,CACZQ,MAAD,IAAYA,MAAM,CAACC,gBADN,CAAjB;IAGH,CALM,MAKA,CACN;;IAED,OAAO5B,QAAQ,CAACmB,GAAT,CAAcC,MAAD,IAAW;MAC3B,MAAMgB,KAAK,GAAwC;QAC/ChB,MAAM,EAAEA,MADuC;QAE/CC,OAAO,EAAEN,MAAM,GAAG,EAAH,GAAQX;MAFwB,CAAnD;MAKA,MAAMiC,iBAAiB,GAAGf,WAAW,CAACgB,MAAZ,CAAoBC,UAAD,IAAe;QACxD,OAAOf,cAAc,CAACgB,KAAf,CAAsBb,MAAD,IAAW;UACnC,OAAOA,MAAM,CAACc,kBAAP,CACHrB,MADG,EAEHmB,UAAU,CACNZ,MAAM,CAACK,cAAP,CAAsBU,IAAtB,GACI,GADJ,GAEIf,MAAM,CAACgB,iBAHL,CAFP,CAAP;QAQH,CATM,CAAP;MAUH,CAXyB,CAA1B;MAYA,IAAI,CAACN,iBAAiB,CAACnB,MAAvB,EAA+B,OAAOkB,KAAP;MAE/BjC,eAAe,CAACyC,OAAhB,CAAyBC,aAAD,IAAkB;QACtCR,iBAAiB,CAACO,OAAlB,CAA2BL,UAAD,IAAe;UACrC,MAAMO,oBAAoB,GAAGvB,OAAO,CAACiB,KAAR,CAAeb,MAAD,IAAW;YAClD,OAAOA,MAAM,CAACc,kBAAP,CACHI,aADG,EAEHN,UAAU,CACN/C,WAAW,CAACuD,UAAZ,CACI,KAAKpD,UAAL,CAAgBqD,MADpB,EAEIrB,MAAM,CAACK,cAAP,CAAsBU,IAAtB,GACI,GADJ,GAEI7C,QAAQ,CAACoD,YAAT,CAAsBC,OAAtB,CACI,GADJ,EAEI,GAFJ,CAFJ,GAMI,GANJ,GAOIvB,MAAM,CAACsB,YAAP,CAAoBC,OAApB,CAA4B,GAA5B,EAAiC,GAAjC,CATR,CADM,CAFP,CAAP;UAgBH,CAjB4B,CAA7B;;UAkBA,IAAIJ,oBAAJ,EAA0B;YACtB,IAAI/B,MAAJ,EAAY;cACR;cAAEqB,KAAK,CAACf,OAAN,CAAuB8B,IAAvB,CAA4BN,aAA5B;YACL,CAFD,MAEO;cACHT,KAAK,CAACf,OAAN,GAAgBwB,aAAhB;YACH;UACJ;QACJ,CA1BD;MA2BH,CA5BD;MA6BA,OAAOT,KAAP;IACH,CAlDM,CAAP;EAmDH;EAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAmCA;EACA;EACA;;EAEA;;;;;EAGU9B,iBAAiB,CACvBT,QADuB,EAEvBG,QAFuB,EAGvBG,eAHuB,EAGU;IAEjC,MAAMiD,gBAAgB,GAAGvD,QAAQ,CAAC6B,sBAAlC;IACA,MAAM2B,SAAS,GAAGD,gBAAgB,CAACV,IAAnC;IACA,MAAMnB,OAAO,GAAG1B,QAAQ,CAACyD,QAAT,GACVF,gBAAgB,CAACvB,YADP,GAEVuB,gBAAgB,CAAC5B,cAFvB;IAGA,MAAMA,cAAc,GAAG3B,QAAQ,CAACyD,QAAT,GACjBF,gBAAgB,CAAC5B,cADA,GAEjB4B,gBAAgB,CAACvB,YAFvB;IAGA,MAAM0B,EAAE,GAAG,KAAK5D,UAAL,CAAgB6D,kBAAhB,EAAX,CAViC,CAYjC;;IACAjC,OAAO,CAACqB,OAAR,CAAiBjB,MAAD,IAAW;MACvB,MAAM8B,UAAU,GAAGjE,WAAW,CAACuD,UAAZ,CACf,KAAKpD,UAAL,CAAgBqD,MADD,EAEfrB,MAAM,CAACC,gBAAP,CAAyBI,cAAzB,CAAwCU,IAAxC,GACI,GADJ,GAEIf,MAAM,CAACC,gBAAP,CAAyBqB,YAAzB,CAAsCC,OAAtC,CAA8C,GAA9C,EAAmD,GAAnD,CAJW,CAAnB;MAMAK,EAAE,CAACG,SAAH,CAAaL,SAAS,GAAG,GAAZ,GAAkB1B,MAAM,CAACsB,YAAtC,EAAoDQ,UAApD;IACH,CARD;IASAjC,cAAc,CAACoB,OAAf,CAAwBjB,MAAD,IAAW;MAC9B,MAAM8B,UAAU,GAAGjE,WAAW,CAACuD,UAAZ,CACf,KAAKpD,UAAL,CAAgBqD,MADD,EAEfrB,MAAM,CAACC,gBAAP,CAAyBI,cAAzB,CAAwCU,IAAxC,GACI,GADJ,GAEI7C,QAAQ,CAACoD,YAAT,CAAsBC,OAAtB,CAA8B,GAA9B,EAAmC,GAAnC,CAFJ,GAGI,GAHJ,GAIIvB,MAAM,CAACC,gBAAP,CAAyBqB,YAAzB,CAAsCC,OAAtC,CAA8C,GAA9C,EAAmD,GAAnD,CANW,CAAnB;MAQAK,EAAE,CAACG,SAAH,CAAaL,SAAS,GAAG,GAAZ,GAAkB1B,MAAM,CAACsB,YAAtC,EAAoDQ,UAApD;IACH,CAVD,EAtBiC,CAkCjC;;IACA,IAAIE,UAAU,GAAG,EAAjB;;IACA,IAAIpC,OAAO,CAACL,MAAR,KAAmB,CAAvB,EAA0B;MACtB,MAAM0C,MAAM,GAAG5D,QAAQ,CAACmB,GAAT,CAAcC,MAAD,IACxBG,OAAO,CAAC,CAAD,CAAP,CAAWK,gBAAX,CAA6BiC,cAA7B,CAA4CzC,MAA5C,CADW,CAAf;MAGA,MAAM0C,aAAa,GAAGF,MAAM,CAACpB,KAAP,CACjBuB,KAAD,IAAW,OAAOA,KAAP,KAAiB,QADV,CAAtB;;MAIA,IAAID,aAAJ,EAAmB;QACfH,UAAU,GAAG,GAAGN,SAAS,IACrB9B,OAAO,CAAC,CAAD,CAAP,CAAW0B,YACf,QAAQW,MAAM,CAACI,IAAP,CAAY,IAAZ,CAAiB,GAFzB;MAGH,CAJD,MAIO;QACHT,EAAE,CAACU,YAAH,CAAgB,SAAhB,EAA2BL,MAA3B;QACAD,UAAU,GACNN,SAAS,GACT,GADA,GAEA9B,OAAO,CAAC,CAAD,CAAP,CAAW0B,YAFX,GAGA,mBAJJ,CAFG,CAMqB;MAC3B;IACJ,CApBD,MAoBO;MACHU,UAAU,GACN,MACA3D,QAAQ,CACHmB,GADL,CACS,CAACC,MAAD,EAAS8C,WAAT,KAAwB;QACzB,OAAO3C,OAAO,CACTJ,GADE,CACGQ,MAAD,IAAW;UACZ,MAAMwC,SAAS,GACX,aACAD,WADA,GAEA,GAFA,GAGAvC,MAAM,CAACyC,YAJX;UAKAb,EAAE,CAACU,YAAH,CACIE,SADJ,EAEIxC,MAAM,CAACC,gBAAP,CAAyBiC,cAAzB,CACIzC,MADJ,CAFJ;UAMA,OACIiC,SAAS,GACT,GADA,GAEA1B,MAAM,CAACsB,YAFP,GAGA,MAHA,GAIAkB,SALJ;QAOH,CApBE,EAqBFH,IArBE,CAqBG,OArBH,CAAP;MAsBH,CAxBL,EAyBK7C,GAzBL,CAyBUkD,SAAD,IAAe,MAAMA,SAAN,GAAkB,GAzB1C,EA0BKL,IA1BL,CA0BU,MA1BV,CADA,GA4BA,GA7BJ;IA8BH,CAvFgC,CAyFjC;;;IACA,IAAIM,UAAU,GAAG,EAAjB;;IACA,IAAInE,eAAJ,EAAqB;MACjB,IAAIqB,cAAc,CAACN,MAAf,KAA0B,CAA9B,EAAiC;QAC7B,MAAM0C,MAAM,GAAGzD,eAAe,CAACgB,GAAhB,CAAqBC,MAAD,IAC/BI,cAAc,CAAC,CAAD,CAAd,CAAkBI,gBAAlB,CAAoCiC,cAApC,CAAmDzC,MAAnD,CADW,CAAf;QAGA,MAAM0C,aAAa,GAAGF,MAAM,CAACpB,KAAP,CACjBuB,KAAD,IAAW,OAAOA,KAAP,KAAiB,QADV,CAAtB;;QAIA,IAAID,aAAJ,EAAmB;UACfQ,UAAU,GAAG,GAAGjB,SAAS,IACrB7B,cAAc,CAAC,CAAD,CAAd,CAAkByB,YACtB,QAAQW,MAAM,CAACI,IAAP,CAAY,IAAZ,CAAiB,GAFzB;QAGH,CAJD,MAIO;UACHT,EAAE,CAACU,YAAH,CAAgB,SAAhB,EAA2BL,MAA3B;UACAU,UAAU,GACNjB,SAAS,GACT,GADA,GAEA7B,cAAc,CAAC,CAAD,CAAd,CAAkByB,YAFlB,GAGA,mBAJJ,CAFG,CAMqB;QAC3B;MACJ,CApBD,MAoBO;QACHqB,UAAU,GACN,MACAnE,eAAe,CACVgB,GADL,CACS,CAACC,MAAD,EAAS8C,WAAT,KAAwB;UACzB,OAAO1C,cAAc,CAChBL,GADE,CACGQ,MAAD,IAAW;YACZ,MAAMwC,SAAS,GACX,aACAD,WADA,GAEA,GAFA,GAGAvC,MAAM,CAACyC,YAJX;YAKAb,EAAE,CAACU,YAAH,CACIE,SADJ,EAEIxC,MAAM,CAACC,gBAAP,CAAyBiC,cAAzB,CACIzC,MADJ,CAFJ;YAMA,OACIiC,SAAS,GACT,GADA,GAEA1B,MAAM,CAACsB,YAFP,GAGA,MAHA,GAIAkB,SALJ;UAOH,CApBE,EAqBFH,IArBE,CAqBG,OArBH,CAAP;QAsBH,CAxBL,EAyBK7C,GAzBL,CAyBUkD,SAAD,IAAe,MAAMA,SAAN,GAAkB,GAzB1C,EA0BKL,IA1BL,CA0BU,MA1BV,CADA,GA4BA,GA7BJ;MA8BH;IACJ,CAhJgC,CAkJjC;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IAEA;;;IACA,MAAMK,SAAS,GAAG,CAACV,UAAD,EAAaW,UAAb,EACbhC,MADa,CACLiC,CAAD,IAAOA,CAAC,CAACrD,MAAF,GAAW,CADZ,EAEb8C,IAFa,CAER,OAFQ,CAAlB;IAGA,OAAOT,EAAE,CACJiB,IADE,CACGpB,gBAAgB,CAACqB,MADpB,EAC4BpB,SAD5B,EAEFqB,KAFE,CAEIL,SAFJ,EAGFM,UAHE,EAAP;EAIH;EAED;;;;;EAGUlE,gCAAgC,CACtCZ,QADsC,EAEtCG,QAFsC,EAGtCG,eAHsC,EAGL;IAEjC,MAAMkD,SAAS,GAAGxD,QAAQ,CAACmC,cAAT,CAAwB4C,UAA1C,CAFiC,CAIjC;IACA;;IACA,MAAMC,yBAAyB,GAAGhF,QAAQ,CAACkC,WAAT,CAAqBS,KAArB,CAC7BsC,UAAD,IAAe;MACX,OAAO,CAAC,CAACjF,QAAQ,CAACmC,cAAT,CAAwB+C,iBAAxB,CAA0CC,IAA1C,CACJrD,MAAD,IAAYA,MAAM,KAAKmD,UADlB,CAAT;IAGH,CAL6B,CAAlC;;IAOA,IAAI3E,eAAe,IAAI0E,yBAAvB,EAAkD;MAC9C,IAAII,cAAc,GAAoB,EAAtC;MACAjF,QAAQ,CAAC4C,OAAT,CAAkBxB,MAAD,IAAW;QACxB,IAAI8D,aAAa,GAAkB,EAAnC;QACArF,QAAQ,CAACmC,cAAT,CAAwBC,cAAxB,CAAuCW,OAAvC,CACKuC,aAAD,IAAkB;UACd,MAAMC,GAAG,GACLD,aAAa,CAACnD,cAAd,CAA6BU,IAA7B,GACA,GADA,GAEAyC,aAAa,CAAClC,YAAd,CAA2BC,OAA3B,CAAmC,GAAnC,EAAwC,GAAxC,CAHJ;UAIAgC,aAAa,CAACE,GAAD,CAAb,GACID,aAAa,CAACtB,cAAd,CAA6BzC,MAA7B,CADJ;QAEH,CARL;QAWAjB,eAAe,CAACyC,OAAhB,CAAyBC,aAAD,IAAkB;UACtChD,QAAQ,CAACkC,WAAT,CAAqBa,OAArB,CAA8BkC,UAAD,IAAe;YACxC,MAAMO,iBAAiB,GACnBP,UAAU,CAACjB,cAAX,CAA0BzC,MAA1B,CADJ;YAEA,MAAMkE,wBAAwB,GAC1BR,UAAU,CAAClD,gBAAX,CAA6BiC,cAA7B,CACIhB,aADJ,CADJ;YAIA,IACIwC,iBAAiB,KAAKjF,SAAtB,IACAkF,wBAAwB,KAAKlF,SAFjC,EAII;;YAEJ,IAAIiF,iBAAiB,KAAKC,wBAA1B,EAAoD;cAChD,MAAMF,GAAG,GACLN,UAAU,CAAClD,gBAAX,CAA6BI,cAA7B,CACKU,IADL,GAEA,GAFA,GAGA7C,QAAQ,CAACoD,YAAT,CAAsBC,OAAtB,CAA8B,GAA9B,EAAmC,GAAnC,CAHA,GAIA,GAJA,GAKA4B,UAAU,CAAClD,gBAAX,CAA6BqB,YAA7B,CAA0CC,OAA1C,CACI,GADJ,EAEI,GAFJ,CANJ;cAUAgC,aAAa,CAACE,GAAD,CAAb,GAAqBE,wBAArB;YACH;UACJ,CA1BD;QA2BH,CA5BD;;QA6BA,IACIC,MAAM,CAACC,IAAP,CAAYN,aAAZ,EAA2BhE,MAA3B,KACArB,QAAQ,CAACmC,cAAT,CAAwBC,cAAxB,CAAuCf,MAAvC,GACIrB,QAAQ,CAACkC,WAAT,CAAqBb,MAH7B,EAIE;UACE+D,cAAc,CAAC9B,IAAf,CAAoB+B,aAApB;QACH;MACJ,CAjDD,EAF8C,CAoD9C;MACA;;MACA,IAAID,cAAc,CAAC/D,MAAf,KAA0BlB,QAAQ,CAACkB,MAAvC,EACI,OAAOuE,OAAO,CAACC,OAAR,CAAgBT,cAAhB,CAAP;IACP,CArEgC,CAuEjC;;;IACA,MAAM1B,EAAE,GAAG,KAAK5D,UAAL,CAAgB6D,kBAAhB,EAAX;IACA3D,QAAQ,CAACmC,cAAT,CAAwBC,cAAxB,CAAuCW,OAAvC,CAAgDuC,aAAD,IAAkB;MAC7D,MAAM1B,UAAU,GAAGjE,WAAW,CAACuD,UAAZ,CACf,KAAKpD,UAAL,CAAgBqD,MADD,EAEfmC,aAAa,CAACnD,cAAd,CAA6BU,IAA7B,GACI,GADJ,GAEIyC,aAAa,CAAClC,YAAd,CAA2BC,OAA3B,CAAmC,GAAnC,EAAwC,GAAxC,CAJW,CAAnB;MAMAK,EAAE,CAACG,SAAH,CACIL,SAAS,GAAG,GAAZ,GAAkB8B,aAAa,CAAClC,YADpC,EAEIQ,UAFJ;IAIH,CAXD;IAYA5D,QAAQ,CAACkC,WAAT,CAAqBa,OAArB,CAA8BjB,MAAD,IAAW;MACpC,MAAM8B,UAAU,GAAGjE,WAAW,CAACuD,UAAZ,CACf,KAAKpD,UAAL,CAAgBqD,MADD,EAEfrB,MAAM,CAACC,gBAAP,CAAyBI,cAAzB,CAAwCU,IAAxC,GACI,GADJ,GAEI7C,QAAQ,CAACoD,YAAT,CAAsBC,OAAtB,CAA8B,GAA9B,EAAmC,GAAnC,CAFJ,GAGI,GAHJ,GAIIvB,MAAM,CAACC,gBAAP,CAAyBqB,YAAzB,CAAsCC,OAAtC,CAA8C,GAA9C,EAAmD,GAAnD,CANW,CAAnB;MAQAK,EAAE,CAACG,SAAH,CAAaL,SAAS,GAAG,GAAZ,GAAkB1B,MAAM,CAACsB,YAAtC,EAAoDQ,UAApD;IACH,CAVD,EArFiC,CAiGjC;;IACA,IAAIY,SAAS,GAAW,EAAxB;;IACA,IAAIxE,QAAQ,CAACmC,cAAT,CAAwBC,cAAxB,CAAuCf,MAAvC,KAAkD,CAAtD,EAAyD;MACrD,MAAM0C,MAAM,GAAG5D,QAAQ,CAACmB,GAAT,CAAcC,MAAD,IACxBvB,QAAQ,CAACmC,cAAT,CAAwBC,cAAxB,CAAuC,CAAvC,EAA0C4B,cAA1C,CACIzC,MADJ,CADW,CAAf;MAKA,MAAM0C,aAAa,GAAGF,MAAM,CAACpB,KAAP,CACjBuB,KAAD,IAAW,OAAOA,KAAP,KAAiB,QADV,CAAtB;;MAIA,IAAID,aAAJ,EAAmB;QACfO,SAAS,GAAG,GAAGhB,SAAS,IACpBxD,QAAQ,CAACmC,cAAT,CAAwBC,cAAxB,CAAuC,CAAvC,EAA0CgB,YAC9C,QAAQW,MAAM,CAACI,IAAP,CAAY,IAAZ,CAAiB,GAFzB;MAGH,CAJD,MAIO;QACHT,EAAE,CAACU,YAAH,CAAgB,QAAhB,EAA0BL,MAA1B;QACAS,SAAS,GACLhB,SAAS,GACT,GADA,GAEAxD,QAAQ,CAACmC,cAAT,CAAwBC,cAAxB,CAAuC,CAAvC,EAA0CgB,YAF1C,GAGA,kBAJJ,CAFG,CAMoB;MAC1B;IACJ,CAtBD,MAsBO;MACHoB,SAAS,GAAGrE,QAAQ,CACfmB,GADO,CACH,CAACC,MAAD,EAAS8C,WAAT,KAAwB;QACzB,OAAOrE,QAAQ,CAACmC,cAAT,CAAwBC,cAAxB,CACFd,GADE,CACE,CAACQ,MAAD,EAASgE,WAAT,KAAwB;UACzB,MAAMxB,SAAS,GACX,WAAWD,WAAX,GAAyB,GAAzB,GAA+ByB,WADnC;UAEApC,EAAE,CAACU,YAAH,CACIE,SADJ,EAEIxC,MAAM,CAACkC,cAAP,CAAsBzC,MAAtB,CAFJ;UAIA,OACIiC,SAAS,GACT,GADA,GAEA1B,MAAM,CAACsB,YAFP,GAGA,MAHA,GAIAkB,SALJ;QAOH,CAfE,EAgBFH,IAhBE,CAgBG,OAhBH,CAAP;MAiBH,CAnBO,EAoBP7C,GApBO,CAoBFkD,SAAD,IAAe,MAAMA,SAAN,GAAkB,GApB9B,EAqBPL,IArBO,CAqBF,MArBE,CAAZ;IAsBH,CAhJgC,CAkJjC;;;IACA,OAAOT,EAAE,CACJiB,IADE,CACG3E,QAAQ,CAACmC,cAAT,CAAwByC,MAD3B,EACmCpB,SADnC,EAEFqB,KAFE,CAEIL,SAFJ,EAGFM,UAHE,EAAP;EAIH;EAED;;;;;EAGUjE,mCAAmC,CACzCb,QADyC,EAEzCG,QAFyC,EAGzCG,eAHyC,EAGR;IAEjCN,QAAQ,GAAGA,QAAQ,CAACsC,eAApB;;IAEA,IACItC,QAAQ,CAACmC,cAAT,CAAwBC,cAAxB,CAAuCf,MAAvC,KACArB,QAAQ,CAACkC,WAAT,CAAqBb,MAFzB,EAGE;MACE,MAAM0E,qBAAqB,GACvB/F,QAAQ,CAACmC,cAAT,CAAwBC,cAAxB,CAAuCO,KAAvC,CAA8Cb,MAAD,IAAW;QACpD,OAAO9B,QAAQ,CAACkC,WAAT,CAAqB8D,OAArB,CAA6BlE,MAA7B,MAAyC,CAAC,CAAjD;MACH,CAFD,CADJ;;MAIA,IAAIiE,qBAAJ,EAA2B;QACvB,OAAOH,OAAO,CAACC,OAAR,CACH1F,QAAQ,CAACmB,GAAT,CAAcC,MAAD,IAAW;UACpB,MAAM0E,MAAM,GAAkB,EAA9B;UACAjG,QAAQ,CAACkC,WAAT,CAAqBa,OAArB,CAA6B,UAAUkC,UAAV,EAAoB;YAC7C,MAAMf,KAAK,GACPe,UAAU,CAAClD,gBAAX,CAA6BiC,cAA7B,CACIzC,MADJ,CADJ;YAIA,MAAM2E,cAAc,GAChBjB,UAAU,CAAClD,gBAAX,CAA6BI,cAA7B,CACKU,IADL,GAEA,GAFA,GAGAoC,UAAU,CAAClD,gBAAX,CAA6BqB,YAA7B,CAA0CC,OAA1C,CACI,GADJ,EAEI,GAFJ,CAJJ;YAQA,MAAM8C,iBAAiB,GACnBlB,UAAU,CAAC9C,cAAX,CAA0BU,IAA1B,GACA,GADA,GAEA7C,QAAQ,CAACsC,eAAT,CAA0Bc,YAA1B,CAAuCC,OAAvC,CACI,GADJ,EAEI,GAFJ,CAFA,GAMA,GANA,GAOA4B,UAAU,CAAC7B,YAAX,CAAwBC,OAAxB,CAAgC,GAAhC,EAAqC,GAArC,CARJ;YASA4C,MAAM,CAACC,cAAD,CAAN,GAAyBhC,KAAzB;YACA+B,MAAM,CAACE,iBAAD,CAAN,GAA4BjC,KAA5B;UACH,CAxBD;UAyBA,OAAO+B,MAAP;QACH,CA5BD,CADG,CAAP;MA+BH;IACJ;;IAED,MAAMzC,SAAS,GAAGxD,QAAQ,CAACmC,cAAT,CAAwB4C,UAA1C,CA/CiC,CAiDjC;;IACA,MAAMrB,EAAE,GAAG,KAAK5D,UAAL,CAAgB6D,kBAAhB,EAAX;IACA3D,QAAQ,CAACmC,cAAT,CAAwBC,cAAxB,CAAuCW,OAAvC,CAAgDuC,aAAD,IAAkB;MAC7D,MAAM1B,UAAU,GAAGjE,WAAW,CAACuD,UAAZ,CACf,KAAKpD,UAAL,CAAgBqD,MADD,EAEfmC,aAAa,CAACnD,cAAd,CAA6BU,IAA7B,GACI,GADJ,GAEI7C,QAAQ,CAACsC,eAAT,CAA0Bc,YAA1B,CAAuCC,OAAvC,CAA+C,GAA/C,EAAoD,GAApD,CAFJ,GAGI,GAHJ,GAIIiC,aAAa,CAAClC,YAAd,CAA2BC,OAA3B,CAAmC,GAAnC,EAAwC,GAAxC,CANW,CAAnB;MAQAK,EAAE,CAACG,SAAH,CACIL,SAAS,GAAG,GAAZ,GAAkB8B,aAAa,CAAClC,YADpC,EAEIQ,UAFJ;IAIH,CAbD;IAcA5D,QAAQ,CAACkC,WAAT,CAAqBa,OAArB,CAA8BjB,MAAD,IAAW;MACpC,MAAM8B,UAAU,GAAGjE,WAAW,CAACuD,UAAZ,CACf,KAAKpD,UAAL,CAAgBqD,MADD,EAEfrB,MAAM,CAACC,gBAAP,CAAyBI,cAAzB,CAAwCU,IAAxC,GACI,GADJ,GAEIf,MAAM,CAACC,gBAAP,CAAyBqB,YAAzB,CAAsCC,OAAtC,CAA8C,GAA9C,EAAmD,GAAnD,CAJW,CAAnB;MAMAK,EAAE,CAACG,SAAH,CAAaL,SAAS,GAAG,GAAZ,GAAkB1B,MAAM,CAACsB,YAAtC,EAAoDQ,UAApD;IACH,CARD,EAjEiC,CA2EjC;;IACA,IAAIY,SAAS,GAAW,EAAxB;;IACA,IAAIxE,QAAQ,CAACkC,WAAT,CAAqBb,MAArB,KAAgC,CAApC,EAAuC;MACnC,MAAM0C,MAAM,GAAG5D,QAAQ,CAACmB,GAAT,CAAcC,MAAD,IACxBvB,QAAQ,CAACkC,WAAT,CAAqB,CAArB,EAAwBH,gBAAxB,CAA0CiC,cAA1C,CACIzC,MADJ,CADW,CAAf;MAKA,MAAM0C,aAAa,GAAGF,MAAM,CAACpB,KAAP,CACjBuB,KAAD,IAAW,OAAOA,KAAP,KAAiB,QADV,CAAtB;;MAIA,IAAID,aAAJ,EAAmB;QACfO,SAAS,GAAG,GAAGhB,SAAS,IACpBxD,QAAQ,CAACkC,WAAT,CAAqB,CAArB,EAAwBkB,YAC5B,QAAQW,MAAM,CAACI,IAAP,CAAY,IAAZ,CAAiB,GAFzB;MAGH,CAJD,MAIO;QACHT,EAAE,CAACU,YAAH,CAAgB,QAAhB,EAA0BL,MAA1B;QACAS,SAAS,GACLhB,SAAS,GACT,GADA,GAEAxD,QAAQ,CAACkC,WAAT,CAAqB,CAArB,EAAwBkB,YAFxB,GAGA,kBAJJ,CAFG,CAMoB;MAC1B;IACJ,CAtBD,MAsBO;MACHoB,SAAS,GAAGrE,QAAQ,CACfmB,GADO,CACH,CAACC,MAAD,EAAS8C,WAAT,KAAwB;QACzB,OAAOrE,QAAQ,CAACkC,WAAT,CACFZ,GADE,CACE,CAAC2D,UAAD,EAAamB,eAAb,KAAgC;UACjC,MAAM9B,SAAS,GACX,WAAWD,WAAX,GAAyB,GAAzB,GAA+B+B,eADnC;UAEA1C,EAAE,CAACU,YAAH,CACIE,SADJ,EAEIW,UAAU,CAAClD,gBAAX,CAA6BiC,cAA7B,CACIzC,MADJ,CAFJ;UAMA,OACIiC,SAAS,GACT,GADA,GAEAyB,UAAU,CAAC7B,YAFX,GAGA,MAHA,GAIAkB,SALJ;QAOH,CAjBE,EAkBFH,IAlBE,CAkBG,OAlBH,CAAP;MAmBH,CArBO,EAsBP7C,GAtBO,CAsBFkD,SAAD,IAAe,MAAMA,SAAN,GAAkB,GAtB9B,EAuBPL,IAvBO,CAuBF,MAvBE,CAAZ;IAwBH,CA5HgC,CA8HjC;;;IACA,OAAOT,EAAE,CACJiB,IADE,CACG3E,QAAQ,CAACmC,cAAT,CAAwByC,MAD3B,EACmCpB,SADnC,EAEFqB,KAFE,CAEIL,SAFJ,EAGFM,UAHE,EAAP;EAIH;;AArrBwB","names":["DriverUtils","RelationIdLoader","constructor","connection","load","relation","entityOrEntities","relatedEntityOrRelatedEntities","entities","Array","isArray","relatedEntities","undefined","isManyToMany","loadForManyToMany","isManyToOne","isOneToOneOwner","loadForManyToOneAndOneToOneOwner","loadForOneToManyAndOneToOneNotOwner","loadManyToManyRelationIdsAndGroup","entitiesOrEntities","relatedEntityOrEntities","queryBuilder","isMany","isOneToMany","relationLoader","length","map","entity","related","relationIds","columns","inverseColumns","isManyToManyOwner","junctionEntityMetadata","column","referencedColumn","ownerColumns","isManyToManyNotOwner","joinColumns","entityMetadata","primaryColumns","isOneToOneNotOwner","inverseRelation","group","entityRelationIds","filter","relationId","every","compareEntityValue","name","propertyAliasName","forEach","relatedEntity","relatedEntityMatched","buildAlias","driver","propertyPath","replace","push","junctionMetadata","mainAlias","isOwning","qb","createQueryBuilder","columnName","addSelect","condition1","values","getEntityValue","areAllNumbers","value","join","setParameter","entityIndex","paramName","propertyName","condition","condition2","v","from","target","where","getRawMany","targetName","hasAllJoinColumnsInEntity","joinColumn","nonVirtualColumns","find","relationIdMaps","relationIdMap","primaryColumn","key","entityColumnValue","relatedEntityColumnValue","Object","keys","Promise","resolve","columnIndex","sameReferencedColumns","indexOf","result","joinColumnName","primaryColumnName","joinColumnIndex"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\query-builder\\RelationIdLoader.ts"],"sourcesContent":["import { RelationMetadata } from \"../metadata/RelationMetadata\"\nimport { ColumnMetadata } from \"../metadata/ColumnMetadata\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { SelectQueryBuilder } from \"./SelectQueryBuilder\"\nimport { DriverUtils } from \"../driver/DriverUtils\"\n\n/**\n * Loads relation ids for the given entities.\n */\nexport class RelationIdLoader {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private connection: DataSource) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Loads relation ids of the given entity or entities.\n     */\n    load(\n        relation: RelationMetadata,\n        entityOrEntities: ObjectLiteral | ObjectLiteral[],\n        relatedEntityOrRelatedEntities?: ObjectLiteral | ObjectLiteral[],\n    ): Promise<any[]> {\n        const entities = Array.isArray(entityOrEntities)\n            ? entityOrEntities\n            : [entityOrEntities]\n        const relatedEntities = Array.isArray(relatedEntityOrRelatedEntities)\n            ? relatedEntityOrRelatedEntities\n            : relatedEntityOrRelatedEntities\n            ? [relatedEntityOrRelatedEntities]\n            : undefined\n\n        // load relation ids depend of relation type\n        if (relation.isManyToMany) {\n            return this.loadForManyToMany(relation, entities, relatedEntities)\n        } else if (relation.isManyToOne || relation.isOneToOneOwner) {\n            return this.loadForManyToOneAndOneToOneOwner(\n                relation,\n                entities,\n                relatedEntities,\n            )\n        } else {\n            // if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n            return this.loadForOneToManyAndOneToOneNotOwner(\n                relation,\n                entities,\n                relatedEntities,\n            )\n        }\n    }\n\n    /**\n     * Loads relation ids of the given entities and groups them into the object with parent and children.\n     *\n     * todo: extract this method?\n     */\n    async loadManyToManyRelationIdsAndGroup<\n        E1 extends ObjectLiteral,\n        E2 extends ObjectLiteral,\n    >(\n        relation: RelationMetadata,\n        entitiesOrEntities: E1 | E1[],\n        relatedEntityOrEntities?: E2 | E2[],\n        queryBuilder?: SelectQueryBuilder<any>,\n    ): Promise<{ entity: E1; related?: E2 | E2[] }[]> {\n        // console.log(\"relation:\", relation.propertyName);\n        // console.log(\"entitiesOrEntities\", entitiesOrEntities);\n        const isMany = relation.isManyToMany || relation.isOneToMany\n        const entities: E1[] = Array.isArray(entitiesOrEntities)\n            ? entitiesOrEntities\n            : [entitiesOrEntities]\n\n        if (!relatedEntityOrEntities) {\n            relatedEntityOrEntities = await this.connection.relationLoader.load(\n                relation,\n                entitiesOrEntities,\n                undefined,\n                queryBuilder,\n            )\n            if (!relatedEntityOrEntities.length)\n                return entities.map((entity) => ({\n                    entity: entity,\n                    related: isMany ? [] : undefined,\n                }))\n        }\n        // const relationIds = await this.load(relation, relatedEntityOrEntities!, entitiesOrEntities);\n        const relationIds = await this.load(\n            relation,\n            entitiesOrEntities,\n            relatedEntityOrEntities,\n        )\n        // console.log(\"entities\", entities);\n        // console.log(\"relatedEntityOrEntities\", relatedEntityOrEntities);\n        // console.log(\"relationIds\", relationIds);\n\n        const relatedEntities: E2[] = Array.isArray(relatedEntityOrEntities)\n            ? relatedEntityOrEntities\n            : [relatedEntityOrEntities!]\n\n        let columns: ColumnMetadata[] = [],\n            inverseColumns: ColumnMetadata[] = []\n        if (relation.isManyToManyOwner) {\n            columns = relation.junctionEntityMetadata!.inverseColumns.map(\n                (column) => column.referencedColumn!,\n            )\n            inverseColumns = relation.junctionEntityMetadata!.ownerColumns.map(\n                (column) => column.referencedColumn!,\n            )\n        } else if (relation.isManyToManyNotOwner) {\n            columns = relation.junctionEntityMetadata!.ownerColumns.map(\n                (column) => column.referencedColumn!,\n            )\n            inverseColumns =\n                relation.junctionEntityMetadata!.inverseColumns.map(\n                    (column) => column.referencedColumn!,\n                )\n        } else if (relation.isManyToOne || relation.isOneToOneOwner) {\n            columns = relation.joinColumns.map(\n                (column) => column.referencedColumn!,\n            )\n            inverseColumns = relation.entityMetadata.primaryColumns\n        } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n            columns = relation.inverseRelation!.entityMetadata.primaryColumns\n            inverseColumns = relation.inverseRelation!.joinColumns.map(\n                (column) => column.referencedColumn!,\n            )\n        } else {\n        }\n\n        return entities.map((entity) => {\n            const group: { entity: E1; related?: E2 | E2[] } = {\n                entity: entity,\n                related: isMany ? [] : undefined,\n            }\n\n            const entityRelationIds = relationIds.filter((relationId) => {\n                return inverseColumns.every((column) => {\n                    return column.compareEntityValue(\n                        entity,\n                        relationId[\n                            column.entityMetadata.name +\n                                \"_\" +\n                                column.propertyAliasName\n                        ],\n                    )\n                })\n            })\n            if (!entityRelationIds.length) return group\n\n            relatedEntities.forEach((relatedEntity) => {\n                entityRelationIds.forEach((relationId) => {\n                    const relatedEntityMatched = columns.every((column) => {\n                        return column.compareEntityValue(\n                            relatedEntity,\n                            relationId[\n                                DriverUtils.buildAlias(\n                                    this.connection.driver,\n                                    column.entityMetadata.name +\n                                        \"_\" +\n                                        relation.propertyPath.replace(\n                                            \".\",\n                                            \"_\",\n                                        ) +\n                                        \"_\" +\n                                        column.propertyPath.replace(\".\", \"_\"),\n                                )\n                            ],\n                        )\n                    })\n                    if (relatedEntityMatched) {\n                        if (isMany) {\n                            ;(group.related as E2[]).push(relatedEntity)\n                        } else {\n                            group.related = relatedEntity\n                        }\n                    }\n                })\n            })\n            return group\n        })\n    }\n\n    /**\n     * Loads relation ids of the given entities and maps them into the given entity property.\n     async loadManyToManyRelationIdsAndMap(\n     relation: RelationMetadata,\n     entityOrEntities: ObjectLiteral|ObjectLiteral[],\n     mapToEntityOrEntities: ObjectLiteral|ObjectLiteral[],\n     propertyName: string\n     ): Promise<void> {\n        const relationIds = await this.loadManyToManyRelationIds(relation, entityOrEntities, mapToEntityOrEntities);\n        const mapToEntities = mapToEntityOrEntities instanceof Array ? mapToEntityOrEntities : [mapToEntityOrEntities];\n        const junctionMetadata = relation.junctionEntityMetadata!;\n        const mainAlias = junctionMetadata.name;\n        const columns = relation.isOwning ? junctionMetadata.inverseColumns : junctionMetadata.ownerColumns;\n        const inverseColumns = relation.isOwning ? junctionMetadata.ownerColumns : junctionMetadata.inverseColumns;\n        mapToEntities.forEach(mapToEntity => {\n            mapToEntity[propertyName] = [];\n            relationIds.forEach(relationId => {\n                const match = inverseColumns.every(column => {\n                    return column.referencedColumn!.getEntityValue(mapToEntity) === relationId[mainAlias + \"_\" + column.propertyName];\n                });\n                if (match) {\n                    if (columns.length === 1) {\n                        mapToEntity[propertyName].push(relationId[mainAlias + \"_\" + columns[0].propertyName]);\n                    } else {\n                        const value = {};\n                        columns.forEach(column => {\n                            column.referencedColumn!.setEntityValue(value, relationId[mainAlias + \"_\" + column.propertyName]);\n                        });\n                        mapToEntity[propertyName].push(value);\n                    }\n                }\n            });\n        });\n    }*/\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Loads relation ids for the many-to-many relation.\n     */\n    protected loadForManyToMany(\n        relation: RelationMetadata,\n        entities: ObjectLiteral[],\n        relatedEntities?: ObjectLiteral[],\n    ) {\n        const junctionMetadata = relation.junctionEntityMetadata!\n        const mainAlias = junctionMetadata.name\n        const columns = relation.isOwning\n            ? junctionMetadata.ownerColumns\n            : junctionMetadata.inverseColumns\n        const inverseColumns = relation.isOwning\n            ? junctionMetadata.inverseColumns\n            : junctionMetadata.ownerColumns\n        const qb = this.connection.createQueryBuilder()\n\n        // select all columns from junction table\n        columns.forEach((column) => {\n            const columnName = DriverUtils.buildAlias(\n                this.connection.driver,\n                column.referencedColumn!.entityMetadata.name +\n                    \"_\" +\n                    column.referencedColumn!.propertyPath.replace(\".\", \"_\"),\n            )\n            qb.addSelect(mainAlias + \".\" + column.propertyPath, columnName)\n        })\n        inverseColumns.forEach((column) => {\n            const columnName = DriverUtils.buildAlias(\n                this.connection.driver,\n                column.referencedColumn!.entityMetadata.name +\n                    \"_\" +\n                    relation.propertyPath.replace(\".\", \"_\") +\n                    \"_\" +\n                    column.referencedColumn!.propertyPath.replace(\".\", \"_\"),\n            )\n            qb.addSelect(mainAlias + \".\" + column.propertyPath, columnName)\n        })\n\n        // add conditions for the given entities\n        let condition1 = \"\"\n        if (columns.length === 1) {\n            const values = entities.map((entity) =>\n                columns[0].referencedColumn!.getEntityValue(entity),\n            )\n            const areAllNumbers = values.every(\n                (value) => typeof value === \"number\",\n            )\n\n            if (areAllNumbers) {\n                condition1 = `${mainAlias}.${\n                    columns[0].propertyPath\n                } IN (${values.join(\", \")})`\n            } else {\n                qb.setParameter(\"values1\", values)\n                condition1 =\n                    mainAlias +\n                    \".\" +\n                    columns[0].propertyPath +\n                    \" IN (:...values1)\" // todo: use ANY for postgres\n            }\n        } else {\n            condition1 =\n                \"(\" +\n                entities\n                    .map((entity, entityIndex) => {\n                        return columns\n                            .map((column) => {\n                                const paramName =\n                                    \"entity1_\" +\n                                    entityIndex +\n                                    \"_\" +\n                                    column.propertyName\n                                qb.setParameter(\n                                    paramName,\n                                    column.referencedColumn!.getEntityValue(\n                                        entity,\n                                    ),\n                                )\n                                return (\n                                    mainAlias +\n                                    \".\" +\n                                    column.propertyPath +\n                                    \" = :\" +\n                                    paramName\n                                )\n                            })\n                            .join(\" AND \")\n                    })\n                    .map((condition) => \"(\" + condition + \")\")\n                    .join(\" OR \") +\n                \")\"\n        }\n\n        // add conditions for the given inverse entities\n        let condition2 = \"\"\n        if (relatedEntities) {\n            if (inverseColumns.length === 1) {\n                const values = relatedEntities.map((entity) =>\n                    inverseColumns[0].referencedColumn!.getEntityValue(entity),\n                )\n                const areAllNumbers = values.every(\n                    (value) => typeof value === \"number\",\n                )\n\n                if (areAllNumbers) {\n                    condition2 = `${mainAlias}.${\n                        inverseColumns[0].propertyPath\n                    } IN (${values.join(\", \")})`\n                } else {\n                    qb.setParameter(\"values2\", values)\n                    condition2 =\n                        mainAlias +\n                        \".\" +\n                        inverseColumns[0].propertyPath +\n                        \" IN (:...values2)\" // todo: use ANY for postgres\n                }\n            } else {\n                condition2 =\n                    \"(\" +\n                    relatedEntities\n                        .map((entity, entityIndex) => {\n                            return inverseColumns\n                                .map((column) => {\n                                    const paramName =\n                                        \"entity2_\" +\n                                        entityIndex +\n                                        \"_\" +\n                                        column.propertyName\n                                    qb.setParameter(\n                                        paramName,\n                                        column.referencedColumn!.getEntityValue(\n                                            entity,\n                                        ),\n                                    )\n                                    return (\n                                        mainAlias +\n                                        \".\" +\n                                        column.propertyPath +\n                                        \" = :\" +\n                                        paramName\n                                    )\n                                })\n                                .join(\" AND \")\n                        })\n                        .map((condition) => \"(\" + condition + \")\")\n                        .join(\" OR \") +\n                    \")\"\n            }\n        }\n\n        // qb.from(junctionMetadata.target, mainAlias)\n        //     .where(condition1 + (condition2 ? \" AND \" + condition2 : \"\"));\n        //\n        // // execute query\n        // const { values1, values2 } = qb.getParameters();\n        // console.log(`I can do it`, { values1, values2 });\n        // if (inverseColumns.length === 1 &&\n        //     columns.length === 1 &&\n        //     this.connection.driver instanceof SqliteDriver &&\n        //     (values1.length + values2.length) > 500 &&\n        //     values1.length === values2.length) {\n        //     console.log(`I can do it`);\n        //     return qb.getRawMany();\n        //\n        // } else {\n        //     return qb.getRawMany();\n        // }\n\n        // execute query\n        const condition = [condition1, condition2]\n            .filter((v) => v.length > 0)\n            .join(\" AND \")\n        return qb\n            .from(junctionMetadata.target, mainAlias)\n            .where(condition)\n            .getRawMany()\n    }\n\n    /**\n     * Loads relation ids for the many-to-one and one-to-one owner relations.\n     */\n    protected loadForManyToOneAndOneToOneOwner(\n        relation: RelationMetadata,\n        entities: ObjectLiteral[],\n        relatedEntities?: ObjectLiteral[],\n    ) {\n        const mainAlias = relation.entityMetadata.targetName\n\n        // console.log(\"entitiesx\", entities);\n        // console.log(\"relatedEntitiesx\", relatedEntities);\n        const hasAllJoinColumnsInEntity = relation.joinColumns.every(\n            (joinColumn) => {\n                return !!relation.entityMetadata.nonVirtualColumns.find(\n                    (column) => column === joinColumn,\n                )\n            },\n        )\n        if (relatedEntities && hasAllJoinColumnsInEntity) {\n            let relationIdMaps: ObjectLiteral[] = []\n            entities.forEach((entity) => {\n                let relationIdMap: ObjectLiteral = {}\n                relation.entityMetadata.primaryColumns.forEach(\n                    (primaryColumn) => {\n                        const key =\n                            primaryColumn.entityMetadata.name +\n                            \"_\" +\n                            primaryColumn.propertyPath.replace(\".\", \"_\")\n                        relationIdMap[key] =\n                            primaryColumn.getEntityValue(entity)\n                    },\n                )\n\n                relatedEntities.forEach((relatedEntity) => {\n                    relation.joinColumns.forEach((joinColumn) => {\n                        const entityColumnValue =\n                            joinColumn.getEntityValue(entity)\n                        const relatedEntityColumnValue =\n                            joinColumn.referencedColumn!.getEntityValue(\n                                relatedEntity,\n                            )\n                        if (\n                            entityColumnValue === undefined ||\n                            relatedEntityColumnValue === undefined\n                        )\n                            return\n\n                        if (entityColumnValue === relatedEntityColumnValue) {\n                            const key =\n                                joinColumn.referencedColumn!.entityMetadata\n                                    .name +\n                                \"_\" +\n                                relation.propertyPath.replace(\".\", \"_\") +\n                                \"_\" +\n                                joinColumn.referencedColumn!.propertyPath.replace(\n                                    \".\",\n                                    \"_\",\n                                )\n                            relationIdMap[key] = relatedEntityColumnValue\n                        }\n                    })\n                })\n                if (\n                    Object.keys(relationIdMap).length ===\n                    relation.entityMetadata.primaryColumns.length +\n                        relation.joinColumns.length\n                ) {\n                    relationIdMaps.push(relationIdMap)\n                }\n            })\n            // console.log(\"relationIdMap\", relationIdMaps);\n            // console.log(\"entities.length\", entities.length);\n            if (relationIdMaps.length === entities.length)\n                return Promise.resolve(relationIdMaps)\n        }\n\n        // select all columns we need\n        const qb = this.connection.createQueryBuilder()\n        relation.entityMetadata.primaryColumns.forEach((primaryColumn) => {\n            const columnName = DriverUtils.buildAlias(\n                this.connection.driver,\n                primaryColumn.entityMetadata.name +\n                    \"_\" +\n                    primaryColumn.propertyPath.replace(\".\", \"_\"),\n            )\n            qb.addSelect(\n                mainAlias + \".\" + primaryColumn.propertyPath,\n                columnName,\n            )\n        })\n        relation.joinColumns.forEach((column) => {\n            const columnName = DriverUtils.buildAlias(\n                this.connection.driver,\n                column.referencedColumn!.entityMetadata.name +\n                    \"_\" +\n                    relation.propertyPath.replace(\".\", \"_\") +\n                    \"_\" +\n                    column.referencedColumn!.propertyPath.replace(\".\", \"_\"),\n            )\n            qb.addSelect(mainAlias + \".\" + column.propertyPath, columnName)\n        })\n\n        // add condition for entities\n        let condition: string = \"\"\n        if (relation.entityMetadata.primaryColumns.length === 1) {\n            const values = entities.map((entity) =>\n                relation.entityMetadata.primaryColumns[0].getEntityValue(\n                    entity,\n                ),\n            )\n            const areAllNumbers = values.every(\n                (value) => typeof value === \"number\",\n            )\n\n            if (areAllNumbers) {\n                condition = `${mainAlias}.${\n                    relation.entityMetadata.primaryColumns[0].propertyPath\n                } IN (${values.join(\", \")})`\n            } else {\n                qb.setParameter(\"values\", values)\n                condition =\n                    mainAlias +\n                    \".\" +\n                    relation.entityMetadata.primaryColumns[0].propertyPath +\n                    \" IN (:...values)\" // todo: use ANY for postgres\n            }\n        } else {\n            condition = entities\n                .map((entity, entityIndex) => {\n                    return relation.entityMetadata.primaryColumns\n                        .map((column, columnIndex) => {\n                            const paramName =\n                                \"entity\" + entityIndex + \"_\" + columnIndex\n                            qb.setParameter(\n                                paramName,\n                                column.getEntityValue(entity),\n                            )\n                            return (\n                                mainAlias +\n                                \".\" +\n                                column.propertyPath +\n                                \" = :\" +\n                                paramName\n                            )\n                        })\n                        .join(\" AND \")\n                })\n                .map((condition) => \"(\" + condition + \")\")\n                .join(\" OR \")\n        }\n\n        // execute query\n        return qb\n            .from(relation.entityMetadata.target, mainAlias)\n            .where(condition)\n            .getRawMany()\n    }\n\n    /**\n     * Loads relation ids for the one-to-many and one-to-one not owner relations.\n     */\n    protected loadForOneToManyAndOneToOneNotOwner(\n        relation: RelationMetadata,\n        entities: ObjectLiteral[],\n        relatedEntities?: ObjectLiteral[],\n    ) {\n        relation = relation.inverseRelation!\n\n        if (\n            relation.entityMetadata.primaryColumns.length ===\n            relation.joinColumns.length\n        ) {\n            const sameReferencedColumns =\n                relation.entityMetadata.primaryColumns.every((column) => {\n                    return relation.joinColumns.indexOf(column) !== -1\n                })\n            if (sameReferencedColumns) {\n                return Promise.resolve(\n                    entities.map((entity) => {\n                        const result: ObjectLiteral = {}\n                        relation.joinColumns.forEach(function (joinColumn) {\n                            const value =\n                                joinColumn.referencedColumn!.getEntityValue(\n                                    entity,\n                                )\n                            const joinColumnName =\n                                joinColumn.referencedColumn!.entityMetadata\n                                    .name +\n                                \"_\" +\n                                joinColumn.referencedColumn!.propertyPath.replace(\n                                    \".\",\n                                    \"_\",\n                                )\n                            const primaryColumnName =\n                                joinColumn.entityMetadata.name +\n                                \"_\" +\n                                relation.inverseRelation!.propertyPath.replace(\n                                    \".\",\n                                    \"_\",\n                                ) +\n                                \"_\" +\n                                joinColumn.propertyPath.replace(\".\", \"_\")\n                            result[joinColumnName] = value\n                            result[primaryColumnName] = value\n                        })\n                        return result\n                    }),\n                )\n            }\n        }\n\n        const mainAlias = relation.entityMetadata.targetName\n\n        // select all columns we need\n        const qb = this.connection.createQueryBuilder()\n        relation.entityMetadata.primaryColumns.forEach((primaryColumn) => {\n            const columnName = DriverUtils.buildAlias(\n                this.connection.driver,\n                primaryColumn.entityMetadata.name +\n                    \"_\" +\n                    relation.inverseRelation!.propertyPath.replace(\".\", \"_\") +\n                    \"_\" +\n                    primaryColumn.propertyPath.replace(\".\", \"_\"),\n            )\n            qb.addSelect(\n                mainAlias + \".\" + primaryColumn.propertyPath,\n                columnName,\n            )\n        })\n        relation.joinColumns.forEach((column) => {\n            const columnName = DriverUtils.buildAlias(\n                this.connection.driver,\n                column.referencedColumn!.entityMetadata.name +\n                    \"_\" +\n                    column.referencedColumn!.propertyPath.replace(\".\", \"_\"),\n            )\n            qb.addSelect(mainAlias + \".\" + column.propertyPath, columnName)\n        })\n\n        // add condition for entities\n        let condition: string = \"\"\n        if (relation.joinColumns.length === 1) {\n            const values = entities.map((entity) =>\n                relation.joinColumns[0].referencedColumn!.getEntityValue(\n                    entity,\n                ),\n            )\n            const areAllNumbers = values.every(\n                (value) => typeof value === \"number\",\n            )\n\n            if (areAllNumbers) {\n                condition = `${mainAlias}.${\n                    relation.joinColumns[0].propertyPath\n                } IN (${values.join(\", \")})`\n            } else {\n                qb.setParameter(\"values\", values)\n                condition =\n                    mainAlias +\n                    \".\" +\n                    relation.joinColumns[0].propertyPath +\n                    \" IN (:...values)\" // todo: use ANY for postgres\n            }\n        } else {\n            condition = entities\n                .map((entity, entityIndex) => {\n                    return relation.joinColumns\n                        .map((joinColumn, joinColumnIndex) => {\n                            const paramName =\n                                \"entity\" + entityIndex + \"_\" + joinColumnIndex\n                            qb.setParameter(\n                                paramName,\n                                joinColumn.referencedColumn!.getEntityValue(\n                                    entity,\n                                ),\n                            )\n                            return (\n                                mainAlias +\n                                \".\" +\n                                joinColumn.propertyPath +\n                                \" = :\" +\n                                paramName\n                            )\n                        })\n                        .join(\" AND \")\n                })\n                .map((condition) => \"(\" + condition + \")\")\n                .join(\" OR \")\n        }\n\n        // execute query\n        return qb\n            .from(relation.entityMetadata.target, mainAlias)\n            .where(condition)\n            .getRawMany()\n    }\n}\n"]},"metadata":{},"sourceType":"module"}