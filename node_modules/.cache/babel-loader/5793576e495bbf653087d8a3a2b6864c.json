{"ast":null,"code":"import { DateUtils } from \"../../util/DateUtils\";\nimport { RdbmsSchemaBuilder } from \"../../schema-builder/RdbmsSchemaBuilder\";\nimport { OrmUtils } from \"../../util/OrmUtils\";\nimport { ApplyValueTransformers } from \"../../util/ApplyValueTransformers\";\nimport { DriverUtils } from \"../DriverUtils\";\nimport { TypeORMError } from \"../../error\";\nimport { InstanceChecker } from \"../../util/InstanceChecker\";\n/**\n * Organizes communication with sqlite DBMS.\n */\n\nexport class AbstractSqliteDriver {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection) {\n    /**\n     * Indicates if replication is enabled.\n     */\n    this.isReplicated = false;\n    /**\n     * Indicates if tree tables are supported by this driver.\n     */\n\n    this.treeSupport = true;\n    /**\n     * Represent transaction support by this driver\n     */\n\n    this.transactionSupport = \"nested\";\n    /**\n     * Gets list of supported column data types by a driver.\n     *\n     * @see https://www.tutorialspoint.com/sqlite/sqlite_data_types.htm\n     * @see https://sqlite.org/datatype3.html\n     */\n\n    this.supportedDataTypes = [\"int\", \"integer\", \"tinyint\", \"smallint\", \"mediumint\", \"bigint\", \"unsigned big int\", \"int2\", \"int8\", \"integer\", \"character\", \"varchar\", \"varying character\", \"nchar\", \"native character\", \"nvarchar\", \"text\", \"clob\", \"text\", \"blob\", \"real\", \"double\", \"double precision\", \"float\", \"real\", \"numeric\", \"decimal\", \"boolean\", \"date\", \"time\", \"datetime\"];\n    /**\n     * Returns type of upsert supported by driver if any\n     */\n\n    this.supportedUpsertType = \"on-conflict-do-update\";\n    /**\n     * Gets list of column data types that support length by a driver.\n     */\n\n    this.withLengthColumnTypes = [\"character\", \"varchar\", \"varying character\", \"nchar\", \"native character\", \"nvarchar\", \"text\", \"blob\", \"clob\"];\n    /**\n     * Gets list of spatial column data types.\n     */\n\n    this.spatialTypes = [];\n    /**\n     * Gets list of column data types that support precision by a driver.\n     */\n\n    this.withPrecisionColumnTypes = [\"real\", \"double\", \"double precision\", \"float\", \"real\", \"numeric\", \"decimal\", \"date\", \"time\", \"datetime\"];\n    /**\n     * Gets list of column data types that support scale by a driver.\n     */\n\n    this.withScaleColumnTypes = [\"real\", \"double\", \"double precision\", \"float\", \"real\", \"numeric\", \"decimal\"];\n    /**\n     * Orm has special columns and we need to know what database column types should be for those types.\n     * Column types are driver dependant.\n     */\n\n    this.mappedDataTypes = {\n      createDate: \"datetime\",\n      createDateDefault: \"datetime('now')\",\n      updateDate: \"datetime\",\n      updateDateDefault: \"datetime('now')\",\n      deleteDate: \"datetime\",\n      deleteDateNullable: true,\n      version: \"integer\",\n      treeLevel: \"integer\",\n      migrationId: \"integer\",\n      migrationName: \"varchar\",\n      migrationTimestamp: \"bigint\",\n      cacheId: \"int\",\n      cacheIdentifier: \"varchar\",\n      cacheTime: \"bigint\",\n      cacheDuration: \"int\",\n      cacheQuery: \"text\",\n      cacheResult: \"text\",\n      metadataType: \"varchar\",\n      metadataDatabase: \"varchar\",\n      metadataSchema: \"varchar\",\n      metadataTable: \"varchar\",\n      metadataName: \"varchar\",\n      metadataValue: \"text\"\n    };\n    this.cteCapabilities = {\n      enabled: true,\n      requiresRecursiveHint: true\n    }; // -------------------------------------------------------------------------\n    // Protected Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Any attached databases (excepting default 'main')\n     */\n\n    this.attachedDatabases = {};\n    this.connection = connection;\n    this.options = connection.options;\n    this.database = DriverUtils.buildDriverOptions(this.options).database;\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Performs connection to the database.\n   */\n\n\n  async connect() {\n    this.databaseConnection = await this.createDatabaseConnection();\n  }\n  /**\n   * Makes any action after connection (e.g. create extensions in Postgres driver).\n   */\n\n\n  afterConnect() {\n    return Promise.resolve();\n  }\n  /**\n   * Closes connection with database.\n   */\n\n\n  async disconnect() {\n    return new Promise((ok, fail) => {\n      this.queryRunner = undefined;\n      this.databaseConnection.close(err => err ? fail(err) : ok());\n    });\n  }\n\n  hasAttachedDatabases() {\n    return !!Object.keys(this.attachedDatabases).length;\n  }\n\n  getAttachedDatabaseHandleByRelativePath(path) {\n    var _a, _b;\n\n    return (_b = (_a = this.attachedDatabases) === null || _a === void 0 ? void 0 : _a[path]) === null || _b === void 0 ? void 0 : _b.attachHandle;\n  }\n\n  getAttachedDatabasePathRelativeByHandle(handle) {\n    var _a;\n\n    return (_a = Object.values(this.attachedDatabases).find(_ref => {\n      let {\n        attachHandle\n      } = _ref;\n      return handle === attachHandle;\n    })) === null || _a === void 0 ? void 0 : _a.attachFilepathRelative;\n  }\n  /**\n   * Creates a schema builder used to build and sync a schema.\n   */\n\n\n  createSchemaBuilder() {\n    return new RdbmsSchemaBuilder(this.connection);\n  }\n  /**\n   * Prepares given value to a value to be persisted, based on its column type and metadata.\n   */\n\n\n  preparePersistentValue(value, columnMetadata) {\n    if (columnMetadata.transformer) value = ApplyValueTransformers.transformTo(columnMetadata.transformer, value);\n    if (value === null || value === undefined) return value;\n\n    if (columnMetadata.type === Boolean || columnMetadata.type === \"boolean\") {\n      return value === true ? 1 : 0;\n    } else if (columnMetadata.type === \"date\") {\n      return DateUtils.mixedDateToDateString(value);\n    } else if (columnMetadata.type === \"time\") {\n      return DateUtils.mixedDateToTimeString(value);\n    } else if (columnMetadata.type === \"datetime\" || columnMetadata.type === Date) {\n      // to string conversation needs because SQLite stores date as integer number, when date came as Object\n      // TODO: think about `toUTC` conversion\n      return DateUtils.mixedDateToUtcDatetimeString(value);\n    } else if (columnMetadata.type === \"simple-array\") {\n      return DateUtils.simpleArrayToString(value);\n    } else if (columnMetadata.type === \"simple-json\") {\n      return DateUtils.simpleJsonToString(value);\n    } else if (columnMetadata.type === \"simple-enum\") {\n      return DateUtils.simpleEnumToString(value);\n    }\n\n    return value;\n  }\n  /**\n   * Prepares given value to a value to be hydrated, based on its column type or metadata.\n   */\n\n\n  prepareHydratedValue(value, columnMetadata) {\n    if (value === null || value === undefined) return columnMetadata.transformer ? ApplyValueTransformers.transformFrom(columnMetadata.transformer, value) : value;\n\n    if (columnMetadata.type === Boolean || columnMetadata.type === \"boolean\") {\n      value = value ? true : false;\n    } else if (columnMetadata.type === \"datetime\" || columnMetadata.type === Date) {\n      /**\n       * Fix date conversion issue\n       *\n       * If the format of the date string is \"2018-03-14 02:33:33.906\", Safari (and iOS WKWebView) will convert it to an invalid date object.\n       * We need to modify the date string to \"2018-03-14T02:33:33.906Z\" and Safari will convert it correctly.\n       *\n       * ISO 8601\n       * https://www.w3.org/TR/NOTE-datetime\n       */\n      if (value && typeof value === \"string\") {\n        // There are various valid time string formats a sqlite time string might have:\n        // https://www.sqlite.org/lang_datefunc.html\n        // There are two separate fixes we may need to do:\n        //   1) Add 'T' separator if space is used instead\n        //   2) Add 'Z' UTC suffix if no timezone or offset specified\n        if (/^\\d\\d\\d\\d-\\d\\d-\\d\\d \\d\\d:\\d\\d/.test(value)) {\n          value = value.replace(\" \", \"T\");\n        }\n\n        if (/^\\d\\d\\d\\d-\\d\\d-\\d\\dT\\d\\d:\\d\\d(:\\d\\d(\\.\\d\\d\\d)?)?$/.test(value)) {\n          value += \"Z\";\n        }\n      }\n\n      value = DateUtils.normalizeHydratedDate(value);\n    } else if (columnMetadata.type === \"date\") {\n      value = DateUtils.mixedDateToDateString(value);\n    } else if (columnMetadata.type === \"time\") {\n      value = DateUtils.mixedTimeToString(value);\n    } else if (columnMetadata.type === \"simple-array\") {\n      value = DateUtils.stringToSimpleArray(value);\n    } else if (columnMetadata.type === \"simple-json\") {\n      value = DateUtils.stringToSimpleJson(value);\n    } else if (columnMetadata.type === \"simple-enum\") {\n      value = DateUtils.stringToSimpleEnum(value, columnMetadata);\n    }\n\n    if (columnMetadata.transformer) value = ApplyValueTransformers.transformFrom(columnMetadata.transformer, value);\n    return value;\n  }\n  /**\n   * Replaces parameters in the given sql with special escaping character\n   * and an array of parameter names to be passed to a query.\n   */\n\n\n  escapeQueryWithParameters(sql, parameters, nativeParameters) {\n    const escapedParameters = Object.keys(nativeParameters).map(key => {\n      // Mapping boolean values to their numeric representation\n      if (typeof nativeParameters[key] === \"boolean\") {\n        return nativeParameters[key] === true ? 1 : 0;\n      }\n\n      if (nativeParameters[key] instanceof Date) {\n        return DateUtils.mixedDateToUtcDatetimeString(nativeParameters[key]);\n      }\n\n      return nativeParameters[key];\n    });\n    if (!parameters || !Object.keys(parameters).length) return [sql, escapedParameters];\n    sql = sql.replace(/:(\\.\\.\\.)?([A-Za-z0-9_.]+)/g, (full, isArray, key) => {\n      if (!parameters.hasOwnProperty(key)) {\n        return full;\n      }\n\n      let value = parameters[key];\n\n      if (isArray) {\n        return value.map(v => {\n          escapedParameters.push(v);\n          return this.createParameter(key, escapedParameters.length - 1);\n        }).join(\", \");\n      }\n\n      if (typeof value === \"function\") {\n        return value();\n      } else if (typeof value === \"number\") {\n        return String(value);\n      }\n\n      if (value instanceof Date) {\n        escapedParameters.push(DateUtils.mixedDateToUtcDatetimeString(value));\n        return this.createParameter(key, escapedParameters.length - 1);\n      }\n\n      escapedParameters.push(value);\n      return this.createParameter(key, escapedParameters.length - 1);\n    }); // todo: make replace only in value statements, otherwise problems\n\n    return [sql, escapedParameters];\n  }\n  /**\n   * Escapes a column name.\n   */\n\n\n  escape(columnName) {\n    return '\"' + columnName + '\"';\n  }\n  /**\n   * Build full table name with database name, schema name and table name.\n   * E.g. myDB.mySchema.myTable\n   *\n   * Returns only simple table name because all inherited drivers does not supports schema and database.\n   */\n\n\n  buildTableName(tableName, schema, database) {\n    return tableName;\n  }\n  /**\n   * Parse a target table name or other types and return a normalized table definition.\n   */\n\n\n  parseTableName(target) {\n    var _a;\n\n    const driverDatabase = this.database;\n    const driverSchema = undefined;\n\n    if (InstanceChecker.isTable(target) || InstanceChecker.isView(target)) {\n      const parsed = this.parseTableName(target.schema ? `\"${target.schema}\".\"${target.name}\"` : target.name);\n      return {\n        database: target.database || parsed.database || driverDatabase,\n        schema: target.schema || parsed.schema || driverSchema,\n        tableName: parsed.tableName\n      };\n    }\n\n    if (InstanceChecker.isTableForeignKey(target)) {\n      const parsed = this.parseTableName(target.referencedTableName);\n      return {\n        database: target.referencedDatabase || parsed.database || driverDatabase,\n        schema: target.referencedSchema || parsed.schema || driverSchema,\n        tableName: parsed.tableName\n      };\n    }\n\n    if (InstanceChecker.isEntityMetadata(target)) {\n      // EntityMetadata tableName is never a path\n      return {\n        database: target.database || driverDatabase,\n        schema: target.schema || driverSchema,\n        tableName: target.tableName\n      };\n    }\n\n    const parts = target.split(\".\");\n\n    if (parts.length === 3) {\n      return {\n        database: parts[0] || driverDatabase,\n        schema: parts[1] || driverSchema,\n        tableName: parts[2]\n      };\n    } else if (parts.length === 2) {\n      const database = (_a = this.getAttachedDatabasePathRelativeByHandle(parts[0])) !== null && _a !== void 0 ? _a : driverDatabase;\n      return {\n        database: database,\n        schema: parts[0],\n        tableName: parts[1]\n      };\n    } else {\n      return {\n        database: driverDatabase,\n        schema: driverSchema,\n        tableName: target\n      };\n    }\n  }\n  /**\n   * Creates a database type from a given column metadata.\n   */\n\n\n  normalizeType(column) {\n    if (column.type === Number || column.type === \"int\") {\n      return \"integer\";\n    } else if (column.type === String) {\n      return \"varchar\";\n    } else if (column.type === Date) {\n      return \"datetime\";\n    } else if (column.type === Boolean) {\n      return \"boolean\";\n    } else if (column.type === \"uuid\") {\n      return \"varchar\";\n    } else if (column.type === \"simple-array\") {\n      return \"text\";\n    } else if (column.type === \"simple-json\") {\n      return \"text\";\n    } else if (column.type === \"simple-enum\") {\n      return \"varchar\";\n    } else {\n      return column.type || \"\";\n    }\n  }\n  /**\n   * Normalizes \"default\" value of the column.\n   */\n\n\n  normalizeDefault(columnMetadata) {\n    const defaultValue = columnMetadata.default;\n\n    if (typeof defaultValue === \"number\") {\n      return \"\" + defaultValue;\n    }\n\n    if (typeof defaultValue === \"boolean\") {\n      return defaultValue ? \"1\" : \"0\";\n    }\n\n    if (typeof defaultValue === \"function\") {\n      return defaultValue();\n    }\n\n    if (typeof defaultValue === \"string\") {\n      return `'${defaultValue}'`;\n    }\n\n    if (defaultValue === null || defaultValue === undefined) {\n      return undefined;\n    }\n\n    return `${defaultValue}`;\n  }\n  /**\n   * Normalizes \"isUnique\" value of the column.\n   */\n\n\n  normalizeIsUnique(column) {\n    return column.entityMetadata.uniques.some(uq => uq.columns.length === 1 && uq.columns[0] === column);\n  }\n  /**\n   * Calculates column length taking into account the default length values.\n   */\n\n\n  getColumnLength(column) {\n    return column.length ? column.length.toString() : \"\";\n  }\n  /**\n   * Normalizes \"default\" value of the column.\n   */\n\n\n  createFullType(column) {\n    let type = column.type;\n\n    if (column.enum) {\n      return \"varchar\";\n    }\n\n    if (column.length) {\n      type += \"(\" + column.length + \")\";\n    } else if (column.precision !== null && column.precision !== undefined && column.scale !== null && column.scale !== undefined) {\n      type += \"(\" + column.precision + \",\" + column.scale + \")\";\n    } else if (column.precision !== null && column.precision !== undefined) {\n      type += \"(\" + column.precision + \")\";\n    }\n\n    if (column.isArray) type += \" array\";\n    return type;\n  }\n  /**\n   * Obtains a new database connection to a master server.\n   * Used for replication.\n   * If replication is not setup then returns default connection's database connection.\n   */\n\n\n  obtainMasterConnection() {\n    return Promise.resolve();\n  }\n  /**\n   * Obtains a new database connection to a slave server.\n   * Used for replication.\n   * If replication is not setup then returns master (default) connection's database connection.\n   */\n\n\n  obtainSlaveConnection() {\n    return Promise.resolve();\n  }\n  /**\n   * Creates generated map of values generated or returned by database after INSERT query.\n   */\n\n\n  createGeneratedMap(metadata, insertResult, entityIndex, entityNum) {\n    const generatedMap = metadata.generatedColumns.reduce((map, generatedColumn) => {\n      let value;\n\n      if (generatedColumn.generationStrategy === \"increment\" && insertResult) {\n        // NOTE: When INSERT statement is successfully completed, the last inserted row ID is returned.\n        // see also: SqliteQueryRunner.query()\n        value = insertResult - entityNum + entityIndex + 1; // } else if (generatedColumn.generationStrategy === \"uuid\") {\n        //     value = insertValue[generatedColumn.databaseName];\n      }\n\n      if (!value) return map;\n      return OrmUtils.mergeDeep(map, generatedColumn.createValueMap(value));\n    }, {});\n    return Object.keys(generatedMap).length > 0 ? generatedMap : undefined;\n  }\n  /**\n   * Differentiate columns of this table and columns from the given column metadatas columns\n   * and returns only changed.\n   */\n\n\n  findChangedColumns(tableColumns, columnMetadatas) {\n    return columnMetadatas.filter(columnMetadata => {\n      const tableColumn = tableColumns.find(c => c.name === columnMetadata.databaseName);\n      if (!tableColumn) return false; // we don't need new columns, we only need exist and changed\n\n      const isColumnChanged = tableColumn.name !== columnMetadata.databaseName || tableColumn.type !== this.normalizeType(columnMetadata) || tableColumn.length !== columnMetadata.length || tableColumn.precision !== columnMetadata.precision || tableColumn.scale !== columnMetadata.scale || this.normalizeDefault(columnMetadata) !== tableColumn.default || tableColumn.isPrimary !== columnMetadata.isPrimary || tableColumn.isNullable !== columnMetadata.isNullable || tableColumn.generatedType !== columnMetadata.generatedType || tableColumn.asExpression !== columnMetadata.asExpression || tableColumn.isUnique !== this.normalizeIsUnique(columnMetadata) || columnMetadata.generationStrategy !== \"uuid\" && tableColumn.isGenerated !== columnMetadata.isGenerated; // DEBUG SECTION\n      // if (isColumnChanged) {\n      //     console.log(\"table:\", columnMetadata.entityMetadata.tableName)\n      //     console.log(\n      //         \"name:\",\n      //         tableColumn.name,\n      //         columnMetadata.databaseName,\n      //     )\n      //     console.log(\n      //         \"type:\",\n      //         tableColumn.type,\n      //         this.normalizeType(columnMetadata),\n      //     )\n      //     console.log(\n      //         \"length:\",\n      //         tableColumn.length,\n      //         columnMetadata.length,\n      //     )\n      //     console.log(\n      //         \"precision:\",\n      //         tableColumn.precision,\n      //         columnMetadata.precision,\n      //     )\n      //     console.log(\"scale:\", tableColumn.scale, columnMetadata.scale)\n      //     console.log(\n      //         \"default:\",\n      //         this.normalizeDefault(columnMetadata),\n      //         columnMetadata.default,\n      //     )\n      //     console.log(\n      //         \"isPrimary:\",\n      //         tableColumn.isPrimary,\n      //         columnMetadata.isPrimary,\n      //     )\n      //     console.log(\n      //         \"isNullable:\",\n      //         tableColumn.isNullable,\n      //         columnMetadata.isNullable,\n      //     )\n      //     console.log(\n      //         \"generatedType:\",\n      //         tableColumn.generatedType,\n      //         columnMetadata.generatedType,\n      //     )\n      //     console.log(\n      //         \"asExpression:\",\n      //         tableColumn.asExpression,\n      //         columnMetadata.asExpression,\n      //     )\n      //     console.log(\n      //         \"isUnique:\",\n      //         tableColumn.isUnique,\n      //         this.normalizeIsUnique(columnMetadata),\n      //     )\n      //     console.log(\n      //         \"isGenerated:\",\n      //         tableColumn.isGenerated,\n      //         columnMetadata.isGenerated,\n      //     )\n      // }\n\n      return isColumnChanged;\n    });\n  }\n  /**\n   * Returns true if driver supports RETURNING / OUTPUT statement.\n   */\n\n\n  isReturningSqlSupported() {\n    return false;\n  }\n  /**\n   * Returns true if driver supports uuid values generation on its own.\n   */\n\n\n  isUUIDGenerationSupported() {\n    return false;\n  }\n  /**\n   * Returns true if driver supports fulltext indices.\n   */\n\n\n  isFullTextColumnTypeSupported() {\n    return false;\n  }\n  /**\n   * Creates an escaped parameter.\n   */\n\n\n  createParameter(parameterName, index) {\n    // return \"$\" + (index + 1);\n    return \"?\"; // return \"$\" + parameterName;\n  } // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Creates connection with the database.\n   */\n\n\n  createDatabaseConnection() {\n    throw new TypeORMError(\"Do not use AbstractSqlite directly, it has to be used with one of the sqlite drivers\");\n  }\n  /**\n   * If driver dependency is not given explicitly, then try to load it via \"require\".\n   */\n\n\n  loadDependencies() {// dependencies have to be loaded in the specific driver\n  }\n\n}","map":{"version":3,"mappings":"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","names":["DateUtils","RdbmsSchemaBuilder","OrmUtils","ApplyValueTransformers","DriverUtils","TypeORMError","InstanceChecker","AbstractSqliteDriver","constructor","connection","createDate","createDateDefault","updateDate","updateDateDefault","deleteDate","deleteDateNullable","version","treeLevel","migrationId","migrationName","migrationTimestamp","cacheId","cacheIdentifier","cacheTime","cacheDuration","cacheQuery","cacheResult","metadataType","metadataDatabase","metadataSchema","metadataTable","metadataName","metadataValue","enabled","requiresRecursiveHint","options","database","buildDriverOptions","connect","databaseConnection","createDatabaseConnection","afterConnect","Promise","resolve","disconnect","ok","fail","queryRunner","undefined","close","err","hasAttachedDatabases","Object","keys","attachedDatabases","length","getAttachedDatabaseHandleByRelativePath","path","_a","_b","attachHandle","getAttachedDatabasePathRelativeByHandle","handle","values","find","attachFilepathRelative","createSchemaBuilder","preparePersistentValue","value","columnMetadata","transformer","transformTo","type","Boolean","mixedDateToDateString","mixedDateToTimeString","Date","mixedDateToUtcDatetimeString","simpleArrayToString","simpleJsonToString","simpleEnumToString","prepareHydratedValue","transformFrom","test","replace","normalizeHydratedDate","mixedTimeToString","stringToSimpleArray","stringToSimpleJson","stringToSimpleEnum","escapeQueryWithParameters","sql","parameters","nativeParameters","escapedParameters","map","key","full","isArray","hasOwnProperty","v","push","createParameter","join","String","escape","columnName","buildTableName","tableName","schema","parseTableName","target","driverDatabase","driverSchema","isTable","isView","parsed","name","isTableForeignKey","referencedTableName","referencedDatabase","referencedSchema","isEntityMetadata","parts","split","normalizeType","column","Number","normalizeDefault","defaultValue","default","normalizeIsUnique","entityMetadata","uniques","some","uq","columns","getColumnLength","toString","createFullType","enum","precision","scale","obtainMasterConnection","obtainSlaveConnection","createGeneratedMap","metadata","insertResult","entityIndex","entityNum","generatedMap","generatedColumns","reduce","generatedColumn","generationStrategy","mergeDeep","createValueMap","findChangedColumns","tableColumns","columnMetadatas","filter","tableColumn","c","databaseName","isColumnChanged","isPrimary","isNullable","generatedType","asExpression","isUnique","isGenerated","isReturningSqlSupported","isUUIDGenerationSupported","isFullTextColumnTypeSupported","parameterName","index","loadDependencies"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\driver\\sqlite-abstract\\AbstractSqliteDriver.ts"],"sourcesContent":["import { Driver } from \"../Driver\"\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { ColumnMetadata } from \"../../metadata/ColumnMetadata\"\nimport { DateUtils } from \"../../util/DateUtils\"\nimport { DataSource } from \"../../data-source/DataSource\"\nimport { RdbmsSchemaBuilder } from \"../../schema-builder/RdbmsSchemaBuilder\"\nimport { CteCapabilities } from \"../types/CteCapabilities\"\nimport { MappedColumnTypes } from \"../types/MappedColumnTypes\"\nimport { ColumnType } from \"../types/ColumnTypes\"\nimport { QueryRunner } from \"../../query-runner/QueryRunner\"\nimport { DataTypeDefaults } from \"../types/DataTypeDefaults\"\nimport { TableColumn } from \"../../schema-builder/table/TableColumn\"\nimport { BaseDataSourceOptions } from \"../../data-source/BaseDataSourceOptions\"\nimport { EntityMetadata } from \"../../metadata/EntityMetadata\"\nimport { OrmUtils } from \"../../util/OrmUtils\"\nimport { ApplyValueTransformers } from \"../../util/ApplyValueTransformers\"\nimport { ReplicationMode } from \"../types/ReplicationMode\"\nimport { DriverUtils } from \"../DriverUtils\"\nimport { TypeORMError } from \"../../error\"\nimport { Table } from \"../../schema-builder/table/Table\"\nimport { View } from \"../../schema-builder/view/View\"\nimport { TableForeignKey } from \"../../schema-builder/table/TableForeignKey\"\nimport { InstanceChecker } from \"../../util/InstanceChecker\"\n\ntype DatabasesMap = Record<\n    string,\n    {\n        attachFilepathAbsolute: string\n        attachFilepathRelative: string\n        attachHandle: string\n    }\n>\n\n/**\n * Organizes communication with sqlite DBMS.\n */\nexport abstract class AbstractSqliteDriver implements Driver {\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Connection used by driver.\n     */\n    connection: DataSource\n\n    /**\n     * Sqlite has a single QueryRunner because it works on a single database connection.\n     */\n    queryRunner?: QueryRunner\n\n    /**\n     * Real database connection with sqlite database.\n     */\n    databaseConnection: any\n\n    // -------------------------------------------------------------------------\n    // Public Implemented Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Connection options.\n     */\n    options: BaseDataSourceOptions\n\n    /**\n     * Master database used to perform all write queries.\n     */\n    database?: string\n\n    /**\n     * Indicates if replication is enabled.\n     */\n    isReplicated: boolean = false\n\n    /**\n     * SQLite underlying library.\n     */\n    sqlite: any\n\n    /**\n     * Indicates if tree tables are supported by this driver.\n     */\n    treeSupport = true\n\n    /**\n     * Represent transaction support by this driver\n     */\n    transactionSupport: \"simple\" | \"nested\" | \"none\" = \"nested\"\n\n    /**\n     * Gets list of supported column data types by a driver.\n     *\n     * @see https://www.tutorialspoint.com/sqlite/sqlite_data_types.htm\n     * @see https://sqlite.org/datatype3.html\n     */\n    supportedDataTypes: ColumnType[] = [\n        \"int\",\n        \"integer\",\n        \"tinyint\",\n        \"smallint\",\n        \"mediumint\",\n        \"bigint\",\n        \"unsigned big int\",\n        \"int2\",\n        \"int8\",\n        \"integer\",\n        \"character\",\n        \"varchar\",\n        \"varying character\",\n        \"nchar\",\n        \"native character\",\n        \"nvarchar\",\n        \"text\",\n        \"clob\",\n        \"text\",\n        \"blob\",\n        \"real\",\n        \"double\",\n        \"double precision\",\n        \"float\",\n        \"real\",\n        \"numeric\",\n        \"decimal\",\n        \"boolean\",\n        \"date\",\n        \"time\",\n        \"datetime\",\n    ]\n\n    /**\n     * Returns type of upsert supported by driver if any\n     */\n    readonly supportedUpsertType = \"on-conflict-do-update\"\n\n    /**\n     * Gets list of column data types that support length by a driver.\n     */\n    withLengthColumnTypes: ColumnType[] = [\n        \"character\",\n        \"varchar\",\n        \"varying character\",\n        \"nchar\",\n        \"native character\",\n        \"nvarchar\",\n        \"text\",\n        \"blob\",\n        \"clob\",\n    ]\n\n    /**\n     * Gets list of spatial column data types.\n     */\n    spatialTypes: ColumnType[] = []\n\n    /**\n     * Gets list of column data types that support precision by a driver.\n     */\n    withPrecisionColumnTypes: ColumnType[] = [\n        \"real\",\n        \"double\",\n        \"double precision\",\n        \"float\",\n        \"real\",\n        \"numeric\",\n        \"decimal\",\n        \"date\",\n        \"time\",\n        \"datetime\",\n    ]\n\n    /**\n     * Gets list of column data types that support scale by a driver.\n     */\n    withScaleColumnTypes: ColumnType[] = [\n        \"real\",\n        \"double\",\n        \"double precision\",\n        \"float\",\n        \"real\",\n        \"numeric\",\n        \"decimal\",\n    ]\n\n    /**\n     * Orm has special columns and we need to know what database column types should be for those types.\n     * Column types are driver dependant.\n     */\n    mappedDataTypes: MappedColumnTypes = {\n        createDate: \"datetime\",\n        createDateDefault: \"datetime('now')\",\n        updateDate: \"datetime\",\n        updateDateDefault: \"datetime('now')\",\n        deleteDate: \"datetime\",\n        deleteDateNullable: true,\n        version: \"integer\",\n        treeLevel: \"integer\",\n        migrationId: \"integer\",\n        migrationName: \"varchar\",\n        migrationTimestamp: \"bigint\",\n        cacheId: \"int\",\n        cacheIdentifier: \"varchar\",\n        cacheTime: \"bigint\",\n        cacheDuration: \"int\",\n        cacheQuery: \"text\",\n        cacheResult: \"text\",\n        metadataType: \"varchar\",\n        metadataDatabase: \"varchar\",\n        metadataSchema: \"varchar\",\n        metadataTable: \"varchar\",\n        metadataName: \"varchar\",\n        metadataValue: \"text\",\n    }\n\n    /**\n     * Default values of length, precision and scale depends on column data type.\n     * Used in the cases when length/precision/scale is not specified by user.\n     */\n    dataTypeDefaults: DataTypeDefaults\n\n    /**\n     * No documentation specifying a maximum length for identifiers could be found\n     * for SQLite.\n     */\n    maxAliasLength?: number\n\n    cteCapabilities: CteCapabilities = {\n        enabled: true,\n        requiresRecursiveHint: true,\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Any attached databases (excepting default 'main')\n     */\n    attachedDatabases: DatabasesMap = {}\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(connection: DataSource) {\n        this.connection = connection\n        this.options = connection.options as BaseDataSourceOptions\n\n        this.database = DriverUtils.buildDriverOptions(this.options).database\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Abstract\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates a query runner used to execute database queries.\n     */\n    abstract createQueryRunner(mode: ReplicationMode): QueryRunner\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Performs connection to the database.\n     */\n    async connect(): Promise<void> {\n        this.databaseConnection = await this.createDatabaseConnection()\n    }\n\n    /**\n     * Makes any action after connection (e.g. create extensions in Postgres driver).\n     */\n    afterConnect(): Promise<void> {\n        return Promise.resolve()\n    }\n\n    /**\n     * Closes connection with database.\n     */\n    async disconnect(): Promise<void> {\n        return new Promise<void>((ok, fail) => {\n            this.queryRunner = undefined\n            this.databaseConnection.close((err: any) =>\n                err ? fail(err) : ok(),\n            )\n        })\n    }\n\n    hasAttachedDatabases(): boolean {\n        return !!Object.keys(this.attachedDatabases).length\n    }\n\n    getAttachedDatabaseHandleByRelativePath(path: string): string | undefined {\n        return this.attachedDatabases?.[path]?.attachHandle\n    }\n\n    getAttachedDatabasePathRelativeByHandle(\n        handle: string,\n    ): string | undefined {\n        return Object.values(this.attachedDatabases).find(\n            ({ attachHandle }) => handle === attachHandle,\n        )?.attachFilepathRelative\n    }\n\n    /**\n     * Creates a schema builder used to build and sync a schema.\n     */\n    createSchemaBuilder() {\n        return new RdbmsSchemaBuilder(this.connection)\n    }\n\n    /**\n     * Prepares given value to a value to be persisted, based on its column type and metadata.\n     */\n    preparePersistentValue(value: any, columnMetadata: ColumnMetadata): any {\n        if (columnMetadata.transformer)\n            value = ApplyValueTransformers.transformTo(\n                columnMetadata.transformer,\n                value,\n            )\n\n        if (value === null || value === undefined) return value\n\n        if (\n            columnMetadata.type === Boolean ||\n            columnMetadata.type === \"boolean\"\n        ) {\n            return value === true ? 1 : 0\n        } else if (columnMetadata.type === \"date\") {\n            return DateUtils.mixedDateToDateString(value)\n        } else if (columnMetadata.type === \"time\") {\n            return DateUtils.mixedDateToTimeString(value)\n        } else if (\n            columnMetadata.type === \"datetime\" ||\n            columnMetadata.type === Date\n        ) {\n            // to string conversation needs because SQLite stores date as integer number, when date came as Object\n            // TODO: think about `toUTC` conversion\n            return DateUtils.mixedDateToUtcDatetimeString(value)\n        } else if (columnMetadata.type === \"simple-array\") {\n            return DateUtils.simpleArrayToString(value)\n        } else if (columnMetadata.type === \"simple-json\") {\n            return DateUtils.simpleJsonToString(value)\n        } else if (columnMetadata.type === \"simple-enum\") {\n            return DateUtils.simpleEnumToString(value)\n        }\n\n        return value\n    }\n\n    /**\n     * Prepares given value to a value to be hydrated, based on its column type or metadata.\n     */\n    prepareHydratedValue(value: any, columnMetadata: ColumnMetadata): any {\n        if (value === null || value === undefined)\n            return columnMetadata.transformer\n                ? ApplyValueTransformers.transformFrom(\n                      columnMetadata.transformer,\n                      value,\n                  )\n                : value\n\n        if (\n            columnMetadata.type === Boolean ||\n            columnMetadata.type === \"boolean\"\n        ) {\n            value = value ? true : false\n        } else if (\n            columnMetadata.type === \"datetime\" ||\n            columnMetadata.type === Date\n        ) {\n            /**\n             * Fix date conversion issue\n             *\n             * If the format of the date string is \"2018-03-14 02:33:33.906\", Safari (and iOS WKWebView) will convert it to an invalid date object.\n             * We need to modify the date string to \"2018-03-14T02:33:33.906Z\" and Safari will convert it correctly.\n             *\n             * ISO 8601\n             * https://www.w3.org/TR/NOTE-datetime\n             */\n            if (value && typeof value === \"string\") {\n                // There are various valid time string formats a sqlite time string might have:\n                // https://www.sqlite.org/lang_datefunc.html\n                // There are two separate fixes we may need to do:\n                //   1) Add 'T' separator if space is used instead\n                //   2) Add 'Z' UTC suffix if no timezone or offset specified\n\n                if (/^\\d\\d\\d\\d-\\d\\d-\\d\\d \\d\\d:\\d\\d/.test(value)) {\n                    value = value.replace(\" \", \"T\")\n                }\n                if (\n                    /^\\d\\d\\d\\d-\\d\\d-\\d\\dT\\d\\d:\\d\\d(:\\d\\d(\\.\\d\\d\\d)?)?$/.test(\n                        value,\n                    )\n                ) {\n                    value += \"Z\"\n                }\n            }\n\n            value = DateUtils.normalizeHydratedDate(value)\n        } else if (columnMetadata.type === \"date\") {\n            value = DateUtils.mixedDateToDateString(value)\n        } else if (columnMetadata.type === \"time\") {\n            value = DateUtils.mixedTimeToString(value)\n        } else if (columnMetadata.type === \"simple-array\") {\n            value = DateUtils.stringToSimpleArray(value)\n        } else if (columnMetadata.type === \"simple-json\") {\n            value = DateUtils.stringToSimpleJson(value)\n        } else if (columnMetadata.type === \"simple-enum\") {\n            value = DateUtils.stringToSimpleEnum(value, columnMetadata)\n        }\n\n        if (columnMetadata.transformer)\n            value = ApplyValueTransformers.transformFrom(\n                columnMetadata.transformer,\n                value,\n            )\n\n        return value\n    }\n\n    /**\n     * Replaces parameters in the given sql with special escaping character\n     * and an array of parameter names to be passed to a query.\n     */\n    escapeQueryWithParameters(\n        sql: string,\n        parameters: ObjectLiteral,\n        nativeParameters: ObjectLiteral,\n    ): [string, any[]] {\n        const escapedParameters: any[] = Object.keys(nativeParameters).map(\n            (key) => {\n                // Mapping boolean values to their numeric representation\n                if (typeof nativeParameters[key] === \"boolean\") {\n                    return nativeParameters[key] === true ? 1 : 0\n                }\n\n                if (nativeParameters[key] instanceof Date) {\n                    return DateUtils.mixedDateToUtcDatetimeString(\n                        nativeParameters[key],\n                    )\n                }\n\n                return nativeParameters[key]\n            },\n        )\n\n        if (!parameters || !Object.keys(parameters).length)\n            return [sql, escapedParameters]\n\n        sql = sql.replace(\n            /:(\\.\\.\\.)?([A-Za-z0-9_.]+)/g,\n            (full, isArray: string, key: string): string => {\n                if (!parameters.hasOwnProperty(key)) {\n                    return full\n                }\n\n                let value: any = parameters[key]\n\n                if (isArray) {\n                    return value\n                        .map((v: any) => {\n                            escapedParameters.push(v)\n                            return this.createParameter(\n                                key,\n                                escapedParameters.length - 1,\n                            )\n                        })\n                        .join(\", \")\n                }\n\n                if (typeof value === \"function\") {\n                    return value()\n                } else if (typeof value === \"number\") {\n                    return String(value)\n                }\n\n                if (value instanceof Date) {\n                    escapedParameters.push(\n                        DateUtils.mixedDateToUtcDatetimeString(value),\n                    )\n                    return this.createParameter(\n                        key,\n                        escapedParameters.length - 1,\n                    )\n                }\n\n                escapedParameters.push(value)\n                return this.createParameter(key, escapedParameters.length - 1)\n            },\n        ) // todo: make replace only in value statements, otherwise problems\n        return [sql, escapedParameters]\n    }\n\n    /**\n     * Escapes a column name.\n     */\n    escape(columnName: string): string {\n        return '\"' + columnName + '\"'\n    }\n\n    /**\n     * Build full table name with database name, schema name and table name.\n     * E.g. myDB.mySchema.myTable\n     *\n     * Returns only simple table name because all inherited drivers does not supports schema and database.\n     */\n    buildTableName(\n        tableName: string,\n        schema?: string,\n        database?: string,\n    ): string {\n        return tableName\n    }\n\n    /**\n     * Parse a target table name or other types and return a normalized table definition.\n     */\n    parseTableName(\n        target: EntityMetadata | Table | View | TableForeignKey | string,\n    ): { database?: string; schema?: string; tableName: string } {\n        const driverDatabase = this.database\n        const driverSchema = undefined\n\n        if (InstanceChecker.isTable(target) || InstanceChecker.isView(target)) {\n            const parsed = this.parseTableName(\n                target.schema\n                    ? `\"${target.schema}\".\"${target.name}\"`\n                    : target.name,\n            )\n\n            return {\n                database: target.database || parsed.database || driverDatabase,\n                schema: target.schema || parsed.schema || driverSchema,\n                tableName: parsed.tableName,\n            }\n        }\n\n        if (InstanceChecker.isTableForeignKey(target)) {\n            const parsed = this.parseTableName(target.referencedTableName)\n\n            return {\n                database:\n                    target.referencedDatabase ||\n                    parsed.database ||\n                    driverDatabase,\n                schema:\n                    target.referencedSchema || parsed.schema || driverSchema,\n                tableName: parsed.tableName,\n            }\n        }\n\n        if (InstanceChecker.isEntityMetadata(target)) {\n            // EntityMetadata tableName is never a path\n\n            return {\n                database: target.database || driverDatabase,\n                schema: target.schema || driverSchema,\n                tableName: target.tableName,\n            }\n        }\n\n        const parts = target.split(\".\")\n\n        if (parts.length === 3) {\n            return {\n                database: parts[0] || driverDatabase,\n                schema: parts[1] || driverSchema,\n                tableName: parts[2],\n            }\n        } else if (parts.length === 2) {\n            const database =\n                this.getAttachedDatabasePathRelativeByHandle(parts[0]) ??\n                driverDatabase\n            return {\n                database: database,\n                schema: parts[0],\n                tableName: parts[1],\n            }\n        } else {\n            return {\n                database: driverDatabase,\n                schema: driverSchema,\n                tableName: target,\n            }\n        }\n    }\n\n    /**\n     * Creates a database type from a given column metadata.\n     */\n    normalizeType(column: {\n        type?: ColumnType\n        length?: number | string\n        precision?: number | null\n        scale?: number\n    }): string {\n        if (column.type === Number || column.type === \"int\") {\n            return \"integer\"\n        } else if (column.type === String) {\n            return \"varchar\"\n        } else if (column.type === Date) {\n            return \"datetime\"\n        } else if (column.type === Boolean) {\n            return \"boolean\"\n        } else if (column.type === \"uuid\") {\n            return \"varchar\"\n        } else if (column.type === \"simple-array\") {\n            return \"text\"\n        } else if (column.type === \"simple-json\") {\n            return \"text\"\n        } else if (column.type === \"simple-enum\") {\n            return \"varchar\"\n        } else {\n            return (column.type as string) || \"\"\n        }\n    }\n\n    /**\n     * Normalizes \"default\" value of the column.\n     */\n    normalizeDefault(columnMetadata: ColumnMetadata): string | undefined {\n        const defaultValue = columnMetadata.default\n\n        if (typeof defaultValue === \"number\") {\n            return \"\" + defaultValue\n        }\n\n        if (typeof defaultValue === \"boolean\") {\n            return defaultValue ? \"1\" : \"0\"\n        }\n\n        if (typeof defaultValue === \"function\") {\n            return defaultValue()\n        }\n\n        if (typeof defaultValue === \"string\") {\n            return `'${defaultValue}'`\n        }\n\n        if (defaultValue === null || defaultValue === undefined) {\n            return undefined\n        }\n\n        return `${defaultValue}`\n    }\n\n    /**\n     * Normalizes \"isUnique\" value of the column.\n     */\n    normalizeIsUnique(column: ColumnMetadata): boolean {\n        return column.entityMetadata.uniques.some(\n            (uq) => uq.columns.length === 1 && uq.columns[0] === column,\n        )\n    }\n\n    /**\n     * Calculates column length taking into account the default length values.\n     */\n    getColumnLength(column: ColumnMetadata): string {\n        return column.length ? column.length.toString() : \"\"\n    }\n\n    /**\n     * Normalizes \"default\" value of the column.\n     */\n    createFullType(column: TableColumn): string {\n        let type = column.type\n        if (column.enum) {\n            return \"varchar\"\n        }\n        if (column.length) {\n            type += \"(\" + column.length + \")\"\n        } else if (\n            column.precision !== null &&\n            column.precision !== undefined &&\n            column.scale !== null &&\n            column.scale !== undefined\n        ) {\n            type += \"(\" + column.precision + \",\" + column.scale + \")\"\n        } else if (\n            column.precision !== null &&\n            column.precision !== undefined\n        ) {\n            type += \"(\" + column.precision + \")\"\n        }\n\n        if (column.isArray) type += \" array\"\n\n        return type\n    }\n\n    /**\n     * Obtains a new database connection to a master server.\n     * Used for replication.\n     * If replication is not setup then returns default connection's database connection.\n     */\n    obtainMasterConnection(): Promise<any> {\n        return Promise.resolve()\n    }\n\n    /**\n     * Obtains a new database connection to a slave server.\n     * Used for replication.\n     * If replication is not setup then returns master (default) connection's database connection.\n     */\n    obtainSlaveConnection(): Promise<any> {\n        return Promise.resolve()\n    }\n\n    /**\n     * Creates generated map of values generated or returned by database after INSERT query.\n     */\n    createGeneratedMap(\n        metadata: EntityMetadata,\n        insertResult: any,\n        entityIndex: number,\n        entityNum: number,\n    ) {\n        const generatedMap = metadata.generatedColumns.reduce(\n            (map, generatedColumn) => {\n                let value: any\n                if (\n                    generatedColumn.generationStrategy === \"increment\" &&\n                    insertResult\n                ) {\n                    // NOTE: When INSERT statement is successfully completed, the last inserted row ID is returned.\n                    // see also: SqliteQueryRunner.query()\n                    value = insertResult - entityNum + entityIndex + 1\n                    // } else if (generatedColumn.generationStrategy === \"uuid\") {\n                    //     value = insertValue[generatedColumn.databaseName];\n                }\n\n                if (!value) return map\n                return OrmUtils.mergeDeep(\n                    map,\n                    generatedColumn.createValueMap(value),\n                )\n            },\n            {} as ObjectLiteral,\n        )\n\n        return Object.keys(generatedMap).length > 0 ? generatedMap : undefined\n    }\n\n    /**\n     * Differentiate columns of this table and columns from the given column metadatas columns\n     * and returns only changed.\n     */\n    findChangedColumns(\n        tableColumns: TableColumn[],\n        columnMetadatas: ColumnMetadata[],\n    ): ColumnMetadata[] {\n        return columnMetadatas.filter((columnMetadata) => {\n            const tableColumn = tableColumns.find(\n                (c) => c.name === columnMetadata.databaseName,\n            )\n            if (!tableColumn) return false // we don't need new columns, we only need exist and changed\n\n            const isColumnChanged =\n                tableColumn.name !== columnMetadata.databaseName ||\n                tableColumn.type !== this.normalizeType(columnMetadata) ||\n                tableColumn.length !== columnMetadata.length ||\n                tableColumn.precision !== columnMetadata.precision ||\n                tableColumn.scale !== columnMetadata.scale ||\n                this.normalizeDefault(columnMetadata) !== tableColumn.default ||\n                tableColumn.isPrimary !== columnMetadata.isPrimary ||\n                tableColumn.isNullable !== columnMetadata.isNullable ||\n                tableColumn.generatedType !== columnMetadata.generatedType ||\n                tableColumn.asExpression !== columnMetadata.asExpression ||\n                tableColumn.isUnique !==\n                    this.normalizeIsUnique(columnMetadata) ||\n                (columnMetadata.generationStrategy !== \"uuid\" &&\n                    tableColumn.isGenerated !== columnMetadata.isGenerated)\n\n            // DEBUG SECTION\n            // if (isColumnChanged) {\n            //     console.log(\"table:\", columnMetadata.entityMetadata.tableName)\n            //     console.log(\n            //         \"name:\",\n            //         tableColumn.name,\n            //         columnMetadata.databaseName,\n            //     )\n            //     console.log(\n            //         \"type:\",\n            //         tableColumn.type,\n            //         this.normalizeType(columnMetadata),\n            //     )\n            //     console.log(\n            //         \"length:\",\n            //         tableColumn.length,\n            //         columnMetadata.length,\n            //     )\n            //     console.log(\n            //         \"precision:\",\n            //         tableColumn.precision,\n            //         columnMetadata.precision,\n            //     )\n            //     console.log(\"scale:\", tableColumn.scale, columnMetadata.scale)\n            //     console.log(\n            //         \"default:\",\n            //         this.normalizeDefault(columnMetadata),\n            //         columnMetadata.default,\n            //     )\n            //     console.log(\n            //         \"isPrimary:\",\n            //         tableColumn.isPrimary,\n            //         columnMetadata.isPrimary,\n            //     )\n            //     console.log(\n            //         \"isNullable:\",\n            //         tableColumn.isNullable,\n            //         columnMetadata.isNullable,\n            //     )\n            //     console.log(\n            //         \"generatedType:\",\n            //         tableColumn.generatedType,\n            //         columnMetadata.generatedType,\n            //     )\n            //     console.log(\n            //         \"asExpression:\",\n            //         tableColumn.asExpression,\n            //         columnMetadata.asExpression,\n            //     )\n            //     console.log(\n            //         \"isUnique:\",\n            //         tableColumn.isUnique,\n            //         this.normalizeIsUnique(columnMetadata),\n            //     )\n            //     console.log(\n            //         \"isGenerated:\",\n            //         tableColumn.isGenerated,\n            //         columnMetadata.isGenerated,\n            //     )\n            // }\n\n            return isColumnChanged\n        })\n    }\n\n    /**\n     * Returns true if driver supports RETURNING / OUTPUT statement.\n     */\n    isReturningSqlSupported(): boolean {\n        return false\n    }\n\n    /**\n     * Returns true if driver supports uuid values generation on its own.\n     */\n    isUUIDGenerationSupported(): boolean {\n        return false\n    }\n\n    /**\n     * Returns true if driver supports fulltext indices.\n     */\n    isFullTextColumnTypeSupported(): boolean {\n        return false\n    }\n\n    /**\n     * Creates an escaped parameter.\n     */\n    createParameter(parameterName: string, index: number): string {\n        // return \"$\" + (index + 1);\n        return \"?\"\n        // return \"$\" + parameterName;\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates connection with the database.\n     */\n    protected createDatabaseConnection() {\n        throw new TypeORMError(\n            \"Do not use AbstractSqlite directly, it has to be used with one of the sqlite drivers\",\n        )\n    }\n\n    /**\n     * If driver dependency is not given explicitly, then try to load it via \"require\".\n     */\n    protected loadDependencies(): void {\n        // dependencies have to be loaded in the specific driver\n    }\n}\n"]},"metadata":{},"sourceType":"module"}