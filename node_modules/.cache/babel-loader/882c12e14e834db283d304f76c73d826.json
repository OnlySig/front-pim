{"ast":null,"code":"import { QueryBuilder } from \"./QueryBuilder\";\nimport { InsertResult } from \"./result/InsertResult\";\nimport { ReturningStatementNotSupportedError } from \"../error/ReturningStatementNotSupportedError\";\nimport { InsertValuesMissingError } from \"../error/InsertValuesMissingError\";\nimport { ReturningResultsEntityUpdator } from \"./ReturningResultsEntityUpdator\";\nimport { BroadcasterResult } from \"../subscriber/BroadcasterResult\";\nimport { TypeORMError } from \"../error\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\nimport { InstanceChecker } from \"../util/InstanceChecker\";\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n */\n\nexport class InsertQueryBuilder extends QueryBuilder {\n  constructor() {\n    super(...arguments);\n    this[\"@instanceof\"] = Symbol.for(\"InsertQueryBuilder\");\n  } // -------------------------------------------------------------------------\n  // Public Implemented Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Gets generated SQL query without parameters being replaced.\n   */\n\n\n  getQuery() {\n    let sql = this.createComment();\n    sql += this.createCteExpression();\n    sql += this.createInsertExpression();\n    return sql.trim();\n  }\n  /**\n   * Executes sql generated by query builder and returns raw database results.\n   */\n\n\n  async execute() {\n    // console.time(\".value sets\");\n    const valueSets = this.getValueSets(); // console.timeEnd(\".value sets\");\n    // If user passed empty array of entities then we don't need to do\n    // anything.\n    //\n    // Fixes GitHub issues #3111 and #5734. If we were to let this through\n    // we would run into problems downstream, like subscribers getting\n    // invoked with the empty array where they expect an entity, and SQL\n    // queries with an empty VALUES clause.\n\n    if (valueSets.length === 0) return new InsertResult(); // console.time(\"QueryBuilder.execute\");\n    // console.time(\".database stuff\");\n\n    const queryRunner = this.obtainQueryRunner();\n    let transactionStartedByUs = false;\n\n    try {\n      // start transaction if it was enabled\n      if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {\n        await queryRunner.startTransaction();\n        transactionStartedByUs = true;\n      } // console.timeEnd(\".database stuff\");\n      // call before insertion methods in listeners and subscribers\n\n\n      if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata) {\n        const broadcastResult = new BroadcasterResult();\n        valueSets.forEach(valueSet => {\n          queryRunner.broadcaster.broadcastBeforeInsertEvent(broadcastResult, this.expressionMap.mainAlias.metadata, valueSet);\n        });\n        await broadcastResult.wait();\n      }\n\n      let declareSql = null;\n      let selectOutputSql = null; // if update entity mode is enabled we may need extra columns for the returning statement\n      // console.time(\".prepare returning statement\");\n\n      const returningResultsEntityUpdator = new ReturningResultsEntityUpdator(queryRunner, this.expressionMap);\n      const returningColumns = [];\n\n      if (Array.isArray(this.expressionMap.returning) && this.expressionMap.mainAlias.hasMetadata) {\n        for (const columnPath of this.expressionMap.returning) {\n          returningColumns.push(...this.expressionMap.mainAlias.metadata.findColumnsWithPropertyPath(columnPath));\n        }\n      }\n\n      if (this.expressionMap.updateEntity === true && this.expressionMap.mainAlias.hasMetadata) {\n        if (!(valueSets.length > 1 && this.connection.driver.options.type === \"oracle\")) {\n          this.expressionMap.extraReturningColumns = this.expressionMap.mainAlias.metadata.getInsertionReturningColumns();\n        }\n\n        returningColumns.push(...this.expressionMap.extraReturningColumns.filter(c => !returningColumns.includes(c)));\n      }\n\n      if (returningColumns.length > 0 && this.connection.driver.options.type === \"mssql\") {\n        declareSql = this.connection.driver.buildTableVariableDeclaration(\"@OutputTable\", returningColumns);\n        selectOutputSql = `SELECT * FROM @OutputTable`;\n      } // console.timeEnd(\".prepare returning statement\");\n      // execute query\n      // console.time(\".getting query and parameters\");\n\n\n      const [insertSql, parameters] = this.getQueryAndParameters(); // console.timeEnd(\".getting query and parameters\");\n      // console.time(\".query execution by database\");\n\n      const statements = [declareSql, insertSql, selectOutputSql];\n      const sql = statements.filter(s => s != null).join(\";\\n\\n\");\n      const queryResult = await queryRunner.query(sql, parameters, true);\n      const insertResult = InsertResult.from(queryResult); // console.timeEnd(\".query execution by database\");\n      // load returning results and set them to the entity if entity updation is enabled\n\n      if (this.expressionMap.updateEntity === true && this.expressionMap.mainAlias.hasMetadata) {\n        // console.time(\".updating entity\");\n        await returningResultsEntityUpdator.insert(insertResult, valueSets); // console.timeEnd(\".updating entity\");\n      } // call after insertion methods in listeners and subscribers\n\n\n      if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata) {\n        const broadcastResult = new BroadcasterResult();\n        valueSets.forEach(valueSet => {\n          queryRunner.broadcaster.broadcastAfterInsertEvent(broadcastResult, this.expressionMap.mainAlias.metadata, valueSet);\n        });\n        await broadcastResult.wait();\n      } // close transaction if we started it\n      // console.time(\".commit\");\n\n\n      if (transactionStartedByUs) {\n        await queryRunner.commitTransaction();\n      } // console.timeEnd(\".commit\");\n\n\n      return insertResult;\n    } catch (error) {\n      // rollback transaction if we started it\n      if (transactionStartedByUs) {\n        try {\n          await queryRunner.rollbackTransaction();\n        } catch (rollbackError) {}\n      }\n\n      throw error;\n    } finally {\n      // console.time(\".releasing connection\");\n      if (queryRunner !== this.queryRunner) {\n        // means we created our own query runner\n        await queryRunner.release();\n      } // console.timeEnd(\".releasing connection\");\n      // console.timeEnd(\"QueryBuilder.execute\");\n\n    }\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Specifies INTO which entity's table insertion will be executed.\n   */\n\n\n  into(entityTarget, columns) {\n    entityTarget = InstanceChecker.isEntitySchema(entityTarget) ? entityTarget.options.name : entityTarget;\n    const mainAlias = this.createFromAlias(entityTarget);\n    this.expressionMap.setMainAlias(mainAlias);\n    this.expressionMap.insertColumns = columns || [];\n    return this;\n  }\n  /**\n   * Values needs to be inserted into table.\n   */\n\n\n  values(values) {\n    this.expressionMap.valuesSet = values;\n    return this;\n  }\n  /**\n   * Optional returning/output clause.\n   */\n\n\n  output(output) {\n    return this.returning(output);\n  }\n  /**\n   * Optional returning/output clause.\n   */\n\n\n  returning(returning) {\n    // not all databases support returning/output cause\n    if (!this.connection.driver.isReturningSqlSupported(\"insert\")) {\n      throw new ReturningStatementNotSupportedError();\n    }\n\n    this.expressionMap.returning = returning;\n    return this;\n  }\n  /**\n   * Indicates if entity must be updated after insertion operations.\n   * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).\n   * Enabled by default.\n   */\n\n\n  updateEntity(enabled) {\n    this.expressionMap.updateEntity = enabled;\n    return this;\n  }\n  /**\n   * Adds additional ON CONFLICT statement supported in postgres and cockroach.\n   *\n   * @deprecated Use `orIgnore` or `orUpdate`\n   */\n\n\n  onConflict(statement) {\n    this.expressionMap.onConflict = statement;\n    return this;\n  }\n  /**\n   * Adds additional ignore statement supported in databases.\n   */\n\n\n  orIgnore() {\n    let statement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    this.expressionMap.onIgnore = !!statement;\n    return this;\n  }\n  /**\n   * Adds additional update statement supported in databases.\n   */\n\n\n  orUpdate(statementOrOverwrite, conflictTarget, orUpdateOptions) {\n    if (!Array.isArray(statementOrOverwrite)) {\n      this.expressionMap.onUpdate = {\n        conflict: statementOrOverwrite === null || statementOrOverwrite === void 0 ? void 0 : statementOrOverwrite.conflict_target,\n        columns: statementOrOverwrite === null || statementOrOverwrite === void 0 ? void 0 : statementOrOverwrite.columns,\n        overwrite: statementOrOverwrite === null || statementOrOverwrite === void 0 ? void 0 : statementOrOverwrite.overwrite,\n        skipUpdateIfNoValuesChanged: orUpdateOptions === null || orUpdateOptions === void 0 ? void 0 : orUpdateOptions.skipUpdateIfNoValuesChanged\n      };\n      return this;\n    }\n\n    this.expressionMap.onUpdate = {\n      overwrite: statementOrOverwrite,\n      conflict: conflictTarget,\n      skipUpdateIfNoValuesChanged: orUpdateOptions === null || orUpdateOptions === void 0 ? void 0 : orUpdateOptions.skipUpdateIfNoValuesChanged\n    };\n    return this;\n  } // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Creates INSERT express used to perform insert query.\n   */\n\n\n  createInsertExpression() {\n    const tableName = this.getTableName(this.getMainTableName());\n    const valuesExpression = this.createValuesExpression(); // its important to get values before returning expression because oracle rely on native parameters and ordering of them is important\n\n    const returningExpression = this.connection.driver.options.type === \"oracle\" && this.getValueSets().length > 1 ? null : this.createReturningExpression(\"insert\"); // oracle doesnt support returning with multi-row insert\n\n    const columnsExpression = this.createColumnNamesExpression();\n    let query = \"INSERT \";\n\n    if (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === \"aurora-mysql\") {\n      query += `${this.expressionMap.onIgnore ? \" IGNORE \" : \"\"}`;\n    }\n\n    query += `INTO ${tableName}`;\n\n    if (this.alias !== this.getMainTableName() && DriverUtils.isPostgresFamily(this.connection.driver)) {\n      query += ` AS \"${this.alias}\"`;\n    } // add columns expression\n\n\n    if (columnsExpression) {\n      query += `(${columnsExpression})`;\n    } else {\n      if (!valuesExpression && (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === \"aurora-mysql\")) // special syntax for mysql DEFAULT VALUES insertion\n        query += \"()\";\n    } // add OUTPUT expression\n\n\n    if (returningExpression && this.connection.driver.options.type === \"mssql\") {\n      query += ` OUTPUT ${returningExpression}`;\n    } // add VALUES expression\n\n\n    if (valuesExpression) {\n      if (this.connection.driver.options.type === \"oracle\" && this.getValueSets().length > 1) {\n        query += ` ${valuesExpression}`;\n      } else {\n        query += ` VALUES ${valuesExpression}`;\n      }\n    } else {\n      if (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === \"aurora-mysql\") {\n        // special syntax for mysql DEFAULT VALUES insertion\n        query += \" VALUES ()\";\n      } else {\n        query += ` DEFAULT VALUES`;\n      }\n    }\n\n    if (this.connection.driver.supportedUpsertType === \"on-conflict-do-update\") {\n      if (this.expressionMap.onIgnore) {\n        query += \" ON CONFLICT DO NOTHING \";\n      } else if (this.expressionMap.onConflict) {\n        query += ` ON CONFLICT ${this.expressionMap.onConflict} `;\n      } else if (this.expressionMap.onUpdate) {\n        const {\n          overwrite,\n          columns,\n          conflict,\n          skipUpdateIfNoValuesChanged\n        } = this.expressionMap.onUpdate;\n        let conflictTarget = \"ON CONFLICT\";\n\n        if (Array.isArray(conflict)) {\n          conflictTarget += ` ( ${conflict.map(column => this.escape(column)).join(\", \")} )`;\n        } else if (conflict) {\n          conflictTarget += ` ON CONSTRAINT ${this.escape(conflict)}`;\n        }\n\n        if (Array.isArray(overwrite)) {\n          query += ` ${conflictTarget} DO UPDATE SET `;\n          query += overwrite === null || overwrite === void 0 ? void 0 : overwrite.map(column => `${this.escape(column)} = EXCLUDED.${this.escape(column)}`).join(\", \");\n          query += \" \";\n        } else if (columns) {\n          query += ` ${conflictTarget} DO UPDATE SET `;\n          query += columns.map(column => `${this.escape(column)} = :${column}`).join(\", \");\n          query += \" \";\n        }\n\n        if (Array.isArray(overwrite) && skipUpdateIfNoValuesChanged && DriverUtils.isPostgresFamily(this.connection.driver)) {\n          query += ` WHERE (`;\n          query += overwrite.map(column => `${tableName}.${this.escape(column)} IS DISTINCT FROM EXCLUDED.${this.escape(column)}`).join(\" OR \");\n          query += \") \";\n        }\n      }\n    } else if (this.connection.driver.supportedUpsertType === \"on-duplicate-key-update\") {\n      if (this.expressionMap.onUpdate) {\n        const {\n          overwrite,\n          columns\n        } = this.expressionMap.onUpdate;\n\n        if (Array.isArray(overwrite)) {\n          query += \" ON DUPLICATE KEY UPDATE \";\n          query += overwrite.map(column => `${this.escape(column)} = VALUES(${this.escape(column)})`).join(\", \");\n          query += \" \";\n        } else if (Array.isArray(columns)) {\n          query += \" ON DUPLICATE KEY UPDATE \";\n          query += columns.map(column => `${this.escape(column)} = :${column}`).join(\", \");\n          query += \" \";\n        }\n      }\n    } else {\n      if (this.expressionMap.onUpdate) {\n        throw new TypeORMError(`onUpdate is not supported by the current database driver`);\n      }\n    } // add RETURNING expression\n\n\n    if (returningExpression && (DriverUtils.isPostgresFamily(this.connection.driver) || this.connection.driver.options.type === \"oracle\" || this.connection.driver.options.type === \"cockroachdb\" || DriverUtils.isMySQLFamily(this.connection.driver))) {\n      query += ` RETURNING ${returningExpression}`;\n    } // Inserting a specific value for an auto-increment primary key in mssql requires enabling IDENTITY_INSERT\n    // IDENTITY_INSERT can only be enabled for tables where there is an IDENTITY column and only if there is a value to be inserted (i.e. supplying DEFAULT is prohibited if IDENTITY_INSERT is enabled)\n\n\n    if (this.connection.driver.options.type === \"mssql\" && this.expressionMap.mainAlias.hasMetadata && this.expressionMap.mainAlias.metadata.columns.filter(column => this.expressionMap.insertColumns.length > 0 ? this.expressionMap.insertColumns.indexOf(column.propertyPath) !== -1 : column.isInsert).some(column => this.isOverridingAutoIncrementBehavior(column))) {\n      query = `SET IDENTITY_INSERT ${tableName} ON; ${query}; SET IDENTITY_INSERT ${tableName} OFF`;\n    }\n\n    return query;\n  }\n  /**\n   * Gets list of columns where values must be inserted to.\n   */\n\n\n  getInsertedColumns() {\n    if (!this.expressionMap.mainAlias.hasMetadata) return [];\n    return this.expressionMap.mainAlias.metadata.columns.filter(column => {\n      // if user specified list of columns he wants to insert to, then we filter only them\n      if (this.expressionMap.insertColumns.length) return this.expressionMap.insertColumns.indexOf(column.propertyPath) !== -1; // skip columns the user doesn't want included by default\n\n      if (!column.isInsert) {\n        return false;\n      } // if user did not specified such list then return all columns except auto-increment one\n      // for Oracle we return auto-increment column as well because Oracle does not support DEFAULT VALUES expression\n\n\n      if (column.isGenerated && column.generationStrategy === \"increment\" && !(this.connection.driver.options.type === \"spanner\") && !(this.connection.driver.options.type === \"oracle\") && !DriverUtils.isSQLiteFamily(this.connection.driver) && !DriverUtils.isMySQLFamily(this.connection.driver) && !(this.connection.driver.options.type === \"aurora-mysql\") && !(this.connection.driver.options.type === \"mssql\" && this.isOverridingAutoIncrementBehavior(column))) return false;\n      return true;\n    });\n  }\n  /**\n   * Creates a columns string where values must be inserted to for INSERT INTO expression.\n   */\n\n\n  createColumnNamesExpression() {\n    const columns = this.getInsertedColumns();\n    if (columns.length > 0) return columns.map(column => this.escape(column.databaseName)).join(\", \"); // in the case if there are no insert columns specified and table without metadata used\n    // we get columns from the inserted value map, in the case if only one inserted map is specified\n\n    if (!this.expressionMap.mainAlias.hasMetadata && !this.expressionMap.insertColumns.length) {\n      const valueSets = this.getValueSets();\n      if (valueSets.length === 1) return Object.keys(valueSets[0]).map(columnName => this.escape(columnName)).join(\", \");\n    } // get a table name and all column database names\n\n\n    return this.expressionMap.insertColumns.map(columnName => this.escape(columnName)).join(\", \");\n  }\n  /**\n   * Creates list of values needs to be inserted in the VALUES expression.\n   */\n\n\n  createValuesExpression() {\n    const valueSets = this.getValueSets();\n    const columns = this.getInsertedColumns(); // if column metadatas are given then apply all necessary operations with values\n\n    if (columns.length > 0) {\n      let expression = \"\";\n      valueSets.forEach((valueSet, valueSetIndex) => {\n        columns.forEach((column, columnIndex) => {\n          if (columnIndex === 0) {\n            if (this.connection.driver.options.type === \"oracle\" && valueSets.length > 1) {\n              expression += \" SELECT \";\n            } else if (this.connection.driver.options.type === \"sap\" && valueSets.length > 1) {\n              expression += \" SELECT \";\n            } else {\n              expression += \"(\";\n            }\n          } // extract real value from the entity\n\n\n          let value = column.getEntityValue(valueSet); // if column is relational and value is an object then get real referenced column value from this object\n          // for example column value is { question: { id: 1 } }, value will be equal to { id: 1 }\n          // and we extract \"1\" from this object\n\n          /*if (column.referencedColumn && value instanceof Object && !(typeof value === \"function\")) { // todo: check if we still need it since getEntityValue already has similar code\n              value = column.referencedColumn.getEntityValue(value);\n          }*/\n\n          if (!(typeof value === \"function\")) {\n            // make sure our value is normalized by a driver\n            value = this.connection.driver.preparePersistentValue(value, column);\n          } // newly inserted entities always have a version equal to 1 (first version)\n          // also, user-specified version must be empty\n\n\n          if (column.isVersion && value === undefined) {\n            expression += \"1\"; // } else if (column.isNestedSetLeft) {\n            //     const tableName = this.connection.driver.escape(column.entityMetadata.tablePath);\n            //     const rightColumnName = this.connection.driver.escape(column.entityMetadata.nestedSetRightColumn!.databaseName);\n            //     const subQuery = `(SELECT c.max + 1 FROM (SELECT MAX(${rightColumnName}) as max from ${tableName}) c)`;\n            //     expression += subQuery;\n            //\n            // } else if (column.isNestedSetRight) {\n            //     const tableName = this.connection.driver.escape(column.entityMetadata.tablePath);\n            //     const rightColumnName = this.connection.driver.escape(column.entityMetadata.nestedSetRightColumn!.databaseName);\n            //     const subQuery = `(SELECT c.max + 2 FROM (SELECT MAX(${rightColumnName}) as max from ${tableName}) c)`;\n            //     expression += subQuery;\n          } else if (column.isDiscriminator) {\n            expression += this.createParameter(this.expressionMap.mainAlias.metadata.discriminatorValue); // return \"1\";\n            // for create and update dates we insert current date\n            // no, we don't do it because this constant is already in \"default\" value of the column\n            // with extended timestamp functionality, like CURRENT_TIMESTAMP(6) for example\n            // } else if (column.isCreateDate || column.isUpdateDate) {\n            //     return \"CURRENT_TIMESTAMP\";\n            // if column is generated uuid and database does not support its generation and custom generated value was not provided by a user - we generate a new uuid value for insertion\n          } else if (column.isGenerated && column.generationStrategy === \"uuid\" && !this.connection.driver.isUUIDGenerationSupported() && value === undefined) {\n            value = uuidv4();\n            expression += this.createParameter(value);\n\n            if (!(valueSetIndex in this.expressionMap.locallyGenerated)) {\n              this.expressionMap.locallyGenerated[valueSetIndex] = {};\n            }\n\n            column.setEntityValue(this.expressionMap.locallyGenerated[valueSetIndex], value); // if value for this column was not provided then insert default value\n          } else if (value === undefined) {\n            if (this.connection.driver.options.type === \"oracle\" && valueSets.length > 1 || DriverUtils.isSQLiteFamily(this.connection.driver) || this.connection.driver.options.type === \"sap\" || this.connection.driver.options.type === \"spanner\") {\n              // unfortunately sqlite does not support DEFAULT expression in INSERT queries\n              if (column.default !== undefined && column.default !== null) {\n                // try to use default defined in the column\n                expression += this.connection.driver.normalizeDefault(column);\n              } else {\n                expression += \"NULL\"; // otherwise simply use NULL and pray if column is nullable\n              }\n            } else {\n              expression += \"DEFAULT\";\n            }\n          } else if (value === null && this.connection.driver.options.type === \"spanner\") {\n            expression += \"NULL\"; // support for SQL expressions in queries\n          } else if (typeof value === \"function\") {\n            expression += value(); // just any other regular value\n          } else {\n            if (this.connection.driver.options.type === \"mssql\") value = this.connection.driver.parametrizeValue(column, value); // we need to store array values in a special class to make sure parameter replacement will work correctly\n            // if (value instanceof Array)\n            //     value = new ArrayParameter(value);\n\n            const paramName = this.createParameter(value);\n\n            if ((DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === \"aurora-mysql\") && this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {\n              const useLegacy = this.connection.driver.options.legacySpatialSupport;\n              const geomFromText = useLegacy ? \"GeomFromText\" : \"ST_GeomFromText\";\n\n              if (column.srid != null) {\n                expression += `${geomFromText}(${paramName}, ${column.srid})`;\n              } else {\n                expression += `${geomFromText}(${paramName})`;\n              }\n            } else if (DriverUtils.isPostgresFamily(this.connection.driver) && this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {\n              if (column.srid != null) {\n                expression += `ST_SetSRID(ST_GeomFromGeoJSON(${paramName}), ${column.srid})::${column.type}`;\n              } else {\n                expression += `ST_GeomFromGeoJSON(${paramName})::${column.type}`;\n              }\n            } else if (this.connection.driver.options.type === \"mssql\" && this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {\n              expression += column.type + \"::STGeomFromText(\" + paramName + \", \" + (column.srid || \"0\") + \")\";\n            } else {\n              expression += paramName;\n            }\n          }\n\n          if (columnIndex === columns.length - 1) {\n            if (valueSetIndex === valueSets.length - 1) {\n              if (this.connection.driver.options.type === \"oracle\" && valueSets.length > 1) {\n                expression += \" FROM DUAL \";\n              } else if (this.connection.driver.options.type === \"sap\" && valueSets.length > 1) {\n                expression += \" FROM dummy \";\n              } else {\n                expression += \")\";\n              }\n            } else {\n              if (this.connection.driver.options.type === \"oracle\" && valueSets.length > 1) {\n                expression += \" FROM DUAL UNION ALL \";\n              } else if (this.connection.driver.options.type === \"sap\" && valueSets.length > 1) {\n                expression += \" FROM dummy UNION ALL \";\n              } else {\n                expression += \"), \";\n              }\n            }\n          } else {\n            expression += \", \";\n          }\n        });\n      });\n      if (expression === \"()\") return \"\";\n      return expression;\n    } else {\n      // for tables without metadata\n      // get values needs to be inserted\n      let expression = \"\";\n      valueSets.forEach((valueSet, insertionIndex) => {\n        const columns = Object.keys(valueSet);\n        columns.forEach((columnName, columnIndex) => {\n          if (columnIndex === 0) {\n            expression += \"(\";\n          }\n\n          const value = valueSet[columnName]; // support for SQL expressions in queries\n\n          if (typeof value === \"function\") {\n            expression += value(); // if value for this column was not provided then insert default value\n          } else if (value === undefined) {\n            if (this.connection.driver.options.type === \"oracle\" && valueSets.length > 1 || DriverUtils.isSQLiteFamily(this.connection.driver) || this.connection.driver.options.type === \"sap\" || this.connection.driver.options.type === \"spanner\") {\n              expression += \"NULL\";\n            } else {\n              expression += \"DEFAULT\";\n            }\n          } else if (value === null && this.connection.driver.options.type === \"spanner\") {// just any other regular value\n          } else {\n            expression += this.createParameter(value);\n          }\n\n          if (columnIndex === Object.keys(valueSet).length - 1) {\n            if (insertionIndex === valueSets.length - 1) {\n              expression += \")\";\n            } else {\n              expression += \"), \";\n            }\n          } else {\n            expression += \", \";\n          }\n        });\n      });\n      if (expression === \"()\") return \"\";\n      return expression;\n    }\n  }\n  /**\n   * Gets array of values need to be inserted into the target table.\n   */\n\n\n  getValueSets() {\n    if (Array.isArray(this.expressionMap.valuesSet)) return this.expressionMap.valuesSet;\n    if (ObjectUtils.isObject(this.expressionMap.valuesSet)) return [this.expressionMap.valuesSet];\n    throw new InsertValuesMissingError();\n  }\n  /**\n   * Checks if column is an auto-generated primary key, but the current insertion specifies a value for it.\n   *\n   * @param column\n   */\n\n\n  isOverridingAutoIncrementBehavior(column) {\n    return column.isPrimary && column.isGenerated && column.generationStrategy === \"increment\" && this.getValueSets().some(valueSet => column.getEntityValue(valueSet) !== undefined && column.getEntityValue(valueSet) !== null);\n  }\n\n}","map":{"version":3,"mappings":"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","names":["QueryBuilder","InsertResult","ReturningStatementNotSupportedError","InsertValuesMissingError","ReturningResultsEntityUpdator","BroadcasterResult","TypeORMError","v4","uuidv4","DriverUtils","ObjectUtils","InstanceChecker","InsertQueryBuilder","constructor","Symbol","for","getQuery","sql","createComment","createCteExpression","createInsertExpression","trim","execute","valueSets","getValueSets","length","queryRunner","obtainQueryRunner","transactionStartedByUs","expressionMap","useTransaction","isTransactionActive","startTransaction","callListeners","mainAlias","hasMetadata","broadcastResult","forEach","valueSet","broadcaster","broadcastBeforeInsertEvent","metadata","wait","declareSql","selectOutputSql","returningResultsEntityUpdator","returningColumns","Array","isArray","returning","columnPath","push","findColumnsWithPropertyPath","updateEntity","connection","driver","options","type","extraReturningColumns","getInsertionReturningColumns","filter","c","includes","buildTableVariableDeclaration","insertSql","parameters","getQueryAndParameters","statements","s","join","queryResult","query","insertResult","from","insert","broadcastAfterInsertEvent","commitTransaction","error","rollbackTransaction","rollbackError","release","into","entityTarget","columns","isEntitySchema","name","createFromAlias","setMainAlias","insertColumns","values","valuesSet","output","isReturningSqlSupported","enabled","onConflict","statement","orIgnore","onIgnore","orUpdate","statementOrOverwrite","conflictTarget","orUpdateOptions","onUpdate","conflict","conflict_target","overwrite","skipUpdateIfNoValuesChanged","tableName","getTableName","getMainTableName","valuesExpression","createValuesExpression","returningExpression","createReturningExpression","columnsExpression","createColumnNamesExpression","isMySQLFamily","alias","isPostgresFamily","supportedUpsertType","map","column","escape","indexOf","propertyPath","isInsert","some","isOverridingAutoIncrementBehavior","getInsertedColumns","isGenerated","generationStrategy","isSQLiteFamily","databaseName","Object","keys","columnName","expression","valueSetIndex","columnIndex","value","getEntityValue","preparePersistentValue","isVersion","undefined","isDiscriminator","createParameter","discriminatorValue","isUUIDGenerationSupported","locallyGenerated","setEntityValue","default","normalizeDefault","parametrizeValue","paramName","spatialTypes","useLegacy","legacySpatialSupport","geomFromText","srid","insertionIndex","isObject","isPrimary"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\query-builder\\InsertQueryBuilder.ts"],"sourcesContent":["import { QueryBuilder } from \"./QueryBuilder\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { EntityTarget } from \"../common/EntityTarget\"\nimport { QueryDeepPartialEntity } from \"./QueryPartialEntity\"\nimport { MysqlDriver } from \"../driver/mysql/MysqlDriver\"\nimport { InsertResult } from \"./result/InsertResult\"\nimport { ReturningStatementNotSupportedError } from \"../error/ReturningStatementNotSupportedError\"\nimport { InsertValuesMissingError } from \"../error/InsertValuesMissingError\"\nimport { ColumnMetadata } from \"../metadata/ColumnMetadata\"\nimport { ReturningResultsEntityUpdator } from \"./ReturningResultsEntityUpdator\"\nimport { BroadcasterResult } from \"../subscriber/BroadcasterResult\"\nimport { TypeORMError } from \"../error\"\nimport { v4 as uuidv4 } from \"uuid\"\nimport { InsertOrUpdateOptions } from \"./InsertOrUpdateOptions\"\nimport { SqlServerDriver } from \"../driver/sqlserver/SqlServerDriver\"\nimport { AuroraMysqlDriver } from \"../driver/aurora-mysql/AuroraMysqlDriver\"\nimport { DriverUtils } from \"../driver/DriverUtils\"\nimport { ObjectUtils } from \"../util/ObjectUtils\"\nimport { InstanceChecker } from \"../util/InstanceChecker\"\n\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n */\nexport class InsertQueryBuilder<\n    Entity extends ObjectLiteral,\n> extends QueryBuilder<Entity> {\n    readonly \"@instanceof\" = Symbol.for(\"InsertQueryBuilder\")\n\n    // -------------------------------------------------------------------------\n    // Public Implemented Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets generated SQL query without parameters being replaced.\n     */\n    getQuery(): string {\n        let sql = this.createComment()\n        sql += this.createCteExpression()\n        sql += this.createInsertExpression()\n        return sql.trim()\n    }\n\n    /**\n     * Executes sql generated by query builder and returns raw database results.\n     */\n    async execute(): Promise<InsertResult> {\n        // console.time(\".value sets\");\n        const valueSets: ObjectLiteral[] = this.getValueSets()\n        // console.timeEnd(\".value sets\");\n\n        // If user passed empty array of entities then we don't need to do\n        // anything.\n        //\n        // Fixes GitHub issues #3111 and #5734. If we were to let this through\n        // we would run into problems downstream, like subscribers getting\n        // invoked with the empty array where they expect an entity, and SQL\n        // queries with an empty VALUES clause.\n        if (valueSets.length === 0) return new InsertResult()\n\n        // console.time(\"QueryBuilder.execute\");\n        // console.time(\".database stuff\");\n        const queryRunner = this.obtainQueryRunner()\n        let transactionStartedByUs: boolean = false\n\n        try {\n            // start transaction if it was enabled\n            if (\n                this.expressionMap.useTransaction === true &&\n                queryRunner.isTransactionActive === false\n            ) {\n                await queryRunner.startTransaction()\n                transactionStartedByUs = true\n            }\n\n            // console.timeEnd(\".database stuff\");\n\n            // call before insertion methods in listeners and subscribers\n            if (\n                this.expressionMap.callListeners === true &&\n                this.expressionMap.mainAlias!.hasMetadata\n            ) {\n                const broadcastResult = new BroadcasterResult()\n                valueSets.forEach((valueSet) => {\n                    queryRunner.broadcaster.broadcastBeforeInsertEvent(\n                        broadcastResult,\n                        this.expressionMap.mainAlias!.metadata,\n                        valueSet,\n                    )\n                })\n                await broadcastResult.wait()\n            }\n\n            let declareSql: string | null = null\n            let selectOutputSql: string | null = null\n\n            // if update entity mode is enabled we may need extra columns for the returning statement\n            // console.time(\".prepare returning statement\");\n            const returningResultsEntityUpdator =\n                new ReturningResultsEntityUpdator(\n                    queryRunner,\n                    this.expressionMap,\n                )\n\n            const returningColumns: ColumnMetadata[] = []\n\n            if (\n                Array.isArray(this.expressionMap.returning) &&\n                this.expressionMap.mainAlias!.hasMetadata\n            ) {\n                for (const columnPath of this.expressionMap.returning) {\n                    returningColumns.push(\n                        ...this.expressionMap.mainAlias!.metadata.findColumnsWithPropertyPath(\n                            columnPath,\n                        ),\n                    )\n                }\n            }\n\n            if (\n                this.expressionMap.updateEntity === true &&\n                this.expressionMap.mainAlias!.hasMetadata\n            ) {\n                if (\n                    !(\n                        valueSets.length > 1 &&\n                        this.connection.driver.options.type === \"oracle\"\n                    )\n                ) {\n                    this.expressionMap.extraReturningColumns =\n                        this.expressionMap.mainAlias!.metadata.getInsertionReturningColumns()\n                }\n\n                returningColumns.push(\n                    ...this.expressionMap.extraReturningColumns.filter(\n                        (c) => !returningColumns.includes(c),\n                    ),\n                )\n            }\n\n            if (\n                returningColumns.length > 0 &&\n                this.connection.driver.options.type === \"mssql\"\n            ) {\n                declareSql = (\n                    this.connection.driver as SqlServerDriver\n                ).buildTableVariableDeclaration(\n                    \"@OutputTable\",\n                    returningColumns,\n                )\n                selectOutputSql = `SELECT * FROM @OutputTable`\n            }\n            // console.timeEnd(\".prepare returning statement\");\n\n            // execute query\n            // console.time(\".getting query and parameters\");\n            const [insertSql, parameters] = this.getQueryAndParameters()\n            // console.timeEnd(\".getting query and parameters\");\n\n            // console.time(\".query execution by database\");\n            const statements = [declareSql, insertSql, selectOutputSql]\n            const sql = statements.filter((s) => s != null).join(\";\\n\\n\")\n\n            const queryResult = await queryRunner.query(sql, parameters, true)\n\n            const insertResult = InsertResult.from(queryResult)\n\n            // console.timeEnd(\".query execution by database\");\n\n            // load returning results and set them to the entity if entity updation is enabled\n            if (\n                this.expressionMap.updateEntity === true &&\n                this.expressionMap.mainAlias!.hasMetadata\n            ) {\n                // console.time(\".updating entity\");\n                await returningResultsEntityUpdator.insert(\n                    insertResult,\n                    valueSets,\n                )\n                // console.timeEnd(\".updating entity\");\n            }\n\n            // call after insertion methods in listeners and subscribers\n            if (\n                this.expressionMap.callListeners === true &&\n                this.expressionMap.mainAlias!.hasMetadata\n            ) {\n                const broadcastResult = new BroadcasterResult()\n                valueSets.forEach((valueSet) => {\n                    queryRunner.broadcaster.broadcastAfterInsertEvent(\n                        broadcastResult,\n                        this.expressionMap.mainAlias!.metadata,\n                        valueSet,\n                    )\n                })\n                await broadcastResult.wait()\n            }\n\n            // close transaction if we started it\n            // console.time(\".commit\");\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction()\n            }\n            // console.timeEnd(\".commit\");\n\n            return insertResult\n        } catch (error) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction()\n                } catch (rollbackError) {}\n            }\n            throw error\n        } finally {\n            // console.time(\".releasing connection\");\n            if (queryRunner !== this.queryRunner) {\n                // means we created our own query runner\n                await queryRunner.release()\n            }\n            // console.timeEnd(\".releasing connection\");\n            // console.timeEnd(\"QueryBuilder.execute\");\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Specifies INTO which entity's table insertion will be executed.\n     */\n    into<T extends ObjectLiteral>(\n        entityTarget: EntityTarget<T>,\n        columns?: string[],\n    ): InsertQueryBuilder<T> {\n        entityTarget = InstanceChecker.isEntitySchema(entityTarget)\n            ? entityTarget.options.name\n            : entityTarget\n        const mainAlias = this.createFromAlias(entityTarget)\n        this.expressionMap.setMainAlias(mainAlias)\n        this.expressionMap.insertColumns = columns || []\n        return this as any as InsertQueryBuilder<T>\n    }\n\n    /**\n     * Values needs to be inserted into table.\n     */\n    values(\n        values:\n            | QueryDeepPartialEntity<Entity>\n            | QueryDeepPartialEntity<Entity>[],\n    ): this {\n        this.expressionMap.valuesSet = values\n        return this\n    }\n\n    /**\n     * Optional returning/output clause.\n     * This will return given column values.\n     */\n    output(columns: string[]): this\n\n    /**\n     * Optional returning/output clause.\n     * Returning is a SQL string containing returning statement.\n     */\n    output(output: string): this\n\n    /**\n     * Optional returning/output clause.\n     */\n    output(output: string | string[]): this\n\n    /**\n     * Optional returning/output clause.\n     */\n    output(output: string | string[]): this {\n        return this.returning(output)\n    }\n\n    /**\n     * Optional returning/output clause.\n     * This will return given column values.\n     */\n    returning(columns: string[]): this\n\n    /**\n     * Optional returning/output clause.\n     * Returning is a SQL string containing returning statement.\n     */\n    returning(returning: string): this\n\n    /**\n     * Optional returning/output clause.\n     */\n    returning(returning: string | string[]): this\n\n    /**\n     * Optional returning/output clause.\n     */\n    returning(returning: string | string[]): this {\n        // not all databases support returning/output cause\n        if (!this.connection.driver.isReturningSqlSupported(\"insert\")) {\n            throw new ReturningStatementNotSupportedError()\n        }\n\n        this.expressionMap.returning = returning\n        return this\n    }\n\n    /**\n     * Indicates if entity must be updated after insertion operations.\n     * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).\n     * Enabled by default.\n     */\n    updateEntity(enabled: boolean): this {\n        this.expressionMap.updateEntity = enabled\n        return this\n    }\n\n    /**\n     * Adds additional ON CONFLICT statement supported in postgres and cockroach.\n     *\n     * @deprecated Use `orIgnore` or `orUpdate`\n     */\n    onConflict(statement: string): this {\n        this.expressionMap.onConflict = statement\n        return this\n    }\n\n    /**\n     * Adds additional ignore statement supported in databases.\n     */\n    orIgnore(statement: string | boolean = true): this {\n        this.expressionMap.onIgnore = !!statement\n        return this\n    }\n\n    /**\n     * @deprecated\n     *\n     * `.orUpdate({ columns: [ \"is_updated\" ] }).setParameter(\"is_updated\", value)`\n     *\n     * is now `.orUpdate([\"is_updated\"])`\n     *\n     * `.orUpdate({ conflict_target: ['date'], overwrite: ['title'] })`\n     *\n     * is now `.orUpdate(['title'], ['date'])`\n     *\n     */\n    orUpdate(statement?: {\n        columns?: string[]\n        overwrite?: string[]\n        conflict_target?: string | string[]\n    }): this\n\n    orUpdate(\n        overwrite: string[],\n        conflictTarget?: string | string[],\n        orUpdateOptions?: InsertOrUpdateOptions,\n    ): this\n\n    /**\n     * Adds additional update statement supported in databases.\n     */\n    orUpdate(\n        statementOrOverwrite?:\n            | {\n                  columns?: string[]\n                  overwrite?: string[]\n                  conflict_target?: string | string[]\n              }\n            | string[],\n        conflictTarget?: string | string[],\n        orUpdateOptions?: InsertOrUpdateOptions,\n    ): this {\n        if (!Array.isArray(statementOrOverwrite)) {\n            this.expressionMap.onUpdate = {\n                conflict: statementOrOverwrite?.conflict_target,\n                columns: statementOrOverwrite?.columns,\n                overwrite: statementOrOverwrite?.overwrite,\n                skipUpdateIfNoValuesChanged:\n                    orUpdateOptions?.skipUpdateIfNoValuesChanged,\n            }\n            return this\n        }\n\n        this.expressionMap.onUpdate = {\n            overwrite: statementOrOverwrite,\n            conflict: conflictTarget,\n            skipUpdateIfNoValuesChanged:\n                orUpdateOptions?.skipUpdateIfNoValuesChanged,\n        }\n        return this\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates INSERT express used to perform insert query.\n     */\n    protected createInsertExpression() {\n        const tableName = this.getTableName(this.getMainTableName())\n        const valuesExpression = this.createValuesExpression() // its important to get values before returning expression because oracle rely on native parameters and ordering of them is important\n        const returningExpression =\n            this.connection.driver.options.type === \"oracle\" &&\n            this.getValueSets().length > 1\n                ? null\n                : this.createReturningExpression(\"insert\") // oracle doesnt support returning with multi-row insert\n        const columnsExpression = this.createColumnNamesExpression()\n        let query = \"INSERT \"\n\n        if (\n            DriverUtils.isMySQLFamily(this.connection.driver) ||\n            this.connection.driver.options.type === \"aurora-mysql\"\n        ) {\n            query += `${this.expressionMap.onIgnore ? \" IGNORE \" : \"\"}`\n        }\n\n        query += `INTO ${tableName}`\n\n        if (\n            this.alias !== this.getMainTableName() &&\n            DriverUtils.isPostgresFamily(this.connection.driver)\n        ) {\n            query += ` AS \"${this.alias}\"`\n        }\n\n        // add columns expression\n        if (columnsExpression) {\n            query += `(${columnsExpression})`\n        } else {\n            if (\n                !valuesExpression &&\n                (DriverUtils.isMySQLFamily(this.connection.driver) ||\n                    this.connection.driver.options.type === \"aurora-mysql\")\n            )\n                // special syntax for mysql DEFAULT VALUES insertion\n                query += \"()\"\n        }\n\n        // add OUTPUT expression\n        if (\n            returningExpression &&\n            this.connection.driver.options.type === \"mssql\"\n        ) {\n            query += ` OUTPUT ${returningExpression}`\n        }\n\n        // add VALUES expression\n        if (valuesExpression) {\n            if (\n                this.connection.driver.options.type === \"oracle\" &&\n                this.getValueSets().length > 1\n            ) {\n                query += ` ${valuesExpression}`\n            } else {\n                query += ` VALUES ${valuesExpression}`\n            }\n        } else {\n            if (\n                DriverUtils.isMySQLFamily(this.connection.driver) ||\n                this.connection.driver.options.type === \"aurora-mysql\"\n            ) {\n                // special syntax for mysql DEFAULT VALUES insertion\n                query += \" VALUES ()\"\n            } else {\n                query += ` DEFAULT VALUES`\n            }\n        }\n        if (\n            this.connection.driver.supportedUpsertType ===\n            \"on-conflict-do-update\"\n        ) {\n            if (this.expressionMap.onIgnore) {\n                query += \" ON CONFLICT DO NOTHING \"\n            } else if (this.expressionMap.onConflict) {\n                query += ` ON CONFLICT ${this.expressionMap.onConflict} `\n            } else if (this.expressionMap.onUpdate) {\n                const {\n                    overwrite,\n                    columns,\n                    conflict,\n                    skipUpdateIfNoValuesChanged,\n                } = this.expressionMap.onUpdate\n\n                let conflictTarget = \"ON CONFLICT\"\n\n                if (Array.isArray(conflict)) {\n                    conflictTarget += ` ( ${conflict\n                        .map((column) => this.escape(column))\n                        .join(\", \")} )`\n                } else if (conflict) {\n                    conflictTarget += ` ON CONSTRAINT ${this.escape(conflict)}`\n                }\n\n                if (Array.isArray(overwrite)) {\n                    query += ` ${conflictTarget} DO UPDATE SET `\n                    query += overwrite\n                        ?.map(\n                            (column) =>\n                                `${this.escape(\n                                    column,\n                                )} = EXCLUDED.${this.escape(column)}`,\n                        )\n                        .join(\", \")\n                    query += \" \"\n                } else if (columns) {\n                    query += ` ${conflictTarget} DO UPDATE SET `\n                    query += columns\n                        .map((column) => `${this.escape(column)} = :${column}`)\n                        .join(\", \")\n                    query += \" \"\n                }\n\n                if (\n                    Array.isArray(overwrite) &&\n                    skipUpdateIfNoValuesChanged &&\n                    DriverUtils.isPostgresFamily(this.connection.driver)\n                ) {\n                    query += ` WHERE (`\n                    query += overwrite\n                        .map(\n                            (column) =>\n                                `${tableName}.${this.escape(\n                                    column,\n                                )} IS DISTINCT FROM EXCLUDED.${this.escape(\n                                    column,\n                                )}`,\n                        )\n                        .join(\" OR \")\n                    query += \") \"\n                }\n            }\n        } else if (\n            this.connection.driver.supportedUpsertType ===\n            \"on-duplicate-key-update\"\n        ) {\n            if (this.expressionMap.onUpdate) {\n                const { overwrite, columns } = this.expressionMap.onUpdate\n\n                if (Array.isArray(overwrite)) {\n                    query += \" ON DUPLICATE KEY UPDATE \"\n                    query += overwrite\n                        .map(\n                            (column) =>\n                                `${this.escape(column)} = VALUES(${this.escape(\n                                    column,\n                                )})`,\n                        )\n                        .join(\", \")\n                    query += \" \"\n                } else if (Array.isArray(columns)) {\n                    query += \" ON DUPLICATE KEY UPDATE \"\n                    query += columns\n                        .map((column) => `${this.escape(column)} = :${column}`)\n                        .join(\", \")\n                    query += \" \"\n                }\n            }\n        } else {\n            if (this.expressionMap.onUpdate) {\n                throw new TypeORMError(\n                    `onUpdate is not supported by the current database driver`,\n                )\n            }\n        }\n\n        // add RETURNING expression\n        if (\n            returningExpression &&\n            (DriverUtils.isPostgresFamily(this.connection.driver) ||\n                this.connection.driver.options.type === \"oracle\" ||\n                this.connection.driver.options.type === \"cockroachdb\" ||\n                DriverUtils.isMySQLFamily(this.connection.driver))\n        ) {\n            query += ` RETURNING ${returningExpression}`\n        }\n\n        // Inserting a specific value for an auto-increment primary key in mssql requires enabling IDENTITY_INSERT\n        // IDENTITY_INSERT can only be enabled for tables where there is an IDENTITY column and only if there is a value to be inserted (i.e. supplying DEFAULT is prohibited if IDENTITY_INSERT is enabled)\n        if (\n            this.connection.driver.options.type === \"mssql\" &&\n            this.expressionMap.mainAlias!.hasMetadata &&\n            this.expressionMap\n                .mainAlias!.metadata.columns.filter((column) =>\n                    this.expressionMap.insertColumns.length > 0\n                        ? this.expressionMap.insertColumns.indexOf(\n                              column.propertyPath,\n                          ) !== -1\n                        : column.isInsert,\n                )\n                .some((column) =>\n                    this.isOverridingAutoIncrementBehavior(column),\n                )\n        ) {\n            query = `SET IDENTITY_INSERT ${tableName} ON; ${query}; SET IDENTITY_INSERT ${tableName} OFF`\n        }\n\n        return query\n    }\n\n    /**\n     * Gets list of columns where values must be inserted to.\n     */\n    protected getInsertedColumns(): ColumnMetadata[] {\n        if (!this.expressionMap.mainAlias!.hasMetadata) return []\n\n        return this.expressionMap.mainAlias!.metadata.columns.filter(\n            (column) => {\n                // if user specified list of columns he wants to insert to, then we filter only them\n                if (this.expressionMap.insertColumns.length)\n                    return (\n                        this.expressionMap.insertColumns.indexOf(\n                            column.propertyPath,\n                        ) !== -1\n                    )\n\n                // skip columns the user doesn't want included by default\n                if (!column.isInsert) {\n                    return false\n                }\n\n                // if user did not specified such list then return all columns except auto-increment one\n                // for Oracle we return auto-increment column as well because Oracle does not support DEFAULT VALUES expression\n                if (\n                    column.isGenerated &&\n                    column.generationStrategy === \"increment\" &&\n                    !(this.connection.driver.options.type === \"spanner\") &&\n                    !(this.connection.driver.options.type === \"oracle\") &&\n                    !DriverUtils.isSQLiteFamily(this.connection.driver) &&\n                    !DriverUtils.isMySQLFamily(this.connection.driver) &&\n                    !(this.connection.driver.options.type === \"aurora-mysql\") &&\n                    !(\n                        this.connection.driver.options.type === \"mssql\" &&\n                        this.isOverridingAutoIncrementBehavior(column)\n                    )\n                )\n                    return false\n\n                return true\n            },\n        )\n    }\n\n    /**\n     * Creates a columns string where values must be inserted to for INSERT INTO expression.\n     */\n    protected createColumnNamesExpression(): string {\n        const columns = this.getInsertedColumns()\n        if (columns.length > 0)\n            return columns\n                .map((column) => this.escape(column.databaseName))\n                .join(\", \")\n\n        // in the case if there are no insert columns specified and table without metadata used\n        // we get columns from the inserted value map, in the case if only one inserted map is specified\n        if (\n            !this.expressionMap.mainAlias!.hasMetadata &&\n            !this.expressionMap.insertColumns.length\n        ) {\n            const valueSets = this.getValueSets()\n            if (valueSets.length === 1)\n                return Object.keys(valueSets[0])\n                    .map((columnName) => this.escape(columnName))\n                    .join(\", \")\n        }\n\n        // get a table name and all column database names\n        return this.expressionMap.insertColumns\n            .map((columnName) => this.escape(columnName))\n            .join(\", \")\n    }\n\n    /**\n     * Creates list of values needs to be inserted in the VALUES expression.\n     */\n    protected createValuesExpression(): string {\n        const valueSets = this.getValueSets()\n        const columns = this.getInsertedColumns()\n\n        // if column metadatas are given then apply all necessary operations with values\n        if (columns.length > 0) {\n            let expression = \"\"\n            valueSets.forEach((valueSet, valueSetIndex) => {\n                columns.forEach((column, columnIndex) => {\n                    if (columnIndex === 0) {\n                        if (\n                            this.connection.driver.options.type === \"oracle\" &&\n                            valueSets.length > 1\n                        ) {\n                            expression += \" SELECT \"\n                        } else if (\n                            this.connection.driver.options.type === \"sap\" &&\n                            valueSets.length > 1\n                        ) {\n                            expression += \" SELECT \"\n                        } else {\n                            expression += \"(\"\n                        }\n                    }\n\n                    // extract real value from the entity\n                    let value = column.getEntityValue(valueSet)\n\n                    // if column is relational and value is an object then get real referenced column value from this object\n                    // for example column value is { question: { id: 1 } }, value will be equal to { id: 1 }\n                    // and we extract \"1\" from this object\n                    /*if (column.referencedColumn && value instanceof Object && !(typeof value === \"function\")) { // todo: check if we still need it since getEntityValue already has similar code\n                        value = column.referencedColumn.getEntityValue(value);\n                    }*/\n\n                    if (!(typeof value === \"function\")) {\n                        // make sure our value is normalized by a driver\n                        value = this.connection.driver.preparePersistentValue(\n                            value,\n                            column,\n                        )\n                    }\n\n                    // newly inserted entities always have a version equal to 1 (first version)\n                    // also, user-specified version must be empty\n                    if (column.isVersion && value === undefined) {\n                        expression += \"1\"\n\n                        // } else if (column.isNestedSetLeft) {\n                        //     const tableName = this.connection.driver.escape(column.entityMetadata.tablePath);\n                        //     const rightColumnName = this.connection.driver.escape(column.entityMetadata.nestedSetRightColumn!.databaseName);\n                        //     const subQuery = `(SELECT c.max + 1 FROM (SELECT MAX(${rightColumnName}) as max from ${tableName}) c)`;\n                        //     expression += subQuery;\n                        //\n                        // } else if (column.isNestedSetRight) {\n                        //     const tableName = this.connection.driver.escape(column.entityMetadata.tablePath);\n                        //     const rightColumnName = this.connection.driver.escape(column.entityMetadata.nestedSetRightColumn!.databaseName);\n                        //     const subQuery = `(SELECT c.max + 2 FROM (SELECT MAX(${rightColumnName}) as max from ${tableName}) c)`;\n                        //     expression += subQuery;\n                    } else if (column.isDiscriminator) {\n                        expression += this.createParameter(\n                            this.expressionMap.mainAlias!.metadata\n                                .discriminatorValue,\n                        )\n                        // return \"1\";\n\n                        // for create and update dates we insert current date\n                        // no, we don't do it because this constant is already in \"default\" value of the column\n                        // with extended timestamp functionality, like CURRENT_TIMESTAMP(6) for example\n                        // } else if (column.isCreateDate || column.isUpdateDate) {\n                        //     return \"CURRENT_TIMESTAMP\";\n\n                        // if column is generated uuid and database does not support its generation and custom generated value was not provided by a user - we generate a new uuid value for insertion\n                    } else if (\n                        column.isGenerated &&\n                        column.generationStrategy === \"uuid\" &&\n                        !this.connection.driver.isUUIDGenerationSupported() &&\n                        value === undefined\n                    ) {\n                        value = uuidv4()\n                        expression += this.createParameter(value)\n\n                        if (\n                            !(\n                                valueSetIndex in\n                                this.expressionMap.locallyGenerated\n                            )\n                        ) {\n                            this.expressionMap.locallyGenerated[valueSetIndex] =\n                                {}\n                        }\n                        column.setEntityValue(\n                            this.expressionMap.locallyGenerated[valueSetIndex],\n                            value,\n                        )\n\n                        // if value for this column was not provided then insert default value\n                    } else if (value === undefined) {\n                        if (\n                            (this.connection.driver.options.type === \"oracle\" &&\n                                valueSets.length > 1) ||\n                            DriverUtils.isSQLiteFamily(\n                                this.connection.driver,\n                            ) ||\n                            this.connection.driver.options.type === \"sap\" ||\n                            this.connection.driver.options.type === \"spanner\"\n                        ) {\n                            // unfortunately sqlite does not support DEFAULT expression in INSERT queries\n                            if (\n                                column.default !== undefined &&\n                                column.default !== null\n                            ) {\n                                // try to use default defined in the column\n                                expression +=\n                                    this.connection.driver.normalizeDefault(\n                                        column,\n                                    )\n                            } else {\n                                expression += \"NULL\" // otherwise simply use NULL and pray if column is nullable\n                            }\n                        } else {\n                            expression += \"DEFAULT\"\n                        }\n                    } else if (\n                        value === null &&\n                        this.connection.driver.options.type === \"spanner\"\n                    ) {\n                        expression += \"NULL\"\n\n                        // support for SQL expressions in queries\n                    } else if (typeof value === \"function\") {\n                        expression += value()\n\n                        // just any other regular value\n                    } else {\n                        if (this.connection.driver.options.type === \"mssql\")\n                            value = (\n                                this.connection.driver as SqlServerDriver\n                            ).parametrizeValue(column, value)\n\n                        // we need to store array values in a special class to make sure parameter replacement will work correctly\n                        // if (value instanceof Array)\n                        //     value = new ArrayParameter(value);\n\n                        const paramName = this.createParameter(value)\n\n                        if (\n                            (DriverUtils.isMySQLFamily(\n                                this.connection.driver,\n                            ) ||\n                                this.connection.driver.options.type ===\n                                    \"aurora-mysql\") &&\n                            this.connection.driver.spatialTypes.indexOf(\n                                column.type,\n                            ) !== -1\n                        ) {\n                            const useLegacy = (\n                                this.connection.driver as\n                                    | MysqlDriver\n                                    | AuroraMysqlDriver\n                            ).options.legacySpatialSupport\n                            const geomFromText = useLegacy\n                                ? \"GeomFromText\"\n                                : \"ST_GeomFromText\"\n                            if (column.srid != null) {\n                                expression += `${geomFromText}(${paramName}, ${column.srid})`\n                            } else {\n                                expression += `${geomFromText}(${paramName})`\n                            }\n                        } else if (\n                            DriverUtils.isPostgresFamily(\n                                this.connection.driver,\n                            ) &&\n                            this.connection.driver.spatialTypes.indexOf(\n                                column.type,\n                            ) !== -1\n                        ) {\n                            if (column.srid != null) {\n                                expression += `ST_SetSRID(ST_GeomFromGeoJSON(${paramName}), ${column.srid})::${column.type}`\n                            } else {\n                                expression += `ST_GeomFromGeoJSON(${paramName})::${column.type}`\n                            }\n                        } else if (\n                            this.connection.driver.options.type === \"mssql\" &&\n                            this.connection.driver.spatialTypes.indexOf(\n                                column.type,\n                            ) !== -1\n                        ) {\n                            expression +=\n                                column.type +\n                                \"::STGeomFromText(\" +\n                                paramName +\n                                \", \" +\n                                (column.srid || \"0\") +\n                                \")\"\n                        } else {\n                            expression += paramName\n                        }\n                    }\n\n                    if (columnIndex === columns.length - 1) {\n                        if (valueSetIndex === valueSets.length - 1) {\n                            if (\n                                this.connection.driver.options.type ===\n                                    \"oracle\" &&\n                                valueSets.length > 1\n                            ) {\n                                expression += \" FROM DUAL \"\n                            } else if (\n                                this.connection.driver.options.type === \"sap\" &&\n                                valueSets.length > 1\n                            ) {\n                                expression += \" FROM dummy \"\n                            } else {\n                                expression += \")\"\n                            }\n                        } else {\n                            if (\n                                this.connection.driver.options.type ===\n                                    \"oracle\" &&\n                                valueSets.length > 1\n                            ) {\n                                expression += \" FROM DUAL UNION ALL \"\n                            } else if (\n                                this.connection.driver.options.type === \"sap\" &&\n                                valueSets.length > 1\n                            ) {\n                                expression += \" FROM dummy UNION ALL \"\n                            } else {\n                                expression += \"), \"\n                            }\n                        }\n                    } else {\n                        expression += \", \"\n                    }\n                })\n            })\n            if (expression === \"()\") return \"\"\n\n            return expression\n        } else {\n            // for tables without metadata\n            // get values needs to be inserted\n            let expression = \"\"\n\n            valueSets.forEach((valueSet, insertionIndex) => {\n                const columns = Object.keys(valueSet)\n                columns.forEach((columnName, columnIndex) => {\n                    if (columnIndex === 0) {\n                        expression += \"(\"\n                    }\n\n                    const value = valueSet[columnName]\n\n                    // support for SQL expressions in queries\n                    if (typeof value === \"function\") {\n                        expression += value()\n\n                        // if value for this column was not provided then insert default value\n                    } else if (value === undefined) {\n                        if (\n                            (this.connection.driver.options.type === \"oracle\" &&\n                                valueSets.length > 1) ||\n                            DriverUtils.isSQLiteFamily(\n                                this.connection.driver,\n                            ) ||\n                            this.connection.driver.options.type === \"sap\" ||\n                            this.connection.driver.options.type === \"spanner\"\n                        ) {\n                            expression += \"NULL\"\n                        } else {\n                            expression += \"DEFAULT\"\n                        }\n                    } else if (\n                        value === null &&\n                        this.connection.driver.options.type === \"spanner\"\n                    ) {\n                        // just any other regular value\n                    } else {\n                        expression += this.createParameter(value)\n                    }\n\n                    if (columnIndex === Object.keys(valueSet).length - 1) {\n                        if (insertionIndex === valueSets.length - 1) {\n                            expression += \")\"\n                        } else {\n                            expression += \"), \"\n                        }\n                    } else {\n                        expression += \", \"\n                    }\n                })\n            })\n            if (expression === \"()\") return \"\"\n            return expression\n        }\n    }\n\n    /**\n     * Gets array of values need to be inserted into the target table.\n     */\n    protected getValueSets(): ObjectLiteral[] {\n        if (Array.isArray(this.expressionMap.valuesSet))\n            return this.expressionMap.valuesSet\n\n        if (ObjectUtils.isObject(this.expressionMap.valuesSet))\n            return [this.expressionMap.valuesSet]\n\n        throw new InsertValuesMissingError()\n    }\n\n    /**\n     * Checks if column is an auto-generated primary key, but the current insertion specifies a value for it.\n     *\n     * @param column\n     */\n    protected isOverridingAutoIncrementBehavior(\n        column: ColumnMetadata,\n    ): boolean {\n        return (\n            column.isPrimary &&\n            column.isGenerated &&\n            column.generationStrategy === \"increment\" &&\n            this.getValueSets().some(\n                (valueSet) =>\n                    column.getEntityValue(valueSet) !== undefined &&\n                    column.getEntityValue(valueSet) !== null,\n            )\n        )\n    }\n}\n"]},"metadata":{},"sourceType":"module"}