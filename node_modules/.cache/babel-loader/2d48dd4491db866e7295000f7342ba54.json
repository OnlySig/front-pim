{"ast":null,"code":"import { DateUtils } from \"../util/DateUtils\";\nimport { OrmUtils } from \"../util/OrmUtils\";\nimport { ApplyValueTransformers } from \"../util/ApplyValueTransformers\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\n/**\n * Finds what columns are changed in the subject entities.\n */\n\nexport class SubjectChangedColumnsComputer {\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Finds what columns are changed in the subject entities.\n   */\n  compute(subjects) {\n    subjects.forEach(subject => {\n      this.computeDiffColumns(subject);\n      this.computeDiffRelationalColumns(subjects, subject);\n    });\n  } // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Differentiate columns from the updated entity and entity stored in the database.\n   */\n\n\n  computeDiffColumns(subject) {\n    // if there is no persisted entity then nothing to compute changed in it\n    if (!subject.entity) return;\n    subject.metadata.columns.forEach(column => {\n      // ignore special columns\n      if (column.isVirtual || column.isDiscriminator // ||\n      // column.isUpdateDate ||\n      // column.isVersion ||\n      // column.isCreateDate\n      ) return;\n      const changeMap = subject.changeMaps.find(changeMap => changeMap.column === column);\n\n      if (changeMap) {\n        subject.changeMaps.splice(subject.changeMaps.indexOf(changeMap), 1);\n      } // get user provided value - column value from the user provided persisted entity\n\n\n      const entityValue = column.getEntityValue(subject.entity); // we don't perform operation over undefined properties (but we DO need null properties!)\n\n      if (entityValue === undefined) return; // if there is no database entity then all columns are treated as new, e.g. changed\n\n      if (subject.databaseEntity) {\n        // skip transform database value for json / jsonb for comparison later on\n        const shouldTransformDatabaseEntity = column.type !== \"json\" && column.type !== \"jsonb\"; // get database value of the column\n\n        let databaseValue = column.getEntityValue(subject.databaseEntity, shouldTransformDatabaseEntity); // filter out \"relational columns\" only in the case if there is a relation object in entity\n\n        if (column.relationMetadata) {\n          const value = column.relationMetadata.getEntityValue(subject.entity);\n          if (value !== null && value !== undefined) return;\n        }\n\n        let normalizedValue = entityValue; // normalize special values to make proper comparision\n\n        if (entityValue !== null) {\n          switch (column.type) {\n            case \"date\":\n              normalizedValue = DateUtils.mixedDateToDateString(entityValue);\n              break;\n\n            case \"time\":\n            case \"time with time zone\":\n            case \"time without time zone\":\n            case \"timetz\":\n              normalizedValue = DateUtils.mixedDateToTimeString(entityValue);\n              break;\n\n            case \"datetime\":\n            case \"datetime2\":\n            case Date:\n            case \"timestamp\":\n            case \"timestamp without time zone\":\n            case \"timestamp with time zone\":\n            case \"timestamp with local time zone\":\n            case \"timestamptz\":\n              normalizedValue = DateUtils.mixedDateToUtcDatetimeString(entityValue);\n              databaseValue = DateUtils.mixedDateToUtcDatetimeString(databaseValue);\n              break;\n\n            case \"json\":\n            case \"jsonb\":\n              // JSON.stringify doesn't work because postgresql sorts jsonb before save.\n              // If you try to save json '[{\"messages\": \"\", \"attribute Key\": \"\", \"level\":\"\"}] ' as jsonb,\n              // then postgresql will save it as '[{\"level\": \"\", \"message\":\"\", \"attributeKey\": \"\"}]'\n              if (OrmUtils.deepCompare(entityValue, databaseValue)) return;\n              break;\n\n            case \"simple-array\":\n              normalizedValue = DateUtils.simpleArrayToString(entityValue);\n              databaseValue = DateUtils.simpleArrayToString(databaseValue);\n              break;\n\n            case \"simple-enum\":\n              normalizedValue = DateUtils.simpleEnumToString(entityValue);\n              databaseValue = DateUtils.simpleEnumToString(databaseValue);\n              break;\n\n            case \"simple-json\":\n              normalizedValue = DateUtils.simpleJsonToString(entityValue);\n              databaseValue = DateUtils.simpleJsonToString(databaseValue);\n              break;\n          }\n\n          if (column.transformer) {\n            normalizedValue = ApplyValueTransformers.transformTo(column.transformer, entityValue);\n          }\n        } // if value is not changed - then do nothing\n\n\n        if (Buffer.isBuffer(normalizedValue) && Buffer.isBuffer(databaseValue)) {\n          if (normalizedValue.equals(databaseValue)) {\n            return;\n          }\n        } else {\n          if (normalizedValue === databaseValue) return;\n        }\n      }\n\n      subject.diffColumns.push(column);\n      subject.changeMaps.push({\n        column: column,\n        value: entityValue\n      });\n    });\n  }\n  /**\n   * Difference columns of the owning one-to-one and many-to-one columns.\n   */\n\n\n  computeDiffRelationalColumns(allSubjects, subject) {\n    // if there is no persisted entity then nothing to compute changed in it\n    if (!subject.entity) return;\n    subject.metadata.relationsWithJoinColumns.forEach(relation => {\n      // get the related entity from the persisted entity\n      let relatedEntity = relation.getEntityValue(subject.entity); // we don't perform operation over undefined properties (but we DO need null properties!)\n\n      if (relatedEntity === undefined) return; // if there is no database entity then all relational columns are treated as new, e.g. changed\n\n      if (subject.databaseEntity) {\n        // here we cover two scenarios:\n        // 1. related entity can be another entity which is natural way\n        // 2. related entity can be just an entity id\n        // if relation entity is just a relation id set (for example post.tag = 1)\n        // then we create an id map from it to make a proper comparision\n        let relatedEntityRelationIdMap = relatedEntity;\n        if (relatedEntityRelationIdMap !== null && ObjectUtils.isObject(relatedEntityRelationIdMap)) relatedEntityRelationIdMap = relation.getRelationIdMap(relatedEntityRelationIdMap); // get database related entity. Since loadRelationIds are used on databaseEntity\n        // related entity will contain only its relation ids\n\n        const databaseRelatedEntityRelationIdMap = relation.getEntityValue(subject.databaseEntity); // if relation ids are equal then we don't need to update anything\n\n        const areRelatedIdsEqual = OrmUtils.compareIds(relatedEntityRelationIdMap, databaseRelatedEntityRelationIdMap);\n\n        if (areRelatedIdsEqual) {\n          return;\n        } else {\n          subject.diffRelations.push(relation);\n        }\n      } // if there is an inserted subject for the related entity of the persisted entity then use it as related entity\n      // this code is used for related entities without ids to be properly inserted (and then updated if needed)\n\n\n      const valueSubject = allSubjects.find(subject => subject.mustBeInserted && subject.entity === relatedEntity);\n      if (valueSubject) relatedEntity = valueSubject; // find if there is already a relation to be changed\n\n      const changeMap = subject.changeMaps.find(changeMap => changeMap.relation === relation);\n\n      if (changeMap) {\n        // and update its value if it was found\n        changeMap.value = relatedEntity;\n      } else {\n        // if it wasn't found add a new relation for change\n        subject.changeMaps.push({\n          relation: relation,\n          value: relatedEntity\n        });\n      }\n    });\n  }\n\n}","map":{"version":3,"mappings":"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","names":["DateUtils","OrmUtils","ApplyValueTransformers","ObjectUtils","SubjectChangedColumnsComputer","compute","subjects","forEach","subject","computeDiffColumns","computeDiffRelationalColumns","entity","metadata","columns","column","isVirtual","isDiscriminator","changeMap","changeMaps","find","splice","indexOf","entityValue","getEntityValue","undefined","databaseEntity","shouldTransformDatabaseEntity","type","databaseValue","relationMetadata","value","normalizedValue","mixedDateToDateString","mixedDateToTimeString","Date","mixedDateToUtcDatetimeString","deepCompare","simpleArrayToString","simpleEnumToString","simpleJsonToString","transformer","transformTo","Buffer","isBuffer","equals","diffColumns","push","allSubjects","relationsWithJoinColumns","relation","relatedEntity","relatedEntityRelationIdMap","isObject","getRelationIdMap","databaseRelatedEntityRelationIdMap","areRelatedIdsEqual","compareIds","diffRelations","valueSubject","mustBeInserted"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\persistence\\SubjectChangedColumnsComputer.ts"],"sourcesContent":["import { Subject } from \"./Subject\"\nimport { DateUtils } from \"../util/DateUtils\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { OrmUtils } from \"../util/OrmUtils\"\nimport { ApplyValueTransformers } from \"../util/ApplyValueTransformers\"\nimport { ObjectUtils } from \"../util/ObjectUtils\"\n\n/**\n * Finds what columns are changed in the subject entities.\n */\nexport class SubjectChangedColumnsComputer {\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Finds what columns are changed in the subject entities.\n     */\n    compute(subjects: Subject[]) {\n        subjects.forEach((subject) => {\n            this.computeDiffColumns(subject)\n            this.computeDiffRelationalColumns(subjects, subject)\n        })\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Differentiate columns from the updated entity and entity stored in the database.\n     */\n    protected computeDiffColumns(subject: Subject): void {\n        // if there is no persisted entity then nothing to compute changed in it\n        if (!subject.entity) return\n\n        subject.metadata.columns.forEach((column) => {\n            // ignore special columns\n            if (\n                column.isVirtual ||\n                column.isDiscriminator // ||\n                // column.isUpdateDate ||\n                // column.isVersion ||\n                // column.isCreateDate\n            )\n                return\n\n            const changeMap = subject.changeMaps.find(\n                (changeMap) => changeMap.column === column,\n            )\n            if (changeMap) {\n                subject.changeMaps.splice(\n                    subject.changeMaps.indexOf(changeMap),\n                    1,\n                )\n            }\n\n            // get user provided value - column value from the user provided persisted entity\n            const entityValue = column.getEntityValue(subject.entity!)\n\n            // we don't perform operation over undefined properties (but we DO need null properties!)\n            if (entityValue === undefined) return\n\n            // if there is no database entity then all columns are treated as new, e.g. changed\n            if (subject.databaseEntity) {\n                // skip transform database value for json / jsonb for comparison later on\n                const shouldTransformDatabaseEntity =\n                    column.type !== \"json\" && column.type !== \"jsonb\"\n\n                // get database value of the column\n                let databaseValue = column.getEntityValue(\n                    subject.databaseEntity,\n                    shouldTransformDatabaseEntity,\n                )\n\n                // filter out \"relational columns\" only in the case if there is a relation object in entity\n                if (column.relationMetadata) {\n                    const value = column.relationMetadata.getEntityValue(\n                        subject.entity!,\n                    )\n                    if (value !== null && value !== undefined) return\n                }\n                let normalizedValue = entityValue\n                // normalize special values to make proper comparision\n                if (entityValue !== null) {\n                    switch (column.type) {\n                        case \"date\":\n                            normalizedValue =\n                                DateUtils.mixedDateToDateString(entityValue)\n                            break\n\n                        case \"time\":\n                        case \"time with time zone\":\n                        case \"time without time zone\":\n                        case \"timetz\":\n                            normalizedValue =\n                                DateUtils.mixedDateToTimeString(entityValue)\n                            break\n\n                        case \"datetime\":\n                        case \"datetime2\":\n                        case Date:\n                        case \"timestamp\":\n                        case \"timestamp without time zone\":\n                        case \"timestamp with time zone\":\n                        case \"timestamp with local time zone\":\n                        case \"timestamptz\":\n                            normalizedValue =\n                                DateUtils.mixedDateToUtcDatetimeString(\n                                    entityValue,\n                                )\n                            databaseValue =\n                                DateUtils.mixedDateToUtcDatetimeString(\n                                    databaseValue,\n                                )\n                            break\n\n                        case \"json\":\n                        case \"jsonb\":\n                            // JSON.stringify doesn't work because postgresql sorts jsonb before save.\n                            // If you try to save json '[{\"messages\": \"\", \"attribute Key\": \"\", \"level\":\"\"}] ' as jsonb,\n                            // then postgresql will save it as '[{\"level\": \"\", \"message\":\"\", \"attributeKey\": \"\"}]'\n                            if (\n                                OrmUtils.deepCompare(entityValue, databaseValue)\n                            )\n                                return\n                            break\n\n                        case \"simple-array\":\n                            normalizedValue =\n                                DateUtils.simpleArrayToString(entityValue)\n                            databaseValue =\n                                DateUtils.simpleArrayToString(databaseValue)\n                            break\n                        case \"simple-enum\":\n                            normalizedValue =\n                                DateUtils.simpleEnumToString(entityValue)\n                            databaseValue =\n                                DateUtils.simpleEnumToString(databaseValue)\n                            break\n                        case \"simple-json\":\n                            normalizedValue =\n                                DateUtils.simpleJsonToString(entityValue)\n                            databaseValue =\n                                DateUtils.simpleJsonToString(databaseValue)\n                            break\n                    }\n\n                    if (column.transformer) {\n                        normalizedValue = ApplyValueTransformers.transformTo(\n                            column.transformer,\n                            entityValue,\n                        )\n                    }\n                }\n\n                // if value is not changed - then do nothing\n                if (\n                    Buffer.isBuffer(normalizedValue) &&\n                    Buffer.isBuffer(databaseValue)\n                ) {\n                    if (normalizedValue.equals(databaseValue)) {\n                        return\n                    }\n                } else {\n                    if (normalizedValue === databaseValue) return\n                }\n            }\n            subject.diffColumns.push(column)\n            subject.changeMaps.push({\n                column: column,\n                value: entityValue,\n            })\n        })\n    }\n\n    /**\n     * Difference columns of the owning one-to-one and many-to-one columns.\n     */\n    protected computeDiffRelationalColumns(\n        allSubjects: Subject[],\n        subject: Subject,\n    ): void {\n        // if there is no persisted entity then nothing to compute changed in it\n        if (!subject.entity) return\n\n        subject.metadata.relationsWithJoinColumns.forEach((relation) => {\n            // get the related entity from the persisted entity\n            let relatedEntity = relation.getEntityValue(subject.entity!)\n\n            // we don't perform operation over undefined properties (but we DO need null properties!)\n            if (relatedEntity === undefined) return\n\n            // if there is no database entity then all relational columns are treated as new, e.g. changed\n            if (subject.databaseEntity) {\n                // here we cover two scenarios:\n                // 1. related entity can be another entity which is natural way\n                // 2. related entity can be just an entity id\n                // if relation entity is just a relation id set (for example post.tag = 1)\n                // then we create an id map from it to make a proper comparision\n                let relatedEntityRelationIdMap: ObjectLiteral = relatedEntity\n                if (\n                    relatedEntityRelationIdMap !== null &&\n                    ObjectUtils.isObject(relatedEntityRelationIdMap)\n                )\n                    relatedEntityRelationIdMap = relation.getRelationIdMap(\n                        relatedEntityRelationIdMap,\n                    )!\n\n                // get database related entity. Since loadRelationIds are used on databaseEntity\n                // related entity will contain only its relation ids\n                const databaseRelatedEntityRelationIdMap =\n                    relation.getEntityValue(subject.databaseEntity)\n\n                // if relation ids are equal then we don't need to update anything\n                const areRelatedIdsEqual = OrmUtils.compareIds(\n                    relatedEntityRelationIdMap,\n                    databaseRelatedEntityRelationIdMap,\n                )\n                if (areRelatedIdsEqual) {\n                    return\n                } else {\n                    subject.diffRelations.push(relation)\n                }\n            }\n\n            // if there is an inserted subject for the related entity of the persisted entity then use it as related entity\n            // this code is used for related entities without ids to be properly inserted (and then updated if needed)\n            const valueSubject = allSubjects.find(\n                (subject) =>\n                    subject.mustBeInserted && subject.entity === relatedEntity,\n            )\n            if (valueSubject) relatedEntity = valueSubject\n\n            // find if there is already a relation to be changed\n            const changeMap = subject.changeMaps.find(\n                (changeMap) => changeMap.relation === relation,\n            )\n            if (changeMap) {\n                // and update its value if it was found\n                changeMap.value = relatedEntity\n            } else {\n                // if it wasn't found add a new relation for change\n                subject.changeMaps.push({\n                    relation: relation,\n                    value: relatedEntity,\n                })\n            }\n        })\n    }\n}\n"]},"metadata":{},"sourceType":"module"}