{"ast":null,"code":"/**\n * Metadata args utility functions.\n */\nexport class MetadataUtils {\n  /**\n   * Gets given's entity all inherited classes.\n   * Gives in order from parents to children.\n   * For example Post extends ContentModel which extends Unit it will give\n   * [Unit, ContentModel, Post]\n   */\n  static getInheritanceTree(entity) {\n    const tree = [entity];\n\n    const getPrototypeOf = object => {\n      const proto = Object.getPrototypeOf(object);\n\n      if (proto && proto.name) {\n        tree.push(proto);\n        getPrototypeOf(proto);\n      }\n    };\n\n    getPrototypeOf(entity);\n    return tree;\n  }\n  /**\n   * Checks if this table is inherited from another table.\n   */\n\n\n  static isInherited(target1, target2) {\n    return target1.prototype instanceof target2;\n  }\n  /**\n   * Filters given array of targets by a given classes.\n   * If classes are not given, then it returns array itself.\n   */\n\n\n  static filterByTarget(array, classes) {\n    if (!classes) return array;\n    return array.filter(item => item.target && classes.indexOf(item.target) !== -1);\n  }\n\n}","map":{"version":3,"mappings":"AAAA;;;AAGA,OAAM,MAAOA,aAAP,CAAoB;EACtB;;;;;;EAMyB,OAAlBC,kBAAkB,CAACC,MAAD,EAAiB;IACtC,MAAMC,IAAI,GAAe,CAACD,MAAD,CAAzB;;IACA,MAAME,cAAc,GAAIC,MAAD,IAA2B;MAC9C,MAAMC,KAAK,GAAGC,MAAM,CAACH,cAAP,CAAsBC,MAAtB,CAAd;;MACA,IAAIC,KAAK,IAAIA,KAAK,CAACE,IAAnB,EAAyB;QACrBL,IAAI,CAACM,IAAL,CAAUH,KAAV;QACAF,cAAc,CAACE,KAAD,CAAd;MACH;IACJ,CAND;;IAOAF,cAAc,CAACF,MAAD,CAAd;IACA,OAAOC,IAAP;EACH;EAED;;;;;EAGkB,OAAXO,WAAW,CAACC,OAAD,EAAoBC,OAApB,EAAqC;IACnD,OAAOD,OAAO,CAACE,SAAR,YAA6BD,OAApC;EACH;EAED;;;;;;EAIqB,OAAdE,cAAc,CACjBC,KADiB,EAEjBC,OAFiB,EAEF;IAEf,IAAI,CAACA,OAAL,EAAc,OAAOD,KAAP;IACd,OAAOA,KAAK,CAACE,MAAN,CACFC,IAAD,IAAUA,IAAI,CAACC,MAAL,IAAeH,OAAO,CAACI,OAAR,CAAgBF,IAAI,CAACC,MAArB,MAAiC,CAAC,CADxD,CAAP;EAGH;;AAvCqB","names":["MetadataUtils","getInheritanceTree","entity","tree","getPrototypeOf","object","proto","Object","name","push","isInherited","target1","target2","prototype","filterByTarget","array","classes","filter","item","target","indexOf"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\metadata-builder\\MetadataUtils.ts"],"sourcesContent":["/**\n * Metadata args utility functions.\n */\nexport class MetadataUtils {\n    /**\n     * Gets given's entity all inherited classes.\n     * Gives in order from parents to children.\n     * For example Post extends ContentModel which extends Unit it will give\n     * [Unit, ContentModel, Post]\n     */\n    static getInheritanceTree(entity: Function): Function[] {\n        const tree: Function[] = [entity]\n        const getPrototypeOf = (object: Function): void => {\n            const proto = Object.getPrototypeOf(object)\n            if (proto && proto.name) {\n                tree.push(proto)\n                getPrototypeOf(proto)\n            }\n        }\n        getPrototypeOf(entity)\n        return tree\n    }\n\n    /**\n     * Checks if this table is inherited from another table.\n     */\n    static isInherited(target1: Function, target2: Function) {\n        return target1.prototype instanceof target2\n    }\n\n    /**\n     * Filters given array of targets by a given classes.\n     * If classes are not given, then it returns array itself.\n     */\n    static filterByTarget<T extends { target?: any }>(\n        array: T[],\n        classes?: any[],\n    ): T[] {\n        if (!classes) return array\n        return array.filter(\n            (item) => item.target && classes.indexOf(item.target) !== -1,\n        )\n    }\n}\n"]},"metadata":{},"sourceType":"module"}