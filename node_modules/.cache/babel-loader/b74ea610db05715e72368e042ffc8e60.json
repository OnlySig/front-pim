{"ast":null,"code":"import { TypeORMError } from \"../error\";\n/**\n * Contains all information about entity's embedded property.\n */\n\nexport class EmbeddedMetadata {\n  // ---------------------------------------------------------------------\n  // Constructor\n  // ---------------------------------------------------------------------\n  constructor(options) {\n    /**\n     * Columns inside this embed.\n     */\n    this.columns = [];\n    /**\n     * Relations inside this embed.\n     */\n\n    this.relations = [];\n    /**\n     * Entity listeners inside this embed.\n     */\n\n    this.listeners = [];\n    /**\n     * Indices applied to the embed columns.\n     */\n\n    this.indices = [];\n    /**\n     * Uniques applied to the embed columns.\n     */\n\n    this.uniques = [];\n    /**\n     * Relation ids inside this embed.\n     */\n\n    this.relationIds = [];\n    /**\n     * Relation counts inside this embed.\n     */\n\n    this.relationCounts = [];\n    /**\n     * Nested embeddable in this embeddable (which has current embedded as parent embedded).\n     */\n\n    this.embeddeds = [];\n    /**\n     * Indicates if the entity should be instantiated using the constructor\n     * or via allocating a new object via `Object.create()`.\n     */\n\n    this.isAlwaysUsingConstructor = true;\n    /**\n     * Indicates if this embedded is in array mode.\n     *\n     * This option works only in mongodb.\n     */\n\n    this.isArray = false;\n    /**\n     * Returns array of property names of current embed and all its parent embeds.\n     *\n     * example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeds\n     * we need to get value of \"id\" column from the post real entity object.\n     * this method will return [\"data\", \"information\", \"counters\"]\n     */\n\n    this.parentPropertyNames = [];\n    /**\n     * Returns array of prefixes of current embed and all its parent embeds.\n     */\n\n    this.parentPrefixes = [];\n    /**\n     * Returns embed metadatas from all levels of the parent tree.\n     *\n     * example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeds\n     * this method will return [embed metadata of data, embed metadata of information, embed metadata of counters]\n     */\n\n    this.embeddedMetadataTree = [];\n    /**\n     * Embed metadatas from all levels of the parent tree.\n     *\n     * example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeds\n     * this method will return [embed metadata of data, embed metadata of information, embed metadata of counters]\n     */\n\n    this.columnsFromTree = [];\n    /**\n     * Relations of this embed and all relations from its child embeds.\n     */\n\n    this.relationsFromTree = [];\n    /**\n     * Relations of this embed and all relations from its child embeds.\n     */\n\n    this.listenersFromTree = [];\n    /**\n     * Indices of this embed and all indices from its child embeds.\n     */\n\n    this.indicesFromTree = [];\n    /**\n     * Uniques of this embed and all uniques from its child embeds.\n     */\n\n    this.uniquesFromTree = [];\n    /**\n     * Relation ids of this embed and all relation ids from its child embeds.\n     */\n\n    this.relationIdsFromTree = [];\n    /**\n     * Relation counts of this embed and all relation counts from its child embeds.\n     */\n\n    this.relationCountsFromTree = [];\n    this.entityMetadata = options.entityMetadata;\n    this.type = options.args.type();\n    this.propertyName = options.args.propertyName;\n    this.customPrefix = options.args.prefix;\n    this.isArray = options.args.isArray;\n  } // ---------------------------------------------------------------------\n  // Public Methods\n  // ---------------------------------------------------------------------\n\n  /**\n   * Creates a new embedded object.\n   */\n\n\n  create(options) {\n    if (!(typeof this.type === \"function\")) {\n      return {};\n    }\n\n    if (!(options === null || options === void 0 ? void 0 : options.fromDeserializer) || this.isAlwaysUsingConstructor) {\n      return new this.type();\n    } else {\n      return Object.create(this.type.prototype);\n    }\n  } // ---------------------------------------------------------------------\n  // Builder Methods\n  // ---------------------------------------------------------------------\n\n\n  build(connection) {\n    this.embeddeds.forEach(embedded => embedded.build(connection));\n    this.prefix = this.buildPrefix(connection);\n    this.parentPropertyNames = this.buildParentPropertyNames();\n    this.parentPrefixes = this.buildParentPrefixes();\n    this.propertyPath = this.parentPropertyNames.join(\".\");\n    this.embeddedMetadataTree = this.buildEmbeddedMetadataTree();\n    this.columnsFromTree = this.buildColumnsFromTree();\n    this.relationsFromTree = this.buildRelationsFromTree();\n    this.listenersFromTree = this.buildListenersFromTree();\n    this.indicesFromTree = this.buildIndicesFromTree();\n    this.uniquesFromTree = this.buildUniquesFromTree();\n    this.relationIdsFromTree = this.buildRelationIdsFromTree();\n    this.relationCountsFromTree = this.buildRelationCountsFromTree();\n\n    if (connection.options.entitySkipConstructor) {\n      this.isAlwaysUsingConstructor = !connection.options.entitySkipConstructor;\n    }\n\n    return this;\n  } // ---------------------------------------------------------------------\n  // Protected Methods\n  // ---------------------------------------------------------------------\n\n\n  buildPartialPrefix() {\n    // if prefix option was not set or explicitly set to true - default prefix\n    if (this.customPrefix === undefined || this.customPrefix === true) {\n      return [this.propertyName];\n    } // if prefix option was set to empty string or explicity set to false - disable prefix\n\n\n    if (this.customPrefix === \"\" || this.customPrefix === false) {\n      return [];\n    } // use custom prefix\n\n\n    if (typeof this.customPrefix === \"string\") {\n      return [this.customPrefix];\n    }\n\n    throw new TypeORMError(`Invalid prefix option given for ${this.entityMetadata.targetName}#${this.propertyName}`);\n  }\n\n  buildPrefix(connection) {\n    if (connection.driver.options.type === \"mongodb\") return this.propertyName;\n    let prefixes = [];\n    if (this.parentEmbeddedMetadata) prefixes.push(this.parentEmbeddedMetadata.buildPrefix(connection));\n    prefixes.push(...this.buildPartialPrefix());\n    return prefixes.join(\"_\"); // todo: use naming strategy instead of \"_\"  !!!\n  }\n\n  buildParentPropertyNames() {\n    return this.parentEmbeddedMetadata ? this.parentEmbeddedMetadata.buildParentPropertyNames().concat(this.propertyName) : [this.propertyName];\n  }\n\n  buildParentPrefixes() {\n    return this.parentEmbeddedMetadata ? this.parentEmbeddedMetadata.buildParentPrefixes().concat(this.buildPartialPrefix()) : this.buildPartialPrefix();\n  }\n\n  buildEmbeddedMetadataTree() {\n    return this.parentEmbeddedMetadata ? this.parentEmbeddedMetadata.buildEmbeddedMetadataTree().concat(this) : [this];\n  }\n\n  buildColumnsFromTree() {\n    return this.embeddeds.reduce((columns, embedded) => columns.concat(embedded.buildColumnsFromTree()), this.columns);\n  }\n\n  buildRelationsFromTree() {\n    return this.embeddeds.reduce((relations, embedded) => relations.concat(embedded.buildRelationsFromTree()), this.relations);\n  }\n\n  buildListenersFromTree() {\n    return this.embeddeds.reduce((relations, embedded) => relations.concat(embedded.buildListenersFromTree()), this.listeners);\n  }\n\n  buildIndicesFromTree() {\n    return this.embeddeds.reduce((relations, embedded) => relations.concat(embedded.buildIndicesFromTree()), this.indices);\n  }\n\n  buildUniquesFromTree() {\n    return this.embeddeds.reduce((relations, embedded) => relations.concat(embedded.buildUniquesFromTree()), this.uniques);\n  }\n\n  buildRelationIdsFromTree() {\n    return this.embeddeds.reduce((relations, embedded) => relations.concat(embedded.buildRelationIdsFromTree()), this.relationIds);\n  }\n\n  buildRelationCountsFromTree() {\n    return this.embeddeds.reduce((relations, embedded) => relations.concat(embedded.buildRelationCountsFromTree()), this.relationCounts);\n  }\n\n}","map":{"version":3,"mappings":"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","names":["TypeORMError","EmbeddedMetadata","constructor","options","entityMetadata","type","args","propertyName","customPrefix","prefix","isArray","create","fromDeserializer","isAlwaysUsingConstructor","Object","prototype","build","connection","embeddeds","forEach","embedded","buildPrefix","parentPropertyNames","buildParentPropertyNames","parentPrefixes","buildParentPrefixes","propertyPath","join","embeddedMetadataTree","buildEmbeddedMetadataTree","columnsFromTree","buildColumnsFromTree","relationsFromTree","buildRelationsFromTree","listenersFromTree","buildListenersFromTree","indicesFromTree","buildIndicesFromTree","uniquesFromTree","buildUniquesFromTree","relationIdsFromTree","buildRelationIdsFromTree","relationCountsFromTree","buildRelationCountsFromTree","entitySkipConstructor","buildPartialPrefix","undefined","targetName","driver","prefixes","parentEmbeddedMetadata","push","concat","reduce","columns","relations","listeners","indices","uniques","relationIds","relationCounts"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\metadata\\EmbeddedMetadata.ts"],"sourcesContent":["import { ColumnMetadata } from \"./ColumnMetadata\"\nimport { RelationMetadata } from \"./RelationMetadata\"\nimport { EntityMetadata } from \"./EntityMetadata\"\nimport { EmbeddedMetadataArgs } from \"../metadata-args/EmbeddedMetadataArgs\"\nimport { RelationIdMetadata } from \"./RelationIdMetadata\"\nimport { RelationCountMetadata } from \"./RelationCountMetadata\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { EntityListenerMetadata } from \"./EntityListenerMetadata\"\nimport { IndexMetadata } from \"./IndexMetadata\"\nimport { UniqueMetadata } from \"./UniqueMetadata\"\nimport { TypeORMError } from \"../error\"\n\n/**\n * Contains all information about entity's embedded property.\n */\nexport class EmbeddedMetadata {\n    // ---------------------------------------------------------------------\n    // Public Properties\n    // ---------------------------------------------------------------------\n\n    /**\n     * Entity metadata where this embedded is.\n     */\n    entityMetadata: EntityMetadata\n\n    /**\n     * Parent embedded in the case if this embedded inside other embedded.\n     */\n    parentEmbeddedMetadata?: EmbeddedMetadata\n\n    /**\n     * Embedded target type.\n     */\n    type: Function | string\n\n    /**\n     * Property name on which this embedded is attached.\n     */\n    propertyName: string\n\n    /**\n     * Gets full path to this embedded property (including embedded property name).\n     * Full path is relevant when embedded is used inside other embeds (one or multiple nested).\n     * For example it will return \"counters.subcounters\".\n     */\n    propertyPath: string\n\n    /**\n     * Columns inside this embed.\n     */\n    columns: ColumnMetadata[] = []\n\n    /**\n     * Relations inside this embed.\n     */\n    relations: RelationMetadata[] = []\n\n    /**\n     * Entity listeners inside this embed.\n     */\n    listeners: EntityListenerMetadata[] = []\n\n    /**\n     * Indices applied to the embed columns.\n     */\n    indices: IndexMetadata[] = []\n\n    /**\n     * Uniques applied to the embed columns.\n     */\n    uniques: UniqueMetadata[] = []\n\n    /**\n     * Relation ids inside this embed.\n     */\n    relationIds: RelationIdMetadata[] = []\n\n    /**\n     * Relation counts inside this embed.\n     */\n    relationCounts: RelationCountMetadata[] = []\n\n    /**\n     * Nested embeddable in this embeddable (which has current embedded as parent embedded).\n     */\n    embeddeds: EmbeddedMetadata[] = []\n\n    /**\n     * Indicates if the entity should be instantiated using the constructor\n     * or via allocating a new object via `Object.create()`.\n     */\n    isAlwaysUsingConstructor: boolean = true\n\n    /**\n     * Indicates if this embedded is in array mode.\n     *\n     * This option works only in mongodb.\n     */\n    isArray: boolean = false\n\n    /**\n     * Prefix of the embedded, used instead of propertyName.\n     * If set to empty string or false, then prefix is not set at all.\n     */\n    customPrefix: string | boolean | undefined\n\n    /**\n     * Gets the prefix of the columns.\n     * By default its a property name of the class where this prefix is.\n     * But if custom prefix is set then it takes its value as a prefix.\n     * However if custom prefix is set to empty string or false, then prefix to column is not applied at all.\n     */\n    prefix: string\n\n    /**\n     * Returns array of property names of current embed and all its parent embeds.\n     *\n     * example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeds\n     * we need to get value of \"id\" column from the post real entity object.\n     * this method will return [\"data\", \"information\", \"counters\"]\n     */\n    parentPropertyNames: string[] = []\n\n    /**\n     * Returns array of prefixes of current embed and all its parent embeds.\n     */\n    parentPrefixes: string[] = []\n\n    /**\n     * Returns embed metadatas from all levels of the parent tree.\n     *\n     * example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeds\n     * this method will return [embed metadata of data, embed metadata of information, embed metadata of counters]\n     */\n    embeddedMetadataTree: EmbeddedMetadata[] = []\n\n    /**\n     * Embed metadatas from all levels of the parent tree.\n     *\n     * example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeds\n     * this method will return [embed metadata of data, embed metadata of information, embed metadata of counters]\n     */\n    columnsFromTree: ColumnMetadata[] = []\n\n    /**\n     * Relations of this embed and all relations from its child embeds.\n     */\n    relationsFromTree: RelationMetadata[] = []\n\n    /**\n     * Relations of this embed and all relations from its child embeds.\n     */\n    listenersFromTree: EntityListenerMetadata[] = []\n\n    /**\n     * Indices of this embed and all indices from its child embeds.\n     */\n    indicesFromTree: IndexMetadata[] = []\n\n    /**\n     * Uniques of this embed and all uniques from its child embeds.\n     */\n    uniquesFromTree: UniqueMetadata[] = []\n\n    /**\n     * Relation ids of this embed and all relation ids from its child embeds.\n     */\n    relationIdsFromTree: RelationIdMetadata[] = []\n\n    /**\n     * Relation counts of this embed and all relation counts from its child embeds.\n     */\n    relationCountsFromTree: RelationCountMetadata[] = []\n\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(options: {\n        entityMetadata: EntityMetadata\n        args: EmbeddedMetadataArgs\n    }) {\n        this.entityMetadata = options.entityMetadata\n        this.type = options.args.type()\n        this.propertyName = options.args.propertyName\n        this.customPrefix = options.args.prefix\n        this.isArray = options.args.isArray\n    }\n\n    // ---------------------------------------------------------------------\n    // Public Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Creates a new embedded object.\n     */\n    create(options?: { fromDeserializer?: boolean }): any {\n        if (!(typeof this.type === \"function\")) {\n            return {}\n        }\n\n        if (!options?.fromDeserializer || this.isAlwaysUsingConstructor) {\n            return new (this.type as any)()\n        } else {\n            return Object.create(this.type.prototype)\n        }\n    }\n\n    // ---------------------------------------------------------------------\n    // Builder Methods\n    // ---------------------------------------------------------------------\n\n    build(connection: DataSource): this {\n        this.embeddeds.forEach((embedded) => embedded.build(connection))\n        this.prefix = this.buildPrefix(connection)\n        this.parentPropertyNames = this.buildParentPropertyNames()\n        this.parentPrefixes = this.buildParentPrefixes()\n        this.propertyPath = this.parentPropertyNames.join(\".\")\n        this.embeddedMetadataTree = this.buildEmbeddedMetadataTree()\n        this.columnsFromTree = this.buildColumnsFromTree()\n        this.relationsFromTree = this.buildRelationsFromTree()\n        this.listenersFromTree = this.buildListenersFromTree()\n        this.indicesFromTree = this.buildIndicesFromTree()\n        this.uniquesFromTree = this.buildUniquesFromTree()\n        this.relationIdsFromTree = this.buildRelationIdsFromTree()\n        this.relationCountsFromTree = this.buildRelationCountsFromTree()\n\n        if (connection.options.entitySkipConstructor) {\n            this.isAlwaysUsingConstructor =\n                !connection.options.entitySkipConstructor\n        }\n\n        return this\n    }\n\n    // ---------------------------------------------------------------------\n    // Protected Methods\n    // ---------------------------------------------------------------------\n\n    protected buildPartialPrefix(): string[] {\n        // if prefix option was not set or explicitly set to true - default prefix\n        if (this.customPrefix === undefined || this.customPrefix === true) {\n            return [this.propertyName]\n        }\n\n        // if prefix option was set to empty string or explicity set to false - disable prefix\n        if (this.customPrefix === \"\" || this.customPrefix === false) {\n            return []\n        }\n\n        // use custom prefix\n        if (typeof this.customPrefix === \"string\") {\n            return [this.customPrefix]\n        }\n\n        throw new TypeORMError(\n            `Invalid prefix option given for ${this.entityMetadata.targetName}#${this.propertyName}`,\n        )\n    }\n\n    protected buildPrefix(connection: DataSource): string {\n        if (connection.driver.options.type === \"mongodb\")\n            return this.propertyName\n\n        let prefixes: string[] = []\n        if (this.parentEmbeddedMetadata)\n            prefixes.push(this.parentEmbeddedMetadata.buildPrefix(connection))\n\n        prefixes.push(...this.buildPartialPrefix())\n\n        return prefixes.join(\"_\") // todo: use naming strategy instead of \"_\"  !!!\n    }\n\n    protected buildParentPropertyNames(): string[] {\n        return this.parentEmbeddedMetadata\n            ? this.parentEmbeddedMetadata\n                  .buildParentPropertyNames()\n                  .concat(this.propertyName)\n            : [this.propertyName]\n    }\n\n    protected buildParentPrefixes(): string[] {\n        return this.parentEmbeddedMetadata\n            ? this.parentEmbeddedMetadata\n                  .buildParentPrefixes()\n                  .concat(this.buildPartialPrefix())\n            : this.buildPartialPrefix()\n    }\n\n    protected buildEmbeddedMetadataTree(): EmbeddedMetadata[] {\n        return this.parentEmbeddedMetadata\n            ? this.parentEmbeddedMetadata\n                  .buildEmbeddedMetadataTree()\n                  .concat(this)\n            : [this]\n    }\n\n    protected buildColumnsFromTree(): ColumnMetadata[] {\n        return this.embeddeds.reduce(\n            (columns, embedded) =>\n                columns.concat(embedded.buildColumnsFromTree()),\n            this.columns,\n        )\n    }\n\n    protected buildRelationsFromTree(): RelationMetadata[] {\n        return this.embeddeds.reduce(\n            (relations, embedded) =>\n                relations.concat(embedded.buildRelationsFromTree()),\n            this.relations,\n        )\n    }\n\n    protected buildListenersFromTree(): EntityListenerMetadata[] {\n        return this.embeddeds.reduce(\n            (relations, embedded) =>\n                relations.concat(embedded.buildListenersFromTree()),\n            this.listeners,\n        )\n    }\n\n    protected buildIndicesFromTree(): IndexMetadata[] {\n        return this.embeddeds.reduce(\n            (relations, embedded) =>\n                relations.concat(embedded.buildIndicesFromTree()),\n            this.indices,\n        )\n    }\n\n    protected buildUniquesFromTree(): UniqueMetadata[] {\n        return this.embeddeds.reduce(\n            (relations, embedded) =>\n                relations.concat(embedded.buildUniquesFromTree()),\n            this.uniques,\n        )\n    }\n\n    protected buildRelationIdsFromTree(): RelationIdMetadata[] {\n        return this.embeddeds.reduce(\n            (relations, embedded) =>\n                relations.concat(embedded.buildRelationIdsFromTree()),\n            this.relationIds,\n        )\n    }\n\n    protected buildRelationCountsFromTree(): RelationCountMetadata[] {\n        return this.embeddeds.reduce(\n            (relations, embedded) =>\n                relations.concat(embedded.buildRelationCountsFromTree()),\n            this.relationCounts,\n        )\n    }\n}\n"]},"metadata":{},"sourceType":"module"}