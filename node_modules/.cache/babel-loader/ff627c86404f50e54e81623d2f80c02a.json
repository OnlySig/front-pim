{"ast":null,"code":"import { Subject } from \"../Subject\";\nimport { OrmUtils } from \"../../util/OrmUtils\";\nimport { EntityMetadata } from \"../../metadata/EntityMetadata\";\n/**\n * Builds operations needs to be executed for one-to-many relations of the given subjects.\n *\n * by example: post contains one-to-many relation with category in the property called \"categories\", e.g.\n *             @OneToMany(type => Category, category => category.post) categories: Category[]\n *             If user adds categories into the post and saves post we need to bind them.\n *             This operation requires updation of category table since its owner of the relation and contains a join column.\n *\n * note: this class shares lot of things with OneToOneInverseSideOperationBuilder, so when you change this class\n *       make sure to reflect changes there as well.\n */\n\nexport class OneToManySubjectBuilder {\n  // ---------------------------------------------------------------------\n  // Constructor\n  // ---------------------------------------------------------------------\n  constructor(subjects) {\n    this.subjects = subjects;\n  } // ---------------------------------------------------------------------\n  // Public Methods\n  // ---------------------------------------------------------------------\n\n  /**\n   * Builds all required operations.\n   */\n\n\n  build() {\n    this.subjects.forEach(subject => {\n      subject.metadata.oneToManyRelations.forEach(relation => {\n        // skip relations for which persistence is disabled\n        if (relation.persistenceEnabled === false) return;\n        this.buildForSubjectRelation(subject, relation);\n      });\n    });\n  } // ---------------------------------------------------------------------\n  // Protected Methods\n  // ---------------------------------------------------------------------\n\n  /**\n   * Builds operations for a given subject and relation.\n   *\n   * by example: subject is \"post\" entity we are saving here and relation is \"categories\" inside it here.\n   */\n\n\n  buildForSubjectRelation(subject, relation) {\n    // prepare objects (relation id maps) for the database entity\n    // by example: since subject is a post, we are expecting to get all post's categories saved in the database here,\n    //             particularly their relation ids, e.g. category ids stored in the database\n    var _a; // in most cases relatedEntityDatabaseValues will contain only the entity key properties.\n    // this is because subject.databaseEntity contains relations with loaded relation ids only.\n    // however if the entity uses the afterLoad hook to calculate any properties, the fetched \"key object\" might include ADDITIONAL properties.\n    // to handle such situations, we pass the data to relation.inverseEntityMetadata.getEntityIdMap to extract the key without any other properties.\n\n\n    let relatedEntityDatabaseRelationIds = [];\n\n    if (subject.databaseEntity) {\n      // related entities in the database can exist only if this entity (post) is saved\n      const relatedEntityDatabaseRelation = relation.getEntityValue(subject.databaseEntity);\n\n      if (relatedEntityDatabaseRelation) {\n        relatedEntityDatabaseRelationIds = relatedEntityDatabaseRelation.map(entity => relation.inverseEntityMetadata.getEntityIdMap(entity));\n      }\n    } // get related entities of persisted entity\n    // by example: get categories from the passed to persist post entity\n\n\n    let relatedEntities = relation.getEntityValue(subject.entity);\n    if (relatedEntities === null) // we treat relations set to null as removed, so we don't skip it\n      relatedEntities = [];\n    if (relatedEntities === undefined) // if relation is undefined then nothing to update\n      return; // extract only relation ids from the related entities, since we only need them for comparison\n    // by example: extract from categories only relation ids (category id, or let's say category title, depend on join column options)\n\n    const relatedPersistedEntityRelationIds = [];\n    relatedEntities.forEach(relatedEntity => {\n      // by example: relatedEntity is a category here\n      let relationIdMap = relation.inverseEntityMetadata.getEntityIdMap(relatedEntity); // by example: relationIdMap is category.id map here, e.g. { id: ... }\n      // try to find a subject of this related entity, maybe it was loaded or was marked for persistence\n\n      let relatedEntitySubject = this.subjects.find(subject => {\n        return subject.entity === relatedEntity;\n      }); // if subject with entity was found take subject identifier as relation id map since it may contain extra properties resolved\n\n      if (relatedEntitySubject) relationIdMap = relatedEntitySubject.identifier; // if relationIdMap is undefined then it means user binds object which is not saved in the database yet\n      // by example: if post contains categories which does not have ids yet (because they are new)\n      //             it means they are always newly inserted and relation update operation always must be created for them\n      //             it does not make sense to perform difference operation for them for both add and remove actions\n\n      if (!relationIdMap) {\n        // we decided to remove this error because it brings complications when saving object with non-saved entities\n        // if (!relatedEntitySubject)\n        //     throw new TypeORMError(`One-to-many relation \"${relation.entityMetadata.name}.${relation.propertyPath}\" contains ` +\n        //         `entities which do not exist in the database yet, thus they cannot be bind in the database. ` +\n        //         `Please setup cascade insertion or save entities before binding it.`);\n        if (!relatedEntitySubject) return; // okay, so related subject exist and its marked for insertion, then add a new change map\n        // by example: this will tell category to insert into its post relation our post we are working with\n        //             relatedEntitySubject is newly inserted CategorySubject\n        //             relation.inverseRelation is ManyToOne relation inside Category\n        //             subject is Post needs to be inserted into Category\n\n        relatedEntitySubject.changeMaps.push({\n          relation: relation.inverseRelation,\n          value: subject\n        });\n        return;\n      } // check if this binding really exist in the database\n      // by example: find our category if its already bind in the database\n\n\n      const relationIdInDatabaseSubjectRelation = relatedEntityDatabaseRelationIds.find(relatedDatabaseEntityRelationId => {\n        return OrmUtils.compareIds(relationIdMap, relatedDatabaseEntityRelationId);\n      }); // if relationIdMap DOES NOT exist in the subject's relation in the database it means its a new relation and we need to \"bind\" them\n      // by example: this will tell category to insert into its post relation our post we are working with\n      //             relatedEntitySubject is newly inserted CategorySubject\n      //             relation.inverseRelation is ManyToOne relation inside Category\n      //             subject is Post needs to be inserted into Category\n\n      if (!relationIdInDatabaseSubjectRelation) {\n        // if there is no relatedEntitySubject then it means \"category\" wasn't persisted,\n        // but since we are going to update \"category\" table (since its an owning side of relation with join column)\n        // we create a new subject here:\n        if (!relatedEntitySubject) {\n          relatedEntitySubject = new Subject({\n            metadata: relation.inverseEntityMetadata,\n            parentSubject: subject,\n            canBeUpdated: true,\n            identifier: relationIdMap\n          });\n          this.subjects.push(relatedEntitySubject);\n        }\n\n        relatedEntitySubject.changeMaps.push({\n          relation: relation.inverseRelation,\n          value: subject\n        });\n      } // if related entity has relation id then we add it to the list of relation ids\n      // this list will be used later to compare with database relation ids to find a difference\n      // what exist in this array and does not exist in the database are newly inserted relations\n      // what does not exist in this array, but exist in the database are removed relations\n      // removed relations are set to null from inverse side of relation\n\n\n      relatedPersistedEntityRelationIds.push(relationIdMap);\n    }); // find what related entities were added and what were removed based on difference between what we save and what database has\n\n    if (((_a = relation.inverseRelation) === null || _a === void 0 ? void 0 : _a.orphanedRowAction) !== \"disable\") {\n      EntityMetadata.difference(relatedEntityDatabaseRelationIds, relatedPersistedEntityRelationIds).forEach(removedRelatedEntityRelationId => {\n        // by example: removedRelatedEntityRelationId is category that was bind in the database before, but now its unbind\n        // todo: probably we can improve this in the future by finding entity with column those values,\n        // todo: maybe it was already in persistence process. This is possible due to unique requirements of join columns\n        // we create a new subject which operations will be executed in subject operation executor\n        const removedRelatedEntitySubject = new Subject({\n          metadata: relation.inverseEntityMetadata,\n          parentSubject: subject,\n          identifier: removedRelatedEntityRelationId\n        });\n\n        if (!relation.inverseRelation || relation.inverseRelation.orphanedRowAction === \"nullify\") {\n          removedRelatedEntitySubject.canBeUpdated = true;\n          removedRelatedEntitySubject.changeMaps = [{\n            relation: relation.inverseRelation,\n            value: null\n          }];\n        } else if (relation.inverseRelation.orphanedRowAction === \"delete\") {\n          removedRelatedEntitySubject.mustBeRemoved = true;\n        } else if (relation.inverseRelation.orphanedRowAction === \"soft-delete\") {\n          removedRelatedEntitySubject.canBeSoftRemoved = true;\n        }\n\n        this.subjects.push(removedRelatedEntitySubject);\n      });\n    }\n  }\n\n}","map":{"version":3,"mappings":"AAAA,SAASA,OAAT,QAAwB,YAAxB;AACA,SAASC,QAAT,QAAyB,qBAAzB;AAEA,SAASC,cAAT,QAA+B,+BAA/B;AAGA;;;;;;;;;;;;AAWA,OAAM,MAAOC,uBAAP,CAA8B;EAChC;EACA;EACA;EAEAC,YAAsBC,QAAtB,EAAyC;IAAnB;EAAuB,CALb,CAOhC;EACA;EACA;;EAEA;;;;;EAGAC,KAAK;IACD,KAAKD,QAAL,CAAcE,OAAd,CAAuBC,OAAD,IAAY;MAC9BA,OAAO,CAACC,QAAR,CAAiBC,kBAAjB,CAAoCH,OAApC,CAA6CI,QAAD,IAAa;QACrD;QACA,IAAIA,QAAQ,CAACC,kBAAT,KAAgC,KAApC,EAA2C;QAE3C,KAAKC,uBAAL,CAA6BL,OAA7B,EAAsCG,QAAtC;MACH,CALD;IAMH,CAPD;EAQH,CAvB+B,CAyBhC;EACA;EACA;;EAEA;;;;;;;EAKUE,uBAAuB,CAC7BL,OAD6B,EAE7BG,QAF6B,EAEH;IAE1B;IACA;IACA;WAJ0B,CAM1B;IACA;IACA;IACA;;;IAEA,IAAIG,gCAAgC,GAAoB,EAAxD;;IACA,IAAIN,OAAO,CAACO,cAAZ,EAA4B;MACxB;MACA,MAAMC,6BAA6B,GAC/BL,QAAQ,CAACM,cAAT,CAAwBT,OAAO,CAACO,cAAhC,CADJ;;MAEA,IAAIC,6BAAJ,EAAmC;QAC/BF,gCAAgC,GAC5BE,6BAA6B,CAACE,GAA9B,CACKC,MAAD,IACIR,QAAQ,CAACS,qBAAT,CAA+BC,cAA/B,CACIF,MADJ,CAFR,CADJ;MAOH;IACJ,CAzByB,CA2B1B;IACA;;;IACA,IAAIG,eAAe,GAAoBX,QAAQ,CAACM,cAAT,CACnCT,OAAO,CAACW,MAD2B,CAAvC;IAGA,IAAIG,eAAe,KAAK,IAAxB,EACI;MACAA,eAAe,GAAG,EAAlB;IACJ,IAAIA,eAAe,KAAKC,SAAxB,EACI;MACA,OArCsB,CAuC1B;IACA;;IACA,MAAMC,iCAAiC,GAAoB,EAA3D;IACAF,eAAe,CAACf,OAAhB,CAAyBkB,aAAD,IAAkB;MACtC;MACA,IAAIC,aAAa,GACbf,QAAQ,CAACS,qBAAT,CAAgCC,cAAhC,CAA+CI,aAA/C,CADJ,CAFsC,CAG4B;MAElE;;MACA,IAAIE,oBAAoB,GAAG,KAAKtB,QAAL,CAAcuB,IAAd,CAAoBpB,OAAD,IAAY;QACtD,OAAOA,OAAO,CAACW,MAAR,KAAmBM,aAA1B;MACH,CAF0B,CAA3B,CANsC,CAUtC;;MACA,IAAIE,oBAAJ,EACID,aAAa,GAAGC,oBAAoB,CAACE,UAArC,CAZkC,CActC;MACA;MACA;MACA;;MACA,IAAI,CAACH,aAAL,EAAoB;QAChB;QACA;QACA;QACA;QACA;QACA,IAAI,CAACC,oBAAL,EAA2B,OANX,CAQhB;QACA;QACA;QACA;QACA;;QACAA,oBAAoB,CAACG,UAArB,CAAgCC,IAAhC,CAAqC;UACjCpB,QAAQ,EAAEA,QAAQ,CAACqB,eADc;UAEjCC,KAAK,EAAEzB;QAF0B,CAArC;QAKA;MACH,CArCqC,CAuCtC;MACA;;;MACA,MAAM0B,mCAAmC,GACrCpB,gCAAgC,CAACc,IAAjC,CACKO,+BAAD,IAAoC;QAChC,OAAOlC,QAAQ,CAACmC,UAAT,CACHV,aADG,EAEHS,+BAFG,CAAP;MAIH,CANL,CADJ,CAzCsC,CAmDtC;MACA;MACA;MACA;MACA;;MACA,IAAI,CAACD,mCAAL,EAA0C;QACtC;QACA;QACA;QACA,IAAI,CAACP,oBAAL,EAA2B;UACvBA,oBAAoB,GAAG,IAAI3B,OAAJ,CAAY;YAC/BS,QAAQ,EAAEE,QAAQ,CAACS,qBADY;YAE/BiB,aAAa,EAAE7B,OAFgB;YAG/B8B,YAAY,EAAE,IAHiB;YAI/BT,UAAU,EAAEH;UAJmB,CAAZ,CAAvB;UAMA,KAAKrB,QAAL,CAAc0B,IAAd,CAAmBJ,oBAAnB;QACH;;QAEDA,oBAAoB,CAACG,UAArB,CAAgCC,IAAhC,CAAqC;UACjCpB,QAAQ,EAAEA,QAAQ,CAACqB,eADc;UAEjCC,KAAK,EAAEzB;QAF0B,CAArC;MAIH,CA1EqC,CA4EtC;MACA;MACA;MACA;MACA;;;MACAgB,iCAAiC,CAACO,IAAlC,CAAuCL,aAAvC;IACH,CAlFD,EA1C0B,CA8H1B;;IACA,IAAI,eAAQ,CAACM,eAAT,MAAwB,IAAxB,IAAwBO,aAAxB,GAAwB,MAAxB,GAAwBA,GAAEC,iBAA1B,MAAgD,SAApD,EAA+D;MAC3DtC,cAAc,CAACuC,UAAf,CACI3B,gCADJ,EAEIU,iCAFJ,EAGEjB,OAHF,CAGWmC,8BAAD,IAAmC;QACzC;QAEA;QACA;QACA;QACA,MAAMC,2BAA2B,GAAG,IAAI3C,OAAJ,CAAY;UAC5CS,QAAQ,EAAEE,QAAQ,CAACS,qBADyB;UAE5CiB,aAAa,EAAE7B,OAF6B;UAG5CqB,UAAU,EAAEa;QAHgC,CAAZ,CAApC;;QAMA,IACI,CAAC/B,QAAQ,CAACqB,eAAV,IACArB,QAAQ,CAACqB,eAAT,CAAyBQ,iBAAzB,KAA+C,SAFnD,EAGE;UACEG,2BAA2B,CAACL,YAA5B,GAA2C,IAA3C;UACAK,2BAA2B,CAACb,UAA5B,GAAyC,CACrC;YACInB,QAAQ,EAAEA,QAAQ,CAACqB,eADvB;YAEIC,KAAK,EAAE;UAFX,CADqC,CAAzC;QAMH,CAXD,MAWO,IACHtB,QAAQ,CAACqB,eAAT,CAAyBQ,iBAAzB,KAA+C,QAD5C,EAEL;UACEG,2BAA2B,CAACC,aAA5B,GAA4C,IAA5C;QACH,CAJM,MAIA,IACHjC,QAAQ,CAACqB,eAAT,CAAyBQ,iBAAzB,KAA+C,aAD5C,EAEL;UACEG,2BAA2B,CAACE,gBAA5B,GAA+C,IAA/C;QACH;;QAED,KAAKxC,QAAL,CAAc0B,IAAd,CAAmBY,2BAAnB;MACH,CArCD;IAsCH;EACJ;;AA3M+B","names":["Subject","OrmUtils","EntityMetadata","OneToManySubjectBuilder","constructor","subjects","build","forEach","subject","metadata","oneToManyRelations","relation","persistenceEnabled","buildForSubjectRelation","relatedEntityDatabaseRelationIds","databaseEntity","relatedEntityDatabaseRelation","getEntityValue","map","entity","inverseEntityMetadata","getEntityIdMap","relatedEntities","undefined","relatedPersistedEntityRelationIds","relatedEntity","relationIdMap","relatedEntitySubject","find","identifier","changeMaps","push","inverseRelation","value","relationIdInDatabaseSubjectRelation","relatedDatabaseEntityRelationId","compareIds","parentSubject","canBeUpdated","_a","orphanedRowAction","difference","removedRelatedEntityRelationId","removedRelatedEntitySubject","mustBeRemoved","canBeSoftRemoved"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\persistence\\subject-builder\\OneToManySubjectBuilder.ts"],"sourcesContent":["import { Subject } from \"../Subject\"\nimport { OrmUtils } from \"../../util/OrmUtils\"\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { EntityMetadata } from \"../../metadata/EntityMetadata\"\nimport { RelationMetadata } from \"../../metadata/RelationMetadata\"\n\n/**\n * Builds operations needs to be executed for one-to-many relations of the given subjects.\n *\n * by example: post contains one-to-many relation with category in the property called \"categories\", e.g.\n *             @OneToMany(type => Category, category => category.post) categories: Category[]\n *             If user adds categories into the post and saves post we need to bind them.\n *             This operation requires updation of category table since its owner of the relation and contains a join column.\n *\n * note: this class shares lot of things with OneToOneInverseSideOperationBuilder, so when you change this class\n *       make sure to reflect changes there as well.\n */\nexport class OneToManySubjectBuilder {\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(protected subjects: Subject[]) {}\n\n    // ---------------------------------------------------------------------\n    // Public Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Builds all required operations.\n     */\n    build(): void {\n        this.subjects.forEach((subject) => {\n            subject.metadata.oneToManyRelations.forEach((relation) => {\n                // skip relations for which persistence is disabled\n                if (relation.persistenceEnabled === false) return\n\n                this.buildForSubjectRelation(subject, relation)\n            })\n        })\n    }\n\n    // ---------------------------------------------------------------------\n    // Protected Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Builds operations for a given subject and relation.\n     *\n     * by example: subject is \"post\" entity we are saving here and relation is \"categories\" inside it here.\n     */\n    protected buildForSubjectRelation(\n        subject: Subject,\n        relation: RelationMetadata,\n    ) {\n        // prepare objects (relation id maps) for the database entity\n        // by example: since subject is a post, we are expecting to get all post's categories saved in the database here,\n        //             particularly their relation ids, e.g. category ids stored in the database\n\n        // in most cases relatedEntityDatabaseValues will contain only the entity key properties.\n        // this is because subject.databaseEntity contains relations with loaded relation ids only.\n        // however if the entity uses the afterLoad hook to calculate any properties, the fetched \"key object\" might include ADDITIONAL properties.\n        // to handle such situations, we pass the data to relation.inverseEntityMetadata.getEntityIdMap to extract the key without any other properties.\n\n        let relatedEntityDatabaseRelationIds: ObjectLiteral[] = []\n        if (subject.databaseEntity) {\n            // related entities in the database can exist only if this entity (post) is saved\n            const relatedEntityDatabaseRelation: ObjectLiteral[] | undefined =\n                relation.getEntityValue(subject.databaseEntity)\n            if (relatedEntityDatabaseRelation) {\n                relatedEntityDatabaseRelationIds =\n                    relatedEntityDatabaseRelation.map(\n                        (entity) =>\n                            relation.inverseEntityMetadata.getEntityIdMap(\n                                entity,\n                            )!,\n                    )\n            }\n        }\n\n        // get related entities of persisted entity\n        // by example: get categories from the passed to persist post entity\n        let relatedEntities: ObjectLiteral[] = relation.getEntityValue(\n            subject.entity!,\n        )\n        if (relatedEntities === null)\n            // we treat relations set to null as removed, so we don't skip it\n            relatedEntities = [] as ObjectLiteral[]\n        if (relatedEntities === undefined)\n            // if relation is undefined then nothing to update\n            return\n\n        // extract only relation ids from the related entities, since we only need them for comparison\n        // by example: extract from categories only relation ids (category id, or let's say category title, depend on join column options)\n        const relatedPersistedEntityRelationIds: ObjectLiteral[] = []\n        relatedEntities.forEach((relatedEntity) => {\n            // by example: relatedEntity is a category here\n            let relationIdMap =\n                relation.inverseEntityMetadata!.getEntityIdMap(relatedEntity) // by example: relationIdMap is category.id map here, e.g. { id: ... }\n\n            // try to find a subject of this related entity, maybe it was loaded or was marked for persistence\n            let relatedEntitySubject = this.subjects.find((subject) => {\n                return subject.entity === relatedEntity\n            })\n\n            // if subject with entity was found take subject identifier as relation id map since it may contain extra properties resolved\n            if (relatedEntitySubject)\n                relationIdMap = relatedEntitySubject.identifier\n\n            // if relationIdMap is undefined then it means user binds object which is not saved in the database yet\n            // by example: if post contains categories which does not have ids yet (because they are new)\n            //             it means they are always newly inserted and relation update operation always must be created for them\n            //             it does not make sense to perform difference operation for them for both add and remove actions\n            if (!relationIdMap) {\n                // we decided to remove this error because it brings complications when saving object with non-saved entities\n                // if (!relatedEntitySubject)\n                //     throw new TypeORMError(`One-to-many relation \"${relation.entityMetadata.name}.${relation.propertyPath}\" contains ` +\n                //         `entities which do not exist in the database yet, thus they cannot be bind in the database. ` +\n                //         `Please setup cascade insertion or save entities before binding it.`);\n                if (!relatedEntitySubject) return\n\n                // okay, so related subject exist and its marked for insertion, then add a new change map\n                // by example: this will tell category to insert into its post relation our post we are working with\n                //             relatedEntitySubject is newly inserted CategorySubject\n                //             relation.inverseRelation is ManyToOne relation inside Category\n                //             subject is Post needs to be inserted into Category\n                relatedEntitySubject.changeMaps.push({\n                    relation: relation.inverseRelation!,\n                    value: subject,\n                })\n\n                return\n            }\n\n            // check if this binding really exist in the database\n            // by example: find our category if its already bind in the database\n            const relationIdInDatabaseSubjectRelation =\n                relatedEntityDatabaseRelationIds.find(\n                    (relatedDatabaseEntityRelationId) => {\n                        return OrmUtils.compareIds(\n                            relationIdMap,\n                            relatedDatabaseEntityRelationId,\n                        )\n                    },\n                )\n\n            // if relationIdMap DOES NOT exist in the subject's relation in the database it means its a new relation and we need to \"bind\" them\n            // by example: this will tell category to insert into its post relation our post we are working with\n            //             relatedEntitySubject is newly inserted CategorySubject\n            //             relation.inverseRelation is ManyToOne relation inside Category\n            //             subject is Post needs to be inserted into Category\n            if (!relationIdInDatabaseSubjectRelation) {\n                // if there is no relatedEntitySubject then it means \"category\" wasn't persisted,\n                // but since we are going to update \"category\" table (since its an owning side of relation with join column)\n                // we create a new subject here:\n                if (!relatedEntitySubject) {\n                    relatedEntitySubject = new Subject({\n                        metadata: relation.inverseEntityMetadata,\n                        parentSubject: subject,\n                        canBeUpdated: true,\n                        identifier: relationIdMap,\n                    })\n                    this.subjects.push(relatedEntitySubject)\n                }\n\n                relatedEntitySubject.changeMaps.push({\n                    relation: relation.inverseRelation!,\n                    value: subject,\n                })\n            }\n\n            // if related entity has relation id then we add it to the list of relation ids\n            // this list will be used later to compare with database relation ids to find a difference\n            // what exist in this array and does not exist in the database are newly inserted relations\n            // what does not exist in this array, but exist in the database are removed relations\n            // removed relations are set to null from inverse side of relation\n            relatedPersistedEntityRelationIds.push(relationIdMap)\n        })\n\n        // find what related entities were added and what were removed based on difference between what we save and what database has\n        if (relation.inverseRelation?.orphanedRowAction !== \"disable\") {\n            EntityMetadata.difference(\n                relatedEntityDatabaseRelationIds,\n                relatedPersistedEntityRelationIds,\n            ).forEach((removedRelatedEntityRelationId) => {\n                // by example: removedRelatedEntityRelationId is category that was bind in the database before, but now its unbind\n\n                // todo: probably we can improve this in the future by finding entity with column those values,\n                // todo: maybe it was already in persistence process. This is possible due to unique requirements of join columns\n                // we create a new subject which operations will be executed in subject operation executor\n                const removedRelatedEntitySubject = new Subject({\n                    metadata: relation.inverseEntityMetadata,\n                    parentSubject: subject,\n                    identifier: removedRelatedEntityRelationId,\n                })\n\n                if (\n                    !relation.inverseRelation ||\n                    relation.inverseRelation.orphanedRowAction === \"nullify\"\n                ) {\n                    removedRelatedEntitySubject.canBeUpdated = true\n                    removedRelatedEntitySubject.changeMaps = [\n                        {\n                            relation: relation.inverseRelation!,\n                            value: null,\n                        },\n                    ]\n                } else if (\n                    relation.inverseRelation.orphanedRowAction === \"delete\"\n                ) {\n                    removedRelatedEntitySubject.mustBeRemoved = true\n                } else if (\n                    relation.inverseRelation.orphanedRowAction === \"soft-delete\"\n                ) {\n                    removedRelatedEntitySubject.canBeSoftRemoved = true\n                }\n\n                this.subjects.push(removedRelatedEntitySubject)\n            })\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}