{"ast":null,"code":"import { Query } from \"../driver/Query\";\nimport { SqlInMemory } from \"../driver/SqlInMemory\";\nimport { TypeORMError } from \"../error/TypeORMError\";\nimport { OrmUtils } from \"../util/OrmUtils\";\nimport { InstanceChecker } from \"../util/InstanceChecker\";\nexport class BaseQueryRunner {\n  constructor() {\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Indicates if connection for this query runner is released.\n     * Once its released, query runner cannot run queries anymore.\n     */\n    this.isReleased = false;\n    /**\n     * Indicates if transaction is in progress.\n     */\n\n    this.isTransactionActive = false;\n    /**\n     * Stores temporarily user data.\n     * Useful for sharing data with subscribers.\n     */\n\n    this.data = {};\n    /**\n     * All synchronized tables in the database.\n     */\n\n    this.loadedTables = [];\n    /**\n     * All synchronized views in the database.\n     */\n\n    this.loadedViews = [];\n    /**\n     * Indicates if special query runner mode in which sql queries won't be executed is enabled.\n     */\n\n    this.sqlMemoryMode = false;\n    /**\n     * Sql-s stored if \"sql in memory\" mode is enabled.\n     */\n\n    this.sqlInMemory = new SqlInMemory();\n    /**\n     * current depth of transaction.\n     * for transactionDepth > 0 will use SAVEPOINT to start and commit/rollback transaction blocks\n     */\n\n    this.transactionDepth = 0;\n    this.cachedTablePaths = {};\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Called before migrations are run.\n   */\n\n\n  async beforeMigration() {// Do nothing\n  }\n  /**\n   * Called after migrations are run.\n   */\n\n\n  async afterMigration() {// Do nothing\n  }\n  /**\n   * Loads given table's data from the database.\n   */\n\n\n  async getTable(tablePath) {\n    this.loadedTables = await this.loadTables([tablePath]);\n    return this.loadedTables.length > 0 ? this.loadedTables[0] : undefined;\n  }\n  /**\n   * Loads all tables (with given names) from the database.\n   */\n\n\n  async getTables(tableNames) {\n    if (!tableNames) {\n      // Don't cache in this case.\n      // This is the new case & isn't used anywhere else anyway.\n      return await this.loadTables(tableNames);\n    }\n\n    this.loadedTables = await this.loadTables(tableNames);\n    return this.loadedTables;\n  }\n  /**\n   * Loads given view's data from the database.\n   */\n\n\n  async getView(viewPath) {\n    this.loadedViews = await this.loadViews([viewPath]);\n    return this.loadedViews.length > 0 ? this.loadedViews[0] : undefined;\n  }\n  /**\n   * Loads given view's data from the database.\n   */\n\n\n  async getViews(viewPaths) {\n    this.loadedViews = await this.loadViews(viewPaths);\n    return this.loadedViews;\n  }\n  /**\n   * Enables special query runner mode in which sql queries won't be executed,\n   * instead they will be memorized into a special variable inside query runner.\n   * You can get memorized sql using getMemorySql() method.\n   */\n\n\n  enableSqlMemory() {\n    this.sqlInMemory = new SqlInMemory();\n    this.sqlMemoryMode = true;\n  }\n  /**\n   * Disables special query runner mode in which sql queries won't be executed\n   * started by calling enableSqlMemory() method.\n   *\n   * Previously memorized sql will be flushed.\n   */\n\n\n  disableSqlMemory() {\n    this.sqlInMemory = new SqlInMemory();\n    this.sqlMemoryMode = false;\n  }\n  /**\n   * Flushes all memorized sqls.\n   */\n\n\n  clearSqlMemory() {\n    this.sqlInMemory = new SqlInMemory();\n  }\n  /**\n   * Gets sql stored in the memory. Parameters in the sql are already replaced.\n   */\n\n\n  getMemorySql() {\n    return this.sqlInMemory;\n  }\n  /**\n   * Executes up sql queries.\n   */\n\n\n  async executeMemoryUpSql() {\n    for (const {\n      query,\n      parameters\n    } of this.sqlInMemory.upQueries) {\n      await this.query(query, parameters);\n    }\n  }\n  /**\n   * Executes down sql queries.\n   */\n\n\n  async executeMemoryDownSql() {\n    for (const {\n      query,\n      parameters\n    } of this.sqlInMemory.downQueries.reverse()) {\n      await this.query(query, parameters);\n    }\n  }\n\n  getReplicationMode() {\n    return this.mode;\n  } // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Gets view from previously loaded views, otherwise loads it from database.\n   */\n\n\n  async getCachedView(viewName) {\n    const view = this.loadedViews.find(view => view.name === viewName);\n    if (view) return view;\n    const foundViews = await this.loadViews([viewName]);\n\n    if (foundViews.length > 0) {\n      this.loadedViews.push(foundViews[0]);\n      return foundViews[0];\n    } else {\n      throw new TypeORMError(`View \"${viewName}\" does not exist.`);\n    }\n  }\n  /**\n   * Gets table from previously loaded tables, otherwise loads it from database.\n   */\n\n\n  async getCachedTable(tableName) {\n    if (tableName in this.cachedTablePaths) {\n      const tablePath = this.cachedTablePaths[tableName];\n      const table = this.loadedTables.find(table => this.getTablePath(table) === tablePath);\n\n      if (table) {\n        return table;\n      }\n    }\n\n    const foundTables = await this.loadTables([tableName]);\n\n    if (foundTables.length > 0) {\n      const foundTablePath = this.getTablePath(foundTables[0]);\n      const cachedTable = this.loadedTables.find(table => this.getTablePath(table) === foundTablePath);\n\n      if (!cachedTable) {\n        this.cachedTablePaths[tableName] = this.getTablePath(foundTables[0]);\n        this.loadedTables.push(foundTables[0]);\n        return foundTables[0];\n      } else {\n        return cachedTable;\n      }\n    } else {\n      throw new TypeORMError(`Table \"${tableName}\" does not exist.`);\n    }\n  }\n  /**\n   * Replaces loaded table with given changed table.\n   */\n\n\n  replaceCachedTable(table, changedTable) {\n    const oldTablePath = this.getTablePath(table);\n    const foundTable = this.loadedTables.find(loadedTable => this.getTablePath(loadedTable) === oldTablePath); // Clean up the lookup cache..\n\n    for (const [key, cachedPath] of Object.entries(this.cachedTablePaths)) {\n      if (cachedPath === oldTablePath) {\n        this.cachedTablePaths[key] = this.getTablePath(changedTable);\n      }\n    }\n\n    if (foundTable) {\n      foundTable.database = changedTable.database;\n      foundTable.schema = changedTable.schema;\n      foundTable.name = changedTable.name;\n      foundTable.columns = changedTable.columns;\n      foundTable.indices = changedTable.indices;\n      foundTable.foreignKeys = changedTable.foreignKeys;\n      foundTable.uniques = changedTable.uniques;\n      foundTable.checks = changedTable.checks;\n      foundTable.justCreated = changedTable.justCreated;\n      foundTable.engine = changedTable.engine;\n    }\n  }\n\n  getTablePath(target) {\n    const parsed = this.connection.driver.parseTableName(target);\n    return this.connection.driver.buildTableName(parsed.tableName, parsed.schema, parsed.database);\n  }\n\n  getTypeormMetadataTableName() {\n    const options = this.connection.driver.options;\n    return this.connection.driver.buildTableName(this.connection.metadataTableName, options.schema, options.database);\n  }\n  /**\n   * Generates SQL query to select record from typeorm metadata table.\n   */\n\n\n  selectTypeormMetadataSql(_ref) {\n    let {\n      database,\n      schema,\n      table,\n      type,\n      name\n    } = _ref;\n    const qb = this.connection.createQueryBuilder();\n    const selectQb = qb.select().from(this.getTypeormMetadataTableName(), \"t\").where(`${qb.escape(\"type\")} = :type`, {\n      type\n    }).andWhere(`${qb.escape(\"name\")} = :name`, {\n      name\n    });\n\n    if (database) {\n      selectQb.andWhere(`${qb.escape(\"database\")} = :database`, {\n        database\n      });\n    }\n\n    if (schema) {\n      selectQb.andWhere(`${qb.escape(\"schema\")} = :schema`, {\n        schema\n      });\n    }\n\n    if (table) {\n      selectQb.andWhere(`${qb.escape(\"table\")} = :table`, {\n        table\n      });\n    }\n\n    const [query, parameters] = selectQb.getQueryAndParameters();\n    return new Query(query, parameters);\n  }\n  /**\n   * Generates SQL query to insert a record into typeorm metadata table.\n   */\n\n\n  insertTypeormMetadataSql(_ref2) {\n    let {\n      database,\n      schema,\n      table,\n      type,\n      name,\n      value\n    } = _ref2;\n    const [query, parameters] = this.connection.createQueryBuilder().insert().into(this.getTypeormMetadataTableName()).values({\n      database: database,\n      schema: schema,\n      table: table,\n      type: type,\n      name: name,\n      value: value\n    }).getQueryAndParameters();\n    return new Query(query, parameters);\n  }\n  /**\n   * Generates SQL query to delete a record from typeorm metadata table.\n   */\n\n\n  deleteTypeormMetadataSql(_ref3) {\n    let {\n      database,\n      schema,\n      table,\n      type,\n      name\n    } = _ref3;\n    const qb = this.connection.createQueryBuilder();\n    const deleteQb = qb.delete().from(this.getTypeormMetadataTableName()).where(`${qb.escape(\"type\")} = :type`, {\n      type\n    }).andWhere(`${qb.escape(\"name\")} = :name`, {\n      name\n    });\n\n    if (database) {\n      deleteQb.andWhere(`${qb.escape(\"database\")} = :database`, {\n        database\n      });\n    }\n\n    if (schema) {\n      deleteQb.andWhere(`${qb.escape(\"schema\")} = :schema`, {\n        schema\n      });\n    }\n\n    if (table) {\n      deleteQb.andWhere(`${qb.escape(\"table\")} = :table`, {\n        table\n      });\n    }\n\n    const [query, parameters] = deleteQb.getQueryAndParameters();\n    return new Query(query, parameters);\n  }\n  /**\n   * Checks if at least one of column properties was changed.\n   * Does not checks column type, length and autoincrement, because these properties changes separately.\n   */\n\n\n  isColumnChanged(oldColumn, newColumn, checkDefault, checkComment) {\n    // this logs need to debug issues in column change detection. Do not delete it!\n    // console.log(\"charset ---------------\");\n    // console.log(oldColumn.charset !== newColumn.charset);\n    // console.log(oldColumn.charset, newColumn.charset);\n    // console.log(\"collation ---------------\");\n    // console.log(oldColumn.collation !== newColumn.collation);\n    // console.log(oldColumn.collation, newColumn.collation);\n    // console.log(\"precision ---------------\");\n    // console.log(oldColumn.precision !== newColumn.precision);\n    // console.log(oldColumn.precision, newColumn.precision);\n    // console.log(\"scale ---------------\");\n    // console.log(oldColumn.scale !== newColumn.scale);\n    // console.log(oldColumn.scale, newColumn.scale);\n    // console.log(\"default ---------------\");\n    // console.log((checkDefault && oldColumn.default !== newColumn.default));\n    // console.log(oldColumn.default, newColumn.default);\n    // console.log(\"isNullable ---------------\");\n    // console.log(oldColumn.isNullable !== newColumn.isNullable);\n    // console.log(oldColumn.isNullable, newColumn.isNullable);\n    // console.log(\"comment ---------------\");\n    // console.log((checkComment && oldColumn.comment !== newColumn.comment));\n    // console.log(oldColumn.comment, newColumn.comment);\n    // console.log(\"enum ---------------\");\n    // console.log(!OrmUtils.isArraysEqual(oldColumn.enum || [], newColumn.enum || []));\n    // console.log(oldColumn.enum, newColumn.enum);\n    return oldColumn.charset !== newColumn.charset || oldColumn.collation !== newColumn.collation || oldColumn.precision !== newColumn.precision || oldColumn.scale !== newColumn.scale || oldColumn.width !== newColumn.width || // MySQL only\n    oldColumn.zerofill !== newColumn.zerofill || // MySQL only\n    oldColumn.unsigned !== newColumn.unsigned || // MySQL only\n    oldColumn.asExpression !== newColumn.asExpression || checkDefault && oldColumn.default !== newColumn.default || oldColumn.onUpdate !== newColumn.onUpdate || // MySQL only\n    oldColumn.isNullable !== newColumn.isNullable || checkComment && oldColumn.comment !== newColumn.comment || !OrmUtils.isArraysEqual(oldColumn.enum || [], newColumn.enum || []);\n  }\n  /**\n   * Checks if column length is by default.\n   */\n\n\n  isDefaultColumnLength(table, column, length) {\n    // if table have metadata, we check if length is specified in column metadata\n    if (this.connection.hasMetadata(table.name)) {\n      const metadata = this.connection.getMetadata(table.name);\n      const columnMetadata = metadata.findColumnWithDatabaseName(column.name);\n\n      if (columnMetadata) {\n        const columnMetadataLength = this.connection.driver.getColumnLength(columnMetadata);\n        if (columnMetadataLength) return false;\n      }\n    }\n\n    if (this.connection.driver.dataTypeDefaults && this.connection.driver.dataTypeDefaults[column.type] && this.connection.driver.dataTypeDefaults[column.type].length) {\n      return this.connection.driver.dataTypeDefaults[column.type].length.toString() === length.toString();\n    }\n\n    return false;\n  }\n  /**\n   * Checks if column precision is by default.\n   */\n\n\n  isDefaultColumnPrecision(table, column, precision) {\n    // if table have metadata, we check if length is specified in column metadata\n    if (this.connection.hasMetadata(table.name)) {\n      const metadata = this.connection.getMetadata(table.name);\n      const columnMetadata = metadata.findColumnWithDatabaseName(column.name);\n      if (columnMetadata && columnMetadata.precision !== null && columnMetadata.precision !== undefined) return false;\n    }\n\n    if (this.connection.driver.dataTypeDefaults && this.connection.driver.dataTypeDefaults[column.type] && this.connection.driver.dataTypeDefaults[column.type].precision !== null && this.connection.driver.dataTypeDefaults[column.type].precision !== undefined) return this.connection.driver.dataTypeDefaults[column.type].precision === precision;\n    return false;\n  }\n  /**\n   * Checks if column scale is by default.\n   */\n\n\n  isDefaultColumnScale(table, column, scale) {\n    // if table have metadata, we check if length is specified in column metadata\n    if (this.connection.hasMetadata(table.name)) {\n      const metadata = this.connection.getMetadata(table.name);\n      const columnMetadata = metadata.findColumnWithDatabaseName(column.name);\n      if (columnMetadata && columnMetadata.scale !== null && columnMetadata.scale !== undefined) return false;\n    }\n\n    if (this.connection.driver.dataTypeDefaults && this.connection.driver.dataTypeDefaults[column.type] && this.connection.driver.dataTypeDefaults[column.type].scale !== null && this.connection.driver.dataTypeDefaults[column.type].scale !== undefined) return this.connection.driver.dataTypeDefaults[column.type].scale === scale;\n    return false;\n  }\n  /**\n   * Executes sql used special for schema build.\n   */\n\n\n  async executeQueries(upQueries, downQueries) {\n    if (InstanceChecker.isQuery(upQueries)) upQueries = [upQueries];\n    if (InstanceChecker.isQuery(downQueries)) downQueries = [downQueries];\n    this.sqlInMemory.upQueries.push(...upQueries);\n    this.sqlInMemory.downQueries.push(...downQueries); // if sql-in-memory mode is enabled then simply store sql in memory and return\n\n    if (this.sqlMemoryMode === true) return Promise.resolve();\n\n    for (const {\n      query,\n      parameters\n    } of upQueries) {\n      await this.query(query, parameters);\n    }\n  }\n  /**\n   * Generated an index name for a table and index\n   */\n\n\n  generateIndexName(table, index) {\n    // new index may be passed without name. In this case we generate index name manually.\n    return this.connection.namingStrategy.indexName(table, index.columnNames, index.where);\n  }\n\n}","map":{"version":3,"mappings":"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","names":["Query","SqlInMemory","TypeORMError","OrmUtils","InstanceChecker","BaseQueryRunner","constructor","beforeMigration","afterMigration","getTable","tablePath","loadedTables","loadTables","length","undefined","getTables","tableNames","getView","viewPath","loadedViews","loadViews","getViews","viewPaths","enableSqlMemory","sqlInMemory","sqlMemoryMode","disableSqlMemory","clearSqlMemory","getMemorySql","executeMemoryUpSql","query","parameters","upQueries","executeMemoryDownSql","downQueries","reverse","getReplicationMode","mode","getCachedView","viewName","view","find","name","foundViews","push","getCachedTable","tableName","cachedTablePaths","table","getTablePath","foundTables","foundTablePath","cachedTable","replaceCachedTable","changedTable","oldTablePath","foundTable","loadedTable","key","cachedPath","Object","entries","database","schema","columns","indices","foreignKeys","uniques","checks","justCreated","engine","target","parsed","connection","driver","parseTableName","buildTableName","getTypeormMetadataTableName","options","metadataTableName","selectTypeormMetadataSql","type","qb","createQueryBuilder","selectQb","select","from","where","escape","andWhere","getQueryAndParameters","insertTypeormMetadataSql","value","insert","into","values","deleteTypeormMetadataSql","deleteQb","delete","isColumnChanged","oldColumn","newColumn","checkDefault","checkComment","charset","collation","precision","scale","width","zerofill","unsigned","asExpression","default","onUpdate","isNullable","comment","isArraysEqual","enum","isDefaultColumnLength","column","hasMetadata","metadata","getMetadata","columnMetadata","findColumnWithDatabaseName","columnMetadataLength","getColumnLength","dataTypeDefaults","toString","isDefaultColumnPrecision","isDefaultColumnScale","executeQueries","isQuery","Promise","resolve","generateIndexName","index","namingStrategy","indexName","columnNames"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\query-runner\\BaseQueryRunner.ts"],"sourcesContent":["import { PostgresConnectionOptions } from \"../driver/postgres/PostgresConnectionOptions\"\nimport { Query } from \"../driver/Query\"\nimport { SqlInMemory } from \"../driver/SqlInMemory\"\nimport { SqlServerConnectionOptions } from \"../driver/sqlserver/SqlServerConnectionOptions\"\nimport { TableIndex } from \"../schema-builder/table/TableIndex\"\nimport { View } from \"../schema-builder/view/View\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { Table } from \"../schema-builder/table/Table\"\nimport { EntityManager } from \"../entity-manager/EntityManager\"\nimport { TableColumn } from \"../schema-builder/table/TableColumn\"\nimport { Broadcaster } from \"../subscriber/Broadcaster\"\nimport { ReplicationMode } from \"../driver/types/ReplicationMode\"\nimport { TypeORMError } from \"../error/TypeORMError\"\nimport { EntityMetadata } from \"../metadata/EntityMetadata\"\nimport { TableForeignKey } from \"../schema-builder/table/TableForeignKey\"\nimport { OrmUtils } from \"../util/OrmUtils\"\nimport { MetadataTableType } from \"../driver/types/MetadataTableType\"\nimport { InstanceChecker } from \"../util/InstanceChecker\"\n\nexport abstract class BaseQueryRunner {\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Connection used by this query runner.\n     */\n    connection: DataSource\n\n    /**\n     * Entity manager working only with current query runner.\n     */\n    manager: EntityManager\n\n    /**\n     * Indicates if connection for this query runner is released.\n     * Once its released, query runner cannot run queries anymore.\n     */\n    isReleased = false\n\n    /**\n     * Indicates if transaction is in progress.\n     */\n    isTransactionActive = false\n\n    /**\n     * Stores temporarily user data.\n     * Useful for sharing data with subscribers.\n     */\n    data = {}\n\n    /**\n     * All synchronized tables in the database.\n     */\n    loadedTables: Table[] = []\n\n    /**\n     * All synchronized views in the database.\n     */\n    loadedViews: View[] = []\n\n    /**\n     * Broadcaster used on this query runner to broadcast entity events.\n     */\n    broadcaster: Broadcaster\n\n    // -------------------------------------------------------------------------\n    // Protected Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Real database connection from a connection pool used to perform queries.\n     */\n    protected databaseConnection: any\n\n    /**\n     * Indicates if special query runner mode in which sql queries won't be executed is enabled.\n     */\n    protected sqlMemoryMode: boolean = false\n\n    /**\n     * Sql-s stored if \"sql in memory\" mode is enabled.\n     */\n    protected sqlInMemory: SqlInMemory = new SqlInMemory()\n\n    /**\n     * Mode in which query runner executes.\n     * Used for replication.\n     * If replication is not setup its value is ignored.\n     */\n    protected mode: ReplicationMode\n\n    /**\n     * current depth of transaction.\n     * for transactionDepth > 0 will use SAVEPOINT to start and commit/rollback transaction blocks\n     */\n    protected transactionDepth = 0\n\n    private cachedTablePaths: Record<string, string> = {}\n\n    // -------------------------------------------------------------------------\n    // Public Abstract Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Executes a given SQL query.\n     */\n    abstract query(\n        query: string,\n        parameters?: any[],\n        useStructuredResult?: boolean,\n    ): Promise<any>\n\n    // -------------------------------------------------------------------------\n    // Protected Abstract Methods\n    // -------------------------------------------------------------------------\n\n    protected abstract loadTables(tablePaths?: string[]): Promise<Table[]>\n\n    protected abstract loadViews(tablePaths?: string[]): Promise<View[]>\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Called before migrations are run.\n     */\n    async beforeMigration(): Promise<void> {\n        // Do nothing\n    }\n\n    /**\n     * Called after migrations are run.\n     */\n    async afterMigration(): Promise<void> {\n        // Do nothing\n    }\n\n    /**\n     * Loads given table's data from the database.\n     */\n    async getTable(tablePath: string): Promise<Table | undefined> {\n        this.loadedTables = await this.loadTables([tablePath])\n        return this.loadedTables.length > 0 ? this.loadedTables[0] : undefined\n    }\n\n    /**\n     * Loads all tables (with given names) from the database.\n     */\n    async getTables(tableNames?: string[]): Promise<Table[]> {\n        if (!tableNames) {\n            // Don't cache in this case.\n            // This is the new case & isn't used anywhere else anyway.\n            return await this.loadTables(tableNames)\n        }\n\n        this.loadedTables = await this.loadTables(tableNames)\n        return this.loadedTables\n    }\n\n    /**\n     * Loads given view's data from the database.\n     */\n    async getView(viewPath: string): Promise<View | undefined> {\n        this.loadedViews = await this.loadViews([viewPath])\n        return this.loadedViews.length > 0 ? this.loadedViews[0] : undefined\n    }\n\n    /**\n     * Loads given view's data from the database.\n     */\n    async getViews(viewPaths?: string[]): Promise<View[]> {\n        this.loadedViews = await this.loadViews(viewPaths)\n        return this.loadedViews\n    }\n\n    /**\n     * Enables special query runner mode in which sql queries won't be executed,\n     * instead they will be memorized into a special variable inside query runner.\n     * You can get memorized sql using getMemorySql() method.\n     */\n    enableSqlMemory(): void {\n        this.sqlInMemory = new SqlInMemory()\n        this.sqlMemoryMode = true\n    }\n\n    /**\n     * Disables special query runner mode in which sql queries won't be executed\n     * started by calling enableSqlMemory() method.\n     *\n     * Previously memorized sql will be flushed.\n     */\n    disableSqlMemory(): void {\n        this.sqlInMemory = new SqlInMemory()\n        this.sqlMemoryMode = false\n    }\n\n    /**\n     * Flushes all memorized sqls.\n     */\n    clearSqlMemory(): void {\n        this.sqlInMemory = new SqlInMemory()\n    }\n\n    /**\n     * Gets sql stored in the memory. Parameters in the sql are already replaced.\n     */\n    getMemorySql(): SqlInMemory {\n        return this.sqlInMemory\n    }\n\n    /**\n     * Executes up sql queries.\n     */\n    async executeMemoryUpSql(): Promise<void> {\n        for (const { query, parameters } of this.sqlInMemory.upQueries) {\n            await this.query(query, parameters)\n        }\n    }\n\n    /**\n     * Executes down sql queries.\n     */\n    async executeMemoryDownSql(): Promise<void> {\n        for (const {\n            query,\n            parameters,\n        } of this.sqlInMemory.downQueries.reverse()) {\n            await this.query(query, parameters)\n        }\n    }\n\n    getReplicationMode(): ReplicationMode {\n        return this.mode\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets view from previously loaded views, otherwise loads it from database.\n     */\n    protected async getCachedView(viewName: string): Promise<View> {\n        const view = this.loadedViews.find((view) => view.name === viewName)\n        if (view) return view\n\n        const foundViews = await this.loadViews([viewName])\n        if (foundViews.length > 0) {\n            this.loadedViews.push(foundViews[0])\n            return foundViews[0]\n        } else {\n            throw new TypeORMError(`View \"${viewName}\" does not exist.`)\n        }\n    }\n\n    /**\n     * Gets table from previously loaded tables, otherwise loads it from database.\n     */\n    protected async getCachedTable(tableName: string): Promise<Table> {\n        if (tableName in this.cachedTablePaths) {\n            const tablePath = this.cachedTablePaths[tableName]\n            const table = this.loadedTables.find(\n                (table) => this.getTablePath(table) === tablePath,\n            )\n\n            if (table) {\n                return table\n            }\n        }\n\n        const foundTables = await this.loadTables([tableName])\n\n        if (foundTables.length > 0) {\n            const foundTablePath = this.getTablePath(foundTables[0])\n\n            const cachedTable = this.loadedTables.find(\n                (table) => this.getTablePath(table) === foundTablePath,\n            )\n\n            if (!cachedTable) {\n                this.cachedTablePaths[tableName] = this.getTablePath(\n                    foundTables[0],\n                )\n                this.loadedTables.push(foundTables[0])\n                return foundTables[0]\n            } else {\n                return cachedTable\n            }\n        } else {\n            throw new TypeORMError(`Table \"${tableName}\" does not exist.`)\n        }\n    }\n\n    /**\n     * Replaces loaded table with given changed table.\n     */\n    protected replaceCachedTable(table: Table, changedTable: Table): void {\n        const oldTablePath = this.getTablePath(table)\n        const foundTable = this.loadedTables.find(\n            (loadedTable) => this.getTablePath(loadedTable) === oldTablePath,\n        )\n\n        // Clean up the lookup cache..\n        for (const [key, cachedPath] of Object.entries(this.cachedTablePaths)) {\n            if (cachedPath === oldTablePath) {\n                this.cachedTablePaths[key] = this.getTablePath(changedTable)\n            }\n        }\n\n        if (foundTable) {\n            foundTable.database = changedTable.database\n            foundTable.schema = changedTable.schema\n            foundTable.name = changedTable.name\n            foundTable.columns = changedTable.columns\n            foundTable.indices = changedTable.indices\n            foundTable.foreignKeys = changedTable.foreignKeys\n            foundTable.uniques = changedTable.uniques\n            foundTable.checks = changedTable.checks\n            foundTable.justCreated = changedTable.justCreated\n            foundTable.engine = changedTable.engine\n        }\n    }\n\n    protected getTablePath(\n        target: EntityMetadata | Table | View | TableForeignKey | string,\n    ): string {\n        const parsed = this.connection.driver.parseTableName(target)\n\n        return this.connection.driver.buildTableName(\n            parsed.tableName,\n            parsed.schema,\n            parsed.database,\n        )\n    }\n\n    protected getTypeormMetadataTableName(): string {\n        const options = <\n            SqlServerConnectionOptions | PostgresConnectionOptions\n        >this.connection.driver.options\n        return this.connection.driver.buildTableName(\n            this.connection.metadataTableName,\n            options.schema,\n            options.database,\n        )\n    }\n\n    /**\n     * Generates SQL query to select record from typeorm metadata table.\n     */\n    protected selectTypeormMetadataSql({\n        database,\n        schema,\n        table,\n        type,\n        name,\n    }: {\n        database?: string\n        schema?: string\n        table?: string\n        type: MetadataTableType\n        name: string\n    }): Query {\n        const qb = this.connection.createQueryBuilder()\n        const selectQb = qb\n            .select()\n            .from(this.getTypeormMetadataTableName(), \"t\")\n            .where(`${qb.escape(\"type\")} = :type`, { type })\n            .andWhere(`${qb.escape(\"name\")} = :name`, { name })\n\n        if (database) {\n            selectQb.andWhere(`${qb.escape(\"database\")} = :database`, {\n                database,\n            })\n        }\n\n        if (schema) {\n            selectQb.andWhere(`${qb.escape(\"schema\")} = :schema`, { schema })\n        }\n\n        if (table) {\n            selectQb.andWhere(`${qb.escape(\"table\")} = :table`, { table })\n        }\n\n        const [query, parameters] = selectQb.getQueryAndParameters()\n        return new Query(query, parameters)\n    }\n\n    /**\n     * Generates SQL query to insert a record into typeorm metadata table.\n     */\n    protected insertTypeormMetadataSql({\n        database,\n        schema,\n        table,\n        type,\n        name,\n        value,\n    }: {\n        database?: string\n        schema?: string\n        table?: string\n        type: MetadataTableType\n        name: string\n        value?: string\n    }): Query {\n        const [query, parameters] = this.connection\n            .createQueryBuilder()\n            .insert()\n            .into(this.getTypeormMetadataTableName())\n            .values({\n                database: database,\n                schema: schema,\n                table: table,\n                type: type,\n                name: name,\n                value: value,\n            })\n            .getQueryAndParameters()\n\n        return new Query(query, parameters)\n    }\n\n    /**\n     * Generates SQL query to delete a record from typeorm metadata table.\n     */\n    protected deleteTypeormMetadataSql({\n        database,\n        schema,\n        table,\n        type,\n        name,\n    }: {\n        database?: string\n        schema?: string\n        table?: string\n        type: MetadataTableType\n        name: string\n    }): Query {\n        const qb = this.connection.createQueryBuilder()\n        const deleteQb = qb\n            .delete()\n            .from(this.getTypeormMetadataTableName())\n            .where(`${qb.escape(\"type\")} = :type`, { type })\n            .andWhere(`${qb.escape(\"name\")} = :name`, { name })\n\n        if (database) {\n            deleteQb.andWhere(`${qb.escape(\"database\")} = :database`, {\n                database,\n            })\n        }\n\n        if (schema) {\n            deleteQb.andWhere(`${qb.escape(\"schema\")} = :schema`, { schema })\n        }\n\n        if (table) {\n            deleteQb.andWhere(`${qb.escape(\"table\")} = :table`, { table })\n        }\n\n        const [query, parameters] = deleteQb.getQueryAndParameters()\n        return new Query(query, parameters)\n    }\n\n    /**\n     * Checks if at least one of column properties was changed.\n     * Does not checks column type, length and autoincrement, because these properties changes separately.\n     */\n    protected isColumnChanged(\n        oldColumn: TableColumn,\n        newColumn: TableColumn,\n        checkDefault?: boolean,\n        checkComment?: boolean,\n    ): boolean {\n        // this logs need to debug issues in column change detection. Do not delete it!\n\n        // console.log(\"charset ---------------\");\n        // console.log(oldColumn.charset !== newColumn.charset);\n        // console.log(oldColumn.charset, newColumn.charset);\n        // console.log(\"collation ---------------\");\n        // console.log(oldColumn.collation !== newColumn.collation);\n        // console.log(oldColumn.collation, newColumn.collation);\n        // console.log(\"precision ---------------\");\n        // console.log(oldColumn.precision !== newColumn.precision);\n        // console.log(oldColumn.precision, newColumn.precision);\n        // console.log(\"scale ---------------\");\n        // console.log(oldColumn.scale !== newColumn.scale);\n        // console.log(oldColumn.scale, newColumn.scale);\n        // console.log(\"default ---------------\");\n        // console.log((checkDefault && oldColumn.default !== newColumn.default));\n        // console.log(oldColumn.default, newColumn.default);\n        // console.log(\"isNullable ---------------\");\n        // console.log(oldColumn.isNullable !== newColumn.isNullable);\n        // console.log(oldColumn.isNullable, newColumn.isNullable);\n        // console.log(\"comment ---------------\");\n        // console.log((checkComment && oldColumn.comment !== newColumn.comment));\n        // console.log(oldColumn.comment, newColumn.comment);\n        // console.log(\"enum ---------------\");\n        // console.log(!OrmUtils.isArraysEqual(oldColumn.enum || [], newColumn.enum || []));\n        // console.log(oldColumn.enum, newColumn.enum);\n\n        return (\n            oldColumn.charset !== newColumn.charset ||\n            oldColumn.collation !== newColumn.collation ||\n            oldColumn.precision !== newColumn.precision ||\n            oldColumn.scale !== newColumn.scale ||\n            oldColumn.width !== newColumn.width || // MySQL only\n            oldColumn.zerofill !== newColumn.zerofill || // MySQL only\n            oldColumn.unsigned !== newColumn.unsigned || // MySQL only\n            oldColumn.asExpression !== newColumn.asExpression ||\n            (checkDefault && oldColumn.default !== newColumn.default) ||\n            oldColumn.onUpdate !== newColumn.onUpdate || // MySQL only\n            oldColumn.isNullable !== newColumn.isNullable ||\n            (checkComment && oldColumn.comment !== newColumn.comment) ||\n            !OrmUtils.isArraysEqual(oldColumn.enum || [], newColumn.enum || [])\n        )\n    }\n\n    /**\n     * Checks if column length is by default.\n     */\n    protected isDefaultColumnLength(\n        table: Table,\n        column: TableColumn,\n        length: string,\n    ): boolean {\n        // if table have metadata, we check if length is specified in column metadata\n        if (this.connection.hasMetadata(table.name)) {\n            const metadata = this.connection.getMetadata(table.name)\n            const columnMetadata = metadata.findColumnWithDatabaseName(\n                column.name,\n            )\n\n            if (columnMetadata) {\n                const columnMetadataLength =\n                    this.connection.driver.getColumnLength(columnMetadata)\n                if (columnMetadataLength) return false\n            }\n        }\n\n        if (\n            this.connection.driver.dataTypeDefaults &&\n            this.connection.driver.dataTypeDefaults[column.type] &&\n            this.connection.driver.dataTypeDefaults[column.type].length\n        ) {\n            return (\n                this.connection.driver.dataTypeDefaults[\n                    column.type\n                ].length!.toString() === length.toString()\n            )\n        }\n\n        return false\n    }\n\n    /**\n     * Checks if column precision is by default.\n     */\n    protected isDefaultColumnPrecision(\n        table: Table,\n        column: TableColumn,\n        precision: number,\n    ): boolean {\n        // if table have metadata, we check if length is specified in column metadata\n        if (this.connection.hasMetadata(table.name)) {\n            const metadata = this.connection.getMetadata(table.name)\n            const columnMetadata = metadata.findColumnWithDatabaseName(\n                column.name,\n            )\n            if (\n                columnMetadata &&\n                columnMetadata.precision !== null &&\n                columnMetadata.precision !== undefined\n            )\n                return false\n        }\n\n        if (\n            this.connection.driver.dataTypeDefaults &&\n            this.connection.driver.dataTypeDefaults[column.type] &&\n            this.connection.driver.dataTypeDefaults[column.type].precision !==\n                null &&\n            this.connection.driver.dataTypeDefaults[column.type].precision !==\n                undefined\n        )\n            return (\n                this.connection.driver.dataTypeDefaults[column.type]\n                    .precision === precision\n            )\n\n        return false\n    }\n\n    /**\n     * Checks if column scale is by default.\n     */\n    protected isDefaultColumnScale(\n        table: Table,\n        column: TableColumn,\n        scale: number,\n    ): boolean {\n        // if table have metadata, we check if length is specified in column metadata\n        if (this.connection.hasMetadata(table.name)) {\n            const metadata = this.connection.getMetadata(table.name)\n            const columnMetadata = metadata.findColumnWithDatabaseName(\n                column.name,\n            )\n            if (\n                columnMetadata &&\n                columnMetadata.scale !== null &&\n                columnMetadata.scale !== undefined\n            )\n                return false\n        }\n\n        if (\n            this.connection.driver.dataTypeDefaults &&\n            this.connection.driver.dataTypeDefaults[column.type] &&\n            this.connection.driver.dataTypeDefaults[column.type].scale !==\n                null &&\n            this.connection.driver.dataTypeDefaults[column.type].scale !==\n                undefined\n        )\n            return (\n                this.connection.driver.dataTypeDefaults[column.type].scale ===\n                scale\n            )\n\n        return false\n    }\n\n    /**\n     * Executes sql used special for schema build.\n     */\n    protected async executeQueries(\n        upQueries: Query | Query[],\n        downQueries: Query | Query[],\n    ): Promise<void> {\n        if (InstanceChecker.isQuery(upQueries)) upQueries = [upQueries]\n        if (InstanceChecker.isQuery(downQueries)) downQueries = [downQueries]\n\n        this.sqlInMemory.upQueries.push(...upQueries)\n        this.sqlInMemory.downQueries.push(...downQueries)\n\n        // if sql-in-memory mode is enabled then simply store sql in memory and return\n        if (this.sqlMemoryMode === true)\n            return Promise.resolve() as Promise<any>\n\n        for (const { query, parameters } of upQueries) {\n            await this.query(query, parameters)\n        }\n    }\n\n    /**\n     * Generated an index name for a table and index\n     */\n    protected generateIndexName(table: Table, index: TableIndex): string {\n        // new index may be passed without name. In this case we generate index name manually.\n        return this.connection.namingStrategy.indexName(\n            table,\n            index.columnNames,\n            index.where,\n        )\n    }\n}\n"]},"metadata":{},"sourceType":"module"}