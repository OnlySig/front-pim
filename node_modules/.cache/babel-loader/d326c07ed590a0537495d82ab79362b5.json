{"ast":null,"code":"import { QueryExpressionMap } from \"./QueryExpressionMap\";\nimport { Brackets } from \"./Brackets\";\nimport { FindOperator } from \"../find-options/FindOperator\";\nimport { In } from \"../find-options/operator/In\";\nimport { TypeORMError } from \"../error\";\nimport { EntityPropertyNotFoundError } from \"../error/EntityPropertyNotFoundError\";\nimport { InstanceChecker } from \"../util/InstanceChecker\";\nimport { escapeRegExp } from \"../util/escapeRegExp\"; // todo: completely cover query builder with tests\n// todo: entityOrProperty can be target name. implement proper behaviour if it is.\n// todo: check in persistment if id exist on object and throw exception (can be in partial selection?)\n// todo: fix problem with long aliases eg getMaxIdentifierLength\n// todo: fix replacing in .select(\"COUNT(post.id) AS cnt\") statement\n// todo: implement joinAlways in relations and relationId\n// todo: finish partial selection\n// todo: sugar methods like: .addCount and .selectCount, selectCountAndMap, selectSum, selectSumAndMap, ...\n// todo: implement @Select decorator\n// todo: add select and map functions\n// todo: implement relation/entity loading and setting them into properties within a separate query\n// .loadAndMap(\"post.categories\", \"post.categories\", qb => ...)\n// .loadAndMap(\"post.categories\", Category, qb => ...)\n\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n */\n\nexport class QueryBuilder {\n  /**\n   * QueryBuilder can be initialized from given Connection and QueryRunner objects or from given other QueryBuilder.\n   */\n  constructor(connectionOrQueryBuilder, queryRunner) {\n    this[\"@instanceof\"] = Symbol.for(\"QueryBuilder\");\n    /**\n     * Memo to help keep place of current parameter index for `createParameter`\n     */\n\n    this.parameterIndex = 0;\n\n    if (InstanceChecker.isQueryBuilder(connectionOrQueryBuilder)) {\n      this.connection = connectionOrQueryBuilder.connection;\n      this.queryRunner = connectionOrQueryBuilder.queryRunner;\n      this.expressionMap = connectionOrQueryBuilder.expressionMap.clone();\n    } else {\n      this.connection = connectionOrQueryBuilder;\n      this.queryRunner = queryRunner;\n      this.expressionMap = new QueryExpressionMap(this.connection);\n    }\n  } // -------------------------------------------------------------------------\n  // Accessors\n  // -------------------------------------------------------------------------\n\n  /**\n   * Gets the main alias string used in this query builder.\n   */\n\n\n  get alias() {\n    if (!this.expressionMap.mainAlias) throw new TypeORMError(`Main alias is not set`); // todo: better exception\n\n    return this.expressionMap.mainAlias.name;\n  }\n  /**\n   * Creates SELECT query and selects given data.\n   * Replaces all previous selections if they exist.\n   */\n\n\n  select(selection, selectionAliasName) {\n    this.expressionMap.queryType = \"select\";\n\n    if (Array.isArray(selection)) {\n      this.expressionMap.selects = selection.map(selection => ({\n        selection: selection\n      }));\n    } else if (selection) {\n      this.expressionMap.selects = [{\n        selection: selection,\n        aliasName: selectionAliasName\n      }];\n    } // loading it dynamically because of circular issue\n\n\n    const SelectQueryBuilderCls = require(\"./SelectQueryBuilder\").SelectQueryBuilder;\n\n    if (InstanceChecker.isSelectQueryBuilder(this)) return this;\n    return new SelectQueryBuilderCls(this);\n  }\n  /**\n   * Creates INSERT query.\n   */\n\n\n  insert() {\n    this.expressionMap.queryType = \"insert\"; // loading it dynamically because of circular issue\n\n    const InsertQueryBuilderCls = require(\"./InsertQueryBuilder\").InsertQueryBuilder;\n\n    if (InstanceChecker.isInsertQueryBuilder(this)) return this;\n    return new InsertQueryBuilderCls(this);\n  }\n  /**\n   * Creates UPDATE query and applies given update values.\n   */\n\n\n  update(entityOrTableNameUpdateSet, maybeUpdateSet) {\n    const updateSet = maybeUpdateSet ? maybeUpdateSet : entityOrTableNameUpdateSet;\n    entityOrTableNameUpdateSet = InstanceChecker.isEntitySchema(entityOrTableNameUpdateSet) ? entityOrTableNameUpdateSet.options.name : entityOrTableNameUpdateSet;\n\n    if (typeof entityOrTableNameUpdateSet === \"function\" || typeof entityOrTableNameUpdateSet === \"string\") {\n      const mainAlias = this.createFromAlias(entityOrTableNameUpdateSet);\n      this.expressionMap.setMainAlias(mainAlias);\n    }\n\n    this.expressionMap.queryType = \"update\";\n    this.expressionMap.valuesSet = updateSet; // loading it dynamically because of circular issue\n\n    const UpdateQueryBuilderCls = require(\"./UpdateQueryBuilder\").UpdateQueryBuilder;\n\n    if (InstanceChecker.isUpdateQueryBuilder(this)) return this;\n    return new UpdateQueryBuilderCls(this);\n  }\n  /**\n   * Creates DELETE query.\n   */\n\n\n  delete() {\n    this.expressionMap.queryType = \"delete\"; // loading it dynamically because of circular issue\n\n    const DeleteQueryBuilderCls = require(\"./DeleteQueryBuilder\").DeleteQueryBuilder;\n\n    if (InstanceChecker.isDeleteQueryBuilder(this)) return this;\n    return new DeleteQueryBuilderCls(this);\n  }\n\n  softDelete() {\n    this.expressionMap.queryType = \"soft-delete\"; // loading it dynamically because of circular issue\n\n    const SoftDeleteQueryBuilderCls = require(\"./SoftDeleteQueryBuilder\").SoftDeleteQueryBuilder;\n\n    if (InstanceChecker.isSoftDeleteQueryBuilder(this)) return this;\n    return new SoftDeleteQueryBuilderCls(this);\n  }\n\n  restore() {\n    this.expressionMap.queryType = \"restore\"; // loading it dynamically because of circular issue\n\n    const SoftDeleteQueryBuilderCls = require(\"./SoftDeleteQueryBuilder\").SoftDeleteQueryBuilder;\n\n    if (InstanceChecker.isSoftDeleteQueryBuilder(this)) return this;\n    return new SoftDeleteQueryBuilderCls(this);\n  }\n  /**\n   * Sets entity's relation with which this query builder gonna work.\n   */\n\n\n  relation(entityTargetOrPropertyPath, maybePropertyPath) {\n    const entityTarget = arguments.length === 2 ? entityTargetOrPropertyPath : undefined;\n    const propertyPath = arguments.length === 2 ? maybePropertyPath : entityTargetOrPropertyPath;\n    this.expressionMap.queryType = \"relation\";\n    this.expressionMap.relationPropertyPath = propertyPath;\n\n    if (entityTarget) {\n      const mainAlias = this.createFromAlias(entityTarget);\n      this.expressionMap.setMainAlias(mainAlias);\n    } // loading it dynamically because of circular issue\n\n\n    const RelationQueryBuilderCls = require(\"./RelationQueryBuilder\").RelationQueryBuilder;\n\n    if (InstanceChecker.isRelationQueryBuilder(this)) return this;\n    return new RelationQueryBuilderCls(this);\n  }\n  /**\n   * Checks if given relation or relations exist in the entity.\n   * Returns true if relation exists, false otherwise.\n   *\n   * todo: move this method to manager? or create a shortcut?\n   */\n\n\n  hasRelation(target, relation) {\n    const entityMetadata = this.connection.getMetadata(target);\n    const relations = Array.isArray(relation) ? relation : [relation];\n    return relations.every(relation => {\n      return !!entityMetadata.findRelationWithPropertyPath(relation);\n    });\n  }\n  /**\n   * Check the existence of a parameter for this query builder.\n   */\n\n\n  hasParameter(key) {\n    var _a;\n\n    return ((_a = this.parentQueryBuilder) === null || _a === void 0 ? void 0 : _a.hasParameter(key)) || key in this.expressionMap.parameters;\n  }\n  /**\n   * Sets parameter name and its value.\n   *\n   * The key for this parameter may contain numbers, letters, underscores, or periods.\n   */\n\n\n  setParameter(key, value) {\n    if (typeof value === \"function\") {\n      throw new TypeORMError(`Function parameter isn't supported in the parameters. Please check \"${key}\" parameter.`);\n    }\n\n    if (!key.match(/^([A-Za-z0-9_.]+)$/)) {\n      throw new TypeORMError(\"QueryBuilder parameter keys may only contain numbers, letters, underscores, or periods.\");\n    }\n\n    if (this.parentQueryBuilder) {\n      this.parentQueryBuilder.setParameter(key, value);\n    }\n\n    this.expressionMap.parameters[key] = value;\n    return this;\n  }\n  /**\n   * Adds all parameters from the given object.\n   */\n\n\n  setParameters(parameters) {\n    for (const [key, value] of Object.entries(parameters)) {\n      this.setParameter(key, value);\n    }\n\n    return this;\n  }\n\n  createParameter(value) {\n    let parameterName;\n\n    do {\n      parameterName = `orm_param_${this.parameterIndex++}`;\n    } while (this.hasParameter(parameterName));\n\n    this.setParameter(parameterName, value);\n    return `:${parameterName}`;\n  }\n  /**\n   * Adds native parameters from the given object.\n   *\n   * @deprecated Use `setParameters` instead\n   */\n\n\n  setNativeParameters(parameters) {\n    // set parent query builder parameters as well in sub-query mode\n    if (this.parentQueryBuilder) {\n      this.parentQueryBuilder.setNativeParameters(parameters);\n    }\n\n    Object.keys(parameters).forEach(key => {\n      this.expressionMap.nativeParameters[key] = parameters[key];\n    });\n    return this;\n  }\n  /**\n   * Gets all parameters.\n   */\n\n\n  getParameters() {\n    const parameters = Object.assign({}, this.expressionMap.parameters); // add discriminator column parameter if it exist\n\n    if (this.expressionMap.mainAlias && this.expressionMap.mainAlias.hasMetadata) {\n      const metadata = this.expressionMap.mainAlias.metadata;\n\n      if (metadata.discriminatorColumn && metadata.parentEntityMetadata) {\n        const values = metadata.childEntityMetadatas.filter(childMetadata => childMetadata.discriminatorColumn).map(childMetadata => childMetadata.discriminatorValue);\n        values.push(metadata.discriminatorValue);\n        parameters[\"discriminatorColumnValues\"] = values;\n      }\n    }\n\n    return parameters;\n  }\n  /**\n   * Prints sql to stdout using console.log.\n   */\n\n\n  printSql() {\n    // TODO rename to logSql()\n    const [query, parameters] = this.getQueryAndParameters();\n    this.connection.logger.logQuery(query, parameters);\n    return this;\n  }\n  /**\n   * Gets generated sql that will be executed.\n   * Parameters in the query are escaped for the currently used driver.\n   */\n\n\n  getSql() {\n    return this.getQueryAndParameters()[0];\n  }\n  /**\n   * Gets query to be executed with all parameters used in it.\n   */\n\n\n  getQueryAndParameters() {\n    // this execution order is important because getQuery method generates this.expressionMap.nativeParameters values\n    const query = this.getQuery();\n    const parameters = this.getParameters();\n    return this.connection.driver.escapeQueryWithParameters(query, parameters, this.expressionMap.nativeParameters);\n  }\n  /**\n   * Executes sql generated by query builder and returns raw database results.\n   */\n\n\n  async execute() {\n    const [sql, parameters] = this.getQueryAndParameters();\n    const queryRunner = this.obtainQueryRunner();\n\n    try {\n      return await queryRunner.query(sql, parameters); // await is needed here because we are using finally\n    } finally {\n      if (queryRunner !== this.queryRunner) {\n        // means we created our own query runner\n        await queryRunner.release();\n      }\n    }\n  }\n  /**\n   * Creates a completely new query builder.\n   * Uses same query runner as current QueryBuilder.\n   */\n\n\n  createQueryBuilder() {\n    return new this.constructor(this.connection, this.queryRunner);\n  }\n  /**\n   * Clones query builder as it is.\n   * Note: it uses new query runner, if you want query builder that uses exactly same query runner,\n   * you can create query builder using its constructor, for example new SelectQueryBuilder(queryBuilder)\n   * where queryBuilder is cloned QueryBuilder.\n   */\n\n\n  clone() {\n    return new this.constructor(this);\n  }\n  /**\n   * Includes a Query comment in the query builder.  This is helpful for debugging purposes,\n   * such as finding a specific query in the database server's logs, or for categorization using\n   * an APM product.\n   */\n\n\n  comment(comment) {\n    this.expressionMap.comment = comment;\n    return this;\n  }\n  /**\n   * Disables escaping.\n   */\n\n\n  disableEscaping() {\n    this.expressionMap.disableEscaping = false;\n    return this;\n  }\n  /**\n   * Escapes table name, column name or alias name using current database's escaping character.\n   */\n\n\n  escape(name) {\n    if (!this.expressionMap.disableEscaping) return name;\n    return this.connection.driver.escape(name);\n  }\n  /**\n   * Sets or overrides query builder's QueryRunner.\n   */\n\n\n  setQueryRunner(queryRunner) {\n    this.queryRunner = queryRunner;\n    return this;\n  }\n  /**\n   * Indicates if listeners and subscribers must be called before and after query execution.\n   * Enabled by default.\n   */\n\n\n  callListeners(enabled) {\n    this.expressionMap.callListeners = enabled;\n    return this;\n  }\n  /**\n   * If set to true the query will be wrapped into a transaction.\n   */\n\n\n  useTransaction(enabled) {\n    this.expressionMap.useTransaction = enabled;\n    return this;\n  }\n  /**\n   * Adds CTE to query\n   */\n\n\n  addCommonTableExpression(queryBuilder, alias, options) {\n    this.expressionMap.commonTableExpressions.push({\n      queryBuilder,\n      alias,\n      options: options || {}\n    });\n    return this;\n  } // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Gets escaped table name with schema name if SqlServer driver used with custom\n   * schema name, otherwise returns escaped table name.\n   */\n\n\n  getTableName(tablePath) {\n    return tablePath.split(\".\").map(i => {\n      // this condition need because in SQL Server driver when custom database name was specified and schema name was not, we got `dbName..tableName` string, and doesn't need to escape middle empty string\n      if (i === \"\") return i;\n      return this.escape(i);\n    }).join(\".\");\n  }\n  /**\n   * Gets name of the table where insert should be performed.\n   */\n\n\n  getMainTableName() {\n    if (!this.expressionMap.mainAlias) throw new TypeORMError(`Entity where values should be inserted is not specified. Call \"qb.into(entity)\" method to specify it.`);\n    if (this.expressionMap.mainAlias.hasMetadata) return this.expressionMap.mainAlias.metadata.tablePath;\n    return this.expressionMap.mainAlias.tablePath;\n  }\n  /**\n   * Specifies FROM which entity's table select/update/delete will be executed.\n   * Also sets a main string alias of the selection data.\n   */\n\n\n  createFromAlias(entityTarget, aliasName) {\n    // if table has a metadata then find it to properly escape its properties\n    // const metadata = this.connection.entityMetadatas.find(metadata => metadata.tableName === tableName);\n    if (this.connection.hasMetadata(entityTarget)) {\n      const metadata = this.connection.getMetadata(entityTarget);\n      return this.expressionMap.createAlias({\n        type: \"from\",\n        name: aliasName,\n        metadata: this.connection.getMetadata(entityTarget),\n        tablePath: metadata.tablePath\n      });\n    } else {\n      if (typeof entityTarget === \"string\") {\n        const isSubquery = entityTarget.substr(0, 1) === \"(\" && entityTarget.substr(-1) === \")\";\n        return this.expressionMap.createAlias({\n          type: \"from\",\n          name: aliasName,\n          tablePath: !isSubquery ? entityTarget : undefined,\n          subQuery: isSubquery ? entityTarget : undefined\n        });\n      }\n\n      const subQueryBuilder = entityTarget(this.subQuery());\n      this.setParameters(subQueryBuilder.getParameters());\n      const subquery = subQueryBuilder.getQuery();\n      return this.expressionMap.createAlias({\n        type: \"from\",\n        name: aliasName,\n        subQuery: subquery\n      });\n    }\n  }\n  /**\n   * Replaces all entity's propertyName to name in the given statement.\n   */\n\n\n  replacePropertyNames(statement) {\n    for (const alias of this.expressionMap.aliases) {\n      if (!alias.hasMetadata) continue;\n      const replaceAliasNamePrefix = this.expressionMap.aliasNamePrefixingEnabled ? `${alias.name}.` : \"\";\n      const replacementAliasNamePrefix = this.expressionMap.aliasNamePrefixingEnabled ? `${this.escape(alias.name)}.` : \"\";\n      const replacements = {}; // Insert & overwrite the replacements from least to most relevant in our replacements object.\n      // To do this we iterate and overwrite in the order of relevance.\n      // Least to Most Relevant:\n      // * Relation Property Path to first join column key\n      // * Relation Property Path + Column Path\n      // * Column Database Name\n      // * Column Property Name\n      // * Column Property Path\n\n      for (const relation of alias.metadata.relations) {\n        if (relation.joinColumns.length > 0) replacements[relation.propertyPath] = relation.joinColumns[0].databaseName;\n      }\n\n      for (const relation of alias.metadata.relations) {\n        for (const joinColumn of [...relation.joinColumns, ...relation.inverseJoinColumns]) {\n          const propertyKey = `${relation.propertyPath}.${joinColumn.referencedColumn.propertyPath}`;\n          replacements[propertyKey] = joinColumn.databaseName;\n        }\n      }\n\n      for (const column of alias.metadata.columns) {\n        replacements[column.databaseName] = column.databaseName;\n      }\n\n      for (const column of alias.metadata.columns) {\n        replacements[column.propertyName] = column.databaseName;\n      }\n\n      for (const column of alias.metadata.columns) {\n        replacements[column.propertyPath] = column.databaseName;\n      }\n\n      statement = statement.replace(new RegExp( // Avoid a lookbehind here since it's not well supported\n      `([ =\\(]|^.{0})` + // any of ' =(' or start of line\n      // followed by our prefix, e.g. 'tablename.' or ''\n      `${escapeRegExp(replaceAliasNamePrefix)}([^ =\\(\\)\\,]+)` + // a possible property name: sequence of anything but ' =(),'\n      // terminated by ' =),' or end of line\n      `(?=[ =\\)\\,]|.{0}$)`, \"gm\"), (match, pre, p) => {\n        if (replacements[p]) {\n          return `${pre}${replacementAliasNamePrefix}${this.escape(replacements[p])}`;\n        }\n\n        return match;\n      });\n    }\n\n    return statement;\n  }\n\n  createComment() {\n    if (!this.expressionMap.comment) {\n      return \"\";\n    } // ANSI SQL 2003 support C style comments - comments that start with `/*` and end with `*/`\n    // In some dialects query nesting is available - but not all.  Because of this, we'll need\n    // to scrub \"ending\" characters from the SQL but otherwise we can leave everything else\n    // as-is and it should be valid.\n\n\n    return `/* ${this.expressionMap.comment.replace(\"*/\", \"\")} */ `;\n  }\n  /**\n   * Creates \"WHERE\" expression.\n   */\n\n\n  createWhereExpression() {\n    const conditionsArray = [];\n    const whereExpression = this.createWhereClausesExpression(this.expressionMap.wheres);\n\n    if (whereExpression.length > 0 && whereExpression !== \"1=1\") {\n      conditionsArray.push(this.replacePropertyNames(whereExpression));\n    }\n\n    if (this.expressionMap.mainAlias.hasMetadata) {\n      const metadata = this.expressionMap.mainAlias.metadata; // Adds the global condition of \"non-deleted\" for the entity with delete date columns in select query.\n\n      if (this.expressionMap.queryType === \"select\" && !this.expressionMap.withDeleted && metadata.deleteDateColumn) {\n        const column = this.expressionMap.aliasNamePrefixingEnabled ? this.expressionMap.mainAlias.name + \".\" + metadata.deleteDateColumn.propertyName : metadata.deleteDateColumn.propertyName;\n        const condition = `${this.replacePropertyNames(column)} IS NULL`;\n        conditionsArray.push(condition);\n      }\n\n      if (metadata.discriminatorColumn && metadata.parentEntityMetadata) {\n        const column = this.expressionMap.aliasNamePrefixingEnabled ? this.expressionMap.mainAlias.name + \".\" + metadata.discriminatorColumn.databaseName : metadata.discriminatorColumn.databaseName;\n        const condition = `${this.replacePropertyNames(column)} IN (:...discriminatorColumnValues)`;\n        conditionsArray.push(condition);\n      }\n    }\n\n    if (this.expressionMap.extraAppendedAndWhereCondition) {\n      const condition = this.replacePropertyNames(this.expressionMap.extraAppendedAndWhereCondition);\n      conditionsArray.push(condition);\n    }\n\n    if (!conditionsArray.length) {\n      return \"\";\n    } else if (conditionsArray.length === 1) {\n      return ` WHERE ${conditionsArray[0]}`;\n    } else {\n      return ` WHERE ( ${conditionsArray.join(\" ) AND ( \")} )`;\n    }\n  }\n  /**\n   * Creates \"RETURNING\" / \"OUTPUT\" expression.\n   */\n\n\n  createReturningExpression(returningType) {\n    const columns = this.getReturningColumns();\n    const driver = this.connection.driver; // also add columns we must auto-return to perform entity updation\n    // if user gave his own returning\n\n    if (typeof this.expressionMap.returning !== \"string\" && this.expressionMap.extraReturningColumns.length > 0 && driver.isReturningSqlSupported(returningType)) {\n      columns.push(...this.expressionMap.extraReturningColumns.filter(column => {\n        return columns.indexOf(column) === -1;\n      }));\n    }\n\n    if (columns.length) {\n      let columnsExpression = columns.map(column => {\n        const name = this.escape(column.databaseName);\n\n        if (driver.options.type === \"mssql\") {\n          if (this.expressionMap.queryType === \"insert\" || this.expressionMap.queryType === \"update\" || this.expressionMap.queryType === \"soft-delete\" || this.expressionMap.queryType === \"restore\") {\n            return \"INSERTED.\" + name;\n          } else {\n            return this.escape(this.getMainTableName()) + \".\" + name;\n          }\n        } else {\n          return name;\n        }\n      }).join(\", \");\n\n      if (driver.options.type === \"oracle\") {\n        columnsExpression += \" INTO \" + columns.map(column => {\n          return this.createParameter({\n            type: driver.columnTypeToNativeParameter(column.type),\n            dir: driver.oracle.BIND_OUT\n          });\n        }).join(\", \");\n      }\n\n      if (driver.options.type === \"mssql\") {\n        if (this.expressionMap.queryType === \"insert\" || this.expressionMap.queryType === \"update\") {\n          columnsExpression += \" INTO @OutputTable\";\n        }\n      }\n\n      return columnsExpression;\n    } else if (typeof this.expressionMap.returning === \"string\") {\n      return this.expressionMap.returning;\n    }\n\n    return \"\";\n  }\n  /**\n   * If returning / output cause is set to array of column names,\n   * then this method will return all column metadatas of those column names.\n   */\n\n\n  getReturningColumns() {\n    const columns = [];\n\n    if (Array.isArray(this.expressionMap.returning)) {\n      ;\n      this.expressionMap.returning.forEach(columnName => {\n        if (this.expressionMap.mainAlias.hasMetadata) {\n          columns.push(...this.expressionMap.mainAlias.metadata.findColumnsWithPropertyPath(columnName));\n        }\n      });\n    }\n\n    return columns;\n  }\n\n  createWhereClausesExpression(clauses) {\n    return clauses.map((clause, index) => {\n      const expression = this.createWhereConditionExpression(clause.condition);\n\n      switch (clause.type) {\n        case \"and\":\n          return (index > 0 ? \"AND \" : \"\") + expression;\n\n        case \"or\":\n          return (index > 0 ? \"OR \" : \"\") + expression;\n      }\n\n      return expression;\n    }).join(\" \").trim();\n  }\n  /**\n   * Computes given where argument - transforms to a where string all forms it can take.\n   */\n\n\n  createWhereConditionExpression(condition) {\n    let alwaysWrap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (typeof condition === \"string\") return condition;\n\n    if (Array.isArray(condition)) {\n      if (condition.length === 0) {\n        return \"1=1\";\n      } // In the future we should probably remove this entire condition\n      // but for now to prevent any breaking changes it exists.\n\n\n      if (condition.length === 1 && !alwaysWrap) {\n        return this.createWhereClausesExpression(condition);\n      }\n\n      return \"(\" + this.createWhereClausesExpression(condition) + \")\";\n    }\n\n    const {\n      driver\n    } = this.connection;\n\n    switch (condition.operator) {\n      case \"lessThan\":\n        return `${condition.parameters[0]} < ${condition.parameters[1]}`;\n\n      case \"lessThanOrEqual\":\n        return `${condition.parameters[0]} <= ${condition.parameters[1]}`;\n\n      case \"arrayContains\":\n        return `${condition.parameters[0]} @> ${condition.parameters[1]}`;\n\n      case \"arrayContainedBy\":\n        return `${condition.parameters[0]} <@ ${condition.parameters[1]}`;\n\n      case \"arrayOverlap\":\n        return `${condition.parameters[0]} && ${condition.parameters[1]}`;\n\n      case \"moreThan\":\n        return `${condition.parameters[0]} > ${condition.parameters[1]}`;\n\n      case \"moreThanOrEqual\":\n        return `${condition.parameters[0]} >= ${condition.parameters[1]}`;\n\n      case \"notEqual\":\n        return `${condition.parameters[0]} != ${condition.parameters[1]}`;\n\n      case \"equal\":\n        return `${condition.parameters[0]} = ${condition.parameters[1]}`;\n\n      case \"ilike\":\n        if (driver.options.type === \"postgres\" || driver.options.type === \"cockroachdb\") {\n          return `${condition.parameters[0]} ILIKE ${condition.parameters[1]}`;\n        }\n\n        return `UPPER(${condition.parameters[0]}) LIKE UPPER(${condition.parameters[1]})`;\n\n      case \"like\":\n        return `${condition.parameters[0]} LIKE ${condition.parameters[1]}`;\n\n      case \"between\":\n        return `${condition.parameters[0]} BETWEEN ${condition.parameters[1]} AND ${condition.parameters[2]}`;\n\n      case \"in\":\n        if (condition.parameters.length <= 1) {\n          return \"0=1\";\n        }\n\n        return `${condition.parameters[0]} IN (${condition.parameters.slice(1).join(\", \")})`;\n\n      case \"any\":\n        return `${condition.parameters[0]} = ANY(${condition.parameters[1]})`;\n\n      case \"isNull\":\n        return `${condition.parameters[0]} IS NULL`;\n\n      case \"not\":\n        return `NOT(${this.createWhereConditionExpression(condition.condition)})`;\n\n      case \"brackets\":\n        return `${this.createWhereConditionExpression(condition.condition, true)}`;\n    }\n\n    throw new TypeError(`Unsupported FindOperator ${FindOperator.constructor.name}`);\n  }\n\n  createCteExpression() {\n    if (!this.hasCommonTableExpressions()) {\n      return \"\";\n    }\n\n    const databaseRequireRecusiveHint = this.connection.driver.cteCapabilities.requiresRecursiveHint;\n    const cteStrings = this.expressionMap.commonTableExpressions.map(cte => {\n      const cteBodyExpression = typeof cte.queryBuilder === \"string\" ? cte.queryBuilder : cte.queryBuilder.getQuery();\n\n      if (typeof cte.queryBuilder !== \"string\") {\n        if (cte.queryBuilder.hasCommonTableExpressions()) {\n          throw new TypeORMError(`Nested CTEs aren't supported (CTE: ${cte.alias})`);\n        }\n\n        if (!this.connection.driver.cteCapabilities.writable && !InstanceChecker.isSelectQueryBuilder(cte.queryBuilder)) {\n          throw new TypeORMError(`Only select queries are supported in CTEs in ${this.connection.options.type} (CTE: ${cte.alias})`);\n        }\n\n        this.setParameters(cte.queryBuilder.getParameters());\n      }\n\n      let cteHeader = this.escape(cte.alias);\n\n      if (cte.options.columnNames) {\n        const escapedColumnNames = cte.options.columnNames.map(column => this.escape(column));\n\n        if (InstanceChecker.isSelectQueryBuilder(cte.queryBuilder)) {\n          if (cte.queryBuilder.expressionMap.selects.length && cte.options.columnNames.length !== cte.queryBuilder.expressionMap.selects.length) {\n            throw new TypeORMError(`cte.options.columnNames length (${cte.options.columnNames.length}) doesn't match subquery select list length ${cte.queryBuilder.expressionMap.selects.length} (CTE: ${cte.alias})`);\n          }\n        }\n\n        cteHeader += `(${escapedColumnNames.join(\", \")})`;\n      }\n\n      const recursiveClause = cte.options.recursive && databaseRequireRecusiveHint ? \"RECURSIVE\" : \"\";\n      const materializeClause = cte.options.materialized && this.connection.driver.cteCapabilities.materializedHint ? \"MATERIALIZED\" : \"\";\n      return [recursiveClause, cteHeader, materializeClause, \"AS\", `(${cteBodyExpression})`].filter(Boolean).join(\" \");\n    });\n    return \"WITH \" + cteStrings.join(\", \") + \" \";\n  }\n  /**\n   * Creates \"WHERE\" condition for an in-ids condition.\n   */\n\n\n  getWhereInIdsCondition(ids) {\n    const metadata = this.expressionMap.mainAlias.metadata;\n    const normalized = (Array.isArray(ids) ? ids : [ids]).map(id => metadata.ensureEntityIdMap(id)); // using in(...ids) for single primary key entities\n\n    if (!metadata.hasMultiplePrimaryKeys) {\n      const primaryColumn = metadata.primaryColumns[0]; // getEntityValue will try to transform `In`, it is a bug\n      // todo: remove this transformer check after #2390 is fixed\n      // This also fails for embedded & relation, so until that is fixed skip it.\n\n      if (!primaryColumn.transformer && !primaryColumn.relationMetadata && !primaryColumn.embeddedMetadata) {\n        return {\n          [primaryColumn.propertyName]: In(normalized.map(id => primaryColumn.getEntityValue(id, false)))\n        };\n      }\n    }\n\n    return new Brackets(qb => {\n      for (const data of normalized) {\n        qb.orWhere(new Brackets(qb => qb.where(data)));\n      }\n    });\n  }\n\n  findColumnsForPropertyPath(propertyPath) {\n    // Make a helper to iterate the entity & relations?\n    // Use that to set the correct alias?  Or the other way around?\n    // Start with the main alias with our property paths\n    let alias = this.expressionMap.mainAlias;\n    const root = [];\n    const propertyPathParts = propertyPath.split(\".\");\n\n    while (propertyPathParts.length > 1) {\n      const part = propertyPathParts[0];\n\n      if (!(alias === null || alias === void 0 ? void 0 : alias.hasMetadata)) {\n        // If there's no metadata, we're wasting our time\n        // and can't actually look any of this up.\n        break;\n      }\n\n      if (alias.metadata.hasEmbeddedWithPropertyPath(part)) {\n        // If this is an embedded then we should combine the two as part of our lookup.\n        // Instead of just breaking, we keep going with this in case there's an embedded/relation\n        // inside an embedded.\n        propertyPathParts.unshift(`${propertyPathParts.shift()}.${propertyPathParts.shift()}`);\n        continue;\n      }\n\n      if (alias.metadata.hasRelationWithPropertyPath(part)) {\n        // If this is a relation then we should find the aliases\n        // that match the relation & then continue further down\n        // the property path\n        const joinAttr = this.expressionMap.joinAttributes.find(joinAttr => joinAttr.relationPropertyPath === part);\n\n        if (!(joinAttr === null || joinAttr === void 0 ? void 0 : joinAttr.alias)) {\n          const fullRelationPath = root.length > 0 ? `${root.join(\".\")}.${part}` : part;\n          throw new Error(`Cannot find alias for relation at ${fullRelationPath}`);\n        }\n\n        alias = joinAttr.alias;\n        root.push(...part.split(\".\"));\n        propertyPathParts.shift();\n        continue;\n      }\n\n      break;\n    }\n\n    if (!alias) {\n      throw new Error(`Cannot find alias for property ${propertyPath}`);\n    } // Remaining parts are combined back and used to find the actual property path\n\n\n    const aliasPropertyPath = propertyPathParts.join(\".\");\n    const columns = alias.metadata.findColumnsWithPropertyPath(aliasPropertyPath);\n\n    if (!columns.length) {\n      throw new EntityPropertyNotFoundError(propertyPath, alias.metadata);\n    }\n\n    return [alias, root, columns];\n  }\n  /**\n   * Creates a property paths for a given ObjectLiteral.\n   */\n\n\n  createPropertyPath(metadata, entity) {\n    let prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n    const paths = [];\n\n    for (const key of Object.keys(entity)) {\n      const path = prefix ? `${prefix}.${key}` : key; // There's times where we don't actually want to traverse deeper.\n      // If the value is a `FindOperator`, or null, or not an object, then we don't, for example.\n\n      if (entity[key] === null || typeof entity[key] !== \"object\" || InstanceChecker.isFindOperator(entity[key])) {\n        paths.push(path);\n        continue;\n      }\n\n      if (metadata.hasEmbeddedWithPropertyPath(path)) {\n        const subPaths = this.createPropertyPath(metadata, entity[key], path);\n        paths.push(...subPaths);\n        continue;\n      }\n\n      if (metadata.hasRelationWithPropertyPath(path)) {\n        const relation = metadata.findRelationWithPropertyPath(path); // There's also cases where we don't want to return back all of the properties.\n        // These handles the situation where someone passes the model & we don't need to make\n        // a HUGE `where` to uniquely look up the entity.\n        // In the case of a *-to-one, there's only ever one possible entity on the other side\n        // so if the join columns are all defined we can return just the relation itself\n        // because it will fetch only the join columns and do the lookup.\n\n        if (relation.relationType === \"one-to-one\" || relation.relationType === \"many-to-one\") {\n          const joinColumns = relation.joinColumns.map(j => j.referencedColumn).filter(j => !!j);\n          const hasAllJoinColumns = joinColumns.length > 0 && joinColumns.every(column => column.getEntityValue(entity[key], false));\n\n          if (hasAllJoinColumns) {\n            paths.push(path);\n            continue;\n          }\n        }\n\n        if (relation.relationType === \"one-to-many\" || relation.relationType === \"many-to-many\") {\n          throw new Error(`Cannot query across ${relation.relationType} for property ${path}`);\n        } // For any other case, if the `entity[key]` contains all of the primary keys we can do a\n        // lookup via these.  We don't need to look up via any other values 'cause these are\n        // the unique primary keys.\n        // This handles the situation where someone passes the model & we don't need to make\n        // a HUGE where.\n\n\n        const primaryColumns = relation.inverseEntityMetadata.primaryColumns;\n        const hasAllPrimaryKeys = primaryColumns.length > 0 && primaryColumns.every(column => column.getEntityValue(entity[key], false));\n\n        if (hasAllPrimaryKeys) {\n          const subPaths = primaryColumns.map(column => `${path}.${column.propertyPath}`);\n          paths.push(...subPaths);\n          continue;\n        } // If nothing else, just return every property that's being passed to us.\n\n\n        const subPaths = this.createPropertyPath(relation.inverseEntityMetadata, entity[key]).map(p => `${path}.${p}`);\n        paths.push(...subPaths);\n        continue;\n      }\n\n      paths.push(path);\n    }\n\n    return paths;\n  }\n\n  *getPredicates(where) {\n    if (this.expressionMap.mainAlias.hasMetadata) {\n      const propertyPaths = this.createPropertyPath(this.expressionMap.mainAlias.metadata, where);\n\n      for (const propertyPath of propertyPaths) {\n        const [alias, aliasPropertyPath, columns] = this.findColumnsForPropertyPath(propertyPath);\n\n        for (const column of columns) {\n          let containedWhere = where;\n\n          for (const part of aliasPropertyPath) {\n            if (!containedWhere || !(part in containedWhere)) {\n              containedWhere = {};\n              break;\n            }\n\n            containedWhere = containedWhere[part];\n          } // Use the correct alias & the property path from the column\n\n\n          const aliasPath = this.expressionMap.aliasNamePrefixingEnabled ? `${alias.name}.${column.propertyPath}` : column.propertyPath;\n          const parameterValue = column.getEntityValue(containedWhere, true);\n          yield [aliasPath, parameterValue];\n        }\n      }\n    } else {\n      for (const key of Object.keys(where)) {\n        const parameterValue = where[key];\n        const aliasPath = this.expressionMap.aliasNamePrefixingEnabled ? `${this.alias}.${key}` : key;\n        yield [aliasPath, parameterValue];\n      }\n    }\n  }\n\n  getWherePredicateCondition(aliasPath, parameterValue) {\n    if (InstanceChecker.isFindOperator(parameterValue)) {\n      let parameters = [];\n\n      if (parameterValue.useParameter) {\n        if (parameterValue.objectLiteralParameters) {\n          this.setParameters(parameterValue.objectLiteralParameters);\n        } else if (parameterValue.multipleParameters) {\n          for (const v of parameterValue.value) {\n            parameters.push(this.createParameter(v));\n          }\n        } else {\n          parameters.push(this.createParameter(parameterValue.value));\n        }\n      }\n\n      if (parameterValue.type === \"raw\") {\n        if (parameterValue.getSql) {\n          return parameterValue.getSql(aliasPath);\n        } else {\n          return {\n            operator: \"equal\",\n            parameters: [aliasPath, parameterValue.value]\n          };\n        }\n      } else if (parameterValue.type === \"not\") {\n        if (parameterValue.child) {\n          return {\n            operator: parameterValue.type,\n            condition: this.getWherePredicateCondition(aliasPath, parameterValue.child)\n          };\n        } else {\n          return {\n            operator: \"notEqual\",\n            parameters: [aliasPath, ...parameters]\n          };\n        }\n      } else {\n        return {\n          operator: parameterValue.type,\n          parameters: [aliasPath, ...parameters]\n        };\n      } // } else if (parameterValue === null) {\n      //     return {\n      //         operator: \"isNull\",\n      //         parameters: [\n      //             aliasPath,\n      //         ]\n      //     };\n\n    } else {\n      return {\n        operator: \"equal\",\n        parameters: [aliasPath, this.createParameter(parameterValue)]\n      };\n    }\n  }\n\n  getWhereCondition(where) {\n    if (typeof where === \"string\") {\n      return where;\n    }\n\n    if (InstanceChecker.isBrackets(where)) {\n      const whereQueryBuilder = this.createQueryBuilder();\n      whereQueryBuilder.parentQueryBuilder = this;\n      whereQueryBuilder.expressionMap.mainAlias = this.expressionMap.mainAlias;\n      whereQueryBuilder.expressionMap.aliasNamePrefixingEnabled = this.expressionMap.aliasNamePrefixingEnabled;\n      whereQueryBuilder.expressionMap.parameters = this.expressionMap.parameters;\n      whereQueryBuilder.expressionMap.nativeParameters = this.expressionMap.nativeParameters;\n      whereQueryBuilder.expressionMap.wheres = [];\n      where.whereFactory(whereQueryBuilder);\n      return {\n        operator: InstanceChecker.isNotBrackets(where) ? \"not\" : \"brackets\",\n        condition: whereQueryBuilder.expressionMap.wheres\n      };\n    }\n\n    if (typeof where === \"function\") {\n      return where(this);\n    }\n\n    const wheres = Array.isArray(where) ? where : [where];\n    const clauses = [];\n\n    for (const where of wheres) {\n      const conditions = []; // Filter the conditions and set up the parameter values\n\n      for (const [aliasPath, parameterValue] of this.getPredicates(where)) {\n        conditions.push({\n          type: \"and\",\n          condition: this.getWherePredicateCondition(aliasPath, parameterValue)\n        });\n      }\n\n      clauses.push({\n        type: \"or\",\n        condition: conditions\n      });\n    }\n\n    if (clauses.length === 1) {\n      return clauses[0].condition;\n    }\n\n    return clauses;\n  }\n  /**\n   * Creates a query builder used to execute sql queries inside this query builder.\n   */\n\n\n  obtainQueryRunner() {\n    return this.queryRunner || this.connection.createQueryRunner();\n  }\n\n  hasCommonTableExpressions() {\n    return this.expressionMap.commonTableExpressions.length > 0;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["QueryExpressionMap","Brackets","FindOperator","In","TypeORMError","EntityPropertyNotFoundError","InstanceChecker","escapeRegExp","QueryBuilder","constructor","connectionOrQueryBuilder","queryRunner","Symbol","for","isQueryBuilder","connection","expressionMap","clone","alias","mainAlias","name","select","selection","selectionAliasName","queryType","Array","isArray","selects","map","aliasName","SelectQueryBuilderCls","require","SelectQueryBuilder","isSelectQueryBuilder","insert","InsertQueryBuilderCls","InsertQueryBuilder","isInsertQueryBuilder","update","entityOrTableNameUpdateSet","maybeUpdateSet","updateSet","isEntitySchema","options","createFromAlias","setMainAlias","valuesSet","UpdateQueryBuilderCls","UpdateQueryBuilder","isUpdateQueryBuilder","delete","DeleteQueryBuilderCls","DeleteQueryBuilder","isDeleteQueryBuilder","softDelete","SoftDeleteQueryBuilderCls","SoftDeleteQueryBuilder","isSoftDeleteQueryBuilder","restore","relation","entityTargetOrPropertyPath","maybePropertyPath","entityTarget","arguments","length","undefined","propertyPath","relationPropertyPath","RelationQueryBuilderCls","RelationQueryBuilder","isRelationQueryBuilder","hasRelation","target","entityMetadata","getMetadata","relations","every","findRelationWithPropertyPath","hasParameter","key","parentQueryBuilder","_a","parameters","setParameter","value","match","setParameters","Object","entries","createParameter","parameterName","parameterIndex","setNativeParameters","keys","forEach","nativeParameters","getParameters","assign","hasMetadata","metadata","discriminatorColumn","parentEntityMetadata","values","childEntityMetadatas","filter","childMetadata","discriminatorValue","push","printSql","query","getQueryAndParameters","logger","logQuery","getSql","getQuery","driver","escapeQueryWithParameters","execute","sql","obtainQueryRunner","release","createQueryBuilder","comment","disableEscaping","escape","setQueryRunner","callListeners","enabled","useTransaction","addCommonTableExpression","queryBuilder","commonTableExpressions","getTableName","tablePath","split","i","join","getMainTableName","createAlias","type","isSubquery","substr","subQuery","subQueryBuilder","subquery","replacePropertyNames","statement","aliases","replaceAliasNamePrefix","aliasNamePrefixingEnabled","replacementAliasNamePrefix","replacements","joinColumns","databaseName","joinColumn","inverseJoinColumns","propertyKey","referencedColumn","column","columns","propertyName","replace","RegExp","pre","p","createComment","createWhereExpression","conditionsArray","whereExpression","createWhereClausesExpression","wheres","withDeleted","deleteDateColumn","condition","extraAppendedAndWhereCondition","createReturningExpression","returningType","getReturningColumns","returning","extraReturningColumns","isReturningSqlSupported","indexOf","columnsExpression","columnTypeToNativeParameter","dir","oracle","BIND_OUT","columnName","findColumnsWithPropertyPath","clauses","clause","index","expression","createWhereConditionExpression","trim","alwaysWrap","operator","slice","TypeError","createCteExpression","hasCommonTableExpressions","databaseRequireRecusiveHint","cteCapabilities","requiresRecursiveHint","cteStrings","cte","cteBodyExpression","writable","cteHeader","columnNames","escapedColumnNames","recursiveClause","recursive","materializeClause","materialized","materializedHint","Boolean","getWhereInIdsCondition","ids","normalized","id","ensureEntityIdMap","hasMultiplePrimaryKeys","primaryColumn","primaryColumns","transformer","relationMetadata","embeddedMetadata","getEntityValue","qb","data","orWhere","where","findColumnsForPropertyPath","root","propertyPathParts","part","hasEmbeddedWithPropertyPath","unshift","shift","hasRelationWithPropertyPath","joinAttr","joinAttributes","find","fullRelationPath","Error","aliasPropertyPath","createPropertyPath","entity","prefix","paths","path","isFindOperator","subPaths","relationType","j","hasAllJoinColumns","inverseEntityMetadata","hasAllPrimaryKeys","getPredicates","propertyPaths","containedWhere","aliasPath","parameterValue","getWherePredicateCondition","useParameter","objectLiteralParameters","multipleParameters","v","child","getWhereCondition","isBrackets","whereQueryBuilder","whereFactory","isNotBrackets","conditions","createQueryRunner"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\query-builder\\QueryBuilder.ts"],"sourcesContent":["import { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { QueryBuilderCteOptions } from \"./QueryBuilderCte\"\nimport { QueryExpressionMap } from \"./QueryExpressionMap\"\nimport { SelectQueryBuilder } from \"./SelectQueryBuilder\"\nimport { UpdateQueryBuilder } from \"./UpdateQueryBuilder\"\nimport { DeleteQueryBuilder } from \"./DeleteQueryBuilder\"\nimport { SoftDeleteQueryBuilder } from \"./SoftDeleteQueryBuilder\"\nimport { InsertQueryBuilder } from \"./InsertQueryBuilder\"\nimport { RelationQueryBuilder } from \"./RelationQueryBuilder\"\nimport { EntityTarget } from \"../common/EntityTarget\"\nimport { Alias } from \"./Alias\"\nimport { Brackets } from \"./Brackets\"\nimport { QueryDeepPartialEntity } from \"./QueryPartialEntity\"\nimport { EntityMetadata } from \"../metadata/EntityMetadata\"\nimport { ColumnMetadata } from \"../metadata/ColumnMetadata\"\nimport { FindOperator } from \"../find-options/FindOperator\"\nimport { In } from \"../find-options/operator/In\"\nimport { TypeORMError } from \"../error\"\nimport { WhereClause, WhereClauseCondition } from \"./WhereClause\"\nimport { NotBrackets } from \"./NotBrackets\"\nimport { EntityPropertyNotFoundError } from \"../error/EntityPropertyNotFoundError\"\nimport { ReturningType } from \"../driver/Driver\"\nimport { OracleDriver } from \"../driver/oracle/OracleDriver\"\nimport { InstanceChecker } from \"../util/InstanceChecker\"\nimport { escapeRegExp } from \"../util/escapeRegExp\"\n\n// todo: completely cover query builder with tests\n// todo: entityOrProperty can be target name. implement proper behaviour if it is.\n// todo: check in persistment if id exist on object and throw exception (can be in partial selection?)\n// todo: fix problem with long aliases eg getMaxIdentifierLength\n// todo: fix replacing in .select(\"COUNT(post.id) AS cnt\") statement\n// todo: implement joinAlways in relations and relationId\n// todo: finish partial selection\n// todo: sugar methods like: .addCount and .selectCount, selectCountAndMap, selectSum, selectSumAndMap, ...\n// todo: implement @Select decorator\n// todo: add select and map functions\n\n// todo: implement relation/entity loading and setting them into properties within a separate query\n// .loadAndMap(\"post.categories\", \"post.categories\", qb => ...)\n// .loadAndMap(\"post.categories\", Category, qb => ...)\n\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n */\nexport abstract class QueryBuilder<Entity extends ObjectLiteral> {\n    readonly \"@instanceof\" = Symbol.for(\"QueryBuilder\")\n\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Connection on which QueryBuilder was created.\n     */\n    readonly connection: DataSource\n\n    /**\n     * Contains all properties of the QueryBuilder that needs to be build a final query.\n     */\n    readonly expressionMap: QueryExpressionMap\n\n    // -------------------------------------------------------------------------\n    // Protected Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Query runner used to execute query builder query.\n     */\n    protected queryRunner?: QueryRunner\n\n    /**\n     * If QueryBuilder was created in a subquery mode then its parent QueryBuilder (who created subquery) will be stored here.\n     */\n    protected parentQueryBuilder: QueryBuilder<any>\n\n    /**\n     * Memo to help keep place of current parameter index for `createParameter`\n     */\n    private parameterIndex = 0\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    /**\n     * QueryBuilder can be initialized from given Connection and QueryRunner objects or from given other QueryBuilder.\n     */\n    constructor(queryBuilder: QueryBuilder<any>)\n\n    /**\n     * QueryBuilder can be initialized from given Connection and QueryRunner objects or from given other QueryBuilder.\n     */\n    constructor(connection: DataSource, queryRunner?: QueryRunner)\n\n    /**\n     * QueryBuilder can be initialized from given Connection and QueryRunner objects or from given other QueryBuilder.\n     */\n    constructor(\n        connectionOrQueryBuilder: DataSource | QueryBuilder<any>,\n        queryRunner?: QueryRunner,\n    ) {\n        if (InstanceChecker.isQueryBuilder(connectionOrQueryBuilder)) {\n            this.connection = connectionOrQueryBuilder.connection\n            this.queryRunner = connectionOrQueryBuilder.queryRunner\n            this.expressionMap = connectionOrQueryBuilder.expressionMap.clone()\n        } else {\n            this.connection = connectionOrQueryBuilder\n            this.queryRunner = queryRunner\n            this.expressionMap = new QueryExpressionMap(this.connection)\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Abstract Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets generated SQL query without parameters being replaced.\n     */\n    abstract getQuery(): string\n\n    // -------------------------------------------------------------------------\n    // Accessors\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets the main alias string used in this query builder.\n     */\n    get alias(): string {\n        if (!this.expressionMap.mainAlias)\n            throw new TypeORMError(`Main alias is not set`) // todo: better exception\n\n        return this.expressionMap.mainAlias.name\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates SELECT query.\n     * Replaces all previous selections if they exist.\n     */\n    select(): SelectQueryBuilder<Entity>\n\n    /**\n     * Creates SELECT query and selects given data.\n     * Replaces all previous selections if they exist.\n     */\n    select(\n        selection: string,\n        selectionAliasName?: string,\n    ): SelectQueryBuilder<Entity>\n\n    /**\n     * Creates SELECT query and selects given data.\n     * Replaces all previous selections if they exist.\n     */\n    select(selection: string[]): SelectQueryBuilder<Entity>\n\n    /**\n     * Creates SELECT query and selects given data.\n     * Replaces all previous selections if they exist.\n     */\n    select(\n        selection?: string | string[],\n        selectionAliasName?: string,\n    ): SelectQueryBuilder<Entity> {\n        this.expressionMap.queryType = \"select\"\n        if (Array.isArray(selection)) {\n            this.expressionMap.selects = selection.map((selection) => ({\n                selection: selection,\n            }))\n        } else if (selection) {\n            this.expressionMap.selects = [\n                { selection: selection, aliasName: selectionAliasName },\n            ]\n        }\n\n        // loading it dynamically because of circular issue\n        const SelectQueryBuilderCls =\n            require(\"./SelectQueryBuilder\").SelectQueryBuilder\n        if (InstanceChecker.isSelectQueryBuilder(this)) return this as any\n\n        return new SelectQueryBuilderCls(this)\n    }\n\n    /**\n     * Creates INSERT query.\n     */\n    insert(): InsertQueryBuilder<Entity> {\n        this.expressionMap.queryType = \"insert\"\n\n        // loading it dynamically because of circular issue\n        const InsertQueryBuilderCls =\n            require(\"./InsertQueryBuilder\").InsertQueryBuilder\n        if (InstanceChecker.isInsertQueryBuilder(this)) return this as any\n\n        return new InsertQueryBuilderCls(this)\n    }\n\n    /**\n     * Creates UPDATE query and applies given update values.\n     */\n    update(): UpdateQueryBuilder<Entity>\n\n    /**\n     * Creates UPDATE query and applies given update values.\n     */\n    update(\n        updateSet: QueryDeepPartialEntity<Entity>,\n    ): UpdateQueryBuilder<Entity>\n\n    /**\n     * Creates UPDATE query for the given entity and applies given update values.\n     */\n    update<Entity extends ObjectLiteral>(\n        entity: EntityTarget<Entity>,\n        updateSet?: QueryDeepPartialEntity<Entity>,\n    ): UpdateQueryBuilder<Entity>\n\n    /**\n     * Creates UPDATE query for the given table name and applies given update values.\n     */\n    update(\n        tableName: string,\n        updateSet?: QueryDeepPartialEntity<Entity>,\n    ): UpdateQueryBuilder<Entity>\n\n    /**\n     * Creates UPDATE query and applies given update values.\n     */\n    update(\n        entityOrTableNameUpdateSet?: EntityTarget<any> | ObjectLiteral,\n        maybeUpdateSet?: ObjectLiteral,\n    ): UpdateQueryBuilder<any> {\n        const updateSet = maybeUpdateSet\n            ? maybeUpdateSet\n            : (entityOrTableNameUpdateSet as ObjectLiteral | undefined)\n        entityOrTableNameUpdateSet = InstanceChecker.isEntitySchema(\n            entityOrTableNameUpdateSet,\n        )\n            ? entityOrTableNameUpdateSet.options.name\n            : entityOrTableNameUpdateSet\n\n        if (\n            typeof entityOrTableNameUpdateSet === \"function\" ||\n            typeof entityOrTableNameUpdateSet === \"string\"\n        ) {\n            const mainAlias = this.createFromAlias(entityOrTableNameUpdateSet)\n            this.expressionMap.setMainAlias(mainAlias)\n        }\n\n        this.expressionMap.queryType = \"update\"\n        this.expressionMap.valuesSet = updateSet\n\n        // loading it dynamically because of circular issue\n        const UpdateQueryBuilderCls =\n            require(\"./UpdateQueryBuilder\").UpdateQueryBuilder\n        if (InstanceChecker.isUpdateQueryBuilder(this)) return this as any\n\n        return new UpdateQueryBuilderCls(this)\n    }\n\n    /**\n     * Creates DELETE query.\n     */\n    delete(): DeleteQueryBuilder<Entity> {\n        this.expressionMap.queryType = \"delete\"\n\n        // loading it dynamically because of circular issue\n        const DeleteQueryBuilderCls =\n            require(\"./DeleteQueryBuilder\").DeleteQueryBuilder\n        if (InstanceChecker.isDeleteQueryBuilder(this)) return this as any\n\n        return new DeleteQueryBuilderCls(this)\n    }\n\n    softDelete(): SoftDeleteQueryBuilder<any> {\n        this.expressionMap.queryType = \"soft-delete\"\n\n        // loading it dynamically because of circular issue\n        const SoftDeleteQueryBuilderCls =\n            require(\"./SoftDeleteQueryBuilder\").SoftDeleteQueryBuilder\n        if (InstanceChecker.isSoftDeleteQueryBuilder(this)) return this as any\n\n        return new SoftDeleteQueryBuilderCls(this)\n    }\n\n    restore(): SoftDeleteQueryBuilder<any> {\n        this.expressionMap.queryType = \"restore\"\n\n        // loading it dynamically because of circular issue\n        const SoftDeleteQueryBuilderCls =\n            require(\"./SoftDeleteQueryBuilder\").SoftDeleteQueryBuilder\n        if (InstanceChecker.isSoftDeleteQueryBuilder(this)) return this as any\n\n        return new SoftDeleteQueryBuilderCls(this)\n    }\n\n    /**\n     * Sets entity's relation with which this query builder gonna work.\n     */\n    relation(propertyPath: string): RelationQueryBuilder<Entity>\n\n    /**\n     * Sets entity's relation with which this query builder gonna work.\n     */\n    relation<T extends ObjectLiteral>(\n        entityTarget: EntityTarget<T>,\n        propertyPath: string,\n    ): RelationQueryBuilder<T>\n\n    /**\n     * Sets entity's relation with which this query builder gonna work.\n     */\n    relation(\n        entityTargetOrPropertyPath: Function | string,\n        maybePropertyPath?: string,\n    ): RelationQueryBuilder<Entity> {\n        const entityTarget =\n            arguments.length === 2 ? entityTargetOrPropertyPath : undefined\n        const propertyPath =\n            arguments.length === 2\n                ? (maybePropertyPath as string)\n                : (entityTargetOrPropertyPath as string)\n\n        this.expressionMap.queryType = \"relation\"\n        this.expressionMap.relationPropertyPath = propertyPath\n\n        if (entityTarget) {\n            const mainAlias = this.createFromAlias(entityTarget)\n            this.expressionMap.setMainAlias(mainAlias)\n        }\n\n        // loading it dynamically because of circular issue\n        const RelationQueryBuilderCls =\n            require(\"./RelationQueryBuilder\").RelationQueryBuilder\n        if (InstanceChecker.isRelationQueryBuilder(this)) return this as any\n\n        return new RelationQueryBuilderCls(this)\n    }\n\n    /**\n     * Checks if given relation exists in the entity.\n     * Returns true if relation exists, false otherwise.\n     *\n     * todo: move this method to manager? or create a shortcut?\n     */\n    hasRelation<T>(target: EntityTarget<T>, relation: string): boolean\n\n    /**\n     * Checks if given relations exist in the entity.\n     * Returns true if relation exists, false otherwise.\n     *\n     * todo: move this method to manager? or create a shortcut?\n     */\n    hasRelation<T>(target: EntityTarget<T>, relation: string[]): boolean\n\n    /**\n     * Checks if given relation or relations exist in the entity.\n     * Returns true if relation exists, false otherwise.\n     *\n     * todo: move this method to manager? or create a shortcut?\n     */\n    hasRelation<T>(\n        target: EntityTarget<T>,\n        relation: string | string[],\n    ): boolean {\n        const entityMetadata = this.connection.getMetadata(target)\n        const relations = Array.isArray(relation) ? relation : [relation]\n        return relations.every((relation) => {\n            return !!entityMetadata.findRelationWithPropertyPath(relation)\n        })\n    }\n\n    /**\n     * Check the existence of a parameter for this query builder.\n     */\n    hasParameter(key: string): boolean {\n        return (\n            this.parentQueryBuilder?.hasParameter(key) ||\n            key in this.expressionMap.parameters\n        )\n    }\n\n    /**\n     * Sets parameter name and its value.\n     *\n     * The key for this parameter may contain numbers, letters, underscores, or periods.\n     */\n    setParameter(key: string, value: any): this {\n        if (typeof value === \"function\") {\n            throw new TypeORMError(\n                `Function parameter isn't supported in the parameters. Please check \"${key}\" parameter.`,\n            )\n        }\n\n        if (!key.match(/^([A-Za-z0-9_.]+)$/)) {\n            throw new TypeORMError(\n                \"QueryBuilder parameter keys may only contain numbers, letters, underscores, or periods.\",\n            )\n        }\n\n        if (this.parentQueryBuilder) {\n            this.parentQueryBuilder.setParameter(key, value)\n        }\n\n        this.expressionMap.parameters[key] = value\n        return this\n    }\n\n    /**\n     * Adds all parameters from the given object.\n     */\n    setParameters(parameters: ObjectLiteral): this {\n        for (const [key, value] of Object.entries(parameters)) {\n            this.setParameter(key, value)\n        }\n\n        return this\n    }\n\n    protected createParameter(value: any): string {\n        let parameterName\n\n        do {\n            parameterName = `orm_param_${this.parameterIndex++}`\n        } while (this.hasParameter(parameterName))\n\n        this.setParameter(parameterName, value)\n\n        return `:${parameterName}`\n    }\n\n    /**\n     * Adds native parameters from the given object.\n     *\n     * @deprecated Use `setParameters` instead\n     */\n    setNativeParameters(parameters: ObjectLiteral): this {\n        // set parent query builder parameters as well in sub-query mode\n        if (this.parentQueryBuilder) {\n            this.parentQueryBuilder.setNativeParameters(parameters)\n        }\n\n        Object.keys(parameters).forEach((key) => {\n            this.expressionMap.nativeParameters[key] = parameters[key]\n        })\n        return this\n    }\n\n    /**\n     * Gets all parameters.\n     */\n    getParameters(): ObjectLiteral {\n        const parameters: ObjectLiteral = Object.assign(\n            {},\n            this.expressionMap.parameters,\n        )\n\n        // add discriminator column parameter if it exist\n        if (\n            this.expressionMap.mainAlias &&\n            this.expressionMap.mainAlias.hasMetadata\n        ) {\n            const metadata = this.expressionMap.mainAlias!.metadata\n            if (metadata.discriminatorColumn && metadata.parentEntityMetadata) {\n                const values = metadata.childEntityMetadatas\n                    .filter(\n                        (childMetadata) => childMetadata.discriminatorColumn,\n                    )\n                    .map((childMetadata) => childMetadata.discriminatorValue)\n                values.push(metadata.discriminatorValue)\n                parameters[\"discriminatorColumnValues\"] = values\n            }\n        }\n\n        return parameters\n    }\n\n    /**\n     * Prints sql to stdout using console.log.\n     */\n    printSql(): this {\n        // TODO rename to logSql()\n        const [query, parameters] = this.getQueryAndParameters()\n        this.connection.logger.logQuery(query, parameters)\n        return this\n    }\n\n    /**\n     * Gets generated sql that will be executed.\n     * Parameters in the query are escaped for the currently used driver.\n     */\n    getSql(): string {\n        return this.getQueryAndParameters()[0]\n    }\n\n    /**\n     * Gets query to be executed with all parameters used in it.\n     */\n    getQueryAndParameters(): [string, any[]] {\n        // this execution order is important because getQuery method generates this.expressionMap.nativeParameters values\n        const query = this.getQuery()\n        const parameters = this.getParameters()\n        return this.connection.driver.escapeQueryWithParameters(\n            query,\n            parameters,\n            this.expressionMap.nativeParameters,\n        )\n    }\n\n    /**\n     * Executes sql generated by query builder and returns raw database results.\n     */\n    async execute(): Promise<any> {\n        const [sql, parameters] = this.getQueryAndParameters()\n        const queryRunner = this.obtainQueryRunner()\n        try {\n            return await queryRunner.query(sql, parameters) // await is needed here because we are using finally\n        } finally {\n            if (queryRunner !== this.queryRunner) {\n                // means we created our own query runner\n                await queryRunner.release()\n            }\n        }\n    }\n\n    /**\n     * Creates a completely new query builder.\n     * Uses same query runner as current QueryBuilder.\n     */\n    createQueryBuilder(): this {\n        return new (this.constructor as any)(this.connection, this.queryRunner)\n    }\n\n    /**\n     * Clones query builder as it is.\n     * Note: it uses new query runner, if you want query builder that uses exactly same query runner,\n     * you can create query builder using its constructor, for example new SelectQueryBuilder(queryBuilder)\n     * where queryBuilder is cloned QueryBuilder.\n     */\n    clone(): this {\n        return new (this.constructor as any)(this)\n    }\n\n    /**\n     * Includes a Query comment in the query builder.  This is helpful for debugging purposes,\n     * such as finding a specific query in the database server's logs, or for categorization using\n     * an APM product.\n     */\n    comment(comment: string): this {\n        this.expressionMap.comment = comment\n        return this\n    }\n\n    /**\n     * Disables escaping.\n     */\n    disableEscaping(): this {\n        this.expressionMap.disableEscaping = false\n        return this\n    }\n\n    /**\n     * Escapes table name, column name or alias name using current database's escaping character.\n     */\n    escape(name: string): string {\n        if (!this.expressionMap.disableEscaping) return name\n        return this.connection.driver.escape(name)\n    }\n\n    /**\n     * Sets or overrides query builder's QueryRunner.\n     */\n    setQueryRunner(queryRunner: QueryRunner): this {\n        this.queryRunner = queryRunner\n        return this\n    }\n\n    /**\n     * Indicates if listeners and subscribers must be called before and after query execution.\n     * Enabled by default.\n     */\n    callListeners(enabled: boolean): this {\n        this.expressionMap.callListeners = enabled\n        return this\n    }\n\n    /**\n     * If set to true the query will be wrapped into a transaction.\n     */\n    useTransaction(enabled: boolean): this {\n        this.expressionMap.useTransaction = enabled\n        return this\n    }\n\n    /**\n     * Adds CTE to query\n     */\n    addCommonTableExpression(\n        queryBuilder: QueryBuilder<any> | string,\n        alias: string,\n        options?: QueryBuilderCteOptions,\n    ): this {\n        this.expressionMap.commonTableExpressions.push({\n            queryBuilder,\n            alias,\n            options: options || {},\n        })\n        return this\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets escaped table name with schema name if SqlServer driver used with custom\n     * schema name, otherwise returns escaped table name.\n     */\n    protected getTableName(tablePath: string): string {\n        return tablePath\n            .split(\".\")\n            .map((i) => {\n                // this condition need because in SQL Server driver when custom database name was specified and schema name was not, we got `dbName..tableName` string, and doesn't need to escape middle empty string\n                if (i === \"\") return i\n                return this.escape(i)\n            })\n            .join(\".\")\n    }\n\n    /**\n     * Gets name of the table where insert should be performed.\n     */\n    protected getMainTableName(): string {\n        if (!this.expressionMap.mainAlias)\n            throw new TypeORMError(\n                `Entity where values should be inserted is not specified. Call \"qb.into(entity)\" method to specify it.`,\n            )\n\n        if (this.expressionMap.mainAlias.hasMetadata)\n            return this.expressionMap.mainAlias.metadata.tablePath\n\n        return this.expressionMap.mainAlias.tablePath!\n    }\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     */\n    protected createFromAlias(\n        entityTarget:\n            | EntityTarget<any>\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        aliasName?: string,\n    ): Alias {\n        // if table has a metadata then find it to properly escape its properties\n        // const metadata = this.connection.entityMetadatas.find(metadata => metadata.tableName === tableName);\n        if (this.connection.hasMetadata(entityTarget)) {\n            const metadata = this.connection.getMetadata(entityTarget)\n\n            return this.expressionMap.createAlias({\n                type: \"from\",\n                name: aliasName,\n                metadata: this.connection.getMetadata(entityTarget),\n                tablePath: metadata.tablePath,\n            })\n        } else {\n            if (typeof entityTarget === \"string\") {\n                const isSubquery =\n                    entityTarget.substr(0, 1) === \"(\" &&\n                    entityTarget.substr(-1) === \")\"\n\n                return this.expressionMap.createAlias({\n                    type: \"from\",\n                    name: aliasName,\n                    tablePath: !isSubquery\n                        ? (entityTarget as string)\n                        : undefined,\n                    subQuery: isSubquery ? entityTarget : undefined,\n                })\n            }\n\n            const subQueryBuilder: SelectQueryBuilder<any> = (\n                entityTarget as any\n            )((this as any as SelectQueryBuilder<any>).subQuery())\n            this.setParameters(subQueryBuilder.getParameters())\n            const subquery = subQueryBuilder.getQuery()\n\n            return this.expressionMap.createAlias({\n                type: \"from\",\n                name: aliasName,\n                subQuery: subquery,\n            })\n        }\n    }\n\n    /**\n     * Replaces all entity's propertyName to name in the given statement.\n     */\n\n    protected replacePropertyNames(statement: string) {\n        for (const alias of this.expressionMap.aliases) {\n            if (!alias.hasMetadata) continue\n            const replaceAliasNamePrefix = this.expressionMap\n                .aliasNamePrefixingEnabled\n                ? `${alias.name}.`\n                : \"\"\n            const replacementAliasNamePrefix = this.expressionMap\n                .aliasNamePrefixingEnabled\n                ? `${this.escape(alias.name)}.`\n                : \"\"\n\n            const replacements: { [key: string]: string } = {}\n\n            // Insert & overwrite the replacements from least to most relevant in our replacements object.\n            // To do this we iterate and overwrite in the order of relevance.\n            // Least to Most Relevant:\n            // * Relation Property Path to first join column key\n            // * Relation Property Path + Column Path\n            // * Column Database Name\n            // * Column Property Name\n            // * Column Property Path\n\n            for (const relation of alias.metadata.relations) {\n                if (relation.joinColumns.length > 0)\n                    replacements[relation.propertyPath] =\n                        relation.joinColumns[0].databaseName\n            }\n\n            for (const relation of alias.metadata.relations) {\n                for (const joinColumn of [\n                    ...relation.joinColumns,\n                    ...relation.inverseJoinColumns,\n                ]) {\n                    const propertyKey = `${relation.propertyPath}.${\n                        joinColumn.referencedColumn!.propertyPath\n                    }`\n                    replacements[propertyKey] = joinColumn.databaseName\n                }\n            }\n\n            for (const column of alias.metadata.columns) {\n                replacements[column.databaseName] = column.databaseName\n            }\n\n            for (const column of alias.metadata.columns) {\n                replacements[column.propertyName] = column.databaseName\n            }\n\n            for (const column of alias.metadata.columns) {\n                replacements[column.propertyPath] = column.databaseName\n            }\n\n            statement = statement.replace(\n                new RegExp(\n                    // Avoid a lookbehind here since it's not well supported\n                    `([ =\\(]|^.{0})` + // any of ' =(' or start of line\n                        // followed by our prefix, e.g. 'tablename.' or ''\n                        `${escapeRegExp(\n                            replaceAliasNamePrefix,\n                        )}([^ =\\(\\)\\,]+)` + // a possible property name: sequence of anything but ' =(),'\n                        // terminated by ' =),' or end of line\n                        `(?=[ =\\)\\,]|.{0}$)`,\n                    \"gm\",\n                ),\n                (match, pre, p) => {\n                    if (replacements[p]) {\n                        return `${pre}${replacementAliasNamePrefix}${this.escape(\n                            replacements[p],\n                        )}`\n                    }\n                    return match\n                },\n            )\n        }\n\n        return statement\n    }\n\n    protected createComment(): string {\n        if (!this.expressionMap.comment) {\n            return \"\"\n        }\n\n        // ANSI SQL 2003 support C style comments - comments that start with `/*` and end with `*/`\n        // In some dialects query nesting is available - but not all.  Because of this, we'll need\n        // to scrub \"ending\" characters from the SQL but otherwise we can leave everything else\n        // as-is and it should be valid.\n\n        return `/* ${this.expressionMap.comment.replace(\"*/\", \"\")} */ `\n    }\n\n    /**\n     * Creates \"WHERE\" expression.\n     */\n    protected createWhereExpression() {\n        const conditionsArray = []\n\n        const whereExpression = this.createWhereClausesExpression(\n            this.expressionMap.wheres,\n        )\n\n        if (whereExpression.length > 0 && whereExpression !== \"1=1\") {\n            conditionsArray.push(this.replacePropertyNames(whereExpression))\n        }\n\n        if (this.expressionMap.mainAlias!.hasMetadata) {\n            const metadata = this.expressionMap.mainAlias!.metadata\n            // Adds the global condition of \"non-deleted\" for the entity with delete date columns in select query.\n            if (\n                this.expressionMap.queryType === \"select\" &&\n                !this.expressionMap.withDeleted &&\n                metadata.deleteDateColumn\n            ) {\n                const column = this.expressionMap.aliasNamePrefixingEnabled\n                    ? this.expressionMap.mainAlias!.name +\n                      \".\" +\n                      metadata.deleteDateColumn.propertyName\n                    : metadata.deleteDateColumn.propertyName\n\n                const condition = `${this.replacePropertyNames(column)} IS NULL`\n                conditionsArray.push(condition)\n            }\n\n            if (metadata.discriminatorColumn && metadata.parentEntityMetadata) {\n                const column = this.expressionMap.aliasNamePrefixingEnabled\n                    ? this.expressionMap.mainAlias!.name +\n                      \".\" +\n                      metadata.discriminatorColumn.databaseName\n                    : metadata.discriminatorColumn.databaseName\n\n                const condition = `${this.replacePropertyNames(\n                    column,\n                )} IN (:...discriminatorColumnValues)`\n                conditionsArray.push(condition)\n            }\n        }\n\n        if (this.expressionMap.extraAppendedAndWhereCondition) {\n            const condition = this.replacePropertyNames(\n                this.expressionMap.extraAppendedAndWhereCondition,\n            )\n            conditionsArray.push(condition)\n        }\n\n        if (!conditionsArray.length) {\n            return \"\"\n        } else if (conditionsArray.length === 1) {\n            return ` WHERE ${conditionsArray[0]}`\n        } else {\n            return ` WHERE ( ${conditionsArray.join(\" ) AND ( \")} )`\n        }\n    }\n\n    /**\n     * Creates \"RETURNING\" / \"OUTPUT\" expression.\n     */\n    protected createReturningExpression(returningType: ReturningType): string {\n        const columns = this.getReturningColumns()\n        const driver = this.connection.driver\n\n        // also add columns we must auto-return to perform entity updation\n        // if user gave his own returning\n        if (\n            typeof this.expressionMap.returning !== \"string\" &&\n            this.expressionMap.extraReturningColumns.length > 0 &&\n            driver.isReturningSqlSupported(returningType)\n        ) {\n            columns.push(\n                ...this.expressionMap.extraReturningColumns.filter((column) => {\n                    return columns.indexOf(column) === -1\n                }),\n            )\n        }\n\n        if (columns.length) {\n            let columnsExpression = columns\n                .map((column) => {\n                    const name = this.escape(column.databaseName)\n                    if (driver.options.type === \"mssql\") {\n                        if (\n                            this.expressionMap.queryType === \"insert\" ||\n                            this.expressionMap.queryType === \"update\" ||\n                            this.expressionMap.queryType === \"soft-delete\" ||\n                            this.expressionMap.queryType === \"restore\"\n                        ) {\n                            return \"INSERTED.\" + name\n                        } else {\n                            return (\n                                this.escape(this.getMainTableName()) +\n                                \".\" +\n                                name\n                            )\n                        }\n                    } else {\n                        return name\n                    }\n                })\n                .join(\", \")\n\n            if (driver.options.type === \"oracle\") {\n                columnsExpression +=\n                    \" INTO \" +\n                    columns\n                        .map((column) => {\n                            return this.createParameter({\n                                type: (\n                                    driver as OracleDriver\n                                ).columnTypeToNativeParameter(column.type),\n                                dir: (driver as OracleDriver).oracle.BIND_OUT,\n                            })\n                        })\n                        .join(\", \")\n            }\n\n            if (driver.options.type === \"mssql\") {\n                if (\n                    this.expressionMap.queryType === \"insert\" ||\n                    this.expressionMap.queryType === \"update\"\n                ) {\n                    columnsExpression += \" INTO @OutputTable\"\n                }\n            }\n\n            return columnsExpression\n        } else if (typeof this.expressionMap.returning === \"string\") {\n            return this.expressionMap.returning\n        }\n\n        return \"\"\n    }\n\n    /**\n     * If returning / output cause is set to array of column names,\n     * then this method will return all column metadatas of those column names.\n     */\n    protected getReturningColumns(): ColumnMetadata[] {\n        const columns: ColumnMetadata[] = []\n        if (Array.isArray(this.expressionMap.returning)) {\n            ;(this.expressionMap.returning as string[]).forEach(\n                (columnName) => {\n                    if (this.expressionMap.mainAlias!.hasMetadata) {\n                        columns.push(\n                            ...this.expressionMap.mainAlias!.metadata.findColumnsWithPropertyPath(\n                                columnName,\n                            ),\n                        )\n                    }\n                },\n            )\n        }\n        return columns\n    }\n\n    protected createWhereClausesExpression(clauses: WhereClause[]): string {\n        return clauses\n            .map((clause, index) => {\n                const expression = this.createWhereConditionExpression(\n                    clause.condition,\n                )\n\n                switch (clause.type) {\n                    case \"and\":\n                        return (index > 0 ? \"AND \" : \"\") + expression\n                    case \"or\":\n                        return (index > 0 ? \"OR \" : \"\") + expression\n                }\n\n                return expression\n            })\n            .join(\" \")\n            .trim()\n    }\n\n    /**\n     * Computes given where argument - transforms to a where string all forms it can take.\n     */\n    protected createWhereConditionExpression(\n        condition: WhereClauseCondition,\n        alwaysWrap: boolean = false,\n    ): string {\n        if (typeof condition === \"string\") return condition\n\n        if (Array.isArray(condition)) {\n            if (condition.length === 0) {\n                return \"1=1\"\n            }\n\n            // In the future we should probably remove this entire condition\n            // but for now to prevent any breaking changes it exists.\n            if (condition.length === 1 && !alwaysWrap) {\n                return this.createWhereClausesExpression(condition)\n            }\n\n            return \"(\" + this.createWhereClausesExpression(condition) + \")\"\n        }\n\n        const { driver } = this.connection\n\n        switch (condition.operator) {\n            case \"lessThan\":\n                return `${condition.parameters[0]} < ${condition.parameters[1]}`\n            case \"lessThanOrEqual\":\n                return `${condition.parameters[0]} <= ${condition.parameters[1]}`\n            case \"arrayContains\":\n                return `${condition.parameters[0]} @> ${condition.parameters[1]}`\n            case \"arrayContainedBy\":\n                return `${condition.parameters[0]} <@ ${condition.parameters[1]}`\n            case \"arrayOverlap\":\n                return `${condition.parameters[0]} && ${condition.parameters[1]}`\n            case \"moreThan\":\n                return `${condition.parameters[0]} > ${condition.parameters[1]}`\n            case \"moreThanOrEqual\":\n                return `${condition.parameters[0]} >= ${condition.parameters[1]}`\n            case \"notEqual\":\n                return `${condition.parameters[0]} != ${condition.parameters[1]}`\n            case \"equal\":\n                return `${condition.parameters[0]} = ${condition.parameters[1]}`\n            case \"ilike\":\n                if (\n                    driver.options.type === \"postgres\" ||\n                    driver.options.type === \"cockroachdb\"\n                ) {\n                    return `${condition.parameters[0]} ILIKE ${condition.parameters[1]}`\n                }\n\n                return `UPPER(${condition.parameters[0]}) LIKE UPPER(${condition.parameters[1]})`\n            case \"like\":\n                return `${condition.parameters[0]} LIKE ${condition.parameters[1]}`\n            case \"between\":\n                return `${condition.parameters[0]} BETWEEN ${condition.parameters[1]} AND ${condition.parameters[2]}`\n            case \"in\":\n                if (condition.parameters.length <= 1) {\n                    return \"0=1\"\n                }\n                return `${condition.parameters[0]} IN (${condition.parameters\n                    .slice(1)\n                    .join(\", \")})`\n            case \"any\":\n                return `${condition.parameters[0]} = ANY(${condition.parameters[1]})`\n            case \"isNull\":\n                return `${condition.parameters[0]} IS NULL`\n\n            case \"not\":\n                return `NOT(${this.createWhereConditionExpression(\n                    condition.condition,\n                )})`\n            case \"brackets\":\n                return `${this.createWhereConditionExpression(\n                    condition.condition,\n                    true,\n                )}`\n        }\n\n        throw new TypeError(\n            `Unsupported FindOperator ${FindOperator.constructor.name}`,\n        )\n    }\n\n    protected createCteExpression(): string {\n        if (!this.hasCommonTableExpressions()) {\n            return \"\"\n        }\n        const databaseRequireRecusiveHint =\n            this.connection.driver.cteCapabilities.requiresRecursiveHint\n\n        const cteStrings = this.expressionMap.commonTableExpressions.map(\n            (cte) => {\n                const cteBodyExpression =\n                    typeof cte.queryBuilder === \"string\"\n                        ? cte.queryBuilder\n                        : cte.queryBuilder.getQuery()\n                if (typeof cte.queryBuilder !== \"string\") {\n                    if (cte.queryBuilder.hasCommonTableExpressions()) {\n                        throw new TypeORMError(\n                            `Nested CTEs aren't supported (CTE: ${cte.alias})`,\n                        )\n                    }\n                    if (\n                        !this.connection.driver.cteCapabilities.writable &&\n                        !InstanceChecker.isSelectQueryBuilder(cte.queryBuilder)\n                    ) {\n                        throw new TypeORMError(\n                            `Only select queries are supported in CTEs in ${this.connection.options.type} (CTE: ${cte.alias})`,\n                        )\n                    }\n                    this.setParameters(cte.queryBuilder.getParameters())\n                }\n                let cteHeader = this.escape(cte.alias)\n                if (cte.options.columnNames) {\n                    const escapedColumnNames = cte.options.columnNames.map(\n                        (column) => this.escape(column),\n                    )\n                    if (\n                        InstanceChecker.isSelectQueryBuilder(cte.queryBuilder)\n                    ) {\n                        if (\n                            cte.queryBuilder.expressionMap.selects.length &&\n                            cte.options.columnNames.length !==\n                                cte.queryBuilder.expressionMap.selects.length\n                        ) {\n                            throw new TypeORMError(\n                                `cte.options.columnNames length (${cte.options.columnNames.length}) doesn't match subquery select list length ${cte.queryBuilder.expressionMap.selects.length} (CTE: ${cte.alias})`,\n                            )\n                        }\n                    }\n                    cteHeader += `(${escapedColumnNames.join(\", \")})`\n                }\n                const recursiveClause =\n                    cte.options.recursive && databaseRequireRecusiveHint\n                        ? \"RECURSIVE\"\n                        : \"\"\n                const materializeClause =\n                    cte.options.materialized &&\n                    this.connection.driver.cteCapabilities.materializedHint\n                        ? \"MATERIALIZED\"\n                        : \"\"\n\n                return [\n                    recursiveClause,\n                    cteHeader,\n                    materializeClause,\n                    \"AS\",\n                    `(${cteBodyExpression})`,\n                ]\n                    .filter(Boolean)\n                    .join(\" \")\n            },\n        )\n\n        return \"WITH \" + cteStrings.join(\", \") + \" \"\n    }\n\n    /**\n     * Creates \"WHERE\" condition for an in-ids condition.\n     */\n    protected getWhereInIdsCondition(\n        ids: any | any[],\n    ): ObjectLiteral | Brackets {\n        const metadata = this.expressionMap.mainAlias!.metadata\n        const normalized = (Array.isArray(ids) ? ids : [ids]).map((id) =>\n            metadata.ensureEntityIdMap(id),\n        )\n\n        // using in(...ids) for single primary key entities\n        if (!metadata.hasMultiplePrimaryKeys) {\n            const primaryColumn = metadata.primaryColumns[0]\n\n            // getEntityValue will try to transform `In`, it is a bug\n            // todo: remove this transformer check after #2390 is fixed\n            // This also fails for embedded & relation, so until that is fixed skip it.\n            if (\n                !primaryColumn.transformer &&\n                !primaryColumn.relationMetadata &&\n                !primaryColumn.embeddedMetadata\n            ) {\n                return {\n                    [primaryColumn.propertyName]: In(\n                        normalized.map((id) =>\n                            primaryColumn.getEntityValue(id, false),\n                        ),\n                    ),\n                }\n            }\n        }\n\n        return new Brackets((qb) => {\n            for (const data of normalized) {\n                qb.orWhere(new Brackets((qb) => qb.where(data)))\n            }\n        })\n    }\n\n    private findColumnsForPropertyPath(\n        propertyPath: string,\n    ): [Alias, string[], ColumnMetadata[]] {\n        // Make a helper to iterate the entity & relations?\n        // Use that to set the correct alias?  Or the other way around?\n\n        // Start with the main alias with our property paths\n        let alias = this.expressionMap.mainAlias\n        const root: string[] = []\n        const propertyPathParts = propertyPath.split(\".\")\n\n        while (propertyPathParts.length > 1) {\n            const part = propertyPathParts[0]\n\n            if (!alias?.hasMetadata) {\n                // If there's no metadata, we're wasting our time\n                // and can't actually look any of this up.\n                break\n            }\n\n            if (alias.metadata.hasEmbeddedWithPropertyPath(part)) {\n                // If this is an embedded then we should combine the two as part of our lookup.\n                // Instead of just breaking, we keep going with this in case there's an embedded/relation\n                // inside an embedded.\n                propertyPathParts.unshift(\n                    `${propertyPathParts.shift()}.${propertyPathParts.shift()}`,\n                )\n                continue\n            }\n\n            if (alias.metadata.hasRelationWithPropertyPath(part)) {\n                // If this is a relation then we should find the aliases\n                // that match the relation & then continue further down\n                // the property path\n                const joinAttr = this.expressionMap.joinAttributes.find(\n                    (joinAttr) => joinAttr.relationPropertyPath === part,\n                )\n\n                if (!joinAttr?.alias) {\n                    const fullRelationPath =\n                        root.length > 0 ? `${root.join(\".\")}.${part}` : part\n                    throw new Error(\n                        `Cannot find alias for relation at ${fullRelationPath}`,\n                    )\n                }\n\n                alias = joinAttr.alias\n                root.push(...part.split(\".\"))\n                propertyPathParts.shift()\n                continue\n            }\n\n            break\n        }\n\n        if (!alias) {\n            throw new Error(`Cannot find alias for property ${propertyPath}`)\n        }\n\n        // Remaining parts are combined back and used to find the actual property path\n        const aliasPropertyPath = propertyPathParts.join(\".\")\n\n        const columns =\n            alias.metadata.findColumnsWithPropertyPath(aliasPropertyPath)\n\n        if (!columns.length) {\n            throw new EntityPropertyNotFoundError(propertyPath, alias.metadata)\n        }\n\n        return [alias, root, columns]\n    }\n\n    /**\n     * Creates a property paths for a given ObjectLiteral.\n     */\n    protected createPropertyPath(\n        metadata: EntityMetadata,\n        entity: ObjectLiteral,\n        prefix: string = \"\",\n    ) {\n        const paths: string[] = []\n\n        for (const key of Object.keys(entity)) {\n            const path = prefix ? `${prefix}.${key}` : key\n\n            // There's times where we don't actually want to traverse deeper.\n            // If the value is a `FindOperator`, or null, or not an object, then we don't, for example.\n            if (\n                entity[key] === null ||\n                typeof entity[key] !== \"object\" ||\n                InstanceChecker.isFindOperator(entity[key])\n            ) {\n                paths.push(path)\n                continue\n            }\n\n            if (metadata.hasEmbeddedWithPropertyPath(path)) {\n                const subPaths = this.createPropertyPath(\n                    metadata,\n                    entity[key],\n                    path,\n                )\n                paths.push(...subPaths)\n                continue\n            }\n\n            if (metadata.hasRelationWithPropertyPath(path)) {\n                const relation = metadata.findRelationWithPropertyPath(path)!\n\n                // There's also cases where we don't want to return back all of the properties.\n                // These handles the situation where someone passes the model & we don't need to make\n                // a HUGE `where` to uniquely look up the entity.\n\n                // In the case of a *-to-one, there's only ever one possible entity on the other side\n                // so if the join columns are all defined we can return just the relation itself\n                // because it will fetch only the join columns and do the lookup.\n                if (\n                    relation.relationType === \"one-to-one\" ||\n                    relation.relationType === \"many-to-one\"\n                ) {\n                    const joinColumns = relation.joinColumns\n                        .map((j) => j.referencedColumn)\n                        .filter((j): j is ColumnMetadata => !!j)\n\n                    const hasAllJoinColumns =\n                        joinColumns.length > 0 &&\n                        joinColumns.every((column) =>\n                            column.getEntityValue(entity[key], false),\n                        )\n\n                    if (hasAllJoinColumns) {\n                        paths.push(path)\n                        continue\n                    }\n                }\n\n                if (\n                    relation.relationType === \"one-to-many\" ||\n                    relation.relationType === \"many-to-many\"\n                ) {\n                    throw new Error(\n                        `Cannot query across ${relation.relationType} for property ${path}`,\n                    )\n                }\n\n                // For any other case, if the `entity[key]` contains all of the primary keys we can do a\n                // lookup via these.  We don't need to look up via any other values 'cause these are\n                // the unique primary keys.\n                // This handles the situation where someone passes the model & we don't need to make\n                // a HUGE where.\n                const primaryColumns =\n                    relation.inverseEntityMetadata.primaryColumns\n                const hasAllPrimaryKeys =\n                    primaryColumns.length > 0 &&\n                    primaryColumns.every((column) =>\n                        column.getEntityValue(entity[key], false),\n                    )\n\n                if (hasAllPrimaryKeys) {\n                    const subPaths = primaryColumns.map(\n                        (column) => `${path}.${column.propertyPath}`,\n                    )\n                    paths.push(...subPaths)\n                    continue\n                }\n\n                // If nothing else, just return every property that's being passed to us.\n                const subPaths = this.createPropertyPath(\n                    relation.inverseEntityMetadata,\n                    entity[key],\n                ).map((p) => `${path}.${p}`)\n                paths.push(...subPaths)\n                continue\n            }\n\n            paths.push(path)\n        }\n\n        return paths\n    }\n\n    protected *getPredicates(where: ObjectLiteral) {\n        if (this.expressionMap.mainAlias!.hasMetadata) {\n            const propertyPaths = this.createPropertyPath(\n                this.expressionMap.mainAlias!.metadata,\n                where,\n            )\n\n            for (const propertyPath of propertyPaths) {\n                const [alias, aliasPropertyPath, columns] =\n                    this.findColumnsForPropertyPath(propertyPath)\n\n                for (const column of columns) {\n                    let containedWhere = where\n\n                    for (const part of aliasPropertyPath) {\n                        if (!containedWhere || !(part in containedWhere)) {\n                            containedWhere = {}\n                            break\n                        }\n\n                        containedWhere = containedWhere[part]\n                    }\n\n                    // Use the correct alias & the property path from the column\n                    const aliasPath = this.expressionMap\n                        .aliasNamePrefixingEnabled\n                        ? `${alias.name}.${column.propertyPath}`\n                        : column.propertyPath\n\n                    const parameterValue = column.getEntityValue(\n                        containedWhere,\n                        true,\n                    )\n\n                    yield [aliasPath, parameterValue]\n                }\n            }\n        } else {\n            for (const key of Object.keys(where)) {\n                const parameterValue = where[key]\n                const aliasPath = this.expressionMap.aliasNamePrefixingEnabled\n                    ? `${this.alias}.${key}`\n                    : key\n\n                yield [aliasPath, parameterValue]\n            }\n        }\n    }\n\n    protected getWherePredicateCondition(\n        aliasPath: string,\n        parameterValue: any,\n    ): WhereClauseCondition {\n        if (InstanceChecker.isFindOperator(parameterValue)) {\n            let parameters: any[] = []\n            if (parameterValue.useParameter) {\n                if (parameterValue.objectLiteralParameters) {\n                    this.setParameters(parameterValue.objectLiteralParameters)\n                } else if (parameterValue.multipleParameters) {\n                    for (const v of parameterValue.value) {\n                        parameters.push(this.createParameter(v))\n                    }\n                } else {\n                    parameters.push(this.createParameter(parameterValue.value))\n                }\n            }\n\n            if (parameterValue.type === \"raw\") {\n                if (parameterValue.getSql) {\n                    return parameterValue.getSql(aliasPath)\n                } else {\n                    return {\n                        operator: \"equal\",\n                        parameters: [aliasPath, parameterValue.value],\n                    }\n                }\n            } else if (parameterValue.type === \"not\") {\n                if (parameterValue.child) {\n                    return {\n                        operator: parameterValue.type,\n                        condition: this.getWherePredicateCondition(\n                            aliasPath,\n                            parameterValue.child,\n                        ),\n                    }\n                } else {\n                    return {\n                        operator: \"notEqual\",\n                        parameters: [aliasPath, ...parameters],\n                    }\n                }\n            } else {\n                return {\n                    operator: parameterValue.type,\n                    parameters: [aliasPath, ...parameters],\n                }\n            }\n            // } else if (parameterValue === null) {\n            //     return {\n            //         operator: \"isNull\",\n            //         parameters: [\n            //             aliasPath,\n            //         ]\n            //     };\n        } else {\n            return {\n                operator: \"equal\",\n                parameters: [aliasPath, this.createParameter(parameterValue)],\n            }\n        }\n    }\n\n    protected getWhereCondition(\n        where:\n            | string\n            | ((qb: this) => string)\n            | Brackets\n            | NotBrackets\n            | ObjectLiteral\n            | ObjectLiteral[],\n    ): WhereClauseCondition {\n        if (typeof where === \"string\") {\n            return where\n        }\n\n        if (InstanceChecker.isBrackets(where)) {\n            const whereQueryBuilder = this.createQueryBuilder()\n\n            whereQueryBuilder.parentQueryBuilder = this\n\n            whereQueryBuilder.expressionMap.mainAlias =\n                this.expressionMap.mainAlias\n            whereQueryBuilder.expressionMap.aliasNamePrefixingEnabled =\n                this.expressionMap.aliasNamePrefixingEnabled\n            whereQueryBuilder.expressionMap.parameters =\n                this.expressionMap.parameters\n            whereQueryBuilder.expressionMap.nativeParameters =\n                this.expressionMap.nativeParameters\n\n            whereQueryBuilder.expressionMap.wheres = []\n\n            where.whereFactory(whereQueryBuilder as any)\n\n            return {\n                operator: InstanceChecker.isNotBrackets(where)\n                    ? \"not\"\n                    : \"brackets\",\n                condition: whereQueryBuilder.expressionMap.wheres,\n            }\n        }\n\n        if (typeof where === \"function\") {\n            return where(this)\n        }\n\n        const wheres: ObjectLiteral[] = Array.isArray(where) ? where : [where]\n        const clauses: WhereClause[] = []\n\n        for (const where of wheres) {\n            const conditions: WhereClauseCondition = []\n\n            // Filter the conditions and set up the parameter values\n            for (const [aliasPath, parameterValue] of this.getPredicates(\n                where,\n            )) {\n                conditions.push({\n                    type: \"and\",\n                    condition: this.getWherePredicateCondition(\n                        aliasPath,\n                        parameterValue,\n                    ),\n                })\n            }\n\n            clauses.push({ type: \"or\", condition: conditions })\n        }\n\n        if (clauses.length === 1) {\n            return clauses[0].condition\n        }\n\n        return clauses\n    }\n\n    /**\n     * Creates a query builder used to execute sql queries inside this query builder.\n     */\n    protected obtainQueryRunner() {\n        return this.queryRunner || this.connection.createQueryRunner()\n    }\n\n    protected hasCommonTableExpressions(): boolean {\n        return this.expressionMap.commonTableExpressions.length > 0\n    }\n}\n"]},"metadata":{},"sourceType":"module"}