{"ast":null,"code":"import { DefaultNamingStrategy } from \"../naming-strategy/DefaultNamingStrategy\";\nimport { CannotConnectAlreadyConnectedError, CannotExecuteNotConnectedError, EntityMetadataNotFoundError, QueryRunnerProviderAlreadyReleasedError } from \"../error\";\nimport { MigrationExecutor } from \"../migration/MigrationExecutor\";\nimport { EntityMetadataValidator } from \"../metadata-builder/EntityMetadataValidator\";\nimport { EntityManagerFactory } from \"../entity-manager/EntityManagerFactory\";\nimport { DriverFactory } from \"../driver/DriverFactory\";\nimport { ConnectionMetadataBuilder } from \"../connection/ConnectionMetadataBuilder\";\nimport { SelectQueryBuilder } from \"../query-builder/SelectQueryBuilder\";\nimport { LoggerFactory } from \"../logger/LoggerFactory\";\nimport { QueryResultCacheFactory } from \"../cache/QueryResultCacheFactory\";\nimport { RelationLoader } from \"../query-builder/RelationLoader\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\nimport { TypeORMError } from \"../error\";\nimport { RelationIdLoader } from \"../query-builder/RelationIdLoader\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\nimport { InstanceChecker } from \"../util/InstanceChecker\";\n/**\n * DataSource is a pre-defined connection configuration to a specific database.\n * You can have multiple data sources connected (with multiple connections in it),\n * connected to multiple databases in your application.\n *\n * Before, it was called `Connection`, but now `Connection` is deprecated\n * because `Connection` isn't the best name for what it's actually is.\n */\n\nexport class DataSource {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(options) {\n    this[\"@instanceof\"] = Symbol.for(\"DataSource\");\n    /**\n     * Migration instances that are registered for this connection.\n     */\n\n    this.migrations = [];\n    /**\n     * Entity subscriber instances that are registered for this connection.\n     */\n\n    this.subscribers = [];\n    /**\n     * All entity metadatas that are registered for this connection.\n     */\n\n    this.entityMetadatas = [];\n    this.name = options.name || \"default\";\n    this.options = options;\n    this.logger = new LoggerFactory().create(this.options.logger, this.options.logging);\n    this.driver = new DriverFactory().create(this);\n    this.manager = this.createEntityManager();\n    this.namingStrategy = options.namingStrategy || new DefaultNamingStrategy();\n    this.metadataTableName = options.metadataTableName || \"typeorm_metadata\";\n    this.queryResultCache = options.cache ? new QueryResultCacheFactory(this).create() : undefined;\n    this.relationLoader = new RelationLoader(this);\n    this.relationIdLoader = new RelationIdLoader(this);\n    this.isInitialized = false;\n  } // -------------------------------------------------------------------------\n  // Public Accessors\n  // -------------------------------------------------------------------------\n\n  /**\n   Indicates if DataSource is initialized or not.\n   *\n   * @deprecated use .isInitialized instead\n   */\n\n\n  get isConnected() {\n    return this.isInitialized;\n  }\n  /**\n   * Gets the mongodb entity manager that allows to perform mongodb-specific repository operations\n   * with any entity in this connection.\n   *\n   * Available only in mongodb connections.\n   */\n\n\n  get mongoManager() {\n    if (!InstanceChecker.isMongoEntityManager(this.manager)) throw new TypeORMError(`MongoEntityManager is only available for MongoDB databases.`);\n    return this.manager;\n  }\n  /**\n   * Gets a sql.js specific Entity Manager that allows to perform special load and save operations\n   *\n   * Available only in connection with the sqljs driver.\n   */\n\n\n  get sqljsManager() {\n    if (!InstanceChecker.isSqljsEntityManager(this.manager)) throw new TypeORMError(`SqljsEntityManager is only available for Sqljs databases.`);\n    return this.manager;\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Updates current connection options with provided options.\n   */\n\n\n  setOptions(options) {\n    Object.assign(this.options, options);\n\n    if (options.logger || options.logging) {\n      this.logger = new LoggerFactory().create(options.logger || this.options.logger, options.logging || this.options.logging);\n    }\n\n    if (options.namingStrategy) {\n      this.namingStrategy = options.namingStrategy;\n    }\n\n    if (options.cache) {\n      this.queryResultCache = new QueryResultCacheFactory(this).create();\n    }\n\n    return this;\n  }\n  /**\n   * Performs connection to the database.\n   * This method should be called once on application bootstrap.\n   * This method not necessarily creates database connection (depend on database type),\n   * but it also can setup a connection pool with database to use.\n   */\n\n\n  async initialize() {\n    if (this.isInitialized) throw new CannotConnectAlreadyConnectedError(this.name); // connect to the database via its driver\n\n    await this.driver.connect(); // connect to the cache-specific database if cache is enabled\n\n    if (this.queryResultCache) await this.queryResultCache.connect(); // set connected status for the current connection\n\n    ObjectUtils.assign(this, {\n      isInitialized: true\n    });\n\n    try {\n      // build all metadatas registered in the current connection\n      await this.buildMetadatas();\n      await this.driver.afterConnect(); // if option is set - drop schema once connection is done\n\n      if (this.options.dropSchema) await this.dropDatabase(); // if option is set - automatically synchronize a schema\n\n      if (this.options.migrationsRun) await this.runMigrations({\n        transaction: this.options.migrationsTransactionMode\n      }); // if option is set - automatically synchronize a schema\n\n      if (this.options.synchronize) await this.synchronize();\n    } catch (error) {\n      // if for some reason build metadata fail (for example validation error during entity metadata check)\n      // connection needs to be closed\n      await this.close();\n      throw error;\n    }\n\n    return this;\n  }\n  /**\n   * Performs connection to the database.\n   * This method should be called once on application bootstrap.\n   * This method not necessarily creates database connection (depend on database type),\n   * but it also can setup a connection pool with database to use.\n   *\n   * @deprecated use .initialize method instead\n   */\n\n\n  async connect() {\n    return this.initialize();\n  }\n  /**\n   * Closes connection with the database.\n   * Once connection is closed, you cannot use repositories or perform any operations except opening connection again.\n   */\n\n\n  async destroy() {\n    if (!this.isInitialized) throw new CannotExecuteNotConnectedError(this.name);\n    await this.driver.disconnect(); // disconnect from the cache-specific database if cache was enabled\n\n    if (this.queryResultCache) await this.queryResultCache.disconnect();\n    ObjectUtils.assign(this, {\n      isInitialized: false\n    });\n  }\n  /**\n   * Closes connection with the database.\n   * Once connection is closed, you cannot use repositories or perform any operations except opening connection again.\n   *\n   * @deprecated use .destroy method instead\n   */\n\n\n  async close() {\n    return this.destroy();\n  }\n  /**\n   * Creates database schema for all entities registered in this connection.\n   * Can be used only after connection to the database is established.\n   *\n   * @param dropBeforeSync If set to true then it drops the database with all its tables and data\n   */\n\n\n  async synchronize() {\n    let dropBeforeSync = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (!this.isInitialized) throw new CannotExecuteNotConnectedError(this.name);\n    if (dropBeforeSync) await this.dropDatabase();\n    const schemaBuilder = this.driver.createSchemaBuilder();\n    await schemaBuilder.build();\n  }\n  /**\n   * Drops the database and all its data.\n   * Be careful with this method on production since this method will erase all your database tables and their data.\n   * Can be used only after connection to the database is established.\n   */\n  // TODO rename\n\n\n  async dropDatabase() {\n    const queryRunner = this.createQueryRunner();\n\n    try {\n      if (this.driver.options.type === \"mssql\" || DriverUtils.isMySQLFamily(this.driver) || this.driver.options.type === \"aurora-mysql\" || DriverUtils.isSQLiteFamily(this.driver)) {\n        const databases = [];\n        this.entityMetadatas.forEach(metadata => {\n          if (metadata.database && databases.indexOf(metadata.database) === -1) databases.push(metadata.database);\n        });\n\n        if (databases.length === 0 && this.driver.database) {\n          databases.push(this.driver.database);\n        }\n\n        if (databases.length === 0) {\n          await queryRunner.clearDatabase();\n        } else {\n          for (const database of databases) {\n            await queryRunner.clearDatabase(database);\n          }\n        }\n      } else {\n        await queryRunner.clearDatabase();\n      }\n    } finally {\n      await queryRunner.release();\n    }\n  }\n  /**\n   * Runs all pending migrations.\n   * Can be used only after connection to the database is established.\n   */\n\n\n  async runMigrations(options) {\n    if (!this.isInitialized) throw new CannotExecuteNotConnectedError(this.name);\n    const migrationExecutor = new MigrationExecutor(this);\n    migrationExecutor.transaction = options && options.transaction || \"all\";\n    migrationExecutor.fake = options && options.fake || false;\n    const successMigrations = await migrationExecutor.executePendingMigrations();\n    return successMigrations;\n  }\n  /**\n   * Reverts last executed migration.\n   * Can be used only after connection to the database is established.\n   */\n\n\n  async undoLastMigration(options) {\n    if (!this.isInitialized) throw new CannotExecuteNotConnectedError(this.name);\n    const migrationExecutor = new MigrationExecutor(this);\n    migrationExecutor.transaction = options && options.transaction || \"all\";\n    migrationExecutor.fake = options && options.fake || false;\n    await migrationExecutor.undoLastMigration();\n  }\n  /**\n   * Lists all migrations and whether they have been run.\n   * Returns true if there are pending migrations\n   */\n\n\n  async showMigrations() {\n    if (!this.isInitialized) {\n      throw new CannotExecuteNotConnectedError(this.name);\n    }\n\n    const migrationExecutor = new MigrationExecutor(this);\n    return await migrationExecutor.showMigrations();\n  }\n  /**\n   * Checks if entity metadata exist for the given entity class, target name or table name.\n   */\n\n\n  hasMetadata(target) {\n    return !!this.findMetadata(target);\n  }\n  /**\n   * Gets entity metadata for the given entity class or schema name.\n   */\n\n\n  getMetadata(target) {\n    const metadata = this.findMetadata(target);\n    if (!metadata) throw new EntityMetadataNotFoundError(target);\n    return metadata;\n  }\n  /**\n   * Gets repository for the given entity.\n   */\n\n\n  getRepository(target) {\n    return this.manager.getRepository(target);\n  }\n  /**\n   * Gets tree repository for the given entity class or name.\n   * Only tree-type entities can have a TreeRepository, like ones decorated with @Tree decorator.\n   */\n\n\n  getTreeRepository(target) {\n    return this.manager.getTreeRepository(target);\n  }\n  /**\n   * Gets mongodb-specific repository for the given entity class or name.\n   * Works only if connection is mongodb-specific.\n   */\n\n\n  getMongoRepository(target) {\n    if (!(this.driver.options.type === \"mongodb\")) throw new TypeORMError(`You can use getMongoRepository only for MongoDB connections.`);\n    return this.manager.getRepository(target);\n  }\n  /**\n   * Gets custom entity repository marked with @EntityRepository decorator.\n   *\n   * @deprecated use Repository.extend function to create a custom repository\n   */\n\n\n  getCustomRepository(customRepository) {\n    return this.manager.getCustomRepository(customRepository);\n  }\n\n  async transaction(isolationOrRunInTransaction, runInTransactionParam) {\n    return this.manager.transaction(isolationOrRunInTransaction, runInTransactionParam);\n  }\n  /**\n   * Executes raw SQL query and returns raw database results.\n   */\n\n\n  async query(query, parameters, queryRunner) {\n    if (InstanceChecker.isMongoEntityManager(this.manager)) throw new TypeORMError(`Queries aren't supported by MongoDB.`);\n    if (queryRunner && queryRunner.isReleased) throw new QueryRunnerProviderAlreadyReleasedError();\n    const usedQueryRunner = queryRunner || this.createQueryRunner();\n\n    try {\n      return await usedQueryRunner.query(query, parameters); // await is needed here because we are using finally\n    } finally {\n      if (!queryRunner) await usedQueryRunner.release();\n    }\n  }\n  /**\n   * Creates a new query builder that can be used to build a SQL query.\n   */\n\n\n  createQueryBuilder(entityOrRunner, alias, queryRunner) {\n    if (InstanceChecker.isMongoEntityManager(this.manager)) throw new TypeORMError(`Query Builder is not supported by MongoDB.`);\n\n    if (alias) {\n      alias = DriverUtils.buildAlias(this.driver, alias);\n      const metadata = this.getMetadata(entityOrRunner);\n      return new SelectQueryBuilder(this, queryRunner).select(alias).from(metadata.target, alias);\n    } else {\n      return new SelectQueryBuilder(this, entityOrRunner);\n    }\n  }\n  /**\n   * Creates a query runner used for perform queries on a single database connection.\n   * Using query runners you can control your queries to execute using single database connection and\n   * manually control your database transaction.\n   *\n   * Mode is used in replication mode and indicates whatever you want to connect\n   * to master database or any of slave databases.\n   * If you perform writes you must use master database,\n   * if you perform reads you can use slave databases.\n   */\n\n\n  createQueryRunner() {\n    let mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"master\";\n    const queryRunner = this.driver.createQueryRunner(mode);\n    const manager = this.createEntityManager(queryRunner);\n    Object.assign(queryRunner, {\n      manager: manager\n    });\n    return queryRunner;\n  }\n  /**\n   * Gets entity metadata of the junction table (many-to-many table).\n   */\n\n\n  getManyToManyMetadata(entityTarget, relationPropertyPath) {\n    const relationMetadata = this.getMetadata(entityTarget).findRelationWithPropertyPath(relationPropertyPath);\n    if (!relationMetadata) throw new TypeORMError(`Relation \"${relationPropertyPath}\" was not found in ${entityTarget} entity.`);\n    if (!relationMetadata.isManyToMany) throw new TypeORMError(`Relation \"${entityTarget}#${relationPropertyPath}\" does not have a many-to-many relationship.` + `You can use this method only on many-to-many relations.`);\n    return relationMetadata.junctionEntityMetadata;\n  }\n  /**\n   * Creates an Entity Manager for the current connection with the help of the EntityManagerFactory.\n   */\n\n\n  createEntityManager(queryRunner) {\n    return new EntityManagerFactory().create(this, queryRunner);\n  } // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Finds exist entity metadata by the given entity class, target name or table name.\n   */\n\n\n  findMetadata(target) {\n    return this.entityMetadatas.find(metadata => {\n      if (metadata.target === target) return true;\n\n      if (InstanceChecker.isEntitySchema(target)) {\n        return metadata.name === target.options.name;\n      }\n\n      if (typeof target === \"string\") {\n        if (target.indexOf(\".\") !== -1) {\n          return metadata.tablePath === target;\n        } else {\n          return metadata.name === target || metadata.tableName === target;\n        }\n      }\n\n      if (ObjectUtils.isObject(target) && typeof target.name === \"string\") {\n        if (target.name.indexOf(\".\") !== -1) {\n          return metadata.tablePath === target.name;\n        } else {\n          return metadata.name === target.name || metadata.tableName === target.name;\n        }\n      }\n\n      return false;\n    });\n  }\n  /**\n   * Builds metadatas for all registered classes inside this connection.\n   */\n\n\n  async buildMetadatas() {\n    const connectionMetadataBuilder = new ConnectionMetadataBuilder(this);\n    const entityMetadataValidator = new EntityMetadataValidator(); // create subscribers instances if they are not disallowed from high-level (for example they can disallowed from migrations run process)\n\n    const flattenedSubscribers = ObjectUtils.mixedListToArray(this.options.subscribers || []);\n    const subscribers = await connectionMetadataBuilder.buildSubscribers(flattenedSubscribers);\n    ObjectUtils.assign(this, {\n      subscribers: subscribers\n    }); // build entity metadatas\n\n    const flattenedEntities = ObjectUtils.mixedListToArray(this.options.entities || []);\n    const entityMetadatas = await connectionMetadataBuilder.buildEntityMetadatas(flattenedEntities);\n    ObjectUtils.assign(this, {\n      entityMetadatas: entityMetadatas\n    }); // create migration instances\n\n    const flattenedMigrations = ObjectUtils.mixedListToArray(this.options.migrations || []);\n    const migrations = await connectionMetadataBuilder.buildMigrations(flattenedMigrations);\n    ObjectUtils.assign(this, {\n      migrations: migrations\n    }); // validate all created entity metadatas to make sure user created entities are valid and correct\n\n    entityMetadataValidator.validateMany(this.entityMetadatas.filter(metadata => metadata.tableType !== \"view\"), this.driver); // set current data source to the entities\n\n    for (let entityMetadata of entityMetadatas) {\n      if (InstanceChecker.isBaseEntityConstructor(entityMetadata.target)) {\n        entityMetadata.target.useDataSource(this);\n      }\n    }\n  }\n\n}","map":{"version":3,"mappings":"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","names":["DefaultNamingStrategy","CannotConnectAlreadyConnectedError","CannotExecuteNotConnectedError","EntityMetadataNotFoundError","QueryRunnerProviderAlreadyReleasedError","MigrationExecutor","EntityMetadataValidator","EntityManagerFactory","DriverFactory","ConnectionMetadataBuilder","SelectQueryBuilder","LoggerFactory","QueryResultCacheFactory","RelationLoader","ObjectUtils","TypeORMError","RelationIdLoader","DriverUtils","InstanceChecker","DataSource","constructor","options","Symbol","for","name","logger","create","logging","driver","manager","createEntityManager","namingStrategy","metadataTableName","queryResultCache","cache","undefined","relationLoader","relationIdLoader","isInitialized","isConnected","mongoManager","isMongoEntityManager","sqljsManager","isSqljsEntityManager","setOptions","Object","assign","initialize","connect","buildMetadatas","afterConnect","dropSchema","dropDatabase","migrationsRun","runMigrations","transaction","migrationsTransactionMode","synchronize","error","close","destroy","disconnect","dropBeforeSync","schemaBuilder","createSchemaBuilder","build","queryRunner","createQueryRunner","type","isMySQLFamily","isSQLiteFamily","databases","entityMetadatas","forEach","metadata","database","indexOf","push","length","clearDatabase","release","migrationExecutor","fake","successMigrations","executePendingMigrations","undoLastMigration","showMigrations","hasMetadata","target","findMetadata","getMetadata","getRepository","getTreeRepository","getMongoRepository","getCustomRepository","customRepository","isolationOrRunInTransaction","runInTransactionParam","query","parameters","isReleased","usedQueryRunner","createQueryBuilder","entityOrRunner","alias","buildAlias","select","from","mode","getManyToManyMetadata","entityTarget","relationPropertyPath","relationMetadata","findRelationWithPropertyPath","isManyToMany","junctionEntityMetadata","find","isEntitySchema","tablePath","tableName","isObject","connectionMetadataBuilder","entityMetadataValidator","flattenedSubscribers","mixedListToArray","subscribers","buildSubscribers","flattenedEntities","entities","buildEntityMetadatas","flattenedMigrations","migrations","buildMigrations","validateMany","filter","tableType","entityMetadata","isBaseEntityConstructor","useDataSource"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\data-source\\DataSource.ts"],"sourcesContent":["import { Driver } from \"../driver/Driver\"\nimport { Repository } from \"../repository/Repository\"\nimport { EntitySubscriberInterface } from \"../subscriber/EntitySubscriberInterface\"\nimport { EntityTarget } from \"../common/EntityTarget\"\nimport { ObjectType } from \"../common/ObjectType\"\nimport { EntityManager } from \"../entity-manager/EntityManager\"\nimport { DefaultNamingStrategy } from \"../naming-strategy/DefaultNamingStrategy\"\nimport {\n    CannotConnectAlreadyConnectedError,\n    CannotExecuteNotConnectedError,\n    EntityMetadataNotFoundError,\n    QueryRunnerProviderAlreadyReleasedError,\n} from \"../error\"\nimport { TreeRepository } from \"../repository/TreeRepository\"\nimport { NamingStrategyInterface } from \"../naming-strategy/NamingStrategyInterface\"\nimport { EntityMetadata } from \"../metadata/EntityMetadata\"\nimport { Logger } from \"../logger/Logger\"\nimport { MigrationInterface } from \"../migration/MigrationInterface\"\nimport { MigrationExecutor } from \"../migration/MigrationExecutor\"\nimport { Migration } from \"../migration/Migration\"\nimport { MongoRepository } from \"../repository/MongoRepository\"\nimport { MongoEntityManager } from \"../entity-manager/MongoEntityManager\"\nimport { EntityMetadataValidator } from \"../metadata-builder/EntityMetadataValidator\"\nimport { DataSourceOptions } from \"./DataSourceOptions\"\nimport { EntityManagerFactory } from \"../entity-manager/EntityManagerFactory\"\nimport { DriverFactory } from \"../driver/DriverFactory\"\nimport { ConnectionMetadataBuilder } from \"../connection/ConnectionMetadataBuilder\"\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\nimport { SelectQueryBuilder } from \"../query-builder/SelectQueryBuilder\"\nimport { LoggerFactory } from \"../logger/LoggerFactory\"\nimport { QueryResultCacheFactory } from \"../cache/QueryResultCacheFactory\"\nimport { QueryResultCache } from \"../cache/QueryResultCache\"\nimport { SqljsEntityManager } from \"../entity-manager/SqljsEntityManager\"\nimport { RelationLoader } from \"../query-builder/RelationLoader\"\nimport { ObjectUtils } from \"../util/ObjectUtils\"\nimport { IsolationLevel } from \"../driver/types/IsolationLevel\"\nimport { ReplicationMode } from \"../driver/types/ReplicationMode\"\nimport { TypeORMError } from \"../error\"\nimport { RelationIdLoader } from \"../query-builder/RelationIdLoader\"\nimport { DriverUtils } from \"../driver/DriverUtils\"\nimport { InstanceChecker } from \"../util/InstanceChecker\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\n\n/**\n * DataSource is a pre-defined connection configuration to a specific database.\n * You can have multiple data sources connected (with multiple connections in it),\n * connected to multiple databases in your application.\n *\n * Before, it was called `Connection`, but now `Connection` is deprecated\n * because `Connection` isn't the best name for what it's actually is.\n */\nexport class DataSource {\n    readonly \"@instanceof\" = Symbol.for(\"DataSource\")\n\n    // -------------------------------------------------------------------------\n    // Public Readonly Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Connection name.\n     *\n     * @deprecated we don't need names anymore since we are going to drop all related methods relying on this property.\n     */\n    readonly name: string\n\n    /**\n     * Connection options.\n     */\n    readonly options: DataSourceOptions\n\n    /**\n     * Indicates if DataSource is initialized or not.\n     */\n    readonly isInitialized: boolean\n\n    /**\n     * Database driver used by this connection.\n     */\n    driver: Driver\n\n    /**\n     * EntityManager of this connection.\n     */\n    readonly manager: EntityManager\n\n    /**\n     * Naming strategy used in the connection.\n     */\n    namingStrategy: NamingStrategyInterface\n\n    /**\n     * Name for the metadata table\n     */\n    readonly metadataTableName: string\n\n    /**\n     * Logger used to log orm events.\n     */\n    logger: Logger\n\n    /**\n     * Migration instances that are registered for this connection.\n     */\n    readonly migrations: MigrationInterface[] = []\n\n    /**\n     * Entity subscriber instances that are registered for this connection.\n     */\n    readonly subscribers: EntitySubscriberInterface<any>[] = []\n\n    /**\n     * All entity metadatas that are registered for this connection.\n     */\n    readonly entityMetadatas: EntityMetadata[] = []\n\n    /**\n     * Used to work with query result cache.\n     */\n    queryResultCache?: QueryResultCache\n\n    /**\n     * Used to load relations and work with lazy relations.\n     */\n    readonly relationLoader: RelationLoader\n\n    readonly relationIdLoader: RelationIdLoader\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(options: DataSourceOptions) {\n        this.name = options.name || \"default\"\n        this.options = options\n        this.logger = new LoggerFactory().create(\n            this.options.logger,\n            this.options.logging,\n        )\n        this.driver = new DriverFactory().create(this)\n        this.manager = this.createEntityManager()\n        this.namingStrategy =\n            options.namingStrategy || new DefaultNamingStrategy()\n        this.metadataTableName = options.metadataTableName || \"typeorm_metadata\"\n        this.queryResultCache = options.cache\n            ? new QueryResultCacheFactory(this).create()\n            : undefined\n        this.relationLoader = new RelationLoader(this)\n        this.relationIdLoader = new RelationIdLoader(this)\n        this.isInitialized = false\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Accessors\n    // -------------------------------------------------------------------------\n\n    /**\n     Indicates if DataSource is initialized or not.\n     *\n     * @deprecated use .isInitialized instead\n     */\n    get isConnected() {\n        return this.isInitialized\n    }\n\n    /**\n     * Gets the mongodb entity manager that allows to perform mongodb-specific repository operations\n     * with any entity in this connection.\n     *\n     * Available only in mongodb connections.\n     */\n    get mongoManager(): MongoEntityManager {\n        if (!InstanceChecker.isMongoEntityManager(this.manager))\n            throw new TypeORMError(\n                `MongoEntityManager is only available for MongoDB databases.`,\n            )\n\n        return this.manager as MongoEntityManager\n    }\n\n    /**\n     * Gets a sql.js specific Entity Manager that allows to perform special load and save operations\n     *\n     * Available only in connection with the sqljs driver.\n     */\n    get sqljsManager(): SqljsEntityManager {\n        if (!InstanceChecker.isSqljsEntityManager(this.manager))\n            throw new TypeORMError(\n                `SqljsEntityManager is only available for Sqljs databases.`,\n            )\n\n        return this.manager\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Updates current connection options with provided options.\n     */\n    setOptions(options: Partial<DataSourceOptions>): this {\n        Object.assign(this.options, options)\n\n        if (options.logger || options.logging) {\n            this.logger = new LoggerFactory().create(\n                options.logger || this.options.logger,\n                options.logging || this.options.logging,\n            )\n        }\n\n        if (options.namingStrategy) {\n            this.namingStrategy = options.namingStrategy\n        }\n\n        if (options.cache) {\n            this.queryResultCache = new QueryResultCacheFactory(this).create()\n        }\n\n        return this\n    }\n\n    /**\n     * Performs connection to the database.\n     * This method should be called once on application bootstrap.\n     * This method not necessarily creates database connection (depend on database type),\n     * but it also can setup a connection pool with database to use.\n     */\n    async initialize(): Promise<this> {\n        if (this.isInitialized)\n            throw new CannotConnectAlreadyConnectedError(this.name)\n\n        // connect to the database via its driver\n        await this.driver.connect()\n\n        // connect to the cache-specific database if cache is enabled\n        if (this.queryResultCache) await this.queryResultCache.connect()\n\n        // set connected status for the current connection\n        ObjectUtils.assign(this, { isInitialized: true })\n\n        try {\n            // build all metadatas registered in the current connection\n            await this.buildMetadatas()\n\n            await this.driver.afterConnect()\n\n            // if option is set - drop schema once connection is done\n            if (this.options.dropSchema) await this.dropDatabase()\n\n            // if option is set - automatically synchronize a schema\n            if (this.options.migrationsRun)\n                await this.runMigrations({\n                    transaction: this.options.migrationsTransactionMode,\n                })\n\n            // if option is set - automatically synchronize a schema\n            if (this.options.synchronize) await this.synchronize()\n        } catch (error) {\n            // if for some reason build metadata fail (for example validation error during entity metadata check)\n            // connection needs to be closed\n            await this.close()\n            throw error\n        }\n\n        return this\n    }\n\n    /**\n     * Performs connection to the database.\n     * This method should be called once on application bootstrap.\n     * This method not necessarily creates database connection (depend on database type),\n     * but it also can setup a connection pool with database to use.\n     *\n     * @deprecated use .initialize method instead\n     */\n    async connect(): Promise<this> {\n        return this.initialize()\n    }\n\n    /**\n     * Closes connection with the database.\n     * Once connection is closed, you cannot use repositories or perform any operations except opening connection again.\n     */\n    async destroy(): Promise<void> {\n        if (!this.isInitialized)\n            throw new CannotExecuteNotConnectedError(this.name)\n\n        await this.driver.disconnect()\n\n        // disconnect from the cache-specific database if cache was enabled\n        if (this.queryResultCache) await this.queryResultCache.disconnect()\n\n        ObjectUtils.assign(this, { isInitialized: false })\n    }\n\n    /**\n     * Closes connection with the database.\n     * Once connection is closed, you cannot use repositories or perform any operations except opening connection again.\n     *\n     * @deprecated use .destroy method instead\n     */\n    async close(): Promise<void> {\n        return this.destroy()\n    }\n\n    /**\n     * Creates database schema for all entities registered in this connection.\n     * Can be used only after connection to the database is established.\n     *\n     * @param dropBeforeSync If set to true then it drops the database with all its tables and data\n     */\n    async synchronize(dropBeforeSync: boolean = false): Promise<void> {\n        if (!this.isInitialized)\n            throw new CannotExecuteNotConnectedError(this.name)\n\n        if (dropBeforeSync) await this.dropDatabase()\n\n        const schemaBuilder = this.driver.createSchemaBuilder()\n        await schemaBuilder.build()\n    }\n\n    /**\n     * Drops the database and all its data.\n     * Be careful with this method on production since this method will erase all your database tables and their data.\n     * Can be used only after connection to the database is established.\n     */\n    // TODO rename\n    async dropDatabase(): Promise<void> {\n        const queryRunner = this.createQueryRunner()\n        try {\n            if (\n                this.driver.options.type === \"mssql\" ||\n                DriverUtils.isMySQLFamily(this.driver) ||\n                this.driver.options.type === \"aurora-mysql\" ||\n                DriverUtils.isSQLiteFamily(this.driver)\n            ) {\n                const databases: string[] = []\n                this.entityMetadatas.forEach((metadata) => {\n                    if (\n                        metadata.database &&\n                        databases.indexOf(metadata.database) === -1\n                    )\n                        databases.push(metadata.database)\n                })\n                if (databases.length === 0 && this.driver.database) {\n                    databases.push(this.driver.database)\n                }\n\n                if (databases.length === 0) {\n                    await queryRunner.clearDatabase()\n                } else {\n                    for (const database of databases) {\n                        await queryRunner.clearDatabase(database)\n                    }\n                }\n            } else {\n                await queryRunner.clearDatabase()\n            }\n        } finally {\n            await queryRunner.release()\n        }\n    }\n\n    /**\n     * Runs all pending migrations.\n     * Can be used only after connection to the database is established.\n     */\n    async runMigrations(options?: {\n        transaction?: \"all\" | \"none\" | \"each\"\n        fake?: boolean\n    }): Promise<Migration[]> {\n        if (!this.isInitialized)\n            throw new CannotExecuteNotConnectedError(this.name)\n\n        const migrationExecutor = new MigrationExecutor(this)\n        migrationExecutor.transaction =\n            (options && options.transaction) || \"all\"\n        migrationExecutor.fake = (options && options.fake) || false\n\n        const successMigrations =\n            await migrationExecutor.executePendingMigrations()\n        return successMigrations\n    }\n\n    /**\n     * Reverts last executed migration.\n     * Can be used only after connection to the database is established.\n     */\n    async undoLastMigration(options?: {\n        transaction?: \"all\" | \"none\" | \"each\"\n        fake?: boolean\n    }): Promise<void> {\n        if (!this.isInitialized)\n            throw new CannotExecuteNotConnectedError(this.name)\n\n        const migrationExecutor = new MigrationExecutor(this)\n        migrationExecutor.transaction =\n            (options && options.transaction) || \"all\"\n        migrationExecutor.fake = (options && options.fake) || false\n\n        await migrationExecutor.undoLastMigration()\n    }\n\n    /**\n     * Lists all migrations and whether they have been run.\n     * Returns true if there are pending migrations\n     */\n    async showMigrations(): Promise<boolean> {\n        if (!this.isInitialized) {\n            throw new CannotExecuteNotConnectedError(this.name)\n        }\n        const migrationExecutor = new MigrationExecutor(this)\n        return await migrationExecutor.showMigrations()\n    }\n\n    /**\n     * Checks if entity metadata exist for the given entity class, target name or table name.\n     */\n    hasMetadata(target: EntityTarget<any>): boolean {\n        return !!this.findMetadata(target)\n    }\n\n    /**\n     * Gets entity metadata for the given entity class or schema name.\n     */\n    getMetadata(target: EntityTarget<any>): EntityMetadata {\n        const metadata = this.findMetadata(target)\n        if (!metadata) throw new EntityMetadataNotFoundError(target)\n\n        return metadata\n    }\n\n    /**\n     * Gets repository for the given entity.\n     */\n    getRepository<Entity extends ObjectLiteral>(\n        target: EntityTarget<Entity>,\n    ): Repository<Entity> {\n        return this.manager.getRepository(target)\n    }\n\n    /**\n     * Gets tree repository for the given entity class or name.\n     * Only tree-type entities can have a TreeRepository, like ones decorated with @Tree decorator.\n     */\n    getTreeRepository<Entity extends ObjectLiteral>(\n        target: EntityTarget<Entity>,\n    ): TreeRepository<Entity> {\n        return this.manager.getTreeRepository(target)\n    }\n\n    /**\n     * Gets mongodb-specific repository for the given entity class or name.\n     * Works only if connection is mongodb-specific.\n     */\n    getMongoRepository<Entity extends ObjectLiteral>(\n        target: EntityTarget<Entity>,\n    ): MongoRepository<Entity> {\n        if (!(this.driver.options.type === \"mongodb\"))\n            throw new TypeORMError(\n                `You can use getMongoRepository only for MongoDB connections.`,\n            )\n\n        return this.manager.getRepository(target) as any\n    }\n\n    /**\n     * Gets custom entity repository marked with @EntityRepository decorator.\n     *\n     * @deprecated use Repository.extend function to create a custom repository\n     */\n    getCustomRepository<T>(customRepository: ObjectType<T>): T {\n        return this.manager.getCustomRepository(customRepository)\n    }\n\n    /**\n     * Wraps given function execution (and all operations made there) into a transaction.\n     * All database operations must be executed using provided entity manager.\n     */\n    async transaction<T>(\n        runInTransaction: (entityManager: EntityManager) => Promise<T>,\n    ): Promise<T>\n    async transaction<T>(\n        isolationLevel: IsolationLevel,\n        runInTransaction: (entityManager: EntityManager) => Promise<T>,\n    ): Promise<T>\n    async transaction<T>(\n        isolationOrRunInTransaction:\n            | IsolationLevel\n            | ((entityManager: EntityManager) => Promise<T>),\n        runInTransactionParam?: (entityManager: EntityManager) => Promise<T>,\n    ): Promise<any> {\n        return this.manager.transaction(\n            isolationOrRunInTransaction as any,\n            runInTransactionParam as any,\n        )\n    }\n\n    /**\n     * Executes raw SQL query and returns raw database results.\n     */\n    async query(\n        query: string,\n        parameters?: any[],\n        queryRunner?: QueryRunner,\n    ): Promise<any> {\n        if (InstanceChecker.isMongoEntityManager(this.manager))\n            throw new TypeORMError(`Queries aren't supported by MongoDB.`)\n\n        if (queryRunner && queryRunner.isReleased)\n            throw new QueryRunnerProviderAlreadyReleasedError()\n\n        const usedQueryRunner = queryRunner || this.createQueryRunner()\n\n        try {\n            return await usedQueryRunner.query(query, parameters) // await is needed here because we are using finally\n        } finally {\n            if (!queryRunner) await usedQueryRunner.release()\n        }\n    }\n\n    /**\n     * Creates a new query builder that can be used to build a SQL query.\n     */\n    createQueryBuilder<Entity extends ObjectLiteral>(\n        entityClass: EntityTarget<Entity>,\n        alias: string,\n        queryRunner?: QueryRunner,\n    ): SelectQueryBuilder<Entity>\n\n    /**\n     * Creates a new query builder that can be used to build a SQL query.\n     */\n    createQueryBuilder(queryRunner?: QueryRunner): SelectQueryBuilder<any>\n\n    /**\n     * Creates a new query builder that can be used to build a SQL query.\n     */\n    createQueryBuilder<Entity extends ObjectLiteral>(\n        entityOrRunner?: EntityTarget<Entity> | QueryRunner,\n        alias?: string,\n        queryRunner?: QueryRunner,\n    ): SelectQueryBuilder<Entity> {\n        if (InstanceChecker.isMongoEntityManager(this.manager))\n            throw new TypeORMError(`Query Builder is not supported by MongoDB.`)\n\n        if (alias) {\n            alias = DriverUtils.buildAlias(this.driver, alias)\n            const metadata = this.getMetadata(\n                entityOrRunner as EntityTarget<Entity>,\n            )\n            return new SelectQueryBuilder(this, queryRunner)\n                .select(alias)\n                .from(metadata.target, alias)\n        } else {\n            return new SelectQueryBuilder(\n                this,\n                entityOrRunner as QueryRunner | undefined,\n            )\n        }\n    }\n\n    /**\n     * Creates a query runner used for perform queries on a single database connection.\n     * Using query runners you can control your queries to execute using single database connection and\n     * manually control your database transaction.\n     *\n     * Mode is used in replication mode and indicates whatever you want to connect\n     * to master database or any of slave databases.\n     * If you perform writes you must use master database,\n     * if you perform reads you can use slave databases.\n     */\n    createQueryRunner(mode: ReplicationMode = \"master\"): QueryRunner {\n        const queryRunner = this.driver.createQueryRunner(mode)\n        const manager = this.createEntityManager(queryRunner)\n        Object.assign(queryRunner, { manager: manager })\n        return queryRunner\n    }\n\n    /**\n     * Gets entity metadata of the junction table (many-to-many table).\n     */\n    getManyToManyMetadata(\n        entityTarget: EntityTarget<any>,\n        relationPropertyPath: string,\n    ) {\n        const relationMetadata =\n            this.getMetadata(entityTarget).findRelationWithPropertyPath(\n                relationPropertyPath,\n            )\n        if (!relationMetadata)\n            throw new TypeORMError(\n                `Relation \"${relationPropertyPath}\" was not found in ${entityTarget} entity.`,\n            )\n        if (!relationMetadata.isManyToMany)\n            throw new TypeORMError(\n                `Relation \"${entityTarget}#${relationPropertyPath}\" does not have a many-to-many relationship.` +\n                    `You can use this method only on many-to-many relations.`,\n            )\n\n        return relationMetadata.junctionEntityMetadata\n    }\n\n    /**\n     * Creates an Entity Manager for the current connection with the help of the EntityManagerFactory.\n     */\n    createEntityManager(queryRunner?: QueryRunner): EntityManager {\n        return new EntityManagerFactory().create(this, queryRunner)\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Finds exist entity metadata by the given entity class, target name or table name.\n     */\n    protected findMetadata(\n        target: EntityTarget<any>,\n    ): EntityMetadata | undefined {\n        return this.entityMetadatas.find((metadata) => {\n            if (metadata.target === target) return true\n            if (InstanceChecker.isEntitySchema(target)) {\n                return metadata.name === target.options.name\n            }\n            if (typeof target === \"string\") {\n                if (target.indexOf(\".\") !== -1) {\n                    return metadata.tablePath === target\n                } else {\n                    return (\n                        metadata.name === target ||\n                        metadata.tableName === target\n                    )\n                }\n            }\n            if (\n                ObjectUtils.isObject(target) &&\n                typeof target.name === \"string\"\n            ) {\n                if (target.name.indexOf(\".\") !== -1) {\n                    return metadata.tablePath === target.name\n                } else {\n                    return (\n                        metadata.name === target.name ||\n                        metadata.tableName === target.name\n                    )\n                }\n            }\n\n            return false\n        })\n    }\n\n    /**\n     * Builds metadatas for all registered classes inside this connection.\n     */\n    protected async buildMetadatas(): Promise<void> {\n        const connectionMetadataBuilder = new ConnectionMetadataBuilder(this)\n        const entityMetadataValidator = new EntityMetadataValidator()\n\n        // create subscribers instances if they are not disallowed from high-level (for example they can disallowed from migrations run process)\n        const flattenedSubscribers = ObjectUtils.mixedListToArray(\n            this.options.subscribers || [],\n        )\n        const subscribers = await connectionMetadataBuilder.buildSubscribers(\n            flattenedSubscribers,\n        )\n        ObjectUtils.assign(this, { subscribers: subscribers })\n\n        // build entity metadatas\n        const flattenedEntities = ObjectUtils.mixedListToArray(\n            this.options.entities || [],\n        )\n        const entityMetadatas =\n            await connectionMetadataBuilder.buildEntityMetadatas(\n                flattenedEntities,\n            )\n        ObjectUtils.assign(this, { entityMetadatas: entityMetadatas })\n\n        // create migration instances\n        const flattenedMigrations = ObjectUtils.mixedListToArray(\n            this.options.migrations || [],\n        )\n        const migrations = await connectionMetadataBuilder.buildMigrations(\n            flattenedMigrations,\n        )\n        ObjectUtils.assign(this, { migrations: migrations })\n\n        // validate all created entity metadatas to make sure user created entities are valid and correct\n        entityMetadataValidator.validateMany(\n            this.entityMetadatas.filter(\n                (metadata) => metadata.tableType !== \"view\",\n            ),\n            this.driver,\n        )\n\n        // set current data source to the entities\n        for (let entityMetadata of entityMetadatas) {\n            if (\n                InstanceChecker.isBaseEntityConstructor(entityMetadata.target)\n            ) {\n                entityMetadata.target.useDataSource(this)\n            }\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}