{"ast":null,"code":"import { EntityMetadata } from \"../metadata/EntityMetadata\";\nimport { ColumnMetadata } from \"../metadata/ColumnMetadata\";\nimport { ForeignKeyMetadata } from \"../metadata/ForeignKeyMetadata\";\nimport { IndexMetadata } from \"../metadata/IndexMetadata\";\n/**\n * Creates EntityMetadata for junction tables of the closure entities.\n * Closure junction tables are tables generated by closure entities.\n */\n\nexport class ClosureJunctionEntityMetadataBuilder {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection) {\n    this.connection = connection;\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Builds EntityMetadata for the closure junction of the given closure entity.\n   */\n\n\n  build(parentClosureEntityMetadata) {\n    // create entity metadata itself\n    const entityMetadata = new EntityMetadata({\n      parentClosureEntityMetadata: parentClosureEntityMetadata,\n      connection: this.connection,\n      args: {\n        target: \"\",\n        name: parentClosureEntityMetadata.treeOptions && parentClosureEntityMetadata.treeOptions.closureTableName ? parentClosureEntityMetadata.treeOptions.closureTableName : parentClosureEntityMetadata.tableNameWithoutPrefix,\n        type: \"closure-junction\"\n      }\n    });\n    entityMetadata.build(); // create ancestor and descendant columns for new closure junction table\n\n    parentClosureEntityMetadata.primaryColumns.forEach(primaryColumn => {\n      entityMetadata.ownColumns.push(new ColumnMetadata({\n        connection: this.connection,\n        entityMetadata: entityMetadata,\n        closureType: \"ancestor\",\n        referencedColumn: primaryColumn,\n        args: {\n          target: \"\",\n          mode: \"virtual\",\n          propertyName: parentClosureEntityMetadata.treeOptions && parentClosureEntityMetadata.treeOptions.ancestorColumnName ? parentClosureEntityMetadata.treeOptions.ancestorColumnName(primaryColumn) : primaryColumn.propertyName + \"_ancestor\",\n          options: {\n            primary: true,\n            length: primaryColumn.length,\n            type: primaryColumn.type\n          }\n        }\n      }));\n      entityMetadata.ownColumns.push(new ColumnMetadata({\n        connection: this.connection,\n        entityMetadata: entityMetadata,\n        closureType: \"descendant\",\n        referencedColumn: primaryColumn,\n        args: {\n          target: \"\",\n          mode: \"virtual\",\n          propertyName: parentClosureEntityMetadata.treeOptions && parentClosureEntityMetadata.treeOptions.descendantColumnName ? parentClosureEntityMetadata.treeOptions.descendantColumnName(primaryColumn) : primaryColumn.propertyName + \"_descendant\",\n          options: {\n            primary: true,\n            length: primaryColumn.length,\n            type: primaryColumn.type\n          }\n        }\n      }));\n    });\n    entityMetadata.ownIndices = [new IndexMetadata({\n      entityMetadata: entityMetadata,\n      columns: [entityMetadata.ownColumns[0]],\n      args: {\n        target: entityMetadata.target,\n        synchronize: true\n      }\n    }), new IndexMetadata({\n      entityMetadata: entityMetadata,\n      columns: [entityMetadata.ownColumns[1]],\n      args: {\n        target: entityMetadata.target,\n        synchronize: true\n      }\n    })]; // if tree level column was defined by a closure entity then add it to the junction columns as well\n\n    if (parentClosureEntityMetadata.treeLevelColumn) {\n      entityMetadata.ownColumns.push(new ColumnMetadata({\n        connection: this.connection,\n        entityMetadata: entityMetadata,\n        args: {\n          target: \"\",\n          mode: \"virtual\",\n          propertyName: \"level\",\n          options: {\n            type: this.connection.driver.mappedDataTypes.treeLevel\n          }\n        }\n      }));\n    } // create junction table foreign keys\n    // Note: CASCADE is not applied to mssql because it does not support multi cascade paths\n\n\n    entityMetadata.foreignKeys = [new ForeignKeyMetadata({\n      entityMetadata: entityMetadata,\n      referencedEntityMetadata: parentClosureEntityMetadata,\n      columns: [entityMetadata.ownColumns[0]],\n      referencedColumns: parentClosureEntityMetadata.primaryColumns,\n      onDelete: this.connection.driver.options.type === \"mssql\" ? \"NO ACTION\" : \"CASCADE\"\n    }), new ForeignKeyMetadata({\n      entityMetadata: entityMetadata,\n      referencedEntityMetadata: parentClosureEntityMetadata,\n      columns: [entityMetadata.ownColumns[1]],\n      referencedColumns: parentClosureEntityMetadata.primaryColumns,\n      onDelete: this.connection.driver.options.type === \"mssql\" ? \"NO ACTION\" : \"CASCADE\"\n    })];\n    return entityMetadata;\n  }\n\n}","map":{"version":3,"mappings":"AAAA,SAASA,cAAT,QAA+B,4BAA/B;AACA,SAASC,cAAT,QAA+B,4BAA/B;AACA,SAASC,kBAAT,QAAmC,gCAAnC;AAEA,SAASC,aAAT,QAA8B,2BAA9B;AAEA;;;;;AAIA,OAAM,MAAOC,oCAAP,CAA2C;EAC7C;EACA;EACA;EAEAC,YAAoBC,UAApB,EAA0C;IAAtB;EAA0B,CALD,CAO7C;EACA;EACA;;EAEA;;;;;EAGAC,KAAK,CAACC,2BAAD,EAA4C;IAC7C;IACA,MAAMC,cAAc,GAAG,IAAIT,cAAJ,CAAmB;MACtCQ,2BAA2B,EAAEA,2BADS;MAEtCF,UAAU,EAAE,KAAKA,UAFqB;MAGtCI,IAAI,EAAE;QACFC,MAAM,EAAE,EADN;QAEFC,IAAI,EACAJ,2BAA2B,CAACK,WAA5B,IACAL,2BAA2B,CAACK,WAA5B,CAAwCC,gBADxC,GAEMN,2BAA2B,CAACK,WAA5B,CACKC,gBAHX,GAIMN,2BAA2B,CAACO,sBAPpC;QAQFC,IAAI,EAAE;MARJ;IAHgC,CAAnB,CAAvB;IAcAP,cAAc,CAACF,KAAf,GAhB6C,CAkB7C;;IACAC,2BAA2B,CAACS,cAA5B,CAA2CC,OAA3C,CAAoDC,aAAD,IAAkB;MACjEV,cAAc,CAACW,UAAf,CAA0BC,IAA1B,CACI,IAAIpB,cAAJ,CAAmB;QACfK,UAAU,EAAE,KAAKA,UADF;QAEfG,cAAc,EAAEA,cAFD;QAGfa,WAAW,EAAE,UAHE;QAIfC,gBAAgB,EAAEJ,aAJH;QAKfT,IAAI,EAAE;UACFC,MAAM,EAAE,EADN;UAEFa,IAAI,EAAE,SAFJ;UAGFC,YAAY,EACRjB,2BAA2B,CAACK,WAA5B,IACAL,2BAA2B,CAACK,WAA5B,CACKa,kBAFL,GAGMlB,2BAA2B,CAACK,WAA5B,CAAwCa,kBAAxC,CACIP,aADJ,CAHN,GAMMA,aAAa,CAACM,YAAd,GAA6B,WAVrC;UAWFE,OAAO,EAAE;YACLC,OAAO,EAAE,IADJ;YAELC,MAAM,EAAEV,aAAa,CAACU,MAFjB;YAGLb,IAAI,EAAEG,aAAa,CAACH;UAHf;QAXP;MALS,CAAnB,CADJ;MAyBAP,cAAc,CAACW,UAAf,CAA0BC,IAA1B,CACI,IAAIpB,cAAJ,CAAmB;QACfK,UAAU,EAAE,KAAKA,UADF;QAEfG,cAAc,EAAEA,cAFD;QAGfa,WAAW,EAAE,YAHE;QAIfC,gBAAgB,EAAEJ,aAJH;QAKfT,IAAI,EAAE;UACFC,MAAM,EAAE,EADN;UAEFa,IAAI,EAAE,SAFJ;UAGFC,YAAY,EACRjB,2BAA2B,CAACK,WAA5B,IACAL,2BAA2B,CAACK,WAA5B,CACKiB,oBAFL,GAGMtB,2BAA2B,CAACK,WAA5B,CAAwCiB,oBAAxC,CACIX,aADJ,CAHN,GAMMA,aAAa,CAACM,YAAd,GAA6B,aAVrC;UAWFE,OAAO,EAAE;YACLC,OAAO,EAAE,IADJ;YAELC,MAAM,EAAEV,aAAa,CAACU,MAFjB;YAGLb,IAAI,EAAEG,aAAa,CAACH;UAHf;QAXP;MALS,CAAnB,CADJ;IAyBH,CAnDD;IAqDAP,cAAc,CAACsB,UAAf,GAA4B,CACxB,IAAI5B,aAAJ,CAAkB;MACdM,cAAc,EAAEA,cADF;MAEduB,OAAO,EAAE,CAACvB,cAAc,CAACW,UAAf,CAA0B,CAA1B,CAAD,CAFK;MAGdV,IAAI,EAAE;QACFC,MAAM,EAAEF,cAAc,CAACE,MADrB;QAEFsB,WAAW,EAAE;MAFX;IAHQ,CAAlB,CADwB,EASxB,IAAI9B,aAAJ,CAAkB;MACdM,cAAc,EAAEA,cADF;MAEduB,OAAO,EAAE,CAACvB,cAAc,CAACW,UAAf,CAA0B,CAA1B,CAAD,CAFK;MAGdV,IAAI,EAAE;QACFC,MAAM,EAAEF,cAAc,CAACE,MADrB;QAEFsB,WAAW,EAAE;MAFX;IAHQ,CAAlB,CATwB,CAA5B,CAxE6C,CA2F7C;;IACA,IAAIzB,2BAA2B,CAAC0B,eAAhC,EAAiD;MAC7CzB,cAAc,CAACW,UAAf,CAA0BC,IAA1B,CACI,IAAIpB,cAAJ,CAAmB;QACfK,UAAU,EAAE,KAAKA,UADF;QAEfG,cAAc,EAAEA,cAFD;QAGfC,IAAI,EAAE;UACFC,MAAM,EAAE,EADN;UAEFa,IAAI,EAAE,SAFJ;UAGFC,YAAY,EAAE,OAHZ;UAIFE,OAAO,EAAE;YACLX,IAAI,EAAE,KAAKV,UAAL,CAAgB6B,MAAhB,CAAuBC,eAAvB,CACDC;UAFA;QAJP;MAHS,CAAnB,CADJ;IAeH,CA5G4C,CA8G7C;IACA;;;IACA5B,cAAc,CAAC6B,WAAf,GAA6B,CACzB,IAAIpC,kBAAJ,CAAuB;MACnBO,cAAc,EAAEA,cADG;MAEnB8B,wBAAwB,EAAE/B,2BAFP;MAGnBwB,OAAO,EAAE,CAACvB,cAAc,CAACW,UAAf,CAA0B,CAA1B,CAAD,CAHU;MAInBoB,iBAAiB,EAAEhC,2BAA2B,CAACS,cAJ5B;MAKnBwB,QAAQ,EACJ,KAAKnC,UAAL,CAAgB6B,MAAhB,CAAuBR,OAAvB,CAA+BX,IAA/B,KAAwC,OAAxC,GACM,WADN,GAEM;IARS,CAAvB,CADyB,EAWzB,IAAId,kBAAJ,CAAuB;MACnBO,cAAc,EAAEA,cADG;MAEnB8B,wBAAwB,EAAE/B,2BAFP;MAGnBwB,OAAO,EAAE,CAACvB,cAAc,CAACW,UAAf,CAA0B,CAA1B,CAAD,CAHU;MAInBoB,iBAAiB,EAAEhC,2BAA2B,CAACS,cAJ5B;MAKnBwB,QAAQ,EACJ,KAAKnC,UAAL,CAAgB6B,MAAhB,CAAuBR,OAAvB,CAA+BX,IAA/B,KAAwC,OAAxC,GACM,WADN,GAEM;IARS,CAAvB,CAXyB,CAA7B;IAuBA,OAAOP,cAAP;EACH;;AAtJ4C","names":["EntityMetadata","ColumnMetadata","ForeignKeyMetadata","IndexMetadata","ClosureJunctionEntityMetadataBuilder","constructor","connection","build","parentClosureEntityMetadata","entityMetadata","args","target","name","treeOptions","closureTableName","tableNameWithoutPrefix","type","primaryColumns","forEach","primaryColumn","ownColumns","push","closureType","referencedColumn","mode","propertyName","ancestorColumnName","options","primary","length","descendantColumnName","ownIndices","columns","synchronize","treeLevelColumn","driver","mappedDataTypes","treeLevel","foreignKeys","referencedEntityMetadata","referencedColumns","onDelete"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\metadata-builder\\ClosureJunctionEntityMetadataBuilder.ts"],"sourcesContent":["import { EntityMetadata } from \"../metadata/EntityMetadata\"\nimport { ColumnMetadata } from \"../metadata/ColumnMetadata\"\nimport { ForeignKeyMetadata } from \"../metadata/ForeignKeyMetadata\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { IndexMetadata } from \"../metadata/IndexMetadata\"\n\n/**\n * Creates EntityMetadata for junction tables of the closure entities.\n * Closure junction tables are tables generated by closure entities.\n */\nexport class ClosureJunctionEntityMetadataBuilder {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private connection: DataSource) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Builds EntityMetadata for the closure junction of the given closure entity.\n     */\n    build(parentClosureEntityMetadata: EntityMetadata) {\n        // create entity metadata itself\n        const entityMetadata = new EntityMetadata({\n            parentClosureEntityMetadata: parentClosureEntityMetadata,\n            connection: this.connection,\n            args: {\n                target: \"\",\n                name:\n                    parentClosureEntityMetadata.treeOptions &&\n                    parentClosureEntityMetadata.treeOptions.closureTableName\n                        ? parentClosureEntityMetadata.treeOptions\n                              .closureTableName\n                        : parentClosureEntityMetadata.tableNameWithoutPrefix,\n                type: \"closure-junction\",\n            },\n        })\n        entityMetadata.build()\n\n        // create ancestor and descendant columns for new closure junction table\n        parentClosureEntityMetadata.primaryColumns.forEach((primaryColumn) => {\n            entityMetadata.ownColumns.push(\n                new ColumnMetadata({\n                    connection: this.connection,\n                    entityMetadata: entityMetadata,\n                    closureType: \"ancestor\",\n                    referencedColumn: primaryColumn,\n                    args: {\n                        target: \"\",\n                        mode: \"virtual\",\n                        propertyName:\n                            parentClosureEntityMetadata.treeOptions &&\n                            parentClosureEntityMetadata.treeOptions\n                                .ancestorColumnName\n                                ? parentClosureEntityMetadata.treeOptions.ancestorColumnName(\n                                      primaryColumn,\n                                  )\n                                : primaryColumn.propertyName + \"_ancestor\",\n                        options: {\n                            primary: true,\n                            length: primaryColumn.length,\n                            type: primaryColumn.type,\n                        },\n                    },\n                }),\n            )\n            entityMetadata.ownColumns.push(\n                new ColumnMetadata({\n                    connection: this.connection,\n                    entityMetadata: entityMetadata,\n                    closureType: \"descendant\",\n                    referencedColumn: primaryColumn,\n                    args: {\n                        target: \"\",\n                        mode: \"virtual\",\n                        propertyName:\n                            parentClosureEntityMetadata.treeOptions &&\n                            parentClosureEntityMetadata.treeOptions\n                                .descendantColumnName\n                                ? parentClosureEntityMetadata.treeOptions.descendantColumnName(\n                                      primaryColumn,\n                                  )\n                                : primaryColumn.propertyName + \"_descendant\",\n                        options: {\n                            primary: true,\n                            length: primaryColumn.length,\n                            type: primaryColumn.type,\n                        },\n                    },\n                }),\n            )\n        })\n\n        entityMetadata.ownIndices = [\n            new IndexMetadata({\n                entityMetadata: entityMetadata,\n                columns: [entityMetadata.ownColumns[0]],\n                args: {\n                    target: entityMetadata.target,\n                    synchronize: true,\n                },\n            }),\n            new IndexMetadata({\n                entityMetadata: entityMetadata,\n                columns: [entityMetadata.ownColumns[1]],\n                args: {\n                    target: entityMetadata.target,\n                    synchronize: true,\n                },\n            }),\n        ]\n\n        // if tree level column was defined by a closure entity then add it to the junction columns as well\n        if (parentClosureEntityMetadata.treeLevelColumn) {\n            entityMetadata.ownColumns.push(\n                new ColumnMetadata({\n                    connection: this.connection,\n                    entityMetadata: entityMetadata,\n                    args: {\n                        target: \"\",\n                        mode: \"virtual\",\n                        propertyName: \"level\",\n                        options: {\n                            type: this.connection.driver.mappedDataTypes\n                                .treeLevel,\n                        },\n                    },\n                }),\n            )\n        }\n\n        // create junction table foreign keys\n        // Note: CASCADE is not applied to mssql because it does not support multi cascade paths\n        entityMetadata.foreignKeys = [\n            new ForeignKeyMetadata({\n                entityMetadata: entityMetadata,\n                referencedEntityMetadata: parentClosureEntityMetadata,\n                columns: [entityMetadata.ownColumns[0]],\n                referencedColumns: parentClosureEntityMetadata.primaryColumns,\n                onDelete:\n                    this.connection.driver.options.type === \"mssql\"\n                        ? \"NO ACTION\"\n                        : \"CASCADE\",\n            }),\n            new ForeignKeyMetadata({\n                entityMetadata: entityMetadata,\n                referencedEntityMetadata: parentClosureEntityMetadata,\n                columns: [entityMetadata.ownColumns[1]],\n                referencedColumns: parentClosureEntityMetadata.primaryColumns,\n                onDelete:\n                    this.connection.driver.options.type === \"mssql\"\n                        ? \"NO ACTION\"\n                        : \"CASCADE\",\n            }),\n        ]\n\n        return entityMetadata\n    }\n}\n"]},"metadata":{},"sourceType":"module"}