{"ast":null,"code":"import { CannotCreateEntityIdMapError } from \"../error/CannotCreateEntityIdMapError\";\nimport { OrmUtils } from \"../util/OrmUtils\";\nimport { EntityPropertyNotFoundError } from \"../error/EntityPropertyNotFoundError\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\nimport { shorten } from \"../util/StringUtils\";\n/**\n * Contains all entity metadata.\n */\n\nexport class EntityMetadata {\n  // ---------------------------------------------------------------------\n  // Constructor\n  // ---------------------------------------------------------------------\n  constructor(options) {\n    this[\"@instanceof\"] = Symbol.for(\"EntityMetadata\");\n    /**\n     * Children entity metadatas. Used in inheritance patterns.\n     */\n\n    this.childEntityMetadatas = [];\n    /**\n     * All \"inheritance tree\" from a target entity.\n     * For example for target Post < ContentModel < Unit it will be an array of [Post, ContentModel, Unit].\n     * It also contains child entities for single table inheritance.\n     */\n\n    this.inheritanceTree = [];\n    /**\n     * Table type. Tables can be closure, junction, etc.\n     */\n\n    this.tableType = \"regular\";\n    /**\n     * Enables Sqlite \"WITHOUT ROWID\" modifier for the \"CREATE TABLE\" statement\n     */\n\n    this.withoutRowid = false;\n    /**\n     * Indicates if schema will be synchronized for this entity or not.\n     */\n\n    this.synchronize = true;\n    /**\n     * Checks if there any non-nullable column exist in this entity.\n     */\n\n    this.hasNonNullableRelations = false;\n    /**\n     * Indicates if this entity metadata of a junction table, or not.\n     * Junction table is a table created by many-to-many relationship.\n     *\n     * Its also possible to understand if entity is junction via tableType.\n     */\n\n    this.isJunction = false;\n    /**\n     * Indicates if the entity should be instantiated using the constructor\n     * or via allocating a new object via `Object.create()`.\n     */\n\n    this.isAlwaysUsingConstructor = true;\n    /**\n     * Checks if this table is a junction table of the closure table.\n     * This type is for tables that contain junction metadata of the closure tables.\n     */\n\n    this.isClosureJunction = false;\n    /**\n     * Checks if entity's table has multiple primary columns.\n     */\n\n    this.hasMultiplePrimaryKeys = false;\n    /**\n     * Indicates if this entity metadata has uuid generated columns.\n     */\n\n    this.hasUUIDGeneratedColumns = false;\n    /**\n     * Entity's column metadatas defined by user.\n     */\n\n    this.ownColumns = [];\n    /**\n     * Columns of the entity, including columns that are coming from the embeddeds of this entity.\n     */\n\n    this.columns = [];\n    /**\n     * Ancestor columns used only in closure junction tables.\n     */\n\n    this.ancestorColumns = [];\n    /**\n     * Descendant columns used only in closure junction tables.\n     */\n\n    this.descendantColumns = [];\n    /**\n     * All columns except for virtual columns.\n     */\n\n    this.nonVirtualColumns = [];\n    /**\n     * In the case if this entity metadata is junction table's entity metadata,\n     * this will contain all referenced columns of owner entity.\n     */\n\n    this.ownerColumns = [];\n    /**\n     * In the case if this entity metadata is junction table's entity metadata,\n     * this will contain all referenced columns of inverse entity.\n     */\n\n    this.inverseColumns = [];\n    /**\n     * Gets the column with generated flag.\n     */\n\n    this.generatedColumns = [];\n    /**\n     * Gets the primary columns.\n     */\n\n    this.primaryColumns = [];\n    /**\n     * Entity's relation metadatas.\n     */\n\n    this.ownRelations = [];\n    /**\n     * Relations of the entity, including relations that are coming from the embeddeds of this entity.\n     */\n\n    this.relations = [];\n    /**\n     * List of eager relations this metadata has.\n     */\n\n    this.eagerRelations = [];\n    /**\n     * List of eager relations this metadata has.\n     */\n\n    this.lazyRelations = [];\n    /**\n     * Gets only one-to-one relations of the entity.\n     */\n\n    this.oneToOneRelations = [];\n    /**\n     * Gets only owner one-to-one relations of the entity.\n     */\n\n    this.ownerOneToOneRelations = [];\n    /**\n     * Gets only one-to-many relations of the entity.\n     */\n\n    this.oneToManyRelations = [];\n    /**\n     * Gets only many-to-one relations of the entity.\n     */\n\n    this.manyToOneRelations = [];\n    /**\n     * Gets only many-to-many relations of the entity.\n     */\n\n    this.manyToManyRelations = [];\n    /**\n     * Gets only owner many-to-many relations of the entity.\n     */\n\n    this.ownerManyToManyRelations = [];\n    /**\n     * Gets only owner one-to-one and many-to-one relations.\n     */\n\n    this.relationsWithJoinColumns = [];\n    /**\n     * Entity's relation id metadatas.\n     */\n\n    this.relationIds = [];\n    /**\n     * Entity's relation id metadatas.\n     */\n\n    this.relationCounts = [];\n    /**\n     * Entity's foreign key metadatas.\n     */\n\n    this.foreignKeys = [];\n    /**\n     * Entity's embedded metadatas.\n     */\n\n    this.embeddeds = [];\n    /**\n     * All embeddeds - embeddeds from this entity metadata and from all child embeddeds, etc.\n     */\n\n    this.allEmbeddeds = [];\n    /**\n     * Entity's own indices.\n     */\n\n    this.ownIndices = [];\n    /**\n     * Entity's index metadatas.\n     */\n\n    this.indices = [];\n    /**\n     * Entity's unique metadatas.\n     */\n\n    this.uniques = [];\n    /**\n     * Entity's own uniques.\n     */\n\n    this.ownUniques = [];\n    /**\n     * Entity's check metadatas.\n     */\n\n    this.checks = [];\n    /**\n     * Entity's exclusion metadatas.\n     */\n\n    this.exclusions = [];\n    /**\n     * Entity's own listener metadatas.\n     */\n\n    this.ownListeners = [];\n    /**\n     * Entity listener metadatas.\n     */\n\n    this.listeners = [];\n    /**\n     * Listener metadatas with \"AFTER LOAD\" type.\n     */\n\n    this.afterLoadListeners = [];\n    /**\n     * Listener metadatas with \"AFTER INSERT\" type.\n     */\n\n    this.beforeInsertListeners = [];\n    /**\n     * Listener metadatas with \"AFTER INSERT\" type.\n     */\n\n    this.afterInsertListeners = [];\n    /**\n     * Listener metadatas with \"AFTER UPDATE\" type.\n     */\n\n    this.beforeUpdateListeners = [];\n    /**\n     * Listener metadatas with \"AFTER UPDATE\" type.\n     */\n\n    this.afterUpdateListeners = [];\n    /**\n     * Listener metadatas with \"AFTER REMOVE\" type.\n     */\n\n    this.beforeRemoveListeners = [];\n    /**\n     * Listener metadatas with \"BEFORE SOFT REMOVE\" type.\n     */\n\n    this.beforeSoftRemoveListeners = [];\n    /**\n     * Listener metadatas with \"BEFORE RECOVER\" type.\n     */\n\n    this.beforeRecoverListeners = [];\n    /**\n     * Listener metadatas with \"AFTER REMOVE\" type.\n     */\n\n    this.afterRemoveListeners = [];\n    /**\n     * Listener metadatas with \"AFTER SOFT REMOVE\" type.\n     */\n\n    this.afterSoftRemoveListeners = [];\n    /**\n     * Listener metadatas with \"AFTER RECOVER\" type.\n     */\n\n    this.afterRecoverListeners = [];\n    this.connection = options.connection;\n    this.inheritanceTree = options.inheritanceTree || [];\n    this.inheritancePattern = options.inheritancePattern;\n    this.treeType = options.tableTree ? options.tableTree.type : undefined;\n    this.treeOptions = options.tableTree ? options.tableTree.options : undefined;\n    this.parentClosureEntityMetadata = options.parentClosureEntityMetadata;\n    this.tableMetadataArgs = options.args;\n    this.target = this.tableMetadataArgs.target;\n    this.tableType = this.tableMetadataArgs.type;\n    this.expression = this.tableMetadataArgs.expression;\n    this.withoutRowid = this.tableMetadataArgs.withoutRowid;\n    this.dependsOn = this.tableMetadataArgs.dependsOn;\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Creates a new entity.\n   */\n\n\n  create(queryRunner, options) {\n    const pojo = options && options.pojo === true ? true : false; // if target is set to a function (e.g. class) that can be created then create it\n\n    let ret;\n\n    if (typeof this.target === \"function\" && !pojo) {\n      if (!(options === null || options === void 0 ? void 0 : options.fromDeserializer) || this.isAlwaysUsingConstructor) {\n        ret = new this.target();\n      } else {\n        ret = Object.create(this.target.prototype);\n      }\n    } else {\n      // otherwise simply return a new empty object\n      ret = {};\n    } // add \"typename\" property\n\n\n    if (this.connection.options.typename) {\n      ret[this.connection.options.typename] = this.targetName;\n    }\n\n    this.lazyRelations.forEach(relation => this.connection.relationLoader.enableLazyLoad(relation, ret, queryRunner));\n    return ret;\n  }\n  /**\n   * Checks if given entity has an id.\n   */\n\n\n  hasId(entity) {\n    if (!entity) return false;\n    return this.primaryColumns.every(primaryColumn => {\n      const value = primaryColumn.getEntityValue(entity);\n      return value !== null && value !== undefined && value !== \"\";\n    });\n  }\n  /**\n   * Checks if given entity / object contains ALL primary keys entity must have.\n   * Returns true if it contains all of them, false if at least one of them is not defined.\n   */\n\n\n  hasAllPrimaryKeys(entity) {\n    return this.primaryColumns.every(primaryColumn => {\n      const value = primaryColumn.getEntityValue(entity);\n      return value !== null && value !== undefined;\n    });\n  }\n  /**\n   * Ensures that given object is an entity id map.\n   * If given id is an object then it means its already id map.\n   * If given id isn't an object then it means its a value of the id column\n   * and it creates a new id map with this value and name of the primary column.\n   */\n\n\n  ensureEntityIdMap(id) {\n    if (ObjectUtils.isObject(id)) return id;\n    if (this.hasMultiplePrimaryKeys) throw new CannotCreateEntityIdMapError(this, id);\n    return this.primaryColumns[0].createValueMap(id);\n  }\n  /**\n   * Gets primary keys of the entity and returns them in a literal object.\n   * For example, for Post{ id: 1, title: \"hello\" } where id is primary it will return { id: 1 }\n   * For multiple primary keys it returns multiple keys in object.\n   * For primary keys inside embeds it returns complex object literal with keys in them.\n   */\n\n\n  getEntityIdMap(entity) {\n    if (!entity) return undefined;\n    return EntityMetadata.getValueMap(entity, this.primaryColumns, {\n      skipNulls: true\n    });\n  }\n  /**\n   * Creates a \"mixed id map\".\n   * If entity has multiple primary keys (ids) then it will return just regular id map, like what getEntityIdMap returns.\n   * But if entity has a single primary key then it will return just value of the id column of the entity, just value.\n   * This is called mixed id map.\n   */\n\n\n  getEntityIdMixedMap(entity) {\n    if (!entity) return entity;\n    const idMap = this.getEntityIdMap(entity);\n\n    if (this.hasMultiplePrimaryKeys) {\n      return idMap;\n    } else if (idMap) {\n      return this.primaryColumns[0].getEntityValue(idMap); // todo: what about parent primary column?\n    }\n\n    return idMap;\n  }\n  /**\n   * Compares two different entities by their ids.\n   * Returns true if they match, false otherwise.\n   */\n\n\n  compareEntities(firstEntity, secondEntity) {\n    const firstEntityIdMap = this.getEntityIdMap(firstEntity);\n    if (!firstEntityIdMap) return false;\n    const secondEntityIdMap = this.getEntityIdMap(secondEntity);\n    if (!secondEntityIdMap) return false;\n    return OrmUtils.compareIds(firstEntityIdMap, secondEntityIdMap);\n  }\n  /**\n   * Finds column with a given property name.\n   */\n\n\n  findColumnWithPropertyName(propertyName) {\n    return this.columns.find(column => column.propertyName === propertyName);\n  }\n  /**\n   * Finds column with a given database name.\n   */\n\n\n  findColumnWithDatabaseName(databaseName) {\n    return this.columns.find(column => column.databaseName === databaseName);\n  }\n  /**\n   * Checks if there is a column or relationship with a given property path.\n   */\n\n\n  hasColumnWithPropertyPath(propertyPath) {\n    const hasColumn = this.columns.some(column => column.propertyPath === propertyPath);\n    return hasColumn || this.hasRelationWithPropertyPath(propertyPath);\n  }\n  /**\n   * Finds column with a given property path.\n   */\n\n\n  findColumnWithPropertyPath(propertyPath) {\n    const column = this.columns.find(column => column.propertyPath === propertyPath);\n    if (column) return column; // in the case if column with property path was not found, try to find a relation with such property path\n    // if we find relation and it has a single join column then its the column user was seeking\n\n    const relation = this.relations.find(relation => relation.propertyPath === propertyPath);\n    if (relation && relation.joinColumns.length === 1) return relation.joinColumns[0];\n    return undefined;\n  }\n  /**\n   * Finds column with a given property path.\n   * Does not search in relation unlike findColumnWithPropertyPath.\n   */\n\n\n  findColumnWithPropertyPathStrict(propertyPath) {\n    return this.columns.find(column => column.propertyPath === propertyPath);\n  }\n  /**\n   * Finds columns with a given property path.\n   * Property path can match a relation, and relations can contain multiple columns.\n   */\n\n\n  findColumnsWithPropertyPath(propertyPath) {\n    const column = this.columns.find(column => column.propertyPath === propertyPath);\n    if (column) return [column]; // in the case if column with property path was not found, try to find a relation with such property path\n    // if we find relation and it has a single join column then its the column user was seeking\n\n    const relation = this.findRelationWithPropertyPath(propertyPath);\n    if (relation && relation.joinColumns) return relation.joinColumns;\n    return [];\n  }\n  /**\n   * Checks if there is a relation with the given property path.\n   */\n\n\n  hasRelationWithPropertyPath(propertyPath) {\n    return this.relations.some(relation => relation.propertyPath === propertyPath);\n  }\n  /**\n   * Finds relation with the given property path.\n   */\n\n\n  findRelationWithPropertyPath(propertyPath) {\n    return this.relations.find(relation => relation.propertyPath === propertyPath);\n  }\n  /**\n   * Checks if there is an embedded with a given property path.\n   */\n\n\n  hasEmbeddedWithPropertyPath(propertyPath) {\n    return this.allEmbeddeds.some(embedded => embedded.propertyPath === propertyPath);\n  }\n  /**\n   * Finds embedded with a given property path.\n   */\n\n\n  findEmbeddedWithPropertyPath(propertyPath) {\n    return this.allEmbeddeds.find(embedded => embedded.propertyPath === propertyPath);\n  }\n  /**\n   * Returns an array of databaseNames mapped from provided propertyPaths\n   */\n\n\n  mapPropertyPathsToColumns(propertyPaths) {\n    return propertyPaths.map(propertyPath => {\n      const column = this.findColumnWithPropertyPath(propertyPath);\n\n      if (column == null) {\n        throw new EntityPropertyNotFoundError(propertyPath, this);\n      }\n\n      return column;\n    });\n  }\n  /**\n   * Iterates through entity and finds and extracts all values from relations in the entity.\n   * If relation value is an array its being flattened.\n   */\n\n\n  extractRelationValuesFromEntity(entity, relations) {\n    const relationsAndValues = [];\n    relations.forEach(relation => {\n      const value = relation.getEntityValue(entity);\n\n      if (Array.isArray(value)) {\n        value.forEach(subValue => relationsAndValues.push([relation, subValue, this.getInverseEntityMetadata(subValue, relation)]));\n      } else if (value) {\n        relationsAndValues.push([relation, value, this.getInverseEntityMetadata(value, relation)]);\n      }\n    });\n    return relationsAndValues;\n  }\n\n  getInverseEntityMetadata(value, relation) {\n    const childEntityMetadata = relation.inverseEntityMetadata.childEntityMetadatas.find(metadata => metadata.target === value.constructor);\n    return childEntityMetadata ? childEntityMetadata : relation.inverseEntityMetadata;\n  } // -------------------------------------------------------------------------\n  // Public Static Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Creates a property paths for a given entity.\n   *\n   * @deprecated\n   */\n\n\n  static createPropertyPath(metadata, entity) {\n    let prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n    const paths = [];\n    Object.keys(entity).forEach(key => {\n      // check for function is needed in the cases when createPropertyPath used on values contain a function as a value\n      // example: .update().set({ name: () => `SUBSTR('', 1, 2)` })\n      const parentPath = prefix ? prefix + \".\" + key : key;\n\n      if (metadata.hasEmbeddedWithPropertyPath(parentPath)) {\n        const subPaths = this.createPropertyPath(metadata, entity[key], parentPath);\n        paths.push(...subPaths);\n      } else {\n        const path = prefix ? prefix + \".\" + key : key;\n        paths.push(path);\n      }\n    });\n    return paths;\n  }\n  /**\n   * Finds difference between two entity id maps.\n   * Returns items that exist in the first array and absent in the second array.\n   */\n\n\n  static difference(firstIdMaps, secondIdMaps) {\n    return firstIdMaps.filter(firstIdMap => {\n      return !secondIdMaps.find(secondIdMap => OrmUtils.compareIds(firstIdMap, secondIdMap));\n    });\n  }\n  /**\n   * Creates value map from the given values and columns.\n   * Examples of usages are primary columns map and join columns map.\n   */\n\n\n  static getValueMap(entity, columns, options) {\n    return columns.reduce((map, column) => {\n      const value = column.getEntityValueMap(entity, options); // make sure that none of the values of the columns are not missing\n\n      if (map === undefined || value === null || value === undefined) return undefined;\n      return OrmUtils.mergeDeep(map, value);\n    }, {});\n  } // ---------------------------------------------------------------------\n  // Public Builder Methods\n  // ---------------------------------------------------------------------\n\n\n  build() {\n    var _a;\n\n    const namingStrategy = this.connection.namingStrategy;\n    const entityPrefix = this.connection.options.entityPrefix;\n    const entitySkipConstructor = this.connection.options.entitySkipConstructor;\n    this.engine = this.tableMetadataArgs.engine;\n    this.database = this.tableMetadataArgs.type === \"entity-child\" && this.parentEntityMetadata ? this.parentEntityMetadata.database : this.tableMetadataArgs.database;\n\n    if (this.tableMetadataArgs.schema) {\n      this.schema = this.tableMetadataArgs.schema;\n    } else if (this.tableMetadataArgs.type === \"entity-child\" && this.parentEntityMetadata) {\n      this.schema = this.parentEntityMetadata.schema;\n    } else if ((_a = this.connection.options) === null || _a === void 0 ? void 0 : _a.hasOwnProperty(\"schema\")) {\n      this.schema = this.connection.options.schema;\n    }\n\n    this.givenTableName = this.tableMetadataArgs.type === \"entity-child\" && this.parentEntityMetadata ? this.parentEntityMetadata.givenTableName : this.tableMetadataArgs.name;\n    this.synchronize = this.tableMetadataArgs.synchronize === false ? false : true;\n    this.targetName = typeof this.tableMetadataArgs.target === \"function\" ? this.tableMetadataArgs.target.name : this.tableMetadataArgs.target;\n\n    if (this.tableMetadataArgs.type === \"closure-junction\") {\n      this.tableNameWithoutPrefix = namingStrategy.closureJunctionTableName(this.givenTableName);\n    } else if (this.tableMetadataArgs.type === \"entity-child\" && this.parentEntityMetadata) {\n      this.tableNameWithoutPrefix = namingStrategy.tableName(this.parentEntityMetadata.targetName, this.parentEntityMetadata.givenTableName);\n    } else {\n      this.tableNameWithoutPrefix = namingStrategy.tableName(this.targetName, this.givenTableName);\n\n      if (this.tableMetadataArgs.type === \"junction\" && this.connection.driver.maxAliasLength && this.connection.driver.maxAliasLength > 0 && this.tableNameWithoutPrefix.length > this.connection.driver.maxAliasLength) {\n        // note: we are not using DriverUtils.buildAlias here because we would like to avoid\n        // hashed table names. However, current algorithm also isn't perfect, but we cannot\n        // change it, since it's a big breaking change. Planned to 0.4.0\n        this.tableNameWithoutPrefix = shorten(this.tableNameWithoutPrefix, {\n          separator: \"_\",\n          segmentLength: 3\n        });\n      }\n    }\n\n    this.tableName = entityPrefix ? namingStrategy.prefixTableName(entityPrefix, this.tableNameWithoutPrefix) : this.tableNameWithoutPrefix;\n    this.target = this.target ? this.target : this.tableName;\n    this.name = this.targetName ? this.targetName : this.tableName;\n    this.expression = this.tableMetadataArgs.expression;\n    this.withoutRowid = this.tableMetadataArgs.withoutRowid === true ? true : false;\n    this.tablePath = this.connection.driver.buildTableName(this.tableName, this.schema, this.database);\n    this.orderBy = typeof this.tableMetadataArgs.orderBy === \"function\" ? this.tableMetadataArgs.orderBy(this.propertiesMap) : this.tableMetadataArgs.orderBy; // todo: is propertiesMap available here? Looks like its not\n\n    if (entitySkipConstructor !== undefined) {\n      this.isAlwaysUsingConstructor = !entitySkipConstructor;\n    }\n\n    this.isJunction = this.tableMetadataArgs.type === \"closure-junction\" || this.tableMetadataArgs.type === \"junction\";\n    this.isClosureJunction = this.tableMetadataArgs.type === \"closure-junction\";\n  }\n  /**\n   * Registers a new column in the entity and recomputes all depend properties.\n   */\n\n\n  registerColumn(column) {\n    if (this.ownColumns.indexOf(column) !== -1) return;\n    this.ownColumns.push(column);\n    this.columns = this.embeddeds.reduce((columns, embedded) => columns.concat(embedded.columnsFromTree), this.ownColumns);\n    this.primaryColumns = this.columns.filter(column => column.isPrimary);\n    this.hasMultiplePrimaryKeys = this.primaryColumns.length > 1;\n    this.hasUUIDGeneratedColumns = this.columns.filter(column => column.isGenerated || column.generationStrategy === \"uuid\").length > 0;\n    this.propertiesMap = this.createPropertiesMap();\n    if (this.childEntityMetadatas) this.childEntityMetadatas.forEach(entityMetadata => entityMetadata.registerColumn(column));\n  }\n  /**\n   * Creates a special object - all columns and relations of the object (plus columns and relations from embeds)\n   * in a special format - { propertyName: propertyName }.\n   *\n   * example: Post{ id: number, name: string, counterEmbed: { count: number }, category: Category }.\n   * This method will create following object:\n   * { id: \"id\", counterEmbed: { count: \"counterEmbed.count\" }, category: \"category\" }\n   */\n\n\n  createPropertiesMap() {\n    const map = {};\n    this.columns.forEach(column => OrmUtils.mergeDeep(map, column.createValueMap(column.propertyPath)));\n    this.relations.forEach(relation => OrmUtils.mergeDeep(map, relation.createValueMap(relation.propertyPath)));\n    return map;\n  }\n  /**\n   * Checks if entity has any column which rely on returning data,\n   * e.g. columns with auto generated value, DEFAULT values considered as dependant of returning data.\n   * For example, if we need to have RETURNING after INSERT (or we need returned id for DBs not supporting RETURNING),\n   * it means we cannot execute bulk inserts in some cases.\n   */\n\n\n  getInsertionReturningColumns() {\n    return this.columns.filter(column => {\n      return column.default !== undefined || column.isGenerated || column.isCreateDate || column.isUpdateDate || column.isDeleteDate || column.isVersion;\n    });\n  }\n\n}","map":{"version":3,"mappings":"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","names":["CannotCreateEntityIdMapError","OrmUtils","EntityPropertyNotFoundError","ObjectUtils","shorten","EntityMetadata","constructor","options","Symbol","for","connection","inheritanceTree","inheritancePattern","treeType","tableTree","type","undefined","treeOptions","parentClosureEntityMetadata","tableMetadataArgs","args","target","tableType","expression","withoutRowid","dependsOn","create","queryRunner","pojo","ret","fromDeserializer","isAlwaysUsingConstructor","Object","prototype","typename","targetName","lazyRelations","forEach","relation","relationLoader","enableLazyLoad","hasId","entity","primaryColumns","every","primaryColumn","value","getEntityValue","hasAllPrimaryKeys","ensureEntityIdMap","id","isObject","hasMultiplePrimaryKeys","createValueMap","getEntityIdMap","getValueMap","skipNulls","getEntityIdMixedMap","idMap","compareEntities","firstEntity","secondEntity","firstEntityIdMap","secondEntityIdMap","compareIds","findColumnWithPropertyName","propertyName","columns","find","column","findColumnWithDatabaseName","databaseName","hasColumnWithPropertyPath","propertyPath","hasColumn","some","hasRelationWithPropertyPath","findColumnWithPropertyPath","relations","joinColumns","length","findColumnWithPropertyPathStrict","findColumnsWithPropertyPath","findRelationWithPropertyPath","hasEmbeddedWithPropertyPath","allEmbeddeds","embedded","findEmbeddedWithPropertyPath","mapPropertyPathsToColumns","propertyPaths","map","extractRelationValuesFromEntity","relationsAndValues","Array","isArray","subValue","push","getInverseEntityMetadata","childEntityMetadata","inverseEntityMetadata","childEntityMetadatas","metadata","createPropertyPath","prefix","paths","keys","key","parentPath","subPaths","path","difference","firstIdMaps","secondIdMaps","filter","firstIdMap","secondIdMap","reduce","getEntityValueMap","mergeDeep","build","namingStrategy","entityPrefix","entitySkipConstructor","engine","database","parentEntityMetadata","schema","_a","hasOwnProperty","givenTableName","name","synchronize","tableNameWithoutPrefix","closureJunctionTableName","tableName","driver","maxAliasLength","separator","segmentLength","prefixTableName","tablePath","buildTableName","orderBy","propertiesMap","isJunction","isClosureJunction","registerColumn","ownColumns","indexOf","embeddeds","concat","columnsFromTree","isPrimary","hasUUIDGeneratedColumns","isGenerated","generationStrategy","createPropertiesMap","entityMetadata","getInsertionReturningColumns","default","isCreateDate","isUpdateDate","isDeleteDate","isVersion"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\metadata\\EntityMetadata.ts"],"sourcesContent":["import { QueryRunner, SelectQueryBuilder } from \"..\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { CannotCreateEntityIdMapError } from \"../error/CannotCreateEntityIdMapError\"\nimport { OrderByCondition } from \"../find-options/OrderByCondition\"\nimport { TableMetadataArgs } from \"../metadata-args/TableMetadataArgs\"\nimport { TreeMetadataArgs } from \"../metadata-args/TreeMetadataArgs\"\nimport { OrmUtils } from \"../util/OrmUtils\"\nimport { CheckMetadata } from \"./CheckMetadata\"\nimport { ColumnMetadata } from \"./ColumnMetadata\"\nimport { EmbeddedMetadata } from \"./EmbeddedMetadata\"\nimport { EntityListenerMetadata } from \"./EntityListenerMetadata\"\nimport { ExclusionMetadata } from \"./ExclusionMetadata\"\nimport { ForeignKeyMetadata } from \"./ForeignKeyMetadata\"\nimport { IndexMetadata } from \"./IndexMetadata\"\nimport { RelationCountMetadata } from \"./RelationCountMetadata\"\nimport { RelationIdMetadata } from \"./RelationIdMetadata\"\nimport { RelationMetadata } from \"./RelationMetadata\"\nimport { TableType } from \"./types/TableTypes\"\nimport { TreeType } from \"./types/TreeTypes\"\nimport { UniqueMetadata } from \"./UniqueMetadata\"\nimport { ClosureTreeOptions } from \"./types/ClosureTreeOptions\"\nimport { EntityPropertyNotFoundError } from \"../error/EntityPropertyNotFoundError\"\nimport { ObjectUtils } from \"../util/ObjectUtils\"\nimport { shorten } from \"../util/StringUtils\"\n\n/**\n * Contains all entity metadata.\n */\nexport class EntityMetadata {\n    readonly \"@instanceof\" = Symbol.for(\"EntityMetadata\")\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Connection where this entity metadata is created.\n     */\n    connection: DataSource\n\n    /**\n     * Metadata arguments used to build this entity metadata.\n     */\n    tableMetadataArgs: TableMetadataArgs\n\n    /**\n     * If entity's table is a closure-typed table, then this entity will have a closure junction table metadata.\n     */\n    closureJunctionTable: EntityMetadata\n\n    /**\n     * If this is entity metadata for a junction closure table then its owner closure table metadata will be set here.\n     */\n    parentClosureEntityMetadata: EntityMetadata\n\n    /**\n     * Parent's entity metadata. Used in inheritance patterns.\n     */\n    parentEntityMetadata: EntityMetadata\n\n    /**\n     * Children entity metadatas. Used in inheritance patterns.\n     */\n    childEntityMetadatas: EntityMetadata[] = []\n\n    /**\n     * All \"inheritance tree\" from a target entity.\n     * For example for target Post < ContentModel < Unit it will be an array of [Post, ContentModel, Unit].\n     * It also contains child entities for single table inheritance.\n     */\n    inheritanceTree: Function[] = []\n\n    /**\n     * Table type. Tables can be closure, junction, etc.\n     */\n    tableType: TableType = \"regular\"\n\n    /**\n     * Target class to which this entity metadata is bind.\n     * Note, that when using table inheritance patterns target can be different rather then table's target.\n     * For virtual tables which lack of real entity (like junction tables) target is equal to their table name.\n     */\n    target: Function | string\n\n    /**\n     * Gets the name of the target.\n     */\n    targetName: string\n\n    /**\n     * Entity's name.\n     * Equal to entity target class's name if target is set to table.\n     * If target class is not then then it equals to table name.\n     */\n    name: string\n\n    /**\n     * View's expression.\n     * Used in views\n     */\n    expression?: string | ((connection: DataSource) => SelectQueryBuilder<any>)\n\n    /**\n     * View's dependencies.\n     * Used in views\n     */\n    dependsOn?: Set<Function | string>\n\n    /**\n     * Enables Sqlite \"WITHOUT ROWID\" modifier for the \"CREATE TABLE\" statement\n     */\n    withoutRowid?: boolean = false\n\n    /**\n     * Original user-given table name (taken from schema or @Entity(tableName) decorator).\n     * If user haven't specified a table name this property will be undefined.\n     */\n    givenTableName?: string\n\n    /**\n     * Entity table name in the database.\n     * This is final table name of the entity.\n     * This name already passed naming strategy, and generated based on\n     * multiple criteria, including user table name and global table prefix.\n     */\n    tableName: string\n\n    /**\n     * Entity table path. Contains database name, schema name and table name.\n     * E.g. myDB.mySchema.myTable\n     */\n    tablePath: string\n\n    /**\n     * Gets the table name without global table prefix.\n     * When querying table you need a table name with prefix, but in some scenarios,\n     * for example when you want to name a junction table that contains names of two other tables,\n     * you may want a table name without prefix.\n     */\n    tableNameWithoutPrefix: string\n\n    /**\n     * Indicates if schema will be synchronized for this entity or not.\n     */\n    synchronize: boolean = true\n\n    /**\n     * Table's database engine type (like \"InnoDB\", \"MyISAM\", etc).\n     */\n    engine?: string\n\n    /**\n     * Database name.\n     */\n    database?: string\n\n    /**\n     * Schema name. Used in Postgres and Sql Server.\n     */\n    schema?: string\n\n    /**\n     * Specifies a default order by used for queries from this table when no explicit order by is specified.\n     */\n    orderBy?: OrderByCondition\n\n    /**\n     * If this entity metadata's table using one of the inheritance patterns,\n     * then this will contain what pattern it uses.\n     */\n    inheritancePattern?: \"STI\" /*|\"CTI\"*/\n\n    /**\n     * Checks if there any non-nullable column exist in this entity.\n     */\n    hasNonNullableRelations: boolean = false\n\n    /**\n     * Indicates if this entity metadata of a junction table, or not.\n     * Junction table is a table created by many-to-many relationship.\n     *\n     * Its also possible to understand if entity is junction via tableType.\n     */\n    isJunction: boolean = false\n\n    /**\n     * Indicates if the entity should be instantiated using the constructor\n     * or via allocating a new object via `Object.create()`.\n     */\n    isAlwaysUsingConstructor: boolean = true\n\n    /**\n     * Indicates if this entity is a tree, what type of tree it is.\n     */\n    treeType?: TreeType\n\n    /**\n     * Indicates if this entity is a tree, what options of tree it has.\n     */\n    treeOptions?: ClosureTreeOptions\n\n    /**\n     * Checks if this table is a junction table of the closure table.\n     * This type is for tables that contain junction metadata of the closure tables.\n     */\n    isClosureJunction: boolean = false\n\n    /**\n     * Checks if entity's table has multiple primary columns.\n     */\n    hasMultiplePrimaryKeys: boolean = false\n\n    /**\n     * Indicates if this entity metadata has uuid generated columns.\n     */\n    hasUUIDGeneratedColumns: boolean = false\n\n    /**\n     * If this entity metadata is a child table of some table, it should have a discriminator value.\n     * Used to store a value in a discriminator column.\n     */\n    discriminatorValue?: string\n\n    /**\n     * Entity's column metadatas defined by user.\n     */\n    ownColumns: ColumnMetadata[] = []\n\n    /**\n     * Columns of the entity, including columns that are coming from the embeddeds of this entity.\n     */\n    columns: ColumnMetadata[] = []\n\n    /**\n     * Ancestor columns used only in closure junction tables.\n     */\n    ancestorColumns: ColumnMetadata[] = []\n\n    /**\n     * Descendant columns used only in closure junction tables.\n     */\n    descendantColumns: ColumnMetadata[] = []\n\n    /**\n     * All columns except for virtual columns.\n     */\n    nonVirtualColumns: ColumnMetadata[] = []\n\n    /**\n     * In the case if this entity metadata is junction table's entity metadata,\n     * this will contain all referenced columns of owner entity.\n     */\n    ownerColumns: ColumnMetadata[] = []\n\n    /**\n     * In the case if this entity metadata is junction table's entity metadata,\n     * this will contain all referenced columns of inverse entity.\n     */\n    inverseColumns: ColumnMetadata[] = []\n\n    /**\n     * Gets the column with generated flag.\n     */\n    generatedColumns: ColumnMetadata[] = []\n\n    /**\n     * Gets the object id column used with mongodb database.\n     */\n    objectIdColumn?: ColumnMetadata\n\n    /**\n     * Gets entity column which contains a create date value.\n     */\n    createDateColumn?: ColumnMetadata\n\n    /**\n     * Gets entity column which contains an update date value.\n     */\n    updateDateColumn?: ColumnMetadata\n\n    /**\n     * Gets entity column which contains a delete date value.\n     */\n    deleteDateColumn?: ColumnMetadata\n\n    /**\n     * Gets entity column which contains an entity version.\n     */\n    versionColumn?: ColumnMetadata\n\n    /**\n     * Gets the discriminator column used to store entity identificator in single-table inheritance tables.\n     */\n    discriminatorColumn?: ColumnMetadata\n\n    /**\n     * Special column that stores tree level in tree entities.\n     */\n    treeLevelColumn?: ColumnMetadata\n\n    /**\n     * Nested set's left value column.\n     * Used only in tree entities with nested set pattern applied.\n     */\n    nestedSetLeftColumn?: ColumnMetadata\n\n    /**\n     * Nested set's right value column.\n     * Used only in tree entities with nested set pattern applied.\n     */\n    nestedSetRightColumn?: ColumnMetadata\n\n    /**\n     * Materialized path column.\n     * Used only in tree entities with materialized path pattern applied.\n     */\n    materializedPathColumn?: ColumnMetadata\n\n    /**\n     * Gets the primary columns.\n     */\n    primaryColumns: ColumnMetadata[] = []\n\n    /**\n     * Entity's relation metadatas.\n     */\n    ownRelations: RelationMetadata[] = []\n\n    /**\n     * Relations of the entity, including relations that are coming from the embeddeds of this entity.\n     */\n    relations: RelationMetadata[] = []\n\n    /**\n     * List of eager relations this metadata has.\n     */\n    eagerRelations: RelationMetadata[] = []\n\n    /**\n     * List of eager relations this metadata has.\n     */\n    lazyRelations: RelationMetadata[] = []\n\n    /**\n     * Gets only one-to-one relations of the entity.\n     */\n    oneToOneRelations: RelationMetadata[] = []\n\n    /**\n     * Gets only owner one-to-one relations of the entity.\n     */\n    ownerOneToOneRelations: RelationMetadata[] = []\n\n    /**\n     * Gets only one-to-many relations of the entity.\n     */\n    oneToManyRelations: RelationMetadata[] = []\n\n    /**\n     * Gets only many-to-one relations of the entity.\n     */\n    manyToOneRelations: RelationMetadata[] = []\n\n    /**\n     * Gets only many-to-many relations of the entity.\n     */\n    manyToManyRelations: RelationMetadata[] = []\n\n    /**\n     * Gets only owner many-to-many relations of the entity.\n     */\n    ownerManyToManyRelations: RelationMetadata[] = []\n\n    /**\n     * Gets only owner one-to-one and many-to-one relations.\n     */\n    relationsWithJoinColumns: RelationMetadata[] = []\n\n    /**\n     * Tree parent relation. Used only in tree-tables.\n     */\n    treeParentRelation?: RelationMetadata\n\n    /**\n     * Tree children relation. Used only in tree-tables.\n     */\n    treeChildrenRelation?: RelationMetadata\n\n    /**\n     * Entity's relation id metadatas.\n     */\n    relationIds: RelationIdMetadata[] = []\n\n    /**\n     * Entity's relation id metadatas.\n     */\n    relationCounts: RelationCountMetadata[] = []\n\n    /**\n     * Entity's foreign key metadatas.\n     */\n    foreignKeys: ForeignKeyMetadata[] = []\n\n    /**\n     * Entity's embedded metadatas.\n     */\n    embeddeds: EmbeddedMetadata[] = []\n\n    /**\n     * All embeddeds - embeddeds from this entity metadata and from all child embeddeds, etc.\n     */\n    allEmbeddeds: EmbeddedMetadata[] = []\n\n    /**\n     * Entity's own indices.\n     */\n    ownIndices: IndexMetadata[] = []\n\n    /**\n     * Entity's index metadatas.\n     */\n    indices: IndexMetadata[] = []\n\n    /**\n     * Entity's unique metadatas.\n     */\n    uniques: UniqueMetadata[] = []\n\n    /**\n     * Entity's own uniques.\n     */\n    ownUniques: UniqueMetadata[] = []\n\n    /**\n     * Entity's check metadatas.\n     */\n    checks: CheckMetadata[] = []\n\n    /**\n     * Entity's exclusion metadatas.\n     */\n    exclusions: ExclusionMetadata[] = []\n\n    /**\n     * Entity's own listener metadatas.\n     */\n    ownListeners: EntityListenerMetadata[] = []\n\n    /**\n     * Entity listener metadatas.\n     */\n    listeners: EntityListenerMetadata[] = []\n\n    /**\n     * Listener metadatas with \"AFTER LOAD\" type.\n     */\n    afterLoadListeners: EntityListenerMetadata[] = []\n\n    /**\n     * Listener metadatas with \"AFTER INSERT\" type.\n     */\n    beforeInsertListeners: EntityListenerMetadata[] = []\n\n    /**\n     * Listener metadatas with \"AFTER INSERT\" type.\n     */\n    afterInsertListeners: EntityListenerMetadata[] = []\n\n    /**\n     * Listener metadatas with \"AFTER UPDATE\" type.\n     */\n    beforeUpdateListeners: EntityListenerMetadata[] = []\n\n    /**\n     * Listener metadatas with \"AFTER UPDATE\" type.\n     */\n    afterUpdateListeners: EntityListenerMetadata[] = []\n\n    /**\n     * Listener metadatas with \"AFTER REMOVE\" type.\n     */\n    beforeRemoveListeners: EntityListenerMetadata[] = []\n\n    /**\n     * Listener metadatas with \"BEFORE SOFT REMOVE\" type.\n     */\n    beforeSoftRemoveListeners: EntityListenerMetadata[] = []\n\n    /**\n     * Listener metadatas with \"BEFORE RECOVER\" type.\n     */\n    beforeRecoverListeners: EntityListenerMetadata[] = []\n\n    /**\n     * Listener metadatas with \"AFTER REMOVE\" type.\n     */\n    afterRemoveListeners: EntityListenerMetadata[] = []\n\n    /**\n     * Listener metadatas with \"AFTER SOFT REMOVE\" type.\n     */\n    afterSoftRemoveListeners: EntityListenerMetadata[] = []\n\n    /**\n     * Listener metadatas with \"AFTER RECOVER\" type.\n     */\n    afterRecoverListeners: EntityListenerMetadata[] = []\n\n    /**\n     * Map of columns and relations of the entity.\n     *\n     * example: Post{ id: number, name: string, counterEmbed: { count: number }, category: Category }.\n     * This method will create following object:\n     * { id: \"id\", counterEmbed: { count: \"counterEmbed.count\" }, category: \"category\" }\n     */\n    propertiesMap: ObjectLiteral\n\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(options: {\n        connection: DataSource\n        inheritanceTree?: Function[]\n        inheritancePattern?: \"STI\" /*|\"CTI\"*/\n        tableTree?: TreeMetadataArgs\n        parentClosureEntityMetadata?: EntityMetadata\n        args: TableMetadataArgs\n    }) {\n        this.connection = options.connection\n        this.inheritanceTree = options.inheritanceTree || []\n        this.inheritancePattern = options.inheritancePattern\n        this.treeType = options.tableTree ? options.tableTree.type : undefined\n        this.treeOptions = options.tableTree\n            ? options.tableTree.options\n            : undefined\n        this.parentClosureEntityMetadata = options.parentClosureEntityMetadata!\n        this.tableMetadataArgs = options.args\n        this.target = this.tableMetadataArgs.target\n        this.tableType = this.tableMetadataArgs.type\n        this.expression = this.tableMetadataArgs.expression\n        this.withoutRowid = this.tableMetadataArgs.withoutRowid\n        this.dependsOn = this.tableMetadataArgs.dependsOn\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates a new entity.\n     */\n    create(\n        queryRunner?: QueryRunner,\n        options?: { fromDeserializer?: boolean; pojo?: boolean },\n    ): any {\n        const pojo = options && options.pojo === true ? true : false\n        // if target is set to a function (e.g. class) that can be created then create it\n        let ret: any\n        if (typeof this.target === \"function\" && !pojo) {\n            if (!options?.fromDeserializer || this.isAlwaysUsingConstructor) {\n                ret = new (<any>this.target)()\n            } else {\n                ret = Object.create(this.target.prototype)\n            }\n        } else {\n            // otherwise simply return a new empty object\n            ret = {}\n        }\n\n        // add \"typename\" property\n        if (this.connection.options.typename) {\n            ret[this.connection.options.typename] = this.targetName\n        }\n\n        this.lazyRelations.forEach((relation) =>\n            this.connection.relationLoader.enableLazyLoad(\n                relation,\n                ret,\n                queryRunner,\n            ),\n        )\n        return ret\n    }\n\n    /**\n     * Checks if given entity has an id.\n     */\n    hasId(entity: ObjectLiteral): boolean {\n        if (!entity) return false\n\n        return this.primaryColumns.every((primaryColumn) => {\n            const value = primaryColumn.getEntityValue(entity)\n            return value !== null && value !== undefined && value !== \"\"\n        })\n    }\n\n    /**\n     * Checks if given entity / object contains ALL primary keys entity must have.\n     * Returns true if it contains all of them, false if at least one of them is not defined.\n     */\n    hasAllPrimaryKeys(entity: ObjectLiteral): boolean {\n        return this.primaryColumns.every((primaryColumn) => {\n            const value = primaryColumn.getEntityValue(entity)\n            return value !== null && value !== undefined\n        })\n    }\n\n    /**\n     * Ensures that given object is an entity id map.\n     * If given id is an object then it means its already id map.\n     * If given id isn't an object then it means its a value of the id column\n     * and it creates a new id map with this value and name of the primary column.\n     */\n    ensureEntityIdMap(id: any): ObjectLiteral {\n        if (ObjectUtils.isObject(id)) return id\n\n        if (this.hasMultiplePrimaryKeys)\n            throw new CannotCreateEntityIdMapError(this, id)\n\n        return this.primaryColumns[0].createValueMap(id)\n    }\n\n    /**\n     * Gets primary keys of the entity and returns them in a literal object.\n     * For example, for Post{ id: 1, title: \"hello\" } where id is primary it will return { id: 1 }\n     * For multiple primary keys it returns multiple keys in object.\n     * For primary keys inside embeds it returns complex object literal with keys in them.\n     */\n    getEntityIdMap(\n        entity: ObjectLiteral | undefined,\n    ): ObjectLiteral | undefined {\n        if (!entity) return undefined\n\n        return EntityMetadata.getValueMap(entity, this.primaryColumns, {\n            skipNulls: true,\n        })\n    }\n\n    /**\n     * Creates a \"mixed id map\".\n     * If entity has multiple primary keys (ids) then it will return just regular id map, like what getEntityIdMap returns.\n     * But if entity has a single primary key then it will return just value of the id column of the entity, just value.\n     * This is called mixed id map.\n     */\n    getEntityIdMixedMap(\n        entity: ObjectLiteral | undefined,\n    ): ObjectLiteral | undefined {\n        if (!entity) return entity\n\n        const idMap = this.getEntityIdMap(entity)\n        if (this.hasMultiplePrimaryKeys) {\n            return idMap\n        } else if (idMap) {\n            return this.primaryColumns[0].getEntityValue(idMap) // todo: what about parent primary column?\n        }\n\n        return idMap\n    }\n\n    /**\n     * Compares two different entities by their ids.\n     * Returns true if they match, false otherwise.\n     */\n    compareEntities(\n        firstEntity: ObjectLiteral,\n        secondEntity: ObjectLiteral,\n    ): boolean {\n        const firstEntityIdMap = this.getEntityIdMap(firstEntity)\n        if (!firstEntityIdMap) return false\n\n        const secondEntityIdMap = this.getEntityIdMap(secondEntity)\n        if (!secondEntityIdMap) return false\n\n        return OrmUtils.compareIds(firstEntityIdMap, secondEntityIdMap)\n    }\n\n    /**\n     * Finds column with a given property name.\n     */\n    findColumnWithPropertyName(\n        propertyName: string,\n    ): ColumnMetadata | undefined {\n        return this.columns.find(\n            (column) => column.propertyName === propertyName,\n        )\n    }\n\n    /**\n     * Finds column with a given database name.\n     */\n    findColumnWithDatabaseName(\n        databaseName: string,\n    ): ColumnMetadata | undefined {\n        return this.columns.find(\n            (column) => column.databaseName === databaseName,\n        )\n    }\n\n    /**\n     * Checks if there is a column or relationship with a given property path.\n     */\n    hasColumnWithPropertyPath(propertyPath: string): boolean {\n        const hasColumn = this.columns.some(\n            (column) => column.propertyPath === propertyPath,\n        )\n        return hasColumn || this.hasRelationWithPropertyPath(propertyPath)\n    }\n\n    /**\n     * Finds column with a given property path.\n     */\n    findColumnWithPropertyPath(\n        propertyPath: string,\n    ): ColumnMetadata | undefined {\n        const column = this.columns.find(\n            (column) => column.propertyPath === propertyPath,\n        )\n        if (column) return column\n\n        // in the case if column with property path was not found, try to find a relation with such property path\n        // if we find relation and it has a single join column then its the column user was seeking\n        const relation = this.relations.find(\n            (relation) => relation.propertyPath === propertyPath,\n        )\n        if (relation && relation.joinColumns.length === 1)\n            return relation.joinColumns[0]\n\n        return undefined\n    }\n\n    /**\n     * Finds column with a given property path.\n     * Does not search in relation unlike findColumnWithPropertyPath.\n     */\n    findColumnWithPropertyPathStrict(\n        propertyPath: string,\n    ): ColumnMetadata | undefined {\n        return this.columns.find(\n            (column) => column.propertyPath === propertyPath,\n        )\n    }\n\n    /**\n     * Finds columns with a given property path.\n     * Property path can match a relation, and relations can contain multiple columns.\n     */\n    findColumnsWithPropertyPath(propertyPath: string): ColumnMetadata[] {\n        const column = this.columns.find(\n            (column) => column.propertyPath === propertyPath,\n        )\n        if (column) return [column]\n\n        // in the case if column with property path was not found, try to find a relation with such property path\n        // if we find relation and it has a single join column then its the column user was seeking\n        const relation = this.findRelationWithPropertyPath(propertyPath)\n        if (relation && relation.joinColumns) return relation.joinColumns\n\n        return []\n    }\n\n    /**\n     * Checks if there is a relation with the given property path.\n     */\n    hasRelationWithPropertyPath(propertyPath: string): boolean {\n        return this.relations.some(\n            (relation) => relation.propertyPath === propertyPath,\n        )\n    }\n\n    /**\n     * Finds relation with the given property path.\n     */\n    findRelationWithPropertyPath(\n        propertyPath: string,\n    ): RelationMetadata | undefined {\n        return this.relations.find(\n            (relation) => relation.propertyPath === propertyPath,\n        )\n    }\n\n    /**\n     * Checks if there is an embedded with a given property path.\n     */\n    hasEmbeddedWithPropertyPath(propertyPath: string): boolean {\n        return this.allEmbeddeds.some(\n            (embedded) => embedded.propertyPath === propertyPath,\n        )\n    }\n\n    /**\n     * Finds embedded with a given property path.\n     */\n    findEmbeddedWithPropertyPath(\n        propertyPath: string,\n    ): EmbeddedMetadata | undefined {\n        return this.allEmbeddeds.find(\n            (embedded) => embedded.propertyPath === propertyPath,\n        )\n    }\n\n    /**\n     * Returns an array of databaseNames mapped from provided propertyPaths\n     */\n    mapPropertyPathsToColumns(propertyPaths: string[]) {\n        return propertyPaths.map((propertyPath) => {\n            const column = this.findColumnWithPropertyPath(propertyPath)\n            if (column == null) {\n                throw new EntityPropertyNotFoundError(propertyPath, this)\n            }\n            return column\n        })\n    }\n\n    /**\n     * Iterates through entity and finds and extracts all values from relations in the entity.\n     * If relation value is an array its being flattened.\n     */\n    extractRelationValuesFromEntity(\n        entity: ObjectLiteral,\n        relations: RelationMetadata[],\n    ): [RelationMetadata, any, EntityMetadata][] {\n        const relationsAndValues: [RelationMetadata, any, EntityMetadata][] = []\n        relations.forEach((relation) => {\n            const value = relation.getEntityValue(entity)\n            if (Array.isArray(value)) {\n                value.forEach((subValue) =>\n                    relationsAndValues.push([\n                        relation,\n                        subValue,\n                        this.getInverseEntityMetadata(subValue, relation),\n                    ]),\n                )\n            } else if (value) {\n                relationsAndValues.push([\n                    relation,\n                    value,\n                    this.getInverseEntityMetadata(value, relation),\n                ])\n            }\n        })\n        return relationsAndValues\n    }\n\n    private getInverseEntityMetadata(\n        value: any,\n        relation: RelationMetadata,\n    ): EntityMetadata {\n        const childEntityMetadata =\n            relation.inverseEntityMetadata.childEntityMetadatas.find(\n                (metadata) => metadata.target === value.constructor,\n            )\n        return childEntityMetadata\n            ? childEntityMetadata\n            : relation.inverseEntityMetadata\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Static Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates a property paths for a given entity.\n     *\n     * @deprecated\n     */\n    static createPropertyPath(\n        metadata: EntityMetadata,\n        entity: ObjectLiteral,\n        prefix: string = \"\",\n    ) {\n        const paths: string[] = []\n        Object.keys(entity).forEach((key) => {\n            // check for function is needed in the cases when createPropertyPath used on values contain a function as a value\n            // example: .update().set({ name: () => `SUBSTR('', 1, 2)` })\n            const parentPath = prefix ? prefix + \".\" + key : key\n            if (metadata.hasEmbeddedWithPropertyPath(parentPath)) {\n                const subPaths = this.createPropertyPath(\n                    metadata,\n                    entity[key],\n                    parentPath,\n                )\n                paths.push(...subPaths)\n            } else {\n                const path = prefix ? prefix + \".\" + key : key\n                paths.push(path)\n            }\n        })\n        return paths\n    }\n\n    /**\n     * Finds difference between two entity id maps.\n     * Returns items that exist in the first array and absent in the second array.\n     */\n    static difference(\n        firstIdMaps: ObjectLiteral[],\n        secondIdMaps: ObjectLiteral[],\n    ): ObjectLiteral[] {\n        return firstIdMaps.filter((firstIdMap) => {\n            return !secondIdMaps.find((secondIdMap) =>\n                OrmUtils.compareIds(firstIdMap, secondIdMap),\n            )\n        })\n    }\n\n    /**\n     * Creates value map from the given values and columns.\n     * Examples of usages are primary columns map and join columns map.\n     */\n    static getValueMap(\n        entity: ObjectLiteral,\n        columns: ColumnMetadata[],\n        options?: { skipNulls?: boolean },\n    ): ObjectLiteral | undefined {\n        return columns.reduce((map, column) => {\n            const value = column.getEntityValueMap(entity, options)\n\n            // make sure that none of the values of the columns are not missing\n            if (map === undefined || value === null || value === undefined)\n                return undefined\n\n            return OrmUtils.mergeDeep(map, value)\n        }, {} as ObjectLiteral | undefined)\n    }\n\n    // ---------------------------------------------------------------------\n    // Public Builder Methods\n    // ---------------------------------------------------------------------\n\n    build() {\n        const namingStrategy = this.connection.namingStrategy\n        const entityPrefix = this.connection.options.entityPrefix\n        const entitySkipConstructor =\n            this.connection.options.entitySkipConstructor\n\n        this.engine = this.tableMetadataArgs.engine\n        this.database =\n            this.tableMetadataArgs.type === \"entity-child\" &&\n            this.parentEntityMetadata\n                ? this.parentEntityMetadata.database\n                : this.tableMetadataArgs.database\n        if (this.tableMetadataArgs.schema) {\n            this.schema = this.tableMetadataArgs.schema\n        } else if (\n            this.tableMetadataArgs.type === \"entity-child\" &&\n            this.parentEntityMetadata\n        ) {\n            this.schema = this.parentEntityMetadata.schema\n        } else if (this.connection.options?.hasOwnProperty(\"schema\")) {\n            this.schema = (this.connection.options as any).schema\n        }\n        this.givenTableName =\n            this.tableMetadataArgs.type === \"entity-child\" &&\n            this.parentEntityMetadata\n                ? this.parentEntityMetadata.givenTableName\n                : this.tableMetadataArgs.name\n        this.synchronize =\n            this.tableMetadataArgs.synchronize === false ? false : true\n        this.targetName =\n            typeof this.tableMetadataArgs.target === \"function\"\n                ? (this.tableMetadataArgs.target as any).name\n                : this.tableMetadataArgs.target\n        if (this.tableMetadataArgs.type === \"closure-junction\") {\n            this.tableNameWithoutPrefix =\n                namingStrategy.closureJunctionTableName(this.givenTableName!)\n        } else if (\n            this.tableMetadataArgs.type === \"entity-child\" &&\n            this.parentEntityMetadata\n        ) {\n            this.tableNameWithoutPrefix = namingStrategy.tableName(\n                this.parentEntityMetadata.targetName,\n                this.parentEntityMetadata.givenTableName,\n            )\n        } else {\n            this.tableNameWithoutPrefix = namingStrategy.tableName(\n                this.targetName,\n                this.givenTableName,\n            )\n\n            if (\n                this.tableMetadataArgs.type === \"junction\" &&\n                this.connection.driver.maxAliasLength &&\n                this.connection.driver.maxAliasLength > 0 &&\n                this.tableNameWithoutPrefix.length >\n                    this.connection.driver.maxAliasLength\n            ) {\n                // note: we are not using DriverUtils.buildAlias here because we would like to avoid\n                // hashed table names. However, current algorithm also isn't perfect, but we cannot\n                // change it, since it's a big breaking change. Planned to 0.4.0\n                this.tableNameWithoutPrefix = shorten(\n                    this.tableNameWithoutPrefix,\n                    { separator: \"_\", segmentLength: 3 },\n                )\n            }\n        }\n        this.tableName = entityPrefix\n            ? namingStrategy.prefixTableName(\n                  entityPrefix,\n                  this.tableNameWithoutPrefix,\n              )\n            : this.tableNameWithoutPrefix\n        this.target = this.target ? this.target : this.tableName\n        this.name = this.targetName ? this.targetName : this.tableName\n        this.expression = this.tableMetadataArgs.expression\n        this.withoutRowid =\n            this.tableMetadataArgs.withoutRowid === true ? true : false\n        this.tablePath = this.connection.driver.buildTableName(\n            this.tableName,\n            this.schema,\n            this.database,\n        )\n        this.orderBy =\n            typeof this.tableMetadataArgs.orderBy === \"function\"\n                ? this.tableMetadataArgs.orderBy(this.propertiesMap)\n                : this.tableMetadataArgs.orderBy // todo: is propertiesMap available here? Looks like its not\n\n        if (entitySkipConstructor !== undefined) {\n            this.isAlwaysUsingConstructor = !entitySkipConstructor\n        }\n\n        this.isJunction =\n            this.tableMetadataArgs.type === \"closure-junction\" ||\n            this.tableMetadataArgs.type === \"junction\"\n        this.isClosureJunction =\n            this.tableMetadataArgs.type === \"closure-junction\"\n    }\n\n    /**\n     * Registers a new column in the entity and recomputes all depend properties.\n     */\n    registerColumn(column: ColumnMetadata) {\n        if (this.ownColumns.indexOf(column) !== -1) return\n\n        this.ownColumns.push(column)\n        this.columns = this.embeddeds.reduce(\n            (columns, embedded) => columns.concat(embedded.columnsFromTree),\n            this.ownColumns,\n        )\n        this.primaryColumns = this.columns.filter((column) => column.isPrimary)\n        this.hasMultiplePrimaryKeys = this.primaryColumns.length > 1\n        this.hasUUIDGeneratedColumns =\n            this.columns.filter(\n                (column) =>\n                    column.isGenerated || column.generationStrategy === \"uuid\",\n            ).length > 0\n        this.propertiesMap = this.createPropertiesMap()\n        if (this.childEntityMetadatas)\n            this.childEntityMetadatas.forEach((entityMetadata) =>\n                entityMetadata.registerColumn(column),\n            )\n    }\n\n    /**\n     * Creates a special object - all columns and relations of the object (plus columns and relations from embeds)\n     * in a special format - { propertyName: propertyName }.\n     *\n     * example: Post{ id: number, name: string, counterEmbed: { count: number }, category: Category }.\n     * This method will create following object:\n     * { id: \"id\", counterEmbed: { count: \"counterEmbed.count\" }, category: \"category\" }\n     */\n    createPropertiesMap(): { [name: string]: string | any } {\n        const map: { [name: string]: string | any } = {}\n        this.columns.forEach((column) =>\n            OrmUtils.mergeDeep(map, column.createValueMap(column.propertyPath)),\n        )\n        this.relations.forEach((relation) =>\n            OrmUtils.mergeDeep(\n                map,\n                relation.createValueMap(relation.propertyPath),\n            ),\n        )\n        return map\n    }\n\n    /**\n     * Checks if entity has any column which rely on returning data,\n     * e.g. columns with auto generated value, DEFAULT values considered as dependant of returning data.\n     * For example, if we need to have RETURNING after INSERT (or we need returned id for DBs not supporting RETURNING),\n     * it means we cannot execute bulk inserts in some cases.\n     */\n    getInsertionReturningColumns(): ColumnMetadata[] {\n        return this.columns.filter((column) => {\n            return (\n                column.default !== undefined ||\n                column.isGenerated ||\n                column.isCreateDate ||\n                column.isUpdateDate ||\n                column.isDeleteDate ||\n                column.isVersion\n            )\n        })\n    }\n}\n"]},"metadata":{},"sourceType":"module"}