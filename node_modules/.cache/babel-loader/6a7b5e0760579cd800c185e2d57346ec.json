{"ast":null,"code":"/**\n * Provides utilities for manipulating tree structures.\n *\n */\nexport class TreeRepositoryUtils {\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  static createRelationMaps(manager, metadata, alias, rawResults) {\n    return rawResults.map(rawResult => {\n      const joinColumn = metadata.treeParentRelation.joinColumns[0]; // fixes issue #2518, default to databaseName property when givenDatabaseName is not set\n\n      const joinColumnName = joinColumn.givenDatabaseName || joinColumn.databaseName;\n      const id = rawResult[alias + \"_\" + metadata.primaryColumns[0].databaseName];\n      const parentId = rawResult[alias + \"_\" + joinColumnName];\n      return {\n        id: manager.connection.driver.prepareHydratedValue(id, metadata.primaryColumns[0]),\n        parentId: manager.connection.driver.prepareHydratedValue(parentId, joinColumn)\n      };\n    });\n  }\n\n  static buildChildrenEntityTree(metadata, entity, entities, relationMaps, options) {\n    const childProperty = metadata.treeChildrenRelation.propertyName;\n\n    if (options.depth === 0) {\n      entity[childProperty] = [];\n      return;\n    }\n\n    const parentEntityId = metadata.primaryColumns[0].getEntityValue(entity);\n    const childRelationMaps = relationMaps.filter(relationMap => relationMap.parentId === parentEntityId);\n    const childIds = new Set(childRelationMaps.map(relationMap => relationMap.id));\n    entity[childProperty] = entities.filter(entity => childIds.has(metadata.primaryColumns[0].getEntityValue(entity)));\n    entity[childProperty].forEach(childEntity => {\n      TreeRepositoryUtils.buildChildrenEntityTree(metadata, childEntity, entities, relationMaps, { ...options,\n        depth: options.depth - 1\n      });\n    });\n  }\n\n  static buildParentEntityTree(metadata, entity, entities, relationMaps) {\n    const parentProperty = metadata.treeParentRelation.propertyName;\n    const entityId = metadata.primaryColumns[0].getEntityValue(entity);\n    const parentRelationMap = relationMaps.find(relationMap => relationMap.id === entityId);\n    const parentEntity = entities.find(entity => {\n      if (!parentRelationMap) return false;\n      return metadata.primaryColumns[0].getEntityValue(entity) === parentRelationMap.parentId;\n    });\n\n    if (parentEntity) {\n      entity[parentProperty] = parentEntity;\n      TreeRepositoryUtils.buildParentEntityTree(metadata, entity[parentProperty], entities, relationMaps);\n    }\n  }\n\n}","map":{"version":3,"mappings":"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","names":["TreeRepositoryUtils","createRelationMaps","manager","metadata","alias","rawResults","map","rawResult","joinColumn","treeParentRelation","joinColumns","joinColumnName","givenDatabaseName","databaseName","id","primaryColumns","parentId","connection","driver","prepareHydratedValue","buildChildrenEntityTree","entity","entities","relationMaps","options","childProperty","treeChildrenRelation","propertyName","depth","parentEntityId","getEntityValue","childRelationMaps","filter","relationMap","childIds","Set","has","forEach","childEntity","buildParentEntityTree","parentProperty","entityId","parentRelationMap","find","parentEntity"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\util\\TreeRepositoryUtils.ts"],"sourcesContent":["import { EntityManager } from \"../entity-manager/EntityManager\"\nimport { EntityMetadata } from \"../metadata/EntityMetadata\"\nimport { FindTreesOptions } from \"../repository/FindTreesOptions\"\n\n/**\n * Provides utilities for manipulating tree structures.\n *\n */\nexport class TreeRepositoryUtils {\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    static createRelationMaps(\n        manager: EntityManager,\n        metadata: EntityMetadata,\n        alias: string,\n        rawResults: any[],\n    ): { id: any; parentId: any }[] {\n        return rawResults.map((rawResult) => {\n            const joinColumn = metadata.treeParentRelation!.joinColumns[0]\n            // fixes issue #2518, default to databaseName property when givenDatabaseName is not set\n            const joinColumnName =\n                joinColumn.givenDatabaseName || joinColumn.databaseName\n            const id =\n                rawResult[alias + \"_\" + metadata.primaryColumns[0].databaseName]\n            const parentId = rawResult[alias + \"_\" + joinColumnName]\n            return {\n                id: manager.connection.driver.prepareHydratedValue(\n                    id,\n                    metadata.primaryColumns[0],\n                ),\n                parentId: manager.connection.driver.prepareHydratedValue(\n                    parentId,\n                    joinColumn,\n                ),\n            }\n        })\n    }\n\n    static buildChildrenEntityTree(\n        metadata: EntityMetadata,\n        entity: any,\n        entities: any[],\n        relationMaps: { id: any; parentId: any }[],\n        options: FindTreesOptions & { depth: number },\n    ): void {\n        const childProperty = metadata.treeChildrenRelation!.propertyName\n        if (options.depth === 0) {\n            entity[childProperty] = []\n            return\n        }\n        const parentEntityId = metadata.primaryColumns[0].getEntityValue(entity)\n        const childRelationMaps = relationMaps.filter(\n            (relationMap) => relationMap.parentId === parentEntityId,\n        )\n        const childIds = new Set(\n            childRelationMaps.map((relationMap) => relationMap.id),\n        )\n        entity[childProperty] = entities.filter((entity) =>\n            childIds.has(metadata.primaryColumns[0].getEntityValue(entity)),\n        )\n        entity[childProperty].forEach((childEntity: any) => {\n            TreeRepositoryUtils.buildChildrenEntityTree(\n                metadata,\n                childEntity,\n                entities,\n                relationMaps,\n                {\n                    ...options,\n                    depth: options.depth - 1,\n                },\n            )\n        })\n    }\n\n    static buildParentEntityTree(\n        metadata: EntityMetadata,\n        entity: any,\n        entities: any[],\n        relationMaps: { id: any; parentId: any }[],\n    ): void {\n        const parentProperty = metadata.treeParentRelation!.propertyName\n        const entityId = metadata.primaryColumns[0].getEntityValue(entity)\n        const parentRelationMap = relationMaps.find(\n            (relationMap) => relationMap.id === entityId,\n        )\n        const parentEntity = entities.find((entity) => {\n            if (!parentRelationMap) return false\n\n            return (\n                metadata.primaryColumns[0].getEntityValue(entity) ===\n                parentRelationMap.parentId\n            )\n        })\n        if (parentEntity) {\n            entity[parentProperty] = parentEntity\n            TreeRepositoryUtils.buildParentEntityTree(\n                metadata,\n                entity[parentProperty],\n                entities,\n                relationMaps,\n            )\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}