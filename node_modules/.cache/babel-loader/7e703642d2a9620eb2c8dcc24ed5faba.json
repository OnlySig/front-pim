{"ast":null,"code":"import { ObjectUtils } from \"../util/ObjectUtils\";\n/**\n * Allows to work with entity relations and perform specific operations with those relations.\n *\n * todo: add transactions everywhere\n */\n\nexport class RelationRemover {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(queryBuilder, expressionMap) {\n    this.queryBuilder = queryBuilder;\n    this.expressionMap = expressionMap;\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Performs remove operation on a relation.\n   */\n\n\n  async remove(value) {\n    const relation = this.expressionMap.relationMetadata;\n\n    if (relation.isOneToMany) {\n      // if (this.expressionMap.of instanceof Array)\n      //     throw new TypeORMError(`You cannot update relations of multiple entities with the same related object. Provide a single entity into .of method.`);\n      // DELETE FROM post WHERE post.categoryId = of AND post.id = id\n      const ofs = Array.isArray(this.expressionMap.of) ? this.expressionMap.of : [this.expressionMap.of];\n      const values = Array.isArray(value) ? value : [value];\n      const updateSet = {};\n      relation.inverseRelation.joinColumns.forEach(column => {\n        updateSet[column.propertyName] = null;\n      });\n      const parameters = {};\n      const conditions = [];\n      ofs.forEach((of, ofIndex) => {\n        conditions.push(...values.map((value, valueIndex) => {\n          return [...relation.inverseRelation.joinColumns.map((column, columnIndex) => {\n            const parameterName = \"joinColumn_\" + ofIndex + \"_\" + valueIndex + \"_\" + columnIndex;\n            parameters[parameterName] = ObjectUtils.isObject(of) ? column.referencedColumn.getEntityValue(of) : of;\n            return `${column.propertyPath} = :${parameterName}`;\n          }), ...relation.inverseRelation.entityMetadata.primaryColumns.map((column, columnIndex) => {\n            const parameterName = \"primaryColumn_\" + valueIndex + \"_\" + valueIndex + \"_\" + columnIndex;\n            parameters[parameterName] = ObjectUtils.isObject(value) ? column.getEntityValue(value) : value;\n            return `${column.propertyPath} = :${parameterName}`;\n          })].join(\" AND \");\n        }));\n      });\n      const condition = conditions.map(str => \"(\" + str + \")\").join(\" OR \");\n      if (!condition) return;\n      await this.queryBuilder.createQueryBuilder().update(relation.inverseEntityMetadata.target).set(updateSet).where(condition).setParameters(parameters).execute();\n    } else {\n      // many to many\n      const junctionMetadata = relation.junctionEntityMetadata;\n      const ofs = Array.isArray(this.expressionMap.of) ? this.expressionMap.of : [this.expressionMap.of];\n      const values = Array.isArray(value) ? value : [value];\n      const firstColumnValues = relation.isManyToManyOwner ? ofs : values;\n      const secondColumnValues = relation.isManyToManyOwner ? values : ofs;\n      const parameters = {};\n      const conditions = [];\n      firstColumnValues.forEach((firstColumnVal, firstColumnValIndex) => {\n        conditions.push(...secondColumnValues.map((secondColumnVal, secondColumnValIndex) => {\n          return [...junctionMetadata.ownerColumns.map((column, columnIndex) => {\n            const parameterName = \"firstValue_\" + firstColumnValIndex + \"_\" + secondColumnValIndex + \"_\" + columnIndex;\n            parameters[parameterName] = ObjectUtils.isObject(firstColumnVal) ? column.referencedColumn.getEntityValue(firstColumnVal) : firstColumnVal;\n            return `${column.databaseName} = :${parameterName}`;\n          }), ...junctionMetadata.inverseColumns.map((column, columnIndex) => {\n            const parameterName = \"secondValue_\" + firstColumnValIndex + \"_\" + secondColumnValIndex + \"_\" + columnIndex;\n            parameters[parameterName] = ObjectUtils.isObject(secondColumnVal) ? column.referencedColumn.getEntityValue(secondColumnVal) : secondColumnVal;\n            return `${column.databaseName} = :${parameterName}`;\n          })].join(\" AND \");\n        }));\n      });\n      const condition = conditions.map(str => \"(\" + str + \")\").join(\" OR \");\n      await this.queryBuilder.createQueryBuilder().delete().from(junctionMetadata.tableName).where(condition).setParameters(parameters).execute();\n    }\n  }\n\n}","map":{"version":3,"mappings":"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","names":["ObjectUtils","RelationRemover","constructor","queryBuilder","expressionMap","remove","value","relation","relationMetadata","isOneToMany","ofs","Array","isArray","of","values","updateSet","inverseRelation","joinColumns","forEach","column","propertyName","parameters","conditions","ofIndex","push","map","valueIndex","columnIndex","parameterName","isObject","referencedColumn","getEntityValue","propertyPath","entityMetadata","primaryColumns","join","condition","str","createQueryBuilder","update","inverseEntityMetadata","target","set","where","setParameters","execute","junctionMetadata","junctionEntityMetadata","firstColumnValues","isManyToManyOwner","secondColumnValues","firstColumnVal","firstColumnValIndex","secondColumnVal","secondColumnValIndex","ownerColumns","databaseName","inverseColumns","delete","from","tableName"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\query-builder\\RelationRemover.ts"],"sourcesContent":["import { QueryBuilder } from \"./QueryBuilder\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { QueryExpressionMap } from \"./QueryExpressionMap\"\nimport { ObjectUtils } from \"../util/ObjectUtils\"\n\n/**\n * Allows to work with entity relations and perform specific operations with those relations.\n *\n * todo: add transactions everywhere\n */\nexport class RelationRemover {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        protected queryBuilder: QueryBuilder<any>,\n        protected expressionMap: QueryExpressionMap,\n    ) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Performs remove operation on a relation.\n     */\n    async remove(value: any | any[]): Promise<void> {\n        const relation = this.expressionMap.relationMetadata\n\n        if (relation.isOneToMany) {\n            // if (this.expressionMap.of instanceof Array)\n            //     throw new TypeORMError(`You cannot update relations of multiple entities with the same related object. Provide a single entity into .of method.`);\n\n            // DELETE FROM post WHERE post.categoryId = of AND post.id = id\n            const ofs = Array.isArray(this.expressionMap.of)\n                ? this.expressionMap.of\n                : [this.expressionMap.of]\n            const values = Array.isArray(value) ? value : [value]\n\n            const updateSet: ObjectLiteral = {}\n            relation.inverseRelation!.joinColumns.forEach((column) => {\n                updateSet[column.propertyName] = null\n            })\n\n            const parameters: ObjectLiteral = {}\n            const conditions: string[] = []\n            ofs.forEach((of, ofIndex) => {\n                conditions.push(\n                    ...values.map((value, valueIndex) => {\n                        return [\n                            ...relation.inverseRelation!.joinColumns.map(\n                                (column, columnIndex) => {\n                                    const parameterName =\n                                        \"joinColumn_\" +\n                                        ofIndex +\n                                        \"_\" +\n                                        valueIndex +\n                                        \"_\" +\n                                        columnIndex\n                                    parameters[parameterName] =\n                                        ObjectUtils.isObject(of)\n                                            ? column.referencedColumn!.getEntityValue(\n                                                  of,\n                                              )\n                                            : of\n                                    return `${column.propertyPath} = :${parameterName}`\n                                },\n                            ),\n                            ...relation.inverseRelation!.entityMetadata.primaryColumns.map(\n                                (column, columnIndex) => {\n                                    const parameterName =\n                                        \"primaryColumn_\" +\n                                        valueIndex +\n                                        \"_\" +\n                                        valueIndex +\n                                        \"_\" +\n                                        columnIndex\n                                    parameters[parameterName] =\n                                        ObjectUtils.isObject(value)\n                                            ? column.getEntityValue(value)\n                                            : value\n                                    return `${column.propertyPath} = :${parameterName}`\n                                },\n                            ),\n                        ].join(\" AND \")\n                    }),\n                )\n            })\n            const condition = conditions\n                .map((str) => \"(\" + str + \")\")\n                .join(\" OR \")\n            if (!condition) return\n\n            await this.queryBuilder\n                .createQueryBuilder()\n                .update(relation.inverseEntityMetadata.target)\n                .set(updateSet)\n                .where(condition)\n                .setParameters(parameters)\n                .execute()\n        } else {\n            // many to many\n\n            const junctionMetadata = relation.junctionEntityMetadata!\n            const ofs = Array.isArray(this.expressionMap.of)\n                ? this.expressionMap.of\n                : [this.expressionMap.of]\n            const values = Array.isArray(value) ? value : [value]\n            const firstColumnValues = relation.isManyToManyOwner ? ofs : values\n            const secondColumnValues = relation.isManyToManyOwner ? values : ofs\n\n            const parameters: ObjectLiteral = {}\n            const conditions: string[] = []\n            firstColumnValues.forEach((firstColumnVal, firstColumnValIndex) => {\n                conditions.push(\n                    ...secondColumnValues.map(\n                        (secondColumnVal, secondColumnValIndex) => {\n                            return [\n                                ...junctionMetadata.ownerColumns.map(\n                                    (column, columnIndex) => {\n                                        const parameterName =\n                                            \"firstValue_\" +\n                                            firstColumnValIndex +\n                                            \"_\" +\n                                            secondColumnValIndex +\n                                            \"_\" +\n                                            columnIndex\n                                        parameters[parameterName] =\n                                            ObjectUtils.isObject(firstColumnVal)\n                                                ? column.referencedColumn!.getEntityValue(\n                                                      firstColumnVal,\n                                                  )\n                                                : firstColumnVal\n                                        return `${column.databaseName} = :${parameterName}`\n                                    },\n                                ),\n                                ...junctionMetadata.inverseColumns.map(\n                                    (column, columnIndex) => {\n                                        const parameterName =\n                                            \"secondValue_\" +\n                                            firstColumnValIndex +\n                                            \"_\" +\n                                            secondColumnValIndex +\n                                            \"_\" +\n                                            columnIndex\n                                        parameters[parameterName] =\n                                            ObjectUtils.isObject(\n                                                secondColumnVal,\n                                            )\n                                                ? column.referencedColumn!.getEntityValue(\n                                                      secondColumnVal,\n                                                  )\n                                                : secondColumnVal\n                                        return `${column.databaseName} = :${parameterName}`\n                                    },\n                                ),\n                            ].join(\" AND \")\n                        },\n                    ),\n                )\n            })\n            const condition = conditions\n                .map((str) => \"(\" + str + \")\")\n                .join(\" OR \")\n\n            await this.queryBuilder\n                .createQueryBuilder()\n                .delete()\n                .from(junctionMetadata.tableName)\n                .where(condition)\n                .setParameters(parameters)\n                .execute()\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}