{"ast":null,"code":"import { QueryBuilderUtils } from \"../QueryBuilderUtils\";\nimport { ObjectUtils } from \"../../util/ObjectUtils\";\nimport { TypeORMError } from \"../../error/TypeORMError\";\n/**\n * Stores all join relation id attributes which will be used to build a JOIN query.\n */\n\nexport class RelationIdAttribute {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(queryExpressionMap, relationIdAttribute) {\n    this.queryExpressionMap = queryExpressionMap;\n    /**\n     * Indicates if relation id should NOT be loaded as id map.\n     */\n\n    this.disableMixedMap = false;\n    ObjectUtils.assign(this, relationIdAttribute || {});\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n\n  get joinInverseSideMetadata() {\n    return this.relation.inverseEntityMetadata;\n  }\n  /**\n   * Alias of the parent of this join.\n   * For example, if we join (\"post.category\", \"categoryAlias\") then \"post\" is a parent alias.\n   * This value is extracted from entityOrProperty value.\n   * This is available when join was made using \"post.category\" syntax.\n   */\n\n\n  get parentAlias() {\n    if (!QueryBuilderUtils.isAliasProperty(this.relationName)) throw new TypeORMError(`Given value must be a string representation of alias property`);\n    return this.relationName.substr(0, this.relationName.indexOf(\".\"));\n  }\n  /**\n   * Relation property name of the parent.\n   * This is used to understand what is joined.\n   * For example, if we join (\"post.category\", \"categoryAlias\") then \"category\" is a relation property.\n   * This value is extracted from entityOrProperty value.\n   * This is available when join was made using \"post.category\" syntax.\n   */\n\n\n  get relationPropertyPath() {\n    if (!QueryBuilderUtils.isAliasProperty(this.relationName)) throw new TypeORMError(`Given value must be a string representation of alias property`);\n    return this.relationName.substr(this.relationName.indexOf(\".\") + 1);\n  }\n  /**\n   * Relation of the parent.\n   * This is used to understand what is joined.\n   * This is available when join was made using \"post.category\" syntax.\n   */\n\n\n  get relation() {\n    if (!QueryBuilderUtils.isAliasProperty(this.relationName)) throw new TypeORMError(`Given value must be a string representation of alias property`);\n    const relationOwnerSelection = this.queryExpressionMap.findAliasByName(this.parentAlias);\n    const relation = relationOwnerSelection.metadata.findRelationWithPropertyPath(this.relationPropertyPath);\n    if (!relation) throw new TypeORMError(`Relation with property path ${this.relationPropertyPath} in entity was not found.`);\n    return relation;\n  }\n  /**\n   * Generates alias of junction table, whose ids we get.\n   */\n\n\n  get junctionAlias() {\n    const [parentAlias, relationProperty] = this.relationName.split(\".\");\n    return parentAlias + \"_\" + relationProperty + \"_rid\";\n  }\n  /**\n   * Metadata of the joined entity.\n   * If extra condition without entity was joined, then it will return undefined.\n   */\n\n\n  get junctionMetadata() {\n    return this.relation.junctionEntityMetadata;\n  }\n\n  get mapToPropertyParentAlias() {\n    return this.mapToProperty.substr(0, this.mapToProperty.indexOf(\".\"));\n  }\n\n  get mapToPropertyPropertyPath() {\n    return this.mapToProperty.substr(this.mapToProperty.indexOf(\".\") + 1);\n  }\n\n}","map":{"version":3,"mappings":"AACA,SAASA,iBAAT,QAAkC,sBAAlC;AAIA,SAASC,WAAT,QAA4B,wBAA5B;AACA,SAASC,YAAT,QAA6B,0BAA7B;AAEA;;;;AAGA,OAAM,MAAOC,mBAAP,CAA0B;EAgC5B;EACA;EACA;EAEAC,YACYC,kBADZ,EAEIC,mBAFJ,EAEsD;IAD1C;IAVZ;;;;IAGA,uBAAkB,KAAlB;IAUIL,WAAW,CAACM,MAAZ,CAAmB,IAAnB,EAAyBD,mBAAmB,IAAI,EAAhD;EACH,CAzC2B,CA2C5B;EACA;EACA;;;EAE2B,IAAvBE,uBAAuB;IACvB,OAAO,KAAKC,QAAL,CAAcC,qBAArB;EACH;EAED;;;;;;;;EAMe,IAAXC,WAAW;IACX,IAAI,CAACX,iBAAiB,CAACY,eAAlB,CAAkC,KAAKC,YAAvC,CAAL,EACI,MAAM,IAAIX,YAAJ,CACF,+DADE,CAAN;IAIJ,OAAO,KAAKW,YAAL,CAAkBC,MAAlB,CAAyB,CAAzB,EAA4B,KAAKD,YAAL,CAAkBE,OAAlB,CAA0B,GAA1B,CAA5B,CAAP;EACH;EAED;;;;;;;;;EAOwB,IAApBC,oBAAoB;IACpB,IAAI,CAAChB,iBAAiB,CAACY,eAAlB,CAAkC,KAAKC,YAAvC,CAAL,EACI,MAAM,IAAIX,YAAJ,CACF,+DADE,CAAN;IAIJ,OAAO,KAAKW,YAAL,CAAkBC,MAAlB,CAAyB,KAAKD,YAAL,CAAkBE,OAAlB,CAA0B,GAA1B,IAAiC,CAA1D,CAAP;EACH;EAED;;;;;;;EAKY,IAARN,QAAQ;IACR,IAAI,CAACT,iBAAiB,CAACY,eAAlB,CAAkC,KAAKC,YAAvC,CAAL,EACI,MAAM,IAAIX,YAAJ,CACF,+DADE,CAAN;IAIJ,MAAMe,sBAAsB,GAAG,KAAKZ,kBAAL,CAAwBa,eAAxB,CAC3B,KAAKP,WADsB,CAA/B;IAGA,MAAMF,QAAQ,GACVQ,sBAAsB,CAACE,QAAvB,CAAgCC,4BAAhC,CACI,KAAKJ,oBADT,CADJ;IAIA,IAAI,CAACP,QAAL,EACI,MAAM,IAAIP,YAAJ,CACF,+BAA+B,KAAKc,oBAAoB,2BADtD,CAAN;IAGJ,OAAOP,QAAP;EACH;EAED;;;;;EAGiB,IAAbY,aAAa;IACb,MAAM,CAACV,WAAD,EAAcW,gBAAd,IAAkC,KAAKT,YAAL,CAAkBU,KAAlB,CAAwB,GAAxB,CAAxC;IACA,OAAOZ,WAAW,GAAG,GAAd,GAAoBW,gBAApB,GAAuC,MAA9C;EACH;EAED;;;;;;EAIoB,IAAhBE,gBAAgB;IAChB,OAAO,KAAKf,QAAL,CAAcgB,sBAArB;EACH;;EAE2B,IAAxBC,wBAAwB;IACxB,OAAO,KAAKC,aAAL,CAAmBb,MAAnB,CAA0B,CAA1B,EAA6B,KAAKa,aAAL,CAAmBZ,OAAnB,CAA2B,GAA3B,CAA7B,CAAP;EACH;;EAE4B,IAAzBa,yBAAyB;IACzB,OAAO,KAAKD,aAAL,CAAmBb,MAAnB,CAA0B,KAAKa,aAAL,CAAmBZ,OAAnB,CAA2B,GAA3B,IAAkC,CAA5D,CAAP;EACH;;AAjI2B","names":["QueryBuilderUtils","ObjectUtils","TypeORMError","RelationIdAttribute","constructor","queryExpressionMap","relationIdAttribute","assign","joinInverseSideMetadata","relation","inverseEntityMetadata","parentAlias","isAliasProperty","relationName","substr","indexOf","relationPropertyPath","relationOwnerSelection","findAliasByName","metadata","findRelationWithPropertyPath","junctionAlias","relationProperty","split","junctionMetadata","junctionEntityMetadata","mapToPropertyParentAlias","mapToProperty","mapToPropertyPropertyPath"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\query-builder\\relation-id\\RelationIdAttribute.ts"],"sourcesContent":["import { RelationMetadata } from \"../../metadata/RelationMetadata\"\nimport { QueryBuilderUtils } from \"../QueryBuilderUtils\"\nimport { EntityMetadata } from \"../../metadata/EntityMetadata\"\nimport { QueryExpressionMap } from \"../QueryExpressionMap\"\nimport { SelectQueryBuilder } from \"../SelectQueryBuilder\"\nimport { ObjectUtils } from \"../../util/ObjectUtils\"\nimport { TypeORMError } from \"../../error/TypeORMError\"\n\n/**\n * Stores all join relation id attributes which will be used to build a JOIN query.\n */\nexport class RelationIdAttribute {\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Alias of the joined (destination) table.\n     */\n    alias?: string\n\n    /**\n     * Name of relation.\n     */\n    relationName: string\n\n    /**\n     * Property + alias of the object where to joined data should be mapped.\n     */\n    mapToProperty: string\n\n    /**\n     * Extra condition applied to \"ON\" section of join.\n     */\n    queryBuilderFactory?: (\n        qb: SelectQueryBuilder<any>,\n    ) => SelectQueryBuilder<any>\n\n    /**\n     * Indicates if relation id should NOT be loaded as id map.\n     */\n    disableMixedMap = false\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        private queryExpressionMap: QueryExpressionMap,\n        relationIdAttribute?: Partial<RelationIdAttribute>,\n    ) {\n        ObjectUtils.assign(this, relationIdAttribute || {})\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    get joinInverseSideMetadata(): EntityMetadata {\n        return this.relation.inverseEntityMetadata\n    }\n\n    /**\n     * Alias of the parent of this join.\n     * For example, if we join (\"post.category\", \"categoryAlias\") then \"post\" is a parent alias.\n     * This value is extracted from entityOrProperty value.\n     * This is available when join was made using \"post.category\" syntax.\n     */\n    get parentAlias(): string {\n        if (!QueryBuilderUtils.isAliasProperty(this.relationName))\n            throw new TypeORMError(\n                `Given value must be a string representation of alias property`,\n            )\n\n        return this.relationName.substr(0, this.relationName.indexOf(\".\"))\n    }\n\n    /**\n     * Relation property name of the parent.\n     * This is used to understand what is joined.\n     * For example, if we join (\"post.category\", \"categoryAlias\") then \"category\" is a relation property.\n     * This value is extracted from entityOrProperty value.\n     * This is available when join was made using \"post.category\" syntax.\n     */\n    get relationPropertyPath(): string {\n        if (!QueryBuilderUtils.isAliasProperty(this.relationName))\n            throw new TypeORMError(\n                `Given value must be a string representation of alias property`,\n            )\n\n        return this.relationName.substr(this.relationName.indexOf(\".\") + 1)\n    }\n\n    /**\n     * Relation of the parent.\n     * This is used to understand what is joined.\n     * This is available when join was made using \"post.category\" syntax.\n     */\n    get relation(): RelationMetadata {\n        if (!QueryBuilderUtils.isAliasProperty(this.relationName))\n            throw new TypeORMError(\n                `Given value must be a string representation of alias property`,\n            )\n\n        const relationOwnerSelection = this.queryExpressionMap.findAliasByName(\n            this.parentAlias!,\n        )\n        const relation =\n            relationOwnerSelection.metadata.findRelationWithPropertyPath(\n                this.relationPropertyPath!,\n            )\n        if (!relation)\n            throw new TypeORMError(\n                `Relation with property path ${this.relationPropertyPath} in entity was not found.`,\n            )\n        return relation\n    }\n\n    /**\n     * Generates alias of junction table, whose ids we get.\n     */\n    get junctionAlias(): string {\n        const [parentAlias, relationProperty] = this.relationName.split(\".\")\n        return parentAlias + \"_\" + relationProperty + \"_rid\"\n    }\n\n    /**\n     * Metadata of the joined entity.\n     * If extra condition without entity was joined, then it will return undefined.\n     */\n    get junctionMetadata(): EntityMetadata {\n        return this.relation.junctionEntityMetadata!\n    }\n\n    get mapToPropertyParentAlias(): string {\n        return this.mapToProperty.substr(0, this.mapToProperty.indexOf(\".\"))\n    }\n\n    get mapToPropertyPropertyPath(): string {\n        return this.mapToProperty.substr(this.mapToProperty.indexOf(\".\") + 1)\n    }\n}\n"]},"metadata":{},"sourceType":"module"}