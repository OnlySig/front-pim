{"ast":null,"code":"/**\n * This source code is from https://github.com/jriecken/dependency-graph\n * Just added \"any\" types here, wrapper everything into exported class.\n * We cant use a package itself because we want to package \"everything-in-it\" for the frontend users of TypeORM.\n */\n\n/**\n * A simple dependency graph\n */\nimport { TypeORMError } from \"../error\";\n/**\n * Helper for creating a Depth-First-Search on\n * a set of edges.\n *\n * Detects cycles and throws an Error if one is detected.\n *\n * @param edges The set of edges to DFS through\n * @param leavesOnly Whether to only return \"leaf\" nodes (ones who have no edges)\n * @param result An array in which the results will be populated\n */\n\nfunction createDFS(edges, leavesOnly, result) {\n  let currentPath = [];\n  let visited = {};\n  return function DFS(currentNode) {\n    visited[currentNode] = true;\n    currentPath.push(currentNode);\n    edges[currentNode].forEach(function (node) {\n      if (!visited[node]) {\n        DFS(node);\n      } else if (currentPath.indexOf(node) >= 0) {\n        currentPath.push(node);\n        throw new TypeORMError(`Dependency Cycle Found: ${currentPath.join(\" -> \")}`);\n      }\n    });\n    currentPath.pop();\n\n    if ((!leavesOnly || edges[currentNode].length === 0) && result.indexOf(currentNode) === -1) {\n      result.push(currentNode);\n    }\n  };\n}\n\nexport class DepGraph {\n  constructor() {\n    this.nodes = {};\n    this.outgoingEdges = {}; // Node -> [Dependency Node]\n\n    this.incomingEdges = {}; // Node -> [Dependant Node]\n  }\n  /**\n   * Add a node to the dependency graph. If a node already exists, this method will do nothing.\n   */\n\n\n  addNode(node, data) {\n    if (!this.hasNode(node)) {\n      // Checking the arguments length allows the user to add a node with undefined data\n      if (arguments.length === 2) {\n        this.nodes[node] = data;\n      } else {\n        this.nodes[node] = node;\n      }\n\n      this.outgoingEdges[node] = [];\n      this.incomingEdges[node] = [];\n    }\n  }\n  /**\n   * Remove a node from the dependency graph. If a node does not exist, this method will do nothing.\n   */\n\n\n  removeNode(node) {\n    if (this.hasNode(node)) {\n      delete this.nodes[node];\n      delete this.outgoingEdges[node];\n      delete this.incomingEdges[node];\n      [this.incomingEdges, this.outgoingEdges].forEach(function (edgeList) {\n        Object.keys(edgeList).forEach(function (key) {\n          let idx = edgeList[key].indexOf(node);\n\n          if (idx >= 0) {\n            edgeList[key].splice(idx, 1);\n          }\n        }, this);\n      });\n    }\n  }\n  /**\n   * Check if a node exists in the graph\n   */\n\n\n  hasNode(node) {\n    return this.nodes.hasOwnProperty(node);\n  }\n  /**\n   * Get the data associated with a node name\n   */\n\n\n  getNodeData(node) {\n    if (this.hasNode(node)) {\n      return this.nodes[node];\n    } else {\n      throw new TypeORMError(`Node does not exist: ${node}`);\n    }\n  }\n  /**\n   * Set the associated data for a given node name. If the node does not exist, this method will throw an error\n   */\n\n\n  setNodeData(node, data) {\n    if (this.hasNode(node)) {\n      this.nodes[node] = data;\n    } else {\n      throw new TypeORMError(`Node does not exist: ${node}`);\n    }\n  }\n  /**\n   * Add a dependency between two nodes. If either of the nodes does not exist,\n   * an Error will be thrown.\n   */\n\n\n  addDependency(from, to) {\n    if (!this.hasNode(from)) {\n      throw new TypeORMError(`Node does not exist: ${from}`);\n    }\n\n    if (!this.hasNode(to)) {\n      throw new TypeORMError(`Node does not exist: ${to}`);\n    }\n\n    if (this.outgoingEdges[from].indexOf(to) === -1) {\n      this.outgoingEdges[from].push(to);\n    }\n\n    if (this.incomingEdges[to].indexOf(from) === -1) {\n      this.incomingEdges[to].push(from);\n    }\n\n    return true;\n  }\n  /**\n   * Remove a dependency between two nodes.\n   */\n\n\n  removeDependency(from, to) {\n    let idx;\n\n    if (this.hasNode(from)) {\n      idx = this.outgoingEdges[from].indexOf(to);\n\n      if (idx >= 0) {\n        this.outgoingEdges[from].splice(idx, 1);\n      }\n    }\n\n    if (this.hasNode(to)) {\n      idx = this.incomingEdges[to].indexOf(from);\n\n      if (idx >= 0) {\n        this.incomingEdges[to].splice(idx, 1);\n      }\n    }\n  }\n  /**\n   * Get an array containing the nodes that the specified node depends on (transitively).\n   *\n   * Throws an Error if the graph has a cycle, or the specified node does not exist.\n   *\n   * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned\n   * in the array.\n   */\n\n\n  dependenciesOf(node, leavesOnly) {\n    if (this.hasNode(node)) {\n      let result = [];\n      let DFS = createDFS(this.outgoingEdges, leavesOnly, result);\n      DFS(node);\n      let idx = result.indexOf(node);\n\n      if (idx >= 0) {\n        result.splice(idx, 1);\n      }\n\n      return result;\n    } else {\n      throw new TypeORMError(`Node does not exist: ${node}`);\n    }\n  }\n  /**\n   * get an array containing the nodes that depend on the specified node (transitively).\n   *\n   * Throws an Error if the graph has a cycle, or the specified node does not exist.\n   *\n   * If `leavesOnly` is true, only nodes that do not have any dependants will be returned in the array.\n   */\n\n\n  dependantsOf(node, leavesOnly) {\n    if (this.hasNode(node)) {\n      let result = [];\n      let DFS = createDFS(this.incomingEdges, leavesOnly, result);\n      DFS(node);\n      let idx = result.indexOf(node);\n\n      if (idx >= 0) {\n        result.splice(idx, 1);\n      }\n\n      return result;\n    } else {\n      throw new TypeORMError(`Node does not exist: ${node}`);\n    }\n  }\n  /**\n   * Construct the overall processing order for the dependency graph.\n   *\n   * Throws an Error if the graph has a cycle.\n   *\n   * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned.\n   */\n\n\n  overallOrder(leavesOnly) {\n    let self = this;\n    let result = [];\n    let keys = Object.keys(this.nodes);\n\n    if (keys.length === 0) {\n      return result; // Empty graph\n    } else {\n      // Look for cycles - we run the DFS starting at all the nodes in case there\n      // are several disconnected subgraphs inside this dependency graph.\n      let CycleDFS = createDFS(this.outgoingEdges, false, []);\n      keys.forEach(function (n) {\n        CycleDFS(n);\n      });\n      let DFS = createDFS(this.outgoingEdges, leavesOnly, result); // Find all potential starting points (nodes with nothing depending on them) an\n      // run a DFS starting at these points to get the order\n\n      keys.filter(function (node) {\n        return self.incomingEdges[node].length === 0;\n      }).forEach(function (n) {\n        DFS(n);\n      });\n      return result;\n    }\n  }\n\n}","map":{"version":3,"mappings":"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","names":["TypeORMError","createDFS","edges","leavesOnly","result","currentPath","visited","DFS","currentNode","push","forEach","node","indexOf","join","pop","length","DepGraph","constructor","addNode","data","hasNode","arguments","nodes","outgoingEdges","incomingEdges","removeNode","edgeList","Object","keys","key","idx","splice","hasOwnProperty","getNodeData","setNodeData","addDependency","from","to","removeDependency","dependenciesOf","dependantsOf","overallOrder","self","CycleDFS","n","filter"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\util\\DepGraph.ts"],"sourcesContent":["/**\n * This source code is from https://github.com/jriecken/dependency-graph\n * Just added \"any\" types here, wrapper everything into exported class.\n * We cant use a package itself because we want to package \"everything-in-it\" for the frontend users of TypeORM.\n */\n\n/**\n * A simple dependency graph\n */\n\nimport { TypeORMError } from \"../error\"\n\n/**\n * Helper for creating a Depth-First-Search on\n * a set of edges.\n *\n * Detects cycles and throws an Error if one is detected.\n *\n * @param edges The set of edges to DFS through\n * @param leavesOnly Whether to only return \"leaf\" nodes (ones who have no edges)\n * @param result An array in which the results will be populated\n */\nfunction createDFS(edges: any, leavesOnly: any, result: any) {\n    let currentPath: any[] = []\n    let visited: any = {}\n    return function DFS(currentNode: any) {\n        visited[currentNode] = true\n        currentPath.push(currentNode)\n        edges[currentNode].forEach(function (node: any) {\n            if (!visited[node]) {\n                DFS(node)\n            } else if (currentPath.indexOf(node) >= 0) {\n                currentPath.push(node)\n                throw new TypeORMError(\n                    `Dependency Cycle Found: ${currentPath.join(\" -> \")}`,\n                )\n            }\n        })\n        currentPath.pop()\n        if (\n            (!leavesOnly || edges[currentNode].length === 0) &&\n            result.indexOf(currentNode) === -1\n        ) {\n            result.push(currentNode)\n        }\n    }\n}\n\nexport class DepGraph {\n    nodes: any = {}\n    outgoingEdges: any = {} // Node -> [Dependency Node]\n    incomingEdges: any = {} // Node -> [Dependant Node]\n\n    /**\n     * Add a node to the dependency graph. If a node already exists, this method will do nothing.\n     */\n    addNode(node: any, data?: any) {\n        if (!this.hasNode(node)) {\n            // Checking the arguments length allows the user to add a node with undefined data\n            if (arguments.length === 2) {\n                this.nodes[node] = data\n            } else {\n                this.nodes[node] = node\n            }\n            this.outgoingEdges[node] = []\n            this.incomingEdges[node] = []\n        }\n    }\n\n    /**\n     * Remove a node from the dependency graph. If a node does not exist, this method will do nothing.\n     */\n    removeNode(node: any) {\n        if (this.hasNode(node)) {\n            delete this.nodes[node]\n            delete this.outgoingEdges[node]\n            delete this.incomingEdges[node]\n            ;[this.incomingEdges, this.outgoingEdges].forEach(function (\n                edgeList,\n            ) {\n                Object.keys(edgeList).forEach(function (key: any) {\n                    let idx = edgeList[key].indexOf(node)\n                    if (idx >= 0) {\n                        edgeList[key].splice(idx, 1)\n                    }\n                }, this)\n            })\n        }\n    }\n\n    /**\n     * Check if a node exists in the graph\n     */\n    hasNode(node: any) {\n        return this.nodes.hasOwnProperty(node)\n    }\n\n    /**\n     * Get the data associated with a node name\n     */\n    getNodeData(node: any) {\n        if (this.hasNode(node)) {\n            return this.nodes[node]\n        } else {\n            throw new TypeORMError(`Node does not exist: ${node}`)\n        }\n    }\n\n    /**\n     * Set the associated data for a given node name. If the node does not exist, this method will throw an error\n     */\n    setNodeData(node: any, data: any) {\n        if (this.hasNode(node)) {\n            this.nodes[node] = data\n        } else {\n            throw new TypeORMError(`Node does not exist: ${node}`)\n        }\n    }\n\n    /**\n     * Add a dependency between two nodes. If either of the nodes does not exist,\n     * an Error will be thrown.\n     */\n    addDependency(from: any, to: any) {\n        if (!this.hasNode(from)) {\n            throw new TypeORMError(`Node does not exist: ${from}`)\n        }\n        if (!this.hasNode(to)) {\n            throw new TypeORMError(`Node does not exist: ${to}`)\n        }\n        if (this.outgoingEdges[from].indexOf(to) === -1) {\n            this.outgoingEdges[from].push(to)\n        }\n        if (this.incomingEdges[to].indexOf(from) === -1) {\n            this.incomingEdges[to].push(from)\n        }\n        return true\n    }\n\n    /**\n     * Remove a dependency between two nodes.\n     */\n    removeDependency(from: any, to: any) {\n        let idx: any\n        if (this.hasNode(from)) {\n            idx = this.outgoingEdges[from].indexOf(to)\n            if (idx >= 0) {\n                this.outgoingEdges[from].splice(idx, 1)\n            }\n        }\n\n        if (this.hasNode(to)) {\n            idx = this.incomingEdges[to].indexOf(from)\n            if (idx >= 0) {\n                this.incomingEdges[to].splice(idx, 1)\n            }\n        }\n    }\n\n    /**\n     * Get an array containing the nodes that the specified node depends on (transitively).\n     *\n     * Throws an Error if the graph has a cycle, or the specified node does not exist.\n     *\n     * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned\n     * in the array.\n     */\n    dependenciesOf(node: any, leavesOnly: any) {\n        if (this.hasNode(node)) {\n            let result: any[] = []\n            let DFS = createDFS(this.outgoingEdges, leavesOnly, result)\n            DFS(node)\n            let idx = result.indexOf(node)\n            if (idx >= 0) {\n                result.splice(idx, 1)\n            }\n            return result\n        } else {\n            throw new TypeORMError(`Node does not exist: ${node}`)\n        }\n    }\n\n    /**\n     * get an array containing the nodes that depend on the specified node (transitively).\n     *\n     * Throws an Error if the graph has a cycle, or the specified node does not exist.\n     *\n     * If `leavesOnly` is true, only nodes that do not have any dependants will be returned in the array.\n     */\n    dependantsOf(node: any, leavesOnly: any) {\n        if (this.hasNode(node)) {\n            let result: any[] = []\n            let DFS = createDFS(this.incomingEdges, leavesOnly, result)\n            DFS(node)\n            let idx = result.indexOf(node)\n            if (idx >= 0) {\n                result.splice(idx, 1)\n            }\n            return result\n        } else {\n            throw new TypeORMError(`Node does not exist: ${node}`)\n        }\n    }\n\n    /**\n     * Construct the overall processing order for the dependency graph.\n     *\n     * Throws an Error if the graph has a cycle.\n     *\n     * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned.\n     */\n    overallOrder(leavesOnly?: any) {\n        let self = this\n        let result: any[] = []\n        let keys = Object.keys(this.nodes)\n        if (keys.length === 0) {\n            return result // Empty graph\n        } else {\n            // Look for cycles - we run the DFS starting at all the nodes in case there\n            // are several disconnected subgraphs inside this dependency graph.\n            let CycleDFS = createDFS(this.outgoingEdges, false, [])\n            keys.forEach(function (n: any) {\n                CycleDFS(n)\n            })\n\n            let DFS = createDFS(this.outgoingEdges, leavesOnly, result)\n            // Find all potential starting points (nodes with nothing depending on them) an\n            // run a DFS starting at these points to get the order\n            keys.filter(function (node) {\n                return self.incomingEdges[node].length === 0\n            }).forEach(function (n) {\n                DFS(n)\n            })\n\n            return result\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}