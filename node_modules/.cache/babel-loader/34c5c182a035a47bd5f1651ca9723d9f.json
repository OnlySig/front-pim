{"ast":null,"code":"/**\n * Loads database entities for all operate subjects which do not have database entity set.\n * All entities that we load database entities for are marked as updated or inserted.\n * To understand which of them really needs to be inserted or updated we need to load\n * their original representations from the database.\n */\nexport class SubjectDatabaseEntityLoader {\n  // ---------------------------------------------------------------------\n  // Constructor\n  // ---------------------------------------------------------------------\n  constructor(queryRunner, subjects) {\n    this.queryRunner = queryRunner;\n    this.subjects = subjects;\n  } // ---------------------------------------------------------------------\n  // Public Methods\n  // ---------------------------------------------------------------------\n\n  /**\n   * Loads database entities for all subjects.\n   *\n   * loadAllRelations flag is used to load all relation ids of the object, no matter if they present in subject entity or not.\n   * This option is used for deletion.\n   */\n\n\n  async load(operationType) {\n    // we are grouping subjects by target to perform more optimized queries using WHERE IN operator\n    // go through the groups and perform loading of database entities of each subject in the group\n    const promises = this.groupByEntityTargets().map(async subjectGroup => {\n      // prepare entity ids of the subjects we need to load\n      const allIds = [];\n      const allSubjects = [];\n      subjectGroup.subjects.forEach(subject => {\n        // we don't load if subject already has a database entity loaded\n        if (subject.databaseEntity || !subject.identifier) return;\n        allIds.push(subject.identifier);\n        allSubjects.push(subject);\n      }); // if there no ids found (means all entities are new and have generated ids) - then nothing to load there\n\n      if (!allIds.length) return;\n      const loadRelationPropertyPaths = []; // for the save, soft-remove and recover operation\n      // extract all property paths of the relations we need to load relation ids for\n      // this is for optimization purpose - this way we don't load relation ids for entities\n      // whose relations are undefined, and since they are undefined its really pointless to\n      // load something for them, since undefined properties are skipped by the orm\n\n      if (operationType === \"save\" || operationType === \"soft-remove\" || operationType === \"recover\") {\n        subjectGroup.subjects.forEach(subject => {\n          // gets all relation property paths that exist in the persisted entity.\n          subject.metadata.relations.forEach(relation => {\n            const value = relation.getEntityValue(subject.entityWithFulfilledIds);\n            if (value === undefined) return;\n            if (loadRelationPropertyPaths.indexOf(relation.propertyPath) === -1) loadRelationPropertyPaths.push(relation.propertyPath);\n          });\n        });\n      } else {\n        // remove\n        // for remove operation\n        // we only need to load junction relation ids since only they are removed by cascades\n        loadRelationPropertyPaths.push(...subjectGroup.subjects[0].metadata.manyToManyRelations.map(relation => relation.propertyPath));\n      }\n\n      const findOptions = {\n        loadEagerRelations: false,\n        loadRelationIds: {\n          relations: loadRelationPropertyPaths,\n          disableMixedMap: true\n        },\n        // the soft-deleted entities should be included in the loaded entities for recover operation\n        withDeleted: true\n      }; // load database entities for all given ids\n\n      let entities = [];\n\n      if (this.queryRunner.connection.driver.options.type === \"mongodb\") {\n        const mongoRepo = this.queryRunner.manager.getRepository(subjectGroup.target);\n        entities = await mongoRepo.findByIds(allIds, findOptions);\n      } else {\n        entities = await this.queryRunner.manager.getRepository(subjectGroup.target).createQueryBuilder().setFindOptions(findOptions).whereInIds(allIds).getMany();\n      } // now when we have entities we need to find subject of each entity\n      // and insert that entity into database entity of the found subjects\n\n\n      entities.forEach(entity => {\n        const subjects = this.findByPersistEntityLike(subjectGroup.target, entity);\n        subjects.forEach(subject => {\n          subject.databaseEntity = entity;\n          if (!subject.identifier) subject.identifier = subject.metadata.hasAllPrimaryKeys(entity) ? subject.metadata.getEntityIdMap(entity) : undefined;\n        });\n      }); // this way we tell what subjects we tried to load database entities of\n\n      for (let subject of allSubjects) {\n        subject.databaseEntityLoaded = true;\n      }\n    });\n    await Promise.all(promises);\n  } // ---------------------------------------------------------------------\n  // Protected Methods\n  // ---------------------------------------------------------------------\n\n  /**\n   * Finds subjects where entity like given subject's entity.\n   * Comparison made by entity id.\n   * Multiple subjects may be returned if duplicates are present in the subject array.\n   * This will likely result in the same row being updated multiple times during a transaction.\n   */\n\n\n  findByPersistEntityLike(entityTarget, entity) {\n    return this.subjects.filter(subject => {\n      if (!subject.entity) return false;\n      if (subject.entity === entity) return true;\n      return subject.metadata.target === entityTarget && subject.metadata.compareEntities(subject.entityWithFulfilledIds, entity);\n    });\n  }\n  /**\n   * Groups given Subject objects into groups separated by entity targets.\n   */\n\n\n  groupByEntityTargets() {\n    return this.subjects.reduce((groups, operatedEntity) => {\n      let group = groups.find(group => group.target === operatedEntity.metadata.target);\n\n      if (!group) {\n        group = {\n          target: operatedEntity.metadata.target,\n          subjects: []\n        };\n        groups.push(group);\n      }\n\n      group.subjects.push(operatedEntity);\n      return groups;\n    }, []);\n  }\n\n}","map":{"version":3,"mappings":"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","names":["SubjectDatabaseEntityLoader","constructor","queryRunner","subjects","load","operationType","promises","groupByEntityTargets","map","subjectGroup","allIds","allSubjects","forEach","subject","databaseEntity","identifier","push","length","loadRelationPropertyPaths","metadata","relations","relation","value","getEntityValue","entityWithFulfilledIds","undefined","indexOf","propertyPath","manyToManyRelations","findOptions","loadEagerRelations","loadRelationIds","disableMixedMap","withDeleted","entities","connection","driver","options","type","mongoRepo","manager","getRepository","target","findByIds","createQueryBuilder","setFindOptions","whereInIds","getMany","entity","findByPersistEntityLike","hasAllPrimaryKeys","getEntityIdMap","databaseEntityLoaded","Promise","all","entityTarget","filter","compareEntities","reduce","groups","operatedEntity","group","find"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\persistence\\SubjectDatabaseEntityLoader.ts"],"sourcesContent":["import { Subject } from \"./Subject\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\nimport { FindManyOptions } from \"../find-options/FindManyOptions\"\nimport { MongoRepository } from \"../repository/MongoRepository\"\n\n/**\n * Loads database entities for all operate subjects which do not have database entity set.\n * All entities that we load database entities for are marked as updated or inserted.\n * To understand which of them really needs to be inserted or updated we need to load\n * their original representations from the database.\n */\nexport class SubjectDatabaseEntityLoader {\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(\n        protected queryRunner: QueryRunner,\n        protected subjects: Subject[],\n    ) {}\n\n    // ---------------------------------------------------------------------\n    // Public Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Loads database entities for all subjects.\n     *\n     * loadAllRelations flag is used to load all relation ids of the object, no matter if they present in subject entity or not.\n     * This option is used for deletion.\n     */\n    async load(\n        operationType: \"save\" | \"remove\" | \"soft-remove\" | \"recover\",\n    ): Promise<void> {\n        // we are grouping subjects by target to perform more optimized queries using WHERE IN operator\n        // go through the groups and perform loading of database entities of each subject in the group\n        const promises = this.groupByEntityTargets().map(\n            async (subjectGroup) => {\n                // prepare entity ids of the subjects we need to load\n                const allIds: ObjectLiteral[] = []\n                const allSubjects: Subject[] = []\n                subjectGroup.subjects.forEach((subject) => {\n                    // we don't load if subject already has a database entity loaded\n                    if (subject.databaseEntity || !subject.identifier) return\n\n                    allIds.push(subject.identifier)\n                    allSubjects.push(subject)\n                })\n\n                // if there no ids found (means all entities are new and have generated ids) - then nothing to load there\n                if (!allIds.length) return\n\n                const loadRelationPropertyPaths: string[] = []\n\n                // for the save, soft-remove and recover operation\n                // extract all property paths of the relations we need to load relation ids for\n                // this is for optimization purpose - this way we don't load relation ids for entities\n                // whose relations are undefined, and since they are undefined its really pointless to\n                // load something for them, since undefined properties are skipped by the orm\n                if (\n                    operationType === \"save\" ||\n                    operationType === \"soft-remove\" ||\n                    operationType === \"recover\"\n                ) {\n                    subjectGroup.subjects.forEach((subject) => {\n                        // gets all relation property paths that exist in the persisted entity.\n                        subject.metadata.relations.forEach((relation) => {\n                            const value = relation.getEntityValue(\n                                subject.entityWithFulfilledIds!,\n                            )\n                            if (value === undefined) return\n\n                            if (\n                                loadRelationPropertyPaths.indexOf(\n                                    relation.propertyPath,\n                                ) === -1\n                            )\n                                loadRelationPropertyPaths.push(\n                                    relation.propertyPath,\n                                )\n                        })\n                    })\n                } else {\n                    // remove\n\n                    // for remove operation\n                    // we only need to load junction relation ids since only they are removed by cascades\n                    loadRelationPropertyPaths.push(\n                        ...subjectGroup.subjects[0].metadata.manyToManyRelations.map(\n                            (relation) => relation.propertyPath,\n                        ),\n                    )\n                }\n\n                const findOptions: FindManyOptions<any> = {\n                    loadEagerRelations: false,\n                    loadRelationIds: {\n                        relations: loadRelationPropertyPaths,\n                        disableMixedMap: true,\n                    },\n                    // the soft-deleted entities should be included in the loaded entities for recover operation\n                    withDeleted: true,\n                }\n\n                // load database entities for all given ids\n                let entities: any[] = []\n                if (\n                    this.queryRunner.connection.driver.options.type ===\n                    \"mongodb\"\n                ) {\n                    const mongoRepo =\n                        this.queryRunner.manager.getRepository<ObjectLiteral>(\n                            subjectGroup.target,\n                        ) as MongoRepository<ObjectLiteral>\n                    entities = await mongoRepo.findByIds(allIds, findOptions)\n                } else {\n                    entities = await this.queryRunner.manager\n                        .getRepository<ObjectLiteral>(subjectGroup.target)\n                        .createQueryBuilder()\n                        .setFindOptions(findOptions)\n                        .whereInIds(allIds)\n                        .getMany()\n                }\n\n                // now when we have entities we need to find subject of each entity\n                // and insert that entity into database entity of the found subjects\n                entities.forEach((entity) => {\n                    const subjects = this.findByPersistEntityLike(\n                        subjectGroup.target,\n                        entity,\n                    )\n                    subjects.forEach((subject) => {\n                        subject.databaseEntity = entity\n                        if (!subject.identifier)\n                            subject.identifier =\n                                subject.metadata.hasAllPrimaryKeys(entity)\n                                    ? subject.metadata.getEntityIdMap(entity)\n                                    : undefined\n                    })\n                })\n\n                // this way we tell what subjects we tried to load database entities of\n                for (let subject of allSubjects) {\n                    subject.databaseEntityLoaded = true\n                }\n            },\n        )\n\n        await Promise.all(promises)\n    }\n\n    // ---------------------------------------------------------------------\n    // Protected Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Finds subjects where entity like given subject's entity.\n     * Comparison made by entity id.\n     * Multiple subjects may be returned if duplicates are present in the subject array.\n     * This will likely result in the same row being updated multiple times during a transaction.\n     */\n    protected findByPersistEntityLike(\n        entityTarget: Function | string,\n        entity: ObjectLiteral,\n    ): Subject[] {\n        return this.subjects.filter((subject) => {\n            if (!subject.entity) return false\n\n            if (subject.entity === entity) return true\n\n            return (\n                subject.metadata.target === entityTarget &&\n                subject.metadata.compareEntities(\n                    subject.entityWithFulfilledIds!,\n                    entity,\n                )\n            )\n        })\n    }\n\n    /**\n     * Groups given Subject objects into groups separated by entity targets.\n     */\n    protected groupByEntityTargets(): {\n        target: Function | string\n        subjects: Subject[]\n    }[] {\n        return this.subjects.reduce((groups, operatedEntity) => {\n            let group = groups.find(\n                (group) => group.target === operatedEntity.metadata.target,\n            )\n            if (!group) {\n                group = { target: operatedEntity.metadata.target, subjects: [] }\n                groups.push(group)\n            }\n            group.subjects.push(operatedEntity)\n            return groups\n        }, [] as { target: Function | string; subjects: Subject[] }[])\n    }\n}\n"]},"metadata":{},"sourceType":"module"}