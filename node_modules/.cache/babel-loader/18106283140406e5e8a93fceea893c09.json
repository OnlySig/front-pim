{"ast":null,"code":"/**\n * Database's table index stored in this class.\n */\nexport class TableIndex {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(options) {\n    this[\"@instanceof\"] = Symbol.for(\"TableIndex\");\n    /**\n     * Columns included in this index.\n     */\n\n    this.columnNames = [];\n    this.name = options.name;\n    this.columnNames = options.columnNames;\n    this.isUnique = !!options.isUnique;\n    this.isSpatial = !!options.isSpatial;\n    this.isFulltext = !!options.isFulltext;\n    this.isNullFiltered = !!options.isNullFiltered;\n    this.parser = options.parser;\n    this.where = options.where ? options.where : \"\";\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Creates a new copy of this index with exactly same properties.\n   */\n\n\n  clone() {\n    return new TableIndex({\n      name: this.name,\n      columnNames: [...this.columnNames],\n      isUnique: this.isUnique,\n      isSpatial: this.isSpatial,\n      isFulltext: this.isFulltext,\n      isNullFiltered: this.isNullFiltered,\n      parser: this.parser,\n      where: this.where\n    });\n  } // -------------------------------------------------------------------------\n  // Static Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Creates index from the index metadata object.\n   */\n\n\n  static create(indexMetadata) {\n    return new TableIndex({\n      name: indexMetadata.name,\n      columnNames: indexMetadata.columns.map(column => column.databaseName),\n      isUnique: indexMetadata.isUnique,\n      isSpatial: indexMetadata.isSpatial,\n      isFulltext: indexMetadata.isFulltext,\n      isNullFiltered: indexMetadata.isNullFiltered,\n      parser: indexMetadata.parser,\n      where: indexMetadata.where\n    });\n  }\n\n}","map":{"version":3,"mappings":"AAGA;;;AAGA,OAAM,MAAOA,UAAP,CAAiB;EAsDnB;EACA;EACA;EAEAC,YAAYC,OAAZ,EAAsC;IAzD7B,sBAAgBC,MAAM,CAACC,GAAP,CAAW,YAAX,CAAhB;IAWT;;;;IAGA,mBAAwB,EAAxB;IA4CI,KAAKC,IAAL,GAAYH,OAAO,CAACG,IAApB;IACA,KAAKC,WAAL,GAAmBJ,OAAO,CAACI,WAA3B;IACA,KAAKC,QAAL,GAAgB,CAAC,CAACL,OAAO,CAACK,QAA1B;IACA,KAAKC,SAAL,GAAiB,CAAC,CAACN,OAAO,CAACM,SAA3B;IACA,KAAKC,UAAL,GAAkB,CAAC,CAACP,OAAO,CAACO,UAA5B;IACA,KAAKC,cAAL,GAAsB,CAAC,CAACR,OAAO,CAACQ,cAAhC;IACA,KAAKC,MAAL,GAAcT,OAAO,CAACS,MAAtB;IACA,KAAKC,KAAL,GAAaV,OAAO,CAACU,KAAR,GAAgBV,OAAO,CAACU,KAAxB,GAAgC,EAA7C;EACH,CAnEkB,CAqEnB;EACA;EACA;;EAEA;;;;;EAGAC,KAAK;IACD,OAAO,IAAIb,UAAJ,CAAkC;MACrCK,IAAI,EAAE,KAAKA,IAD0B;MAErCC,WAAW,EAAE,CAAC,GAAG,KAAKA,WAAT,CAFwB;MAGrCC,QAAQ,EAAE,KAAKA,QAHsB;MAIrCC,SAAS,EAAE,KAAKA,SAJqB;MAKrCC,UAAU,EAAE,KAAKA,UALoB;MAMrCC,cAAc,EAAE,KAAKA,cANgB;MAOrCC,MAAM,EAAE,KAAKA,MAPwB;MAQrCC,KAAK,EAAE,KAAKA;IARyB,CAAlC,CAAP;EAUH,CAvFkB,CAyFnB;EACA;EACA;;EAEA;;;;;EAGa,OAANE,MAAM,CAACC,aAAD,EAA6B;IACtC,OAAO,IAAIf,UAAJ,CAAkC;MACrCK,IAAI,EAAEU,aAAa,CAACV,IADiB;MAErCC,WAAW,EAAES,aAAa,CAACC,OAAd,CAAsBC,GAAtB,CACRC,MAAD,IAAYA,MAAM,CAACC,YADV,CAFwB;MAKrCZ,QAAQ,EAAEQ,aAAa,CAACR,QALa;MAMrCC,SAAS,EAAEO,aAAa,CAACP,SANY;MAOrCC,UAAU,EAAEM,aAAa,CAACN,UAPW;MAQrCC,cAAc,EAAEK,aAAa,CAACL,cARO;MASrCC,MAAM,EAAEI,aAAa,CAACJ,MATe;MAUrCC,KAAK,EAAEG,aAAa,CAACH;IAVgB,CAAlC,CAAP;EAYH;;AA7GkB","names":["TableIndex","constructor","options","Symbol","for","name","columnNames","isUnique","isSpatial","isFulltext","isNullFiltered","parser","where","clone","create","indexMetadata","columns","map","column","databaseName"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\schema-builder\\table\\TableIndex.ts"],"sourcesContent":["import { IndexMetadata } from \"../../metadata/IndexMetadata\"\nimport { TableIndexOptions } from \"../options/TableIndexOptions\"\n\n/**\n * Database's table index stored in this class.\n */\nexport class TableIndex {\n    readonly \"@instanceof\" = Symbol.for(\"TableIndex\")\n\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Index name.\n     */\n    name?: string\n\n    /**\n     * Columns included in this index.\n     */\n    columnNames: string[] = []\n\n    /**\n     * Indicates if this index is unique.\n     */\n    isUnique: boolean\n\n    /**\n     * The SPATIAL modifier indexes the entire column and does not allow indexed columns to contain NULL values.\n     * Works only in MySQL.\n     */\n    isSpatial: boolean\n\n    /**\n     * The FULLTEXT modifier indexes the entire column and does not allow prefixing.\n     * Works only in MySQL.\n     */\n    isFulltext: boolean\n\n    /**\n     * NULL_FILTERED indexes are particularly useful for indexing sparse columns, where most rows contain a NULL value.\n     * In these cases, the NULL_FILTERED index can be considerably smaller and more efficient to maintain than\n     * a normal index that includes NULL values.\n     *\n     * Works only in Spanner.\n     */\n    isNullFiltered: boolean\n\n    /**\n     * Fulltext parser.\n     * Works only in MySQL.\n     */\n    parser?: string\n\n    /**\n     * Index filter condition.\n     */\n    where: string\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(options: TableIndexOptions) {\n        this.name = options.name\n        this.columnNames = options.columnNames\n        this.isUnique = !!options.isUnique\n        this.isSpatial = !!options.isSpatial\n        this.isFulltext = !!options.isFulltext\n        this.isNullFiltered = !!options.isNullFiltered\n        this.parser = options.parser\n        this.where = options.where ? options.where : \"\"\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates a new copy of this index with exactly same properties.\n     */\n    clone(): TableIndex {\n        return new TableIndex(<TableIndexOptions>{\n            name: this.name,\n            columnNames: [...this.columnNames],\n            isUnique: this.isUnique,\n            isSpatial: this.isSpatial,\n            isFulltext: this.isFulltext,\n            isNullFiltered: this.isNullFiltered,\n            parser: this.parser,\n            where: this.where,\n        })\n    }\n\n    // -------------------------------------------------------------------------\n    // Static Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates index from the index metadata object.\n     */\n    static create(indexMetadata: IndexMetadata): TableIndex {\n        return new TableIndex(<TableIndexOptions>{\n            name: indexMetadata.name,\n            columnNames: indexMetadata.columns.map(\n                (column) => column.databaseName,\n            ),\n            isUnique: indexMetadata.isUnique,\n            isSpatial: indexMetadata.isSpatial,\n            isFulltext: indexMetadata.isFulltext,\n            isNullFiltered: indexMetadata.isNullFiltered,\n            parser: indexMetadata.parser,\n            where: indexMetadata.where,\n        })\n    }\n}\n"]},"metadata":{},"sourceType":"module"}