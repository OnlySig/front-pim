{"ast":null,"code":"import { getMetadataArgsStorage } from \"../../globals\";\nimport { ColumnTypeUndefinedError } from \"../../error/ColumnTypeUndefinedError\";\nimport { PrimaryColumnCannotBeNullableError } from \"../../error/PrimaryColumnCannotBeNullableError\";\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n * Primary columns also creates a PRIMARY KEY for this column in a db.\n */\n\nexport function PrimaryColumn(typeOrOptions, options) {\n  return function (object, propertyName) {\n    // normalize parameters\n    let type;\n\n    if (typeof typeOrOptions === \"string\" || typeOrOptions === String || typeOrOptions === Boolean || typeOrOptions === Number) {\n      type = typeOrOptions;\n    } else {\n      options = Object.assign({}, typeOrOptions);\n    }\n\n    if (!options) options = {}; // if type is not given explicitly then try to guess it\n\n    const reflectMetadataType = Reflect && Reflect.getMetadata ? Reflect.getMetadata(\"design:type\", object, propertyName) : undefined;\n    if (!type && reflectMetadataType) type = reflectMetadataType; // check if there is no type in column options then set type from first function argument, or guessed one\n\n    if (!options.type && type) options.type = type; // if we still don't have a type then we need to give error to user that type is required\n\n    if (!options.type) throw new ColumnTypeUndefinedError(object, propertyName); // check if column is not nullable, because we cannot allow a primary key to be nullable\n\n    if (options.nullable) throw new PrimaryColumnCannotBeNullableError(object, propertyName); // explicitly set a primary to column options\n\n    options.primary = true; // create and register a new column metadata\n\n    getMetadataArgsStorage().columns.push({\n      target: object.constructor,\n      propertyName: propertyName,\n      mode: \"regular\",\n      options: options\n    });\n\n    if (options.generated) {\n      getMetadataArgsStorage().generations.push({\n        target: object.constructor,\n        propertyName: propertyName,\n        strategy: typeof options.generated === \"string\" ? options.generated : \"increment\"\n      });\n    }\n  };\n}","map":{"version":3,"mappings":"AAAA,SAASA,sBAAT,QAAuC,eAAvC;AACA,SAASC,wBAAT,QAAyC,sCAAzC;AACA,SAASC,kCAAT,QAAmD,gDAAnD;AA6BA;;;;;;AAKA,OAAM,SAAUC,aAAV,CACFC,aADE,EAEFC,OAFE,EAE4B;EAE9B,OAAO,UAAUC,MAAV,EAA0BC,YAA1B,EAA8C;IACjD;IACA,IAAIC,IAAJ;;IACA,IACI,OAAOJ,aAAP,KAAyB,QAAzB,IACAA,aAAa,KAAKK,MADlB,IAEAL,aAAa,KAAKM,OAFlB,IAGAN,aAAa,KAAKO,MAJtB,EAKE;MACEH,IAAI,GAAGJ,aAAP;IACH,CAPD,MAOO;MACHC,OAAO,GAAGO,MAAM,CAACC,MAAP,CAAc,EAAd,EAAwCT,aAAxC,CAAV;IACH;;IACD,IAAI,CAACC,OAAL,EAAcA,OAAO,GAAG,EAAV,CAbmC,CAejD;;IACA,MAAMS,mBAAmB,GACrBC,OAAO,IAAKA,OAAe,CAACC,WAA5B,GACOD,OAAe,CAACC,WAAhB,CACG,aADH,EAEGV,MAFH,EAGGC,YAHH,CADP,GAMMU,SAPV;IAQA,IAAI,CAACT,IAAD,IAASM,mBAAb,EAAkCN,IAAI,GAAGM,mBAAP,CAxBe,CA0BjD;;IACA,IAAI,CAACT,OAAO,CAACG,IAAT,IAAiBA,IAArB,EAA2BH,OAAO,CAACG,IAAR,GAAeA,IAAf,CA3BsB,CA6BjD;;IACA,IAAI,CAACH,OAAO,CAACG,IAAb,EACI,MAAM,IAAIP,wBAAJ,CAA6BK,MAA7B,EAAqCC,YAArC,CAAN,CA/B6C,CAiCjD;;IACA,IAAIF,OAAO,CAACa,QAAZ,EACI,MAAM,IAAIhB,kCAAJ,CAAuCI,MAAvC,EAA+CC,YAA/C,CAAN,CAnC6C,CAqCjD;;IACAF,OAAO,CAACc,OAAR,GAAkB,IAAlB,CAtCiD,CAwCjD;;IACAnB,sBAAsB,GAAGoB,OAAzB,CAAiCC,IAAjC,CAAsC;MAClCC,MAAM,EAAEhB,MAAM,CAACiB,WADmB;MAElChB,YAAY,EAAEA,YAFoB;MAGlCiB,IAAI,EAAE,SAH4B;MAIlCnB,OAAO,EAAEA;IAJyB,CAAtC;;IAOA,IAAIA,OAAO,CAACoB,SAAZ,EAAuB;MACnBzB,sBAAsB,GAAG0B,WAAzB,CAAqCL,IAArC,CAA0C;QACtCC,MAAM,EAAEhB,MAAM,CAACiB,WADuB;QAEtChB,YAAY,EAAEA,YAFwB;QAGtCoB,QAAQ,EACJ,OAAOtB,OAAO,CAACoB,SAAf,KAA6B,QAA7B,GACMpB,OAAO,CAACoB,SADd,GAEM;MAN4B,CAA1C;IAQH;EACJ,CA1DD;AA2DH","names":["getMetadataArgsStorage","ColumnTypeUndefinedError","PrimaryColumnCannotBeNullableError","PrimaryColumn","typeOrOptions","options","object","propertyName","type","String","Boolean","Number","Object","assign","reflectMetadataType","Reflect","getMetadata","undefined","nullable","primary","columns","push","target","constructor","mode","generated","generations","strategy"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\decorator\\columns\\PrimaryColumn.ts"],"sourcesContent":["import { getMetadataArgsStorage } from \"../../globals\"\nimport { ColumnTypeUndefinedError } from \"../../error/ColumnTypeUndefinedError\"\nimport { PrimaryColumnCannotBeNullableError } from \"../../error/PrimaryColumnCannotBeNullableError\"\nimport { ColumnMetadataArgs } from \"../../metadata-args/ColumnMetadataArgs\"\nimport { GeneratedMetadataArgs } from \"../../metadata-args/GeneratedMetadataArgs\"\nimport { ColumnOptions } from \"../options/ColumnOptions\"\nimport { ColumnType } from \"../../driver/types/ColumnTypes\"\n\n/**\n * Describes all primary key column's options.\n * If specified, the nullable field must be set to false.\n */\nexport type PrimaryColumnOptions = ColumnOptions & { nullable?: false }\n\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n * Primary columns also creates a PRIMARY KEY for this column in a db.\n */\nexport function PrimaryColumn(options?: PrimaryColumnOptions): PropertyDecorator\n\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n * Primary columns also creates a PRIMARY KEY for this column in a db.\n */\nexport function PrimaryColumn(\n    type?: ColumnType,\n    options?: PrimaryColumnOptions,\n): PropertyDecorator\n\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n * Primary columns also creates a PRIMARY KEY for this column in a db.\n */\nexport function PrimaryColumn(\n    typeOrOptions?: ColumnType | PrimaryColumnOptions,\n    options?: PrimaryColumnOptions,\n): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        // normalize parameters\n        let type: ColumnType | undefined\n        if (\n            typeof typeOrOptions === \"string\" ||\n            typeOrOptions === String ||\n            typeOrOptions === Boolean ||\n            typeOrOptions === Number\n        ) {\n            type = typeOrOptions as ColumnType\n        } else {\n            options = Object.assign({}, <PrimaryColumnOptions>typeOrOptions)\n        }\n        if (!options) options = {} as PrimaryColumnOptions\n\n        // if type is not given explicitly then try to guess it\n        const reflectMetadataType =\n            Reflect && (Reflect as any).getMetadata\n                ? (Reflect as any).getMetadata(\n                      \"design:type\",\n                      object,\n                      propertyName,\n                  )\n                : undefined\n        if (!type && reflectMetadataType) type = reflectMetadataType\n\n        // check if there is no type in column options then set type from first function argument, or guessed one\n        if (!options.type && type) options.type = type\n\n        // if we still don't have a type then we need to give error to user that type is required\n        if (!options.type)\n            throw new ColumnTypeUndefinedError(object, propertyName)\n\n        // check if column is not nullable, because we cannot allow a primary key to be nullable\n        if (options.nullable)\n            throw new PrimaryColumnCannotBeNullableError(object, propertyName)\n\n        // explicitly set a primary to column options\n        options.primary = true\n\n        // create and register a new column metadata\n        getMetadataArgsStorage().columns.push({\n            target: object.constructor,\n            propertyName: propertyName,\n            mode: \"regular\",\n            options: options,\n        } as ColumnMetadataArgs)\n\n        if (options.generated) {\n            getMetadataArgsStorage().generations.push({\n                target: object.constructor,\n                propertyName: propertyName,\n                strategy:\n                    typeof options.generated === \"string\"\n                        ? options.generated\n                        : \"increment\",\n            } as GeneratedMetadataArgs)\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}