{"ast":null,"code":"import { QueryBuilder } from \"./QueryBuilder\";\nimport { UpdateResult } from \"./result/UpdateResult\";\nimport { ReturningStatementNotSupportedError } from \"../error/ReturningStatementNotSupportedError\";\nimport { ReturningResultsEntityUpdator } from \"./ReturningResultsEntityUpdator\";\nimport { LimitOnUpdateNotSupportedError } from \"../error/LimitOnUpdateNotSupportedError\";\nimport { MissingDeleteDateColumnError } from \"../error/MissingDeleteDateColumnError\";\nimport { UpdateValuesMissingError } from \"../error/UpdateValuesMissingError\";\nimport { TypeORMError } from \"../error\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\nimport { InstanceChecker } from \"../util/InstanceChecker\";\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n */\n\nexport class SoftDeleteQueryBuilder extends QueryBuilder {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connectionOrQueryBuilder, queryRunner) {\n    super(connectionOrQueryBuilder, queryRunner);\n    this[\"@instanceof\"] = Symbol.for(\"SoftDeleteQueryBuilder\");\n    this.expressionMap.aliasNamePrefixingEnabled = false;\n  } // -------------------------------------------------------------------------\n  // Public Implemented Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Gets generated SQL query without parameters being replaced.\n   */\n\n\n  getQuery() {\n    let sql = this.createUpdateExpression();\n    sql += this.createCteExpression();\n    sql += this.createOrderByExpression();\n    sql += this.createLimitExpression();\n    return sql.trim();\n  }\n  /**\n   * Executes sql generated by query builder and returns raw database results.\n   */\n\n\n  async execute() {\n    const queryRunner = this.obtainQueryRunner();\n    let transactionStartedByUs = false;\n\n    try {\n      // start transaction if it was enabled\n      if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {\n        await queryRunner.startTransaction();\n        transactionStartedByUs = true;\n      } // call before soft remove and recover methods in listeners and subscribers\n\n\n      if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata) {\n        if (this.expressionMap.queryType === \"soft-delete\") await queryRunner.broadcaster.broadcast(\"BeforeSoftRemove\", this.expressionMap.mainAlias.metadata);else if (this.expressionMap.queryType === \"restore\") await queryRunner.broadcaster.broadcast(\"BeforeRecover\", this.expressionMap.mainAlias.metadata);\n      } // if update entity mode is enabled we may need extra columns for the returning statement\n\n\n      const returningResultsEntityUpdator = new ReturningResultsEntityUpdator(queryRunner, this.expressionMap);\n\n      if (this.expressionMap.updateEntity === true && this.expressionMap.mainAlias.hasMetadata && this.expressionMap.whereEntities.length > 0) {\n        this.expressionMap.extraReturningColumns = returningResultsEntityUpdator.getSoftDeletionReturningColumns();\n      } // execute update query\n\n\n      const [sql, parameters] = this.getQueryAndParameters();\n      const queryResult = await queryRunner.query(sql, parameters, true);\n      const updateResult = UpdateResult.from(queryResult); // if we are updating entities and entity updation is enabled we must update some of entity columns (like version, update date, etc.)\n\n      if (this.expressionMap.updateEntity === true && this.expressionMap.mainAlias.hasMetadata && this.expressionMap.whereEntities.length > 0) {\n        await returningResultsEntityUpdator.update(updateResult, this.expressionMap.whereEntities);\n      } // call after soft remove and recover methods in listeners and subscribers\n\n\n      if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata) {\n        if (this.expressionMap.queryType === \"soft-delete\") await queryRunner.broadcaster.broadcast(\"AfterSoftRemove\", this.expressionMap.mainAlias.metadata);else if (this.expressionMap.queryType === \"restore\") await queryRunner.broadcaster.broadcast(\"AfterRecover\", this.expressionMap.mainAlias.metadata);\n      } // close transaction if we started it\n\n\n      if (transactionStartedByUs) await queryRunner.commitTransaction();\n      return updateResult;\n    } catch (error) {\n      // rollback transaction if we started it\n      if (transactionStartedByUs) {\n        try {\n          await queryRunner.rollbackTransaction();\n        } catch (rollbackError) {}\n      }\n\n      throw error;\n    } finally {\n      if (queryRunner !== this.queryRunner) {\n        // means we created our own query runner\n        await queryRunner.release();\n      }\n    }\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Specifies FROM which entity's table select/update/delete/soft-delete will be executed.\n   * Also sets a main string alias of the selection data.\n   */\n\n\n  from(entityTarget, aliasName) {\n    entityTarget = InstanceChecker.isEntitySchema(entityTarget) ? entityTarget.options.name : entityTarget;\n    const mainAlias = this.createFromAlias(entityTarget, aliasName);\n    this.expressionMap.setMainAlias(mainAlias);\n    return this;\n  }\n  /**\n   * Sets WHERE condition in the query builder.\n   * If you had previously WHERE expression defined,\n   * calling this function will override previously set WHERE conditions.\n   * Additionally you can add parameters used in where expression.\n   */\n\n\n  where(where, parameters) {\n    this.expressionMap.wheres = []; // don't move this block below since computeWhereParameter can add where expressions\n\n    const condition = this.getWhereCondition(where);\n    if (condition) this.expressionMap.wheres = [{\n      type: \"simple\",\n      condition: condition\n    }];\n    if (parameters) this.setParameters(parameters);\n    return this;\n  }\n  /**\n   * Adds new AND WHERE condition in the query builder.\n   * Additionally you can add parameters used in where expression.\n   */\n\n\n  andWhere(where, parameters) {\n    this.expressionMap.wheres.push({\n      type: \"and\",\n      condition: this.getWhereCondition(where)\n    });\n    if (parameters) this.setParameters(parameters);\n    return this;\n  }\n  /**\n   * Adds new OR WHERE condition in the query builder.\n   * Additionally you can add parameters used in where expression.\n   */\n\n\n  orWhere(where, parameters) {\n    this.expressionMap.wheres.push({\n      type: \"or\",\n      condition: this.getWhereCondition(where)\n    });\n    if (parameters) this.setParameters(parameters);\n    return this;\n  }\n  /**\n   * Adds new AND WHERE with conditions for the given ids.\n   */\n\n\n  whereInIds(ids) {\n    return this.where(this.getWhereInIdsCondition(ids));\n  }\n  /**\n   * Adds new AND WHERE with conditions for the given ids.\n   */\n\n\n  andWhereInIds(ids) {\n    return this.andWhere(this.getWhereInIdsCondition(ids));\n  }\n  /**\n   * Adds new OR WHERE with conditions for the given ids.\n   */\n\n\n  orWhereInIds(ids) {\n    return this.orWhere(this.getWhereInIdsCondition(ids));\n  }\n  /**\n   * Optional returning/output clause.\n   */\n\n\n  output(output) {\n    return this.returning(output);\n  }\n  /**\n   * Optional returning/output clause.\n   */\n\n\n  returning(returning) {\n    // not all databases support returning/output cause\n    if (!this.connection.driver.isReturningSqlSupported(\"update\")) {\n      throw new ReturningStatementNotSupportedError();\n    }\n\n    this.expressionMap.returning = returning;\n    return this;\n  }\n  /**\n   * Sets ORDER BY condition in the query builder.\n   * If you had previously ORDER BY expression defined,\n   * calling this function will override previously set ORDER BY conditions.\n   */\n\n\n  orderBy(sort) {\n    let order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"ASC\";\n    let nulls = arguments.length > 2 ? arguments[2] : undefined;\n\n    if (sort) {\n      if (typeof sort === \"object\") {\n        this.expressionMap.orderBys = sort;\n      } else {\n        if (nulls) {\n          this.expressionMap.orderBys = {\n            [sort]: {\n              order,\n              nulls\n            }\n          };\n        } else {\n          this.expressionMap.orderBys = {\n            [sort]: order\n          };\n        }\n      }\n    } else {\n      this.expressionMap.orderBys = {};\n    }\n\n    return this;\n  }\n  /**\n   * Adds ORDER BY condition in the query builder.\n   */\n\n\n  addOrderBy(sort) {\n    let order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"ASC\";\n    let nulls = arguments.length > 2 ? arguments[2] : undefined;\n\n    if (nulls) {\n      this.expressionMap.orderBys[sort] = {\n        order,\n        nulls\n      };\n    } else {\n      this.expressionMap.orderBys[sort] = order;\n    }\n\n    return this;\n  }\n  /**\n   * Sets LIMIT - maximum number of rows to be selected.\n   */\n\n\n  limit(limit) {\n    this.expressionMap.limit = limit;\n    return this;\n  }\n  /**\n   * Indicates if entity must be updated after update operation.\n   * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).\n   * Enabled by default.\n   */\n\n\n  whereEntity(entity) {\n    if (!this.expressionMap.mainAlias.hasMetadata) throw new TypeORMError(`.whereEntity method can only be used on queries which update real entity table.`);\n    this.expressionMap.wheres = [];\n    const entities = Array.isArray(entity) ? entity : [entity];\n    entities.forEach(entity => {\n      const entityIdMap = this.expressionMap.mainAlias.metadata.getEntityIdMap(entity);\n      if (!entityIdMap) throw new TypeORMError(`Provided entity does not have ids set, cannot perform operation.`);\n      this.orWhereInIds(entityIdMap);\n    });\n    this.expressionMap.whereEntities = entities;\n    return this;\n  }\n  /**\n   * Indicates if entity must be updated after update operation.\n   * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).\n   * Enabled by default.\n   */\n\n\n  updateEntity(enabled) {\n    this.expressionMap.updateEntity = enabled;\n    return this;\n  } // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Creates UPDATE express used to perform insert query.\n   */\n\n\n  createUpdateExpression() {\n    const metadata = this.expressionMap.mainAlias.hasMetadata ? this.expressionMap.mainAlias.metadata : undefined;\n    if (!metadata) throw new TypeORMError(`Cannot get entity metadata for the given alias \"${this.expressionMap.mainAlias}\"`);\n\n    if (!metadata.deleteDateColumn) {\n      throw new MissingDeleteDateColumnError(metadata);\n    } // prepare columns and values to be updated\n\n\n    const updateColumnAndValues = [];\n\n    switch (this.expressionMap.queryType) {\n      case \"soft-delete\":\n        updateColumnAndValues.push(this.escape(metadata.deleteDateColumn.databaseName) + \" = CURRENT_TIMESTAMP\");\n        break;\n\n      case \"restore\":\n        updateColumnAndValues.push(this.escape(metadata.deleteDateColumn.databaseName) + \" = NULL\");\n        break;\n\n      default:\n        throw new TypeORMError(`The queryType must be \"soft-delete\" or \"restore\"`);\n    }\n\n    if (metadata.versionColumn) updateColumnAndValues.push(this.escape(metadata.versionColumn.databaseName) + \" = \" + this.escape(metadata.versionColumn.databaseName) + \" + 1\");\n    if (metadata.updateDateColumn) updateColumnAndValues.push(this.escape(metadata.updateDateColumn.databaseName) + \" = CURRENT_TIMESTAMP\"); // todo: fix issue with CURRENT_TIMESTAMP(6) being used, can \"DEFAULT\" be used?!\n\n    if (updateColumnAndValues.length <= 0) {\n      throw new UpdateValuesMissingError();\n    } // get a table name and all column database names\n\n\n    const whereExpression = this.createWhereExpression();\n    const returningExpression = this.createReturningExpression(\"update\");\n\n    if (returningExpression === \"\") {\n      return `UPDATE ${this.getTableName(this.getMainTableName())} SET ${updateColumnAndValues.join(\", \")}${whereExpression}`; // todo: how do we replace aliases in where to nothing?\n    }\n\n    if (this.connection.driver.options.type === \"mssql\") {\n      return `UPDATE ${this.getTableName(this.getMainTableName())} SET ${updateColumnAndValues.join(\", \")} OUTPUT ${returningExpression}${whereExpression}`;\n    }\n\n    return `UPDATE ${this.getTableName(this.getMainTableName())} SET ${updateColumnAndValues.join(\", \")}${whereExpression} RETURNING ${returningExpression}`;\n  }\n  /**\n   * Creates \"ORDER BY\" part of SQL query.\n   */\n\n\n  createOrderByExpression() {\n    const orderBys = this.expressionMap.orderBys;\n    if (Object.keys(orderBys).length > 0) return \" ORDER BY \" + Object.keys(orderBys).map(columnName => {\n      if (typeof orderBys[columnName] === \"string\") {\n        return this.replacePropertyNames(columnName) + \" \" + orderBys[columnName];\n      } else {\n        return this.replacePropertyNames(columnName) + \" \" + orderBys[columnName].order + \" \" + orderBys[columnName].nulls;\n      }\n    }).join(\", \");\n    return \"\";\n  }\n  /**\n   * Creates \"LIMIT\" parts of SQL query.\n   */\n\n\n  createLimitExpression() {\n    let limit = this.expressionMap.limit;\n\n    if (limit) {\n      if (DriverUtils.isMySQLFamily(this.connection.driver)) {\n        return \" LIMIT \" + limit;\n      } else {\n        throw new LimitOnUpdateNotSupportedError();\n      }\n    }\n\n    return \"\";\n  }\n\n}","map":{"version":3,"mappings":"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","names":["QueryBuilder","UpdateResult","ReturningStatementNotSupportedError","ReturningResultsEntityUpdator","LimitOnUpdateNotSupportedError","MissingDeleteDateColumnError","UpdateValuesMissingError","TypeORMError","DriverUtils","InstanceChecker","SoftDeleteQueryBuilder","constructor","connectionOrQueryBuilder","queryRunner","Symbol","for","expressionMap","aliasNamePrefixingEnabled","getQuery","sql","createUpdateExpression","createCteExpression","createOrderByExpression","createLimitExpression","trim","execute","obtainQueryRunner","transactionStartedByUs","useTransaction","isTransactionActive","startTransaction","callListeners","mainAlias","hasMetadata","queryType","broadcaster","broadcast","metadata","returningResultsEntityUpdator","updateEntity","whereEntities","length","extraReturningColumns","getSoftDeletionReturningColumns","parameters","getQueryAndParameters","queryResult","query","updateResult","from","update","commitTransaction","error","rollbackTransaction","rollbackError","release","entityTarget","aliasName","isEntitySchema","options","name","createFromAlias","setMainAlias","where","wheres","condition","getWhereCondition","type","setParameters","andWhere","push","orWhere","whereInIds","ids","getWhereInIdsCondition","andWhereInIds","orWhereInIds","output","returning","connection","driver","isReturningSqlSupported","orderBy","sort","order","nulls","orderBys","addOrderBy","limit","whereEntity","entity","entities","Array","isArray","forEach","entityIdMap","getEntityIdMap","enabled","undefined","deleteDateColumn","updateColumnAndValues","escape","databaseName","versionColumn","updateDateColumn","whereExpression","createWhereExpression","returningExpression","createReturningExpression","getTableName","getMainTableName","join","Object","keys","map","columnName","replacePropertyNames","isMySQLFamily"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\query-builder\\SoftDeleteQueryBuilder.ts"],"sourcesContent":["import { QueryBuilder } from \"./QueryBuilder\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { EntityTarget } from \"../common/EntityTarget\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\nimport { WhereExpressionBuilder } from \"./WhereExpressionBuilder\"\nimport { Brackets } from \"./Brackets\"\nimport { UpdateResult } from \"./result/UpdateResult\"\nimport { ReturningStatementNotSupportedError } from \"../error/ReturningStatementNotSupportedError\"\nimport { ReturningResultsEntityUpdator } from \"./ReturningResultsEntityUpdator\"\nimport { OrderByCondition } from \"../find-options/OrderByCondition\"\nimport { LimitOnUpdateNotSupportedError } from \"../error/LimitOnUpdateNotSupportedError\"\nimport { MissingDeleteDateColumnError } from \"../error/MissingDeleteDateColumnError\"\nimport { UpdateValuesMissingError } from \"../error/UpdateValuesMissingError\"\nimport { TypeORMError } from \"../error\"\nimport { DriverUtils } from \"../driver/DriverUtils\"\nimport { InstanceChecker } from \"../util/InstanceChecker\"\n\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n */\nexport class SoftDeleteQueryBuilder<Entity extends ObjectLiteral>\n    extends QueryBuilder<Entity>\n    implements WhereExpressionBuilder\n{\n    readonly \"@instanceof\" = Symbol.for(\"SoftDeleteQueryBuilder\")\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        connectionOrQueryBuilder: DataSource | QueryBuilder<any>,\n        queryRunner?: QueryRunner,\n    ) {\n        super(connectionOrQueryBuilder as any, queryRunner)\n        this.expressionMap.aliasNamePrefixingEnabled = false\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Implemented Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets generated SQL query without parameters being replaced.\n     */\n    getQuery(): string {\n        let sql = this.createUpdateExpression()\n        sql += this.createCteExpression()\n        sql += this.createOrderByExpression()\n        sql += this.createLimitExpression()\n        return sql.trim()\n    }\n\n    /**\n     * Executes sql generated by query builder and returns raw database results.\n     */\n    async execute(): Promise<UpdateResult> {\n        const queryRunner = this.obtainQueryRunner()\n        let transactionStartedByUs: boolean = false\n\n        try {\n            // start transaction if it was enabled\n            if (\n                this.expressionMap.useTransaction === true &&\n                queryRunner.isTransactionActive === false\n            ) {\n                await queryRunner.startTransaction()\n                transactionStartedByUs = true\n            }\n\n            // call before soft remove and recover methods in listeners and subscribers\n            if (\n                this.expressionMap.callListeners === true &&\n                this.expressionMap.mainAlias!.hasMetadata\n            ) {\n                if (this.expressionMap.queryType === \"soft-delete\")\n                    await queryRunner.broadcaster.broadcast(\n                        \"BeforeSoftRemove\",\n                        this.expressionMap.mainAlias!.metadata,\n                    )\n                else if (this.expressionMap.queryType === \"restore\")\n                    await queryRunner.broadcaster.broadcast(\n                        \"BeforeRecover\",\n                        this.expressionMap.mainAlias!.metadata,\n                    )\n            }\n\n            // if update entity mode is enabled we may need extra columns for the returning statement\n            const returningResultsEntityUpdator =\n                new ReturningResultsEntityUpdator(\n                    queryRunner,\n                    this.expressionMap,\n                )\n            if (\n                this.expressionMap.updateEntity === true &&\n                this.expressionMap.mainAlias!.hasMetadata &&\n                this.expressionMap.whereEntities.length > 0\n            ) {\n                this.expressionMap.extraReturningColumns =\n                    returningResultsEntityUpdator.getSoftDeletionReturningColumns()\n            }\n\n            // execute update query\n            const [sql, parameters] = this.getQueryAndParameters()\n\n            const queryResult = await queryRunner.query(sql, parameters, true)\n            const updateResult = UpdateResult.from(queryResult)\n\n            // if we are updating entities and entity updation is enabled we must update some of entity columns (like version, update date, etc.)\n            if (\n                this.expressionMap.updateEntity === true &&\n                this.expressionMap.mainAlias!.hasMetadata &&\n                this.expressionMap.whereEntities.length > 0\n            ) {\n                await returningResultsEntityUpdator.update(\n                    updateResult,\n                    this.expressionMap.whereEntities,\n                )\n            }\n\n            // call after soft remove and recover methods in listeners and subscribers\n            if (\n                this.expressionMap.callListeners === true &&\n                this.expressionMap.mainAlias!.hasMetadata\n            ) {\n                if (this.expressionMap.queryType === \"soft-delete\")\n                    await queryRunner.broadcaster.broadcast(\n                        \"AfterSoftRemove\",\n                        this.expressionMap.mainAlias!.metadata,\n                    )\n                else if (this.expressionMap.queryType === \"restore\")\n                    await queryRunner.broadcaster.broadcast(\n                        \"AfterRecover\",\n                        this.expressionMap.mainAlias!.metadata,\n                    )\n            }\n\n            // close transaction if we started it\n            if (transactionStartedByUs) await queryRunner.commitTransaction()\n\n            return updateResult\n        } catch (error) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction()\n                } catch (rollbackError) {}\n            }\n            throw error\n        } finally {\n            if (queryRunner !== this.queryRunner) {\n                // means we created our own query runner\n                await queryRunner.release()\n            }\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Specifies FROM which entity's table select/update/delete/soft-delete will be executed.\n     * Also sets a main string alias of the selection data.\n     */\n    from<T extends ObjectLiteral>(\n        entityTarget: EntityTarget<T>,\n        aliasName?: string,\n    ): SoftDeleteQueryBuilder<T> {\n        entityTarget = InstanceChecker.isEntitySchema(entityTarget)\n            ? entityTarget.options.name\n            : entityTarget\n        const mainAlias = this.createFromAlias(entityTarget, aliasName)\n        this.expressionMap.setMainAlias(mainAlias)\n        return this as any as SoftDeleteQueryBuilder<T>\n    }\n\n    /**\n     * Sets WHERE condition in the query builder.\n     * If you had previously WHERE expression defined,\n     * calling this function will override previously set WHERE conditions.\n     * Additionally you can add parameters used in where expression.\n     */\n    where(\n        where:\n            | string\n            | ((qb: this) => string)\n            | Brackets\n            | ObjectLiteral\n            | ObjectLiteral[],\n        parameters?: ObjectLiteral,\n    ): this {\n        this.expressionMap.wheres = [] // don't move this block below since computeWhereParameter can add where expressions\n        const condition = this.getWhereCondition(where)\n        if (condition)\n            this.expressionMap.wheres = [\n                { type: \"simple\", condition: condition },\n            ]\n        if (parameters) this.setParameters(parameters)\n        return this\n    }\n\n    /**\n     * Adds new AND WHERE condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    andWhere(\n        where:\n            | string\n            | ((qb: this) => string)\n            | Brackets\n            | ObjectLiteral\n            | ObjectLiteral[],\n        parameters?: ObjectLiteral,\n    ): this {\n        this.expressionMap.wheres.push({\n            type: \"and\",\n            condition: this.getWhereCondition(where),\n        })\n        if (parameters) this.setParameters(parameters)\n        return this\n    }\n\n    /**\n     * Adds new OR WHERE condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    orWhere(\n        where:\n            | string\n            | ((qb: this) => string)\n            | Brackets\n            | ObjectLiteral\n            | ObjectLiteral[],\n        parameters?: ObjectLiteral,\n    ): this {\n        this.expressionMap.wheres.push({\n            type: \"or\",\n            condition: this.getWhereCondition(where),\n        })\n        if (parameters) this.setParameters(parameters)\n        return this\n    }\n\n    /**\n     * Adds new AND WHERE with conditions for the given ids.\n     */\n    whereInIds(ids: any | any[]): this {\n        return this.where(this.getWhereInIdsCondition(ids))\n    }\n\n    /**\n     * Adds new AND WHERE with conditions for the given ids.\n     */\n    andWhereInIds(ids: any | any[]): this {\n        return this.andWhere(this.getWhereInIdsCondition(ids))\n    }\n\n    /**\n     * Adds new OR WHERE with conditions for the given ids.\n     */\n    orWhereInIds(ids: any | any[]): this {\n        return this.orWhere(this.getWhereInIdsCondition(ids))\n    }\n    /**\n     * Optional returning/output clause.\n     * This will return given column values.\n     */\n    output(columns: string[]): this\n\n    /**\n     * Optional returning/output clause.\n     * Returning is a SQL string containing returning statement.\n     */\n    output(output: string): this\n\n    /**\n     * Optional returning/output clause.\n     */\n    output(output: string | string[]): this\n\n    /**\n     * Optional returning/output clause.\n     */\n    output(output: string | string[]): this {\n        return this.returning(output)\n    }\n\n    /**\n     * Optional returning/output clause.\n     * This will return given column values.\n     */\n    returning(columns: string[]): this\n\n    /**\n     * Optional returning/output clause.\n     * Returning is a SQL string containing returning statement.\n     */\n    returning(returning: string): this\n\n    /**\n     * Optional returning/output clause.\n     */\n    returning(returning: string | string[]): this\n\n    /**\n     * Optional returning/output clause.\n     */\n    returning(returning: string | string[]): this {\n        // not all databases support returning/output cause\n        if (!this.connection.driver.isReturningSqlSupported(\"update\")) {\n            throw new ReturningStatementNotSupportedError()\n        }\n\n        this.expressionMap.returning = returning\n        return this\n    }\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     *\n     * Calling order by without order set will remove all previously set order bys.\n     */\n    orderBy(): this\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(\n        sort: string,\n        order?: \"ASC\" | \"DESC\",\n        nulls?: \"NULLS FIRST\" | \"NULLS LAST\",\n    ): this\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(order: OrderByCondition): this\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(\n        sort?: string | OrderByCondition,\n        order: \"ASC\" | \"DESC\" = \"ASC\",\n        nulls?: \"NULLS FIRST\" | \"NULLS LAST\",\n    ): this {\n        if (sort) {\n            if (typeof sort === \"object\") {\n                this.expressionMap.orderBys = sort as OrderByCondition\n            } else {\n                if (nulls) {\n                    this.expressionMap.orderBys = {\n                        [sort as string]: { order, nulls },\n                    }\n                } else {\n                    this.expressionMap.orderBys = { [sort as string]: order }\n                }\n            }\n        } else {\n            this.expressionMap.orderBys = {}\n        }\n        return this\n    }\n\n    /**\n     * Adds ORDER BY condition in the query builder.\n     */\n    addOrderBy(\n        sort: string,\n        order: \"ASC\" | \"DESC\" = \"ASC\",\n        nulls?: \"NULLS FIRST\" | \"NULLS LAST\",\n    ): this {\n        if (nulls) {\n            this.expressionMap.orderBys[sort] = { order, nulls }\n        } else {\n            this.expressionMap.orderBys[sort] = order\n        }\n        return this\n    }\n\n    /**\n     * Sets LIMIT - maximum number of rows to be selected.\n     */\n    limit(limit?: number): this {\n        this.expressionMap.limit = limit\n        return this\n    }\n\n    /**\n     * Indicates if entity must be updated after update operation.\n     * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).\n     * Enabled by default.\n     */\n    whereEntity(entity: Entity | Entity[]): this {\n        if (!this.expressionMap.mainAlias!.hasMetadata)\n            throw new TypeORMError(\n                `.whereEntity method can only be used on queries which update real entity table.`,\n            )\n\n        this.expressionMap.wheres = []\n        const entities: Entity[] = Array.isArray(entity) ? entity : [entity]\n        entities.forEach((entity) => {\n            const entityIdMap =\n                this.expressionMap.mainAlias!.metadata.getEntityIdMap(entity)\n            if (!entityIdMap)\n                throw new TypeORMError(\n                    `Provided entity does not have ids set, cannot perform operation.`,\n                )\n\n            this.orWhereInIds(entityIdMap)\n        })\n\n        this.expressionMap.whereEntities = entities\n        return this\n    }\n\n    /**\n     * Indicates if entity must be updated after update operation.\n     * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).\n     * Enabled by default.\n     */\n    updateEntity(enabled: boolean): this {\n        this.expressionMap.updateEntity = enabled\n        return this\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates UPDATE express used to perform insert query.\n     */\n    protected createUpdateExpression() {\n        const metadata = this.expressionMap.mainAlias!.hasMetadata\n            ? this.expressionMap.mainAlias!.metadata\n            : undefined\n        if (!metadata)\n            throw new TypeORMError(\n                `Cannot get entity metadata for the given alias \"${this.expressionMap.mainAlias}\"`,\n            )\n        if (!metadata.deleteDateColumn) {\n            throw new MissingDeleteDateColumnError(metadata)\n        }\n\n        // prepare columns and values to be updated\n        const updateColumnAndValues: string[] = []\n\n        switch (this.expressionMap.queryType) {\n            case \"soft-delete\":\n                updateColumnAndValues.push(\n                    this.escape(metadata.deleteDateColumn.databaseName) +\n                        \" = CURRENT_TIMESTAMP\",\n                )\n                break\n            case \"restore\":\n                updateColumnAndValues.push(\n                    this.escape(metadata.deleteDateColumn.databaseName) +\n                        \" = NULL\",\n                )\n                break\n            default:\n                throw new TypeORMError(\n                    `The queryType must be \"soft-delete\" or \"restore\"`,\n                )\n        }\n        if (metadata.versionColumn)\n            updateColumnAndValues.push(\n                this.escape(metadata.versionColumn.databaseName) +\n                    \" = \" +\n                    this.escape(metadata.versionColumn.databaseName) +\n                    \" + 1\",\n            )\n        if (metadata.updateDateColumn)\n            updateColumnAndValues.push(\n                this.escape(metadata.updateDateColumn.databaseName) +\n                    \" = CURRENT_TIMESTAMP\",\n            ) // todo: fix issue with CURRENT_TIMESTAMP(6) being used, can \"DEFAULT\" be used?!\n\n        if (updateColumnAndValues.length <= 0) {\n            throw new UpdateValuesMissingError()\n        }\n\n        // get a table name and all column database names\n        const whereExpression = this.createWhereExpression()\n        const returningExpression = this.createReturningExpression(\"update\")\n\n        if (returningExpression === \"\") {\n            return `UPDATE ${this.getTableName(\n                this.getMainTableName(),\n            )} SET ${updateColumnAndValues.join(\", \")}${whereExpression}` // todo: how do we replace aliases in where to nothing?\n        }\n        if (this.connection.driver.options.type === \"mssql\") {\n            return `UPDATE ${this.getTableName(\n                this.getMainTableName(),\n            )} SET ${updateColumnAndValues.join(\n                \", \",\n            )} OUTPUT ${returningExpression}${whereExpression}`\n        }\n        return `UPDATE ${this.getTableName(\n            this.getMainTableName(),\n        )} SET ${updateColumnAndValues.join(\n            \", \",\n        )}${whereExpression} RETURNING ${returningExpression}`\n    }\n\n    /**\n     * Creates \"ORDER BY\" part of SQL query.\n     */\n    protected createOrderByExpression() {\n        const orderBys = this.expressionMap.orderBys\n        if (Object.keys(orderBys).length > 0)\n            return (\n                \" ORDER BY \" +\n                Object.keys(orderBys)\n                    .map((columnName) => {\n                        if (typeof orderBys[columnName] === \"string\") {\n                            return (\n                                this.replacePropertyNames(columnName) +\n                                \" \" +\n                                orderBys[columnName]\n                            )\n                        } else {\n                            return (\n                                this.replacePropertyNames(columnName) +\n                                \" \" +\n                                (orderBys[columnName] as any).order +\n                                \" \" +\n                                (orderBys[columnName] as any).nulls\n                            )\n                        }\n                    })\n                    .join(\", \")\n            )\n\n        return \"\"\n    }\n\n    /**\n     * Creates \"LIMIT\" parts of SQL query.\n     */\n    protected createLimitExpression(): string {\n        let limit: number | undefined = this.expressionMap.limit\n\n        if (limit) {\n            if (DriverUtils.isMySQLFamily(this.connection.driver)) {\n                return \" LIMIT \" + limit\n            } else {\n                throw new LimitOnUpdateNotSupportedError()\n            }\n        }\n\n        return \"\"\n    }\n}\n"]},"metadata":{},"sourceType":"module"}