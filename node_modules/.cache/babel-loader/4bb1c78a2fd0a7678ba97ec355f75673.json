{"ast":null,"code":"import { QueryBuilderUtils } from \"../QueryBuilderUtils\";\nimport { ObjectUtils } from \"../../util/ObjectUtils\";\nimport { TypeORMError } from \"../../error/TypeORMError\";\nexport class RelationCountAttribute {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(expressionMap, relationCountAttribute) {\n    this.expressionMap = expressionMap;\n    ObjectUtils.assign(this, relationCountAttribute || {});\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n\n  get joinInverseSideMetadata() {\n    return this.relation.inverseEntityMetadata;\n  }\n  /**\n   * Alias of the parent of this join.\n   * For example, if we join (\"post.category\", \"categoryAlias\") then \"post\" is a parent alias.\n   * This value is extracted from entityOrProperty value.\n   * This is available when join was made using \"post.category\" syntax.\n   */\n\n\n  get parentAlias() {\n    if (!QueryBuilderUtils.isAliasProperty(this.relationName)) throw new TypeORMError(`Given value must be a string representation of alias property`);\n    return this.relationName.split(\".\")[0];\n  }\n  /**\n   * Relation property name of the parent.\n   * This is used to understand what is joined.\n   * For example, if we join (\"post.category\", \"categoryAlias\") then \"category\" is a relation property.\n   * This value is extracted from entityOrProperty value.\n   * This is available when join was made using \"post.category\" syntax.\n   */\n\n\n  get relationProperty() {\n    if (!QueryBuilderUtils.isAliasProperty(this.relationName)) throw new TypeORMError(`Given value is a string representation of alias property`);\n    return this.relationName.split(\".\")[1];\n  }\n\n  get junctionAlias() {\n    const [parentAlias, relationProperty] = this.relationName.split(\".\");\n    return parentAlias + \"_\" + relationProperty + \"_rc\";\n  }\n  /**\n   * Relation of the parent.\n   * This is used to understand what is joined.\n   * This is available when join was made using \"post.category\" syntax.\n   */\n\n\n  get relation() {\n    if (!QueryBuilderUtils.isAliasProperty(this.relationName)) throw new TypeORMError(`Given value is a string representation of alias property`);\n    const [parentAlias, propertyPath] = this.relationName.split(\".\");\n    const relationOwnerSelection = this.expressionMap.findAliasByName(parentAlias);\n    const relation = relationOwnerSelection.metadata.findRelationWithPropertyPath(propertyPath);\n    if (!relation) throw new TypeORMError(`Relation with property path ${propertyPath} in entity was not found.`);\n    return relation;\n  }\n  /**\n   * Metadata of the joined entity.\n   * If table without entity was joined, then it will return undefined.\n   */\n\n\n  get metadata() {\n    if (!QueryBuilderUtils.isAliasProperty(this.relationName)) throw new TypeORMError(`Given value is a string representation of alias property`);\n    const parentAlias = this.relationName.split(\".\")[0];\n    const selection = this.expressionMap.findAliasByName(parentAlias);\n    return selection.metadata;\n  }\n\n  get mapToPropertyPropertyName() {\n    return this.mapToProperty.split(\".\")[1];\n  }\n\n}","map":{"version":3,"mappings":"AACA,SAASA,iBAAT,QAAkC,sBAAlC;AAIA,SAASC,WAAT,QAA4B,wBAA5B;AACA,SAASC,YAAT,QAA6B,0BAA7B;AAEA,OAAM,MAAOC,sBAAP,CAA6B;EAuB/B;EACA;EACA;EAEAC,YACYC,aADZ,EAEIC,sBAFJ,EAE4D;IADhD;IAGRL,WAAW,CAACM,MAAZ,CAAmB,IAAnB,EAAyBD,sBAAsB,IAAI,EAAnD;EACH,CAhC8B,CAkC/B;EACA;EACA;;;EAE2B,IAAvBE,uBAAuB;IACvB,OAAO,KAAKC,QAAL,CAAcC,qBAArB;EACH;EAED;;;;;;;;EAMe,IAAXC,WAAW;IACX,IAAI,CAACX,iBAAiB,CAACY,eAAlB,CAAkC,KAAKC,YAAvC,CAAL,EACI,MAAM,IAAIX,YAAJ,CACF,+DADE,CAAN;IAIJ,OAAO,KAAKW,YAAL,CAAkBC,KAAlB,CAAwB,GAAxB,EAA6B,CAA7B,CAAP;EACH;EAED;;;;;;;;;EAOoB,IAAhBC,gBAAgB;IAChB,IAAI,CAACf,iBAAiB,CAACY,eAAlB,CAAkC,KAAKC,YAAvC,CAAL,EACI,MAAM,IAAIX,YAAJ,CACF,0DADE,CAAN;IAIJ,OAAO,KAAKW,YAAL,CAAkBC,KAAlB,CAAwB,GAAxB,EAA6B,CAA7B,CAAP;EACH;;EAEgB,IAAbE,aAAa;IACb,MAAM,CAACL,WAAD,EAAcI,gBAAd,IAAkC,KAAKF,YAAL,CAAkBC,KAAlB,CAAwB,GAAxB,CAAxC;IACA,OAAOH,WAAW,GAAG,GAAd,GAAoBI,gBAApB,GAAuC,KAA9C;EACH;EAED;;;;;;;EAKY,IAARN,QAAQ;IACR,IAAI,CAACT,iBAAiB,CAACY,eAAlB,CAAkC,KAAKC,YAAvC,CAAL,EACI,MAAM,IAAIX,YAAJ,CACF,0DADE,CAAN;IAIJ,MAAM,CAACS,WAAD,EAAcM,YAAd,IAA8B,KAAKJ,YAAL,CAAkBC,KAAlB,CAAwB,GAAxB,CAApC;IACA,MAAMI,sBAAsB,GACxB,KAAKb,aAAL,CAAmBc,eAAnB,CAAmCR,WAAnC,CADJ;IAEA,MAAMF,QAAQ,GACVS,sBAAsB,CAACE,QAAvB,CAAgCC,4BAAhC,CACIJ,YADJ,CADJ;IAIA,IAAI,CAACR,QAAL,EACI,MAAM,IAAIP,YAAJ,CACF,+BAA+Be,YAAY,2BADzC,CAAN;IAGJ,OAAOR,QAAP;EACH;EAED;;;;;;EAIY,IAARW,QAAQ;IACR,IAAI,CAACpB,iBAAiB,CAACY,eAAlB,CAAkC,KAAKC,YAAvC,CAAL,EACI,MAAM,IAAIX,YAAJ,CACF,0DADE,CAAN;IAIJ,MAAMS,WAAW,GAAG,KAAKE,YAAL,CAAkBC,KAAlB,CAAwB,GAAxB,EAA6B,CAA7B,CAApB;IACA,MAAMQ,SAAS,GAAG,KAAKjB,aAAL,CAAmBc,eAAnB,CAAmCR,WAAnC,CAAlB;IACA,OAAOW,SAAS,CAACF,QAAjB;EACH;;EAE4B,IAAzBG,yBAAyB;IACzB,OAAO,KAAKC,aAAL,CAAoBV,KAApB,CAA0B,GAA1B,EAA+B,CAA/B,CAAP;EACH;;AAxH8B","names":["QueryBuilderUtils","ObjectUtils","TypeORMError","RelationCountAttribute","constructor","expressionMap","relationCountAttribute","assign","joinInverseSideMetadata","relation","inverseEntityMetadata","parentAlias","isAliasProperty","relationName","split","relationProperty","junctionAlias","propertyPath","relationOwnerSelection","findAliasByName","metadata","findRelationWithPropertyPath","selection","mapToPropertyPropertyName","mapToProperty"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\query-builder\\relation-count\\RelationCountAttribute.ts"],"sourcesContent":["import { EntityMetadata } from \"../../metadata/EntityMetadata\"\nimport { QueryBuilderUtils } from \"../QueryBuilderUtils\"\nimport { RelationMetadata } from \"../../metadata/RelationMetadata\"\nimport { QueryExpressionMap } from \"../QueryExpressionMap\"\nimport { SelectQueryBuilder } from \"../SelectQueryBuilder\"\nimport { ObjectUtils } from \"../../util/ObjectUtils\"\nimport { TypeORMError } from \"../../error/TypeORMError\"\n\nexport class RelationCountAttribute {\n    /**\n     * Alias of the joined (destination) table.\n     */\n    alias?: string\n\n    /**\n     * Name of relation.\n     */\n    relationName: string\n\n    /**\n     * Property + alias of the object where to joined data should be mapped.\n     */\n    mapToProperty: string\n\n    /**\n     * Extra condition applied to \"ON\" section of join.\n     */\n    queryBuilderFactory?: (\n        qb: SelectQueryBuilder<any>,\n    ) => SelectQueryBuilder<any>\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        private expressionMap: QueryExpressionMap,\n        relationCountAttribute?: Partial<RelationCountAttribute>,\n    ) {\n        ObjectUtils.assign(this, relationCountAttribute || {})\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    get joinInverseSideMetadata(): EntityMetadata {\n        return this.relation.inverseEntityMetadata\n    }\n\n    /**\n     * Alias of the parent of this join.\n     * For example, if we join (\"post.category\", \"categoryAlias\") then \"post\" is a parent alias.\n     * This value is extracted from entityOrProperty value.\n     * This is available when join was made using \"post.category\" syntax.\n     */\n    get parentAlias(): string {\n        if (!QueryBuilderUtils.isAliasProperty(this.relationName))\n            throw new TypeORMError(\n                `Given value must be a string representation of alias property`,\n            )\n\n        return this.relationName.split(\".\")[0]\n    }\n\n    /**\n     * Relation property name of the parent.\n     * This is used to understand what is joined.\n     * For example, if we join (\"post.category\", \"categoryAlias\") then \"category\" is a relation property.\n     * This value is extracted from entityOrProperty value.\n     * This is available when join was made using \"post.category\" syntax.\n     */\n    get relationProperty(): string | undefined {\n        if (!QueryBuilderUtils.isAliasProperty(this.relationName))\n            throw new TypeORMError(\n                `Given value is a string representation of alias property`,\n            )\n\n        return this.relationName.split(\".\")[1]\n    }\n\n    get junctionAlias(): string {\n        const [parentAlias, relationProperty] = this.relationName.split(\".\")\n        return parentAlias + \"_\" + relationProperty + \"_rc\"\n    }\n\n    /**\n     * Relation of the parent.\n     * This is used to understand what is joined.\n     * This is available when join was made using \"post.category\" syntax.\n     */\n    get relation(): RelationMetadata {\n        if (!QueryBuilderUtils.isAliasProperty(this.relationName))\n            throw new TypeORMError(\n                `Given value is a string representation of alias property`,\n            )\n\n        const [parentAlias, propertyPath] = this.relationName.split(\".\")\n        const relationOwnerSelection =\n            this.expressionMap.findAliasByName(parentAlias)\n        const relation =\n            relationOwnerSelection.metadata.findRelationWithPropertyPath(\n                propertyPath,\n            )\n        if (!relation)\n            throw new TypeORMError(\n                `Relation with property path ${propertyPath} in entity was not found.`,\n            )\n        return relation\n    }\n\n    /**\n     * Metadata of the joined entity.\n     * If table without entity was joined, then it will return undefined.\n     */\n    get metadata(): EntityMetadata {\n        if (!QueryBuilderUtils.isAliasProperty(this.relationName))\n            throw new TypeORMError(\n                `Given value is a string representation of alias property`,\n            )\n\n        const parentAlias = this.relationName.split(\".\")[0]\n        const selection = this.expressionMap.findAliasByName(parentAlias)\n        return selection.metadata\n    }\n\n    get mapToPropertyPropertyName(): string {\n        return this.mapToProperty!.split(\".\")[1]\n    }\n}\n"]},"metadata":{},"sourceType":"module"}