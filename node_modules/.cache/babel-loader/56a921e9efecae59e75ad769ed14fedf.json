{"ast":null,"code":"import { MustBeEntityError } from \"../error/MustBeEntityError\";\nimport { SubjectExecutor } from \"./SubjectExecutor\";\nimport { CannotDetermineEntityError } from \"../error/CannotDetermineEntityError\";\nimport { Subject } from \"./Subject\";\nimport { OneToManySubjectBuilder } from \"./subject-builder/OneToManySubjectBuilder\";\nimport { OneToOneInverseSideSubjectBuilder } from \"./subject-builder/OneToOneInverseSideSubjectBuilder\";\nimport { ManyToManySubjectBuilder } from \"./subject-builder/ManyToManySubjectBuilder\";\nimport { SubjectDatabaseEntityLoader } from \"./SubjectDatabaseEntityLoader\";\nimport { CascadesSubjectBuilder } from \"./subject-builder/CascadesSubjectBuilder\";\nimport { OrmUtils } from \"../util/OrmUtils\";\n/**\n * Persists a single entity or multiple entities - saves or removes them.\n */\n\nexport class EntityPersistExecutor {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection, queryRunner, mode, target, entity, options) {\n    this.connection = connection;\n    this.queryRunner = queryRunner;\n    this.mode = mode;\n    this.target = target;\n    this.entity = entity;\n    this.options = options;\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Executes persistence operation ob given entity or entities.\n   */\n\n\n  async execute() {\n    // check if entity we are going to save is valid and is an object\n    if (!this.entity || typeof this.entity !== \"object\") return Promise.reject(new MustBeEntityError(this.mode, this.entity)); // we MUST call \"fake\" resolve here to make sure all properties of lazily loaded relations are resolved\n\n    await Promise.resolve(); // if query runner is already defined in this class, it means this entity manager was already created for a single connection\n    // if its not defined we create a new query runner - single connection where we'll execute all our operations\n\n    const queryRunner = this.queryRunner || this.connection.createQueryRunner(); // save data in the query runner - this is useful functionality to share data from outside of the world\n    // with third classes - like subscribers and listener methods\n\n    let oldQueryRunnerData = queryRunner.data;\n\n    if (this.options && this.options.data) {\n      queryRunner.data = this.options.data;\n    }\n\n    try {\n      // collect all operate subjects\n      const entities = Array.isArray(this.entity) ? this.entity : [this.entity];\n      const entitiesInChunks = this.options && this.options.chunk && this.options.chunk > 0 ? OrmUtils.chunk(entities, this.options.chunk) : [entities]; // console.time(\"building subject executors...\");\n\n      const executors = await Promise.all(entitiesInChunks.map(async entities => {\n        const subjects = []; // create subjects for all entities we received for the persistence\n\n        entities.forEach(entity => {\n          const entityTarget = this.target ? this.target : entity.constructor;\n          if (entityTarget === Object) throw new CannotDetermineEntityError(this.mode);\n          let metadata = this.connection.getMetadata(entityTarget); // Check for single table inheritance and find the correct metadata in that case.\n          // Goal is to use the correct discriminator as we could have a repository\n          // for an (abstract) base class and thus the target would not match.\n\n          if (metadata.inheritancePattern === \"STI\" && metadata.childEntityMetadatas.length > 0) {\n            const matchingChildMetadata = metadata.childEntityMetadatas.find(meta => entity.constructor === meta.target);\n\n            if (matchingChildMetadata) {\n              metadata = matchingChildMetadata;\n            }\n          }\n\n          subjects.push(new Subject({\n            metadata,\n            entity: entity,\n            canBeInserted: this.mode === \"save\",\n            canBeUpdated: this.mode === \"save\",\n            mustBeRemoved: this.mode === \"remove\",\n            canBeSoftRemoved: this.mode === \"soft-remove\",\n            canBeRecovered: this.mode === \"recover\"\n          }));\n        }); // console.time(\"building cascades...\");\n        // go through each entity with metadata and create subjects and subjects by cascades for them\n\n        const cascadesSubjectBuilder = new CascadesSubjectBuilder(subjects);\n        subjects.forEach(subject => {\n          // next step we build list of subjects we will operate with\n          // these subjects are subjects that we need to insert or update alongside with main persisted entity\n          cascadesSubjectBuilder.build(subject, this.mode);\n        }); // console.timeEnd(\"building cascades...\");\n        // load database entities for all subjects we have\n        // next step is to load database entities for all operate subjects\n        // console.time(\"loading...\");\n\n        await new SubjectDatabaseEntityLoader(queryRunner, subjects).load(this.mode); // console.timeEnd(\"loading...\");\n        // console.time(\"other subjects...\");\n        // build all related subjects and change maps\n\n        if (this.mode === \"save\" || this.mode === \"soft-remove\" || this.mode === \"recover\") {\n          new OneToManySubjectBuilder(subjects).build();\n          new OneToOneInverseSideSubjectBuilder(subjects).build();\n          new ManyToManySubjectBuilder(subjects).build();\n        } else {\n          subjects.forEach(subject => {\n            if (subject.mustBeRemoved) {\n              new ManyToManySubjectBuilder(subjects).buildForAllRemoval(subject);\n            }\n          });\n        } // console.timeEnd(\"other subjects...\");\n        // console.timeEnd(\"building subjects...\");\n        // console.log(\"subjects\", subjects);\n        // create a subject executor\n\n\n        return new SubjectExecutor(queryRunner, subjects, this.options);\n      })); // console.timeEnd(\"building subject executors...\");\n      // make sure we have at least one executable operation before we create a transaction and proceed\n      // if we don't have operations it means we don't really need to update or remove something\n\n      const executorsWithExecutableOperations = executors.filter(executor => executor.hasExecutableOperations);\n      if (executorsWithExecutableOperations.length === 0) return; // start execute queries in a transaction\n      // if transaction is already opened in this query runner then we don't touch it\n      // if its not opened yet then we open it here, and once we finish - we close it\n\n      let isTransactionStartedByUs = false;\n\n      try {\n        // open transaction if its not opened yet\n        if (!queryRunner.isTransactionActive) {\n          if (!this.options || this.options.transaction !== false) {\n            // start transaction until it was not explicitly disabled\n            isTransactionStartedByUs = true;\n            await queryRunner.startTransaction();\n          }\n        } // execute all persistence operations for all entities we have\n        // console.time(\"executing subject executors...\");\n\n\n        for (const executor of executorsWithExecutableOperations) {\n          await executor.execute();\n        } // console.timeEnd(\"executing subject executors...\");\n        // commit transaction if it was started by us\n        // console.time(\"commit\");\n\n\n        if (isTransactionStartedByUs === true) await queryRunner.commitTransaction(); // console.timeEnd(\"commit\");\n      } catch (error) {\n        // rollback transaction if it was started by us\n        if (isTransactionStartedByUs) {\n          try {\n            await queryRunner.rollbackTransaction();\n          } catch (rollbackError) {}\n        }\n\n        throw error;\n      }\n    } finally {\n      queryRunner.data = oldQueryRunnerData; // release query runner only if its created by us\n\n      if (!this.queryRunner) await queryRunner.release();\n    }\n  }\n\n}","map":{"version":3,"mappings":"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","names":["MustBeEntityError","SubjectExecutor","CannotDetermineEntityError","Subject","OneToManySubjectBuilder","OneToOneInverseSideSubjectBuilder","ManyToManySubjectBuilder","SubjectDatabaseEntityLoader","CascadesSubjectBuilder","OrmUtils","EntityPersistExecutor","constructor","connection","queryRunner","mode","target","entity","options","execute","Promise","reject","resolve","createQueryRunner","oldQueryRunnerData","data","entities","Array","isArray","entitiesInChunks","chunk","executors","all","map","subjects","forEach","entityTarget","Object","metadata","getMetadata","inheritancePattern","childEntityMetadatas","length","matchingChildMetadata","find","meta","push","canBeInserted","canBeUpdated","mustBeRemoved","canBeSoftRemoved","canBeRecovered","cascadesSubjectBuilder","subject","build","load","buildForAllRemoval","executorsWithExecutableOperations","filter","executor","hasExecutableOperations","isTransactionStartedByUs","isTransactionActive","transaction","startTransaction","commitTransaction","error","rollbackTransaction","rollbackError","release"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\persistence\\EntityPersistExecutor.ts"],"sourcesContent":["import { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { SaveOptions } from \"../repository/SaveOptions\"\nimport { RemoveOptions } from \"../repository/RemoveOptions\"\nimport { MustBeEntityError } from \"../error/MustBeEntityError\"\nimport { SubjectExecutor } from \"./SubjectExecutor\"\nimport { CannotDetermineEntityError } from \"../error/CannotDetermineEntityError\"\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { Subject } from \"./Subject\"\nimport { OneToManySubjectBuilder } from \"./subject-builder/OneToManySubjectBuilder\"\nimport { OneToOneInverseSideSubjectBuilder } from \"./subject-builder/OneToOneInverseSideSubjectBuilder\"\nimport { ManyToManySubjectBuilder } from \"./subject-builder/ManyToManySubjectBuilder\"\nimport { SubjectDatabaseEntityLoader } from \"./SubjectDatabaseEntityLoader\"\nimport { CascadesSubjectBuilder } from \"./subject-builder/CascadesSubjectBuilder\"\nimport { OrmUtils } from \"../util/OrmUtils\"\n\n/**\n * Persists a single entity or multiple entities - saves or removes them.\n */\nexport class EntityPersistExecutor {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        protected connection: DataSource,\n        protected queryRunner: QueryRunner | undefined,\n        protected mode: \"save\" | \"remove\" | \"soft-remove\" | \"recover\",\n        protected target: Function | string | undefined,\n        protected entity: ObjectLiteral | ObjectLiteral[],\n        protected options?: SaveOptions & RemoveOptions,\n    ) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Executes persistence operation ob given entity or entities.\n     */\n    async execute(): Promise<void> {\n        // check if entity we are going to save is valid and is an object\n        if (!this.entity || typeof this.entity !== \"object\")\n            return Promise.reject(new MustBeEntityError(this.mode, this.entity))\n\n        // we MUST call \"fake\" resolve here to make sure all properties of lazily loaded relations are resolved\n        await Promise.resolve()\n\n        // if query runner is already defined in this class, it means this entity manager was already created for a single connection\n        // if its not defined we create a new query runner - single connection where we'll execute all our operations\n        const queryRunner =\n            this.queryRunner || this.connection.createQueryRunner()\n\n        // save data in the query runner - this is useful functionality to share data from outside of the world\n        // with third classes - like subscribers and listener methods\n        let oldQueryRunnerData = queryRunner.data\n        if (this.options && this.options.data) {\n            queryRunner.data = this.options.data\n        }\n\n        try {\n            // collect all operate subjects\n            const entities: ObjectLiteral[] = Array.isArray(this.entity)\n                ? this.entity\n                : [this.entity]\n            const entitiesInChunks =\n                this.options && this.options.chunk && this.options.chunk > 0\n                    ? OrmUtils.chunk(entities, this.options.chunk)\n                    : [entities]\n\n            // console.time(\"building subject executors...\");\n            const executors = await Promise.all(\n                entitiesInChunks.map(async (entities) => {\n                    const subjects: Subject[] = []\n\n                    // create subjects for all entities we received for the persistence\n                    entities.forEach((entity) => {\n                        const entityTarget = this.target\n                            ? this.target\n                            : entity.constructor\n                        if (entityTarget === Object)\n                            throw new CannotDetermineEntityError(this.mode)\n\n                        let metadata = this.connection.getMetadata(entityTarget)\n\n                        // Check for single table inheritance and find the correct metadata in that case.\n                        // Goal is to use the correct discriminator as we could have a repository\n                        // for an (abstract) base class and thus the target would not match.\n                        if (\n                            metadata.inheritancePattern === \"STI\" &&\n                            metadata.childEntityMetadatas.length > 0\n                        ) {\n                            const matchingChildMetadata =\n                                metadata.childEntityMetadatas.find(\n                                    (meta) =>\n                                        entity.constructor === meta.target,\n                                )\n                            if (matchingChildMetadata) {\n                                metadata = matchingChildMetadata\n                            }\n                        }\n\n                        subjects.push(\n                            new Subject({\n                                metadata,\n                                entity: entity,\n                                canBeInserted: this.mode === \"save\",\n                                canBeUpdated: this.mode === \"save\",\n                                mustBeRemoved: this.mode === \"remove\",\n                                canBeSoftRemoved: this.mode === \"soft-remove\",\n                                canBeRecovered: this.mode === \"recover\",\n                            }),\n                        )\n                    })\n\n                    // console.time(\"building cascades...\");\n                    // go through each entity with metadata and create subjects and subjects by cascades for them\n                    const cascadesSubjectBuilder = new CascadesSubjectBuilder(\n                        subjects,\n                    )\n                    subjects.forEach((subject) => {\n                        // next step we build list of subjects we will operate with\n                        // these subjects are subjects that we need to insert or update alongside with main persisted entity\n                        cascadesSubjectBuilder.build(subject, this.mode)\n                    })\n                    // console.timeEnd(\"building cascades...\");\n\n                    // load database entities for all subjects we have\n                    // next step is to load database entities for all operate subjects\n                    // console.time(\"loading...\");\n                    await new SubjectDatabaseEntityLoader(\n                        queryRunner,\n                        subjects,\n                    ).load(this.mode)\n                    // console.timeEnd(\"loading...\");\n\n                    // console.time(\"other subjects...\");\n                    // build all related subjects and change maps\n                    if (\n                        this.mode === \"save\" ||\n                        this.mode === \"soft-remove\" ||\n                        this.mode === \"recover\"\n                    ) {\n                        new OneToManySubjectBuilder(subjects).build()\n                        new OneToOneInverseSideSubjectBuilder(subjects).build()\n                        new ManyToManySubjectBuilder(subjects).build()\n                    } else {\n                        subjects.forEach((subject) => {\n                            if (subject.mustBeRemoved) {\n                                new ManyToManySubjectBuilder(\n                                    subjects,\n                                ).buildForAllRemoval(subject)\n                            }\n                        })\n                    }\n                    // console.timeEnd(\"other subjects...\");\n                    // console.timeEnd(\"building subjects...\");\n                    // console.log(\"subjects\", subjects);\n\n                    // create a subject executor\n                    return new SubjectExecutor(\n                        queryRunner,\n                        subjects,\n                        this.options,\n                    )\n                }),\n            )\n            // console.timeEnd(\"building subject executors...\");\n\n            // make sure we have at least one executable operation before we create a transaction and proceed\n            // if we don't have operations it means we don't really need to update or remove something\n            const executorsWithExecutableOperations = executors.filter(\n                (executor) => executor.hasExecutableOperations,\n            )\n            if (executorsWithExecutableOperations.length === 0) return\n\n            // start execute queries in a transaction\n            // if transaction is already opened in this query runner then we don't touch it\n            // if its not opened yet then we open it here, and once we finish - we close it\n            let isTransactionStartedByUs = false\n            try {\n                // open transaction if its not opened yet\n                if (!queryRunner.isTransactionActive) {\n                    if (!this.options || this.options.transaction !== false) {\n                        // start transaction until it was not explicitly disabled\n                        isTransactionStartedByUs = true\n                        await queryRunner.startTransaction()\n                    }\n                }\n\n                // execute all persistence operations for all entities we have\n                // console.time(\"executing subject executors...\");\n                for (const executor of executorsWithExecutableOperations) {\n                    await executor.execute()\n                }\n                // console.timeEnd(\"executing subject executors...\");\n\n                // commit transaction if it was started by us\n                // console.time(\"commit\");\n                if (isTransactionStartedByUs === true)\n                    await queryRunner.commitTransaction()\n                // console.timeEnd(\"commit\");\n            } catch (error) {\n                // rollback transaction if it was started by us\n                if (isTransactionStartedByUs) {\n                    try {\n                        await queryRunner.rollbackTransaction()\n                    } catch (rollbackError) {}\n                }\n                throw error\n            }\n        } finally {\n            queryRunner.data = oldQueryRunnerData\n\n            // release query runner only if its created by us\n            if (!this.queryRunner) await queryRunner.release()\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}