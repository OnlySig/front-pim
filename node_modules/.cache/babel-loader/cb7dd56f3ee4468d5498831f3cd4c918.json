{"ast":null,"code":"import { QueryRunnerAlreadyReleasedError } from \"../../error/QueryRunnerAlreadyReleasedError\";\nimport { QueryFailedError } from \"../../error/QueryFailedError\";\nimport { AbstractSqliteQueryRunner } from \"../sqlite-abstract/AbstractSqliteQueryRunner\";\nimport { Broadcaster } from \"../../subscriber/Broadcaster\";\nimport { TypeORMError } from \"../../error\";\nimport { QueryResult } from \"../../query-runner/QueryResult\";\n/**\n * Runs queries on a single sqlite database connection.\n */\n\nexport class CordovaQueryRunner extends AbstractSqliteQueryRunner {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(driver) {\n    super();\n    this.driver = driver;\n    this.connection = driver.connection;\n    this.broadcaster = new Broadcaster(this);\n  }\n  /**\n   * Called before migrations are run.\n   */\n\n\n  async beforeMigration() {\n    await this.query(`PRAGMA foreign_keys = OFF`);\n  }\n  /**\n   * Called after migrations are run.\n   */\n\n\n  async afterMigration() {\n    await this.query(`PRAGMA foreign_keys = ON`);\n  }\n  /**\n   * Executes a given SQL query.\n   */\n\n\n  async query(query, parameters) {\n    let useStructuredResult = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (this.isReleased) throw new QueryRunnerAlreadyReleasedError();\n    const databaseConnection = await this.connect();\n    this.driver.connection.logger.logQuery(query, parameters, this);\n    const queryStartTime = +new Date();\n\n    try {\n      const raw = await new Promise(async (ok, fail) => {\n        databaseConnection.executeSql(query, parameters, raw => ok(raw), err => fail(err));\n      }); // log slow queries if maxQueryExecution time is set\n\n      const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;\n      const queryEndTime = +new Date();\n      const queryExecutionTime = queryEndTime - queryStartTime;\n\n      if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) {\n        this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);\n      }\n\n      const result = new QueryResult();\n\n      if (query.substr(0, 11) === \"INSERT INTO\") {\n        result.raw = raw.insertId;\n      } else {\n        let resultSet = [];\n\n        for (let i = 0; i < raw.rows.length; i++) {\n          resultSet.push(raw.rows.item(i));\n        }\n\n        result.records = resultSet;\n        result.raw = resultSet;\n      }\n\n      if (useStructuredResult) {\n        return result;\n      } else {\n        return result.raw;\n      }\n    } catch (err) {\n      this.driver.connection.logger.logQueryError(err, query, parameters, this);\n      throw new QueryFailedError(query, parameters, err);\n    }\n  }\n  /**\n   * Insert a new row with given values into the given table.\n   * Returns value of the generated column if given and generate column exist in the table.\n   // todo: implement new syntax\n  async insert(tableName: string, keyValues: ObjectLiteral): Promise<InsertResult> {\n      const keys = Object.keys(keyValues);\n      const columns = keys.map(key => `\"${key}\"`).join(\", \");\n      const values = keys.map(key => \"?\").join(\",\");\n      const generatedColumns = this.connection.hasMetadata(tableName) ? this.connection.getMetadata(tableName).generatedColumns : [];\n      const sql = columns.length > 0 ? (`INSERT INTO \"${tableName}\"(${columns}) VALUES (${values})`) : `INSERT INTO \"${tableName}\" DEFAULT VALUES`;\n      const parameters = keys.map(key => keyValues[key]);\n       return new Promise<InsertResult>(async (ok, fail) => {\n          this.driver.connection.logger.logQuery(sql, parameters, this);\n          const __this = this;\n          const databaseConnection = await this.connect();\n          databaseConnection.executeSql(sql, parameters, (resultSet: any) => {\n              const generatedMap = generatedColumns.reduce((map, generatedColumn) => {\n                  const value = generatedColumn.isPrimary && generatedColumn.generationStrategy === \"increment\" && resultSet.insertId ? resultSet.insertId : keyValues[generatedColumn.databaseName];\n                  if (!value) return map;\n                  return OrmUtils.mergeDeep(map, generatedColumn.createValueMap(value));\n              }, {} as ObjectLiteral);\n               ok({\n                  result: undefined,\n                  generatedMap: Object.keys(generatedMap).length > 0 ? generatedMap : undefined\n              });\n          }, (err: any) => {\n              __this.driver.connection.logger.logQueryError(err, sql, parameters, this);\n              fail(err);\n          });\n      });\n  }*/\n\n  /**\n   * Would start a transaction but this driver does not support transactions.\n   */\n\n\n  async startTransaction() {\n    throw new TypeORMError(\"Transactions are not supported by the Cordova driver\");\n  }\n  /**\n   * Would start a transaction but this driver does not support transactions.\n   */\n\n\n  async commitTransaction() {\n    throw new TypeORMError(\"Transactions are not supported by the Cordova driver\");\n  }\n  /**\n   * Would start a transaction but this driver does not support transactions.\n   */\n\n\n  async rollbackTransaction() {\n    throw new TypeORMError(\"Transactions are not supported by the Cordova driver\");\n  }\n  /**\n   * Removes all tables from the currently connected database.\n   * Be careful with using this method and avoid using it in production or migrations\n   * (because it can clear all your database).\n   */\n\n\n  async clearDatabase() {\n    await this.query(`PRAGMA foreign_keys = OFF`);\n\n    try {\n      const selectViewDropsQuery = `SELECT 'DROP VIEW \"' || name || '\";' as query FROM \"sqlite_master\" WHERE \"type\" = 'view'`;\n      const dropViewQueries = await this.query(selectViewDropsQuery);\n      const selectTableDropsQuery = `SELECT 'DROP TABLE \"' || name || '\";' as query FROM \"sqlite_master\" WHERE \"type\" = 'table' AND \"name\" != 'sqlite_sequence'`;\n      const dropTableQueries = await this.query(selectTableDropsQuery);\n      await Promise.all(dropViewQueries.map(q => this.query(q[\"query\"])));\n      await Promise.all(dropTableQueries.map(q => this.query(q[\"query\"])));\n    } finally {\n      await this.query(`PRAGMA foreign_keys = ON`);\n    }\n  } // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Parametrizes given object of values. Used to create column=value queries.\n   */\n\n\n  parametrize(objectLiteral) {\n    let startIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return Object.keys(objectLiteral).map((key, index) => `\"${key}\"` + \"=?\");\n  }\n\n}","map":{"version":3,"mappings":"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","names":["QueryRunnerAlreadyReleasedError","QueryFailedError","AbstractSqliteQueryRunner","Broadcaster","TypeORMError","QueryResult","CordovaQueryRunner","constructor","driver","connection","broadcaster","beforeMigration","query","afterMigration","parameters","useStructuredResult","isReleased","databaseConnection","connect","logger","logQuery","queryStartTime","Date","raw","Promise","ok","fail","executeSql","err","maxQueryExecutionTime","options","queryEndTime","queryExecutionTime","logQuerySlow","result","substr","insertId","resultSet","i","rows","length","push","item","records","logQueryError","startTransaction","commitTransaction","rollbackTransaction","clearDatabase","selectViewDropsQuery","dropViewQueries","selectTableDropsQuery","dropTableQueries","all","map","q","parametrize","objectLiteral","startIndex","Object","keys","key","index"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\driver\\cordova\\CordovaQueryRunner.ts"],"sourcesContent":["import { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { QueryRunnerAlreadyReleasedError } from \"../../error/QueryRunnerAlreadyReleasedError\"\nimport { QueryFailedError } from \"../../error/QueryFailedError\"\nimport { AbstractSqliteQueryRunner } from \"../sqlite-abstract/AbstractSqliteQueryRunner\"\nimport { CordovaDriver } from \"./CordovaDriver\"\nimport { Broadcaster } from \"../../subscriber/Broadcaster\"\nimport { TypeORMError } from \"../../error\"\nimport { QueryResult } from \"../../query-runner/QueryResult\"\n\n/**\n * Runs queries on a single sqlite database connection.\n */\nexport class CordovaQueryRunner extends AbstractSqliteQueryRunner {\n    /**\n     * Database driver used by connection.\n     */\n    driver: CordovaDriver\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(driver: CordovaDriver) {\n        super()\n        this.driver = driver\n        this.connection = driver.connection\n        this.broadcaster = new Broadcaster(this)\n    }\n\n    /**\n     * Called before migrations are run.\n     */\n    async beforeMigration(): Promise<void> {\n        await this.query(`PRAGMA foreign_keys = OFF`)\n    }\n\n    /**\n     * Called after migrations are run.\n     */\n    async afterMigration(): Promise<void> {\n        await this.query(`PRAGMA foreign_keys = ON`)\n    }\n\n    /**\n     * Executes a given SQL query.\n     */\n    async query(\n        query: string,\n        parameters?: any[],\n        useStructuredResult = false,\n    ): Promise<any> {\n        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError()\n\n        const databaseConnection = await this.connect()\n        this.driver.connection.logger.logQuery(query, parameters, this)\n        const queryStartTime = +new Date()\n\n        try {\n            const raw = await new Promise<any>(async (ok, fail) => {\n                databaseConnection.executeSql(\n                    query,\n                    parameters,\n                    (raw: any) => ok(raw),\n                    (err: any) => fail(err),\n                )\n            })\n\n            // log slow queries if maxQueryExecution time is set\n            const maxQueryExecutionTime =\n                this.driver.options.maxQueryExecutionTime\n            const queryEndTime = +new Date()\n            const queryExecutionTime = queryEndTime - queryStartTime\n            if (\n                maxQueryExecutionTime &&\n                queryExecutionTime > maxQueryExecutionTime\n            ) {\n                this.driver.connection.logger.logQuerySlow(\n                    queryExecutionTime,\n                    query,\n                    parameters,\n                    this,\n                )\n            }\n\n            const result = new QueryResult()\n\n            if (query.substr(0, 11) === \"INSERT INTO\") {\n                result.raw = raw.insertId\n            } else {\n                let resultSet = []\n                for (let i = 0; i < raw.rows.length; i++) {\n                    resultSet.push(raw.rows.item(i))\n                }\n\n                result.records = resultSet\n                result.raw = resultSet\n            }\n\n            if (useStructuredResult) {\n                return result\n            } else {\n                return result.raw\n            }\n        } catch (err) {\n            this.driver.connection.logger.logQueryError(\n                err,\n                query,\n                parameters,\n                this,\n            )\n            throw new QueryFailedError(query, parameters, err)\n        }\n    }\n\n    /**\n     * Insert a new row with given values into the given table.\n     * Returns value of the generated column if given and generate column exist in the table.\n     // todo: implement new syntax\n    async insert(tableName: string, keyValues: ObjectLiteral): Promise<InsertResult> {\n        const keys = Object.keys(keyValues);\n        const columns = keys.map(key => `\"${key}\"`).join(\", \");\n        const values = keys.map(key => \"?\").join(\",\");\n        const generatedColumns = this.connection.hasMetadata(tableName) ? this.connection.getMetadata(tableName).generatedColumns : [];\n        const sql = columns.length > 0 ? (`INSERT INTO \"${tableName}\"(${columns}) VALUES (${values})`) : `INSERT INTO \"${tableName}\" DEFAULT VALUES`;\n        const parameters = keys.map(key => keyValues[key]);\n\n        return new Promise<InsertResult>(async (ok, fail) => {\n            this.driver.connection.logger.logQuery(sql, parameters, this);\n            const __this = this;\n            const databaseConnection = await this.connect();\n            databaseConnection.executeSql(sql, parameters, (resultSet: any) => {\n                const generatedMap = generatedColumns.reduce((map, generatedColumn) => {\n                    const value = generatedColumn.isPrimary && generatedColumn.generationStrategy === \"increment\" && resultSet.insertId ? resultSet.insertId : keyValues[generatedColumn.databaseName];\n                    if (!value) return map;\n                    return OrmUtils.mergeDeep(map, generatedColumn.createValueMap(value));\n                }, {} as ObjectLiteral);\n\n                ok({\n                    result: undefined,\n                    generatedMap: Object.keys(generatedMap).length > 0 ? generatedMap : undefined\n                });\n            }, (err: any) => {\n                __this.driver.connection.logger.logQueryError(err, sql, parameters, this);\n                fail(err);\n            });\n        });\n    }*/\n\n    /**\n     * Would start a transaction but this driver does not support transactions.\n     */\n    async startTransaction(): Promise<void> {\n        throw new TypeORMError(\n            \"Transactions are not supported by the Cordova driver\",\n        )\n    }\n\n    /**\n     * Would start a transaction but this driver does not support transactions.\n     */\n    async commitTransaction(): Promise<void> {\n        throw new TypeORMError(\n            \"Transactions are not supported by the Cordova driver\",\n        )\n    }\n\n    /**\n     * Would start a transaction but this driver does not support transactions.\n     */\n    async rollbackTransaction(): Promise<void> {\n        throw new TypeORMError(\n            \"Transactions are not supported by the Cordova driver\",\n        )\n    }\n\n    /**\n     * Removes all tables from the currently connected database.\n     * Be careful with using this method and avoid using it in production or migrations\n     * (because it can clear all your database).\n     */\n    async clearDatabase(): Promise<void> {\n        await this.query(`PRAGMA foreign_keys = OFF`)\n        try {\n            const selectViewDropsQuery = `SELECT 'DROP VIEW \"' || name || '\";' as query FROM \"sqlite_master\" WHERE \"type\" = 'view'`\n            const dropViewQueries: ObjectLiteral[] = await this.query(\n                selectViewDropsQuery,\n            )\n\n            const selectTableDropsQuery = `SELECT 'DROP TABLE \"' || name || '\";' as query FROM \"sqlite_master\" WHERE \"type\" = 'table' AND \"name\" != 'sqlite_sequence'`\n            const dropTableQueries: ObjectLiteral[] = await this.query(\n                selectTableDropsQuery,\n            )\n\n            await Promise.all(\n                dropViewQueries.map((q) => this.query(q[\"query\"])),\n            )\n            await Promise.all(\n                dropTableQueries.map((q) => this.query(q[\"query\"])),\n            )\n        } finally {\n            await this.query(`PRAGMA foreign_keys = ON`)\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Parametrizes given object of values. Used to create column=value queries.\n     */\n    protected parametrize(\n        objectLiteral: ObjectLiteral,\n        startIndex: number = 0,\n    ): string[] {\n        return Object.keys(objectLiteral).map((key, index) => `\"${key}\"` + \"=?\")\n    }\n}\n"]},"metadata":{},"sourceType":"module"}