{"ast":null,"code":"import { ColumnMetadata } from \"../metadata/ColumnMetadata\";\nimport { UniqueMetadata } from \"../metadata/UniqueMetadata\";\nimport { ForeignKeyMetadata } from \"../metadata/ForeignKeyMetadata\";\nimport { TypeORMError } from \"../error\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\n/**\n * Builds join column for the many-to-one and one-to-one owner relations.\n *\n * Cases it should cover:\n * 1. when join column is set with custom name and without referenced column name\n * we need automatically set referenced column name - primary ids by default\n * @JoinColumn({ name: \"custom_name\" })\n *\n * 2. when join column is set with only referenced column name\n * we need automatically set join column name - relation name + referenced column name\n * @JoinColumn({ referencedColumnName: \"title\" })\n *\n * 3. when join column is set without both referenced column name and join column name\n * we need to automatically set both of them\n * @JoinColumn()\n *\n * 4. when join column is not set at all (as in case of @ManyToOne relation)\n * we need to create join column for it with proper referenced column name and join column name\n *\n * 5. when multiple join columns set none of referencedColumnName and name can be optional\n * both options are required\n * @JoinColumn([\n *      { name: \"category_title\", referencedColumnName: \"type\" },\n *      { name: \"category_title\", referencedColumnName: \"name\" },\n * ])\n *\n * Since for many-to-one relations having JoinColumn decorator is not required,\n * we need to go thought each many-to-one relation without join column decorator set\n * and create join column metadata args for them.\n */\n\nexport class RelationJoinColumnBuilder {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection) {\n    this.connection = connection;\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Builds a foreign key of the many-to-one or one-to-one owner relations.\n   */\n\n\n  build(joinColumns, relation) {\n    var _a;\n\n    const referencedColumns = this.collectReferencedColumns(joinColumns, relation);\n    const columns = this.collectColumns(joinColumns, relation, referencedColumns);\n    if (!referencedColumns.length || !relation.createForeignKeyConstraints) return {\n      foreignKey: undefined,\n      columns,\n      uniqueConstraint: undefined\n    }; // this case is possible for one-to-one non owning side and relations with createForeignKeyConstraints = false\n\n    const foreignKey = new ForeignKeyMetadata({\n      name: (_a = joinColumns[0]) === null || _a === void 0 ? void 0 : _a.foreignKeyConstraintName,\n      entityMetadata: relation.entityMetadata,\n      referencedEntityMetadata: relation.inverseEntityMetadata,\n      namingStrategy: this.connection.namingStrategy,\n      columns: columns,\n      referencedColumns: referencedColumns,\n      onDelete: relation.onDelete,\n      onUpdate: relation.onUpdate,\n      deferrable: relation.deferrable\n    }); // Oracle does not allow both primary and unique constraints on the same column\n\n    if (this.connection.driver.options.type === \"oracle\" && columns.every(column => column.isPrimary)) return {\n      foreignKey,\n      columns,\n      uniqueConstraint: undefined\n    }; // CockroachDB requires UNIQUE constraints on referenced columns\n\n    if (referencedColumns.length > 0 && relation.isOneToOne) {\n      const uniqueConstraint = new UniqueMetadata({\n        entityMetadata: relation.entityMetadata,\n        columns: foreignKey.columns,\n        args: {\n          name: this.connection.namingStrategy.relationConstraintName(relation.entityMetadata.tableName, foreignKey.columns.map(c => c.databaseName)),\n          target: relation.entityMetadata.target\n        }\n      });\n      uniqueConstraint.build(this.connection.namingStrategy);\n      return {\n        foreignKey,\n        columns,\n        uniqueConstraint\n      };\n    }\n\n    return {\n      foreignKey,\n      columns,\n      uniqueConstraint: undefined\n    };\n  } // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Collects referenced columns from the given join column args.\n   */\n\n\n  collectReferencedColumns(joinColumns, relation) {\n    const hasAnyReferencedColumnName = joinColumns.find(joinColumnArgs => !!joinColumnArgs.referencedColumnName);\n    const manyToOneWithoutJoinColumn = joinColumns.length === 0 && relation.isManyToOne;\n    const hasJoinColumnWithoutAnyReferencedColumnName = joinColumns.length > 0 && !hasAnyReferencedColumnName;\n\n    if (manyToOneWithoutJoinColumn || hasJoinColumnWithoutAnyReferencedColumnName) {\n      // covers case3 and case1\n      return relation.inverseEntityMetadata.primaryColumns;\n    } else {\n      // cases with referenced columns defined\n      return joinColumns.map(joinColumn => {\n        const referencedColumn = relation.inverseEntityMetadata.ownColumns.find(column => column.propertyName === joinColumn.referencedColumnName); // todo: can we also search in relations?\n\n        if (!referencedColumn) throw new TypeORMError(`Referenced column ${joinColumn.referencedColumnName} was not found in entity ${relation.inverseEntityMetadata.name}`);\n        return referencedColumn;\n      });\n    }\n  }\n  /**\n   * Collects columns from the given join column args.\n   */\n\n\n  collectColumns(joinColumns, relation, referencedColumns) {\n    return referencedColumns.map(referencedColumn => {\n      // in the case if relation has join column with only name set we need this check\n      const joinColumnMetadataArg = joinColumns.find(joinColumn => {\n        return (!joinColumn.referencedColumnName || joinColumn.referencedColumnName === referencedColumn.propertyName) && !!joinColumn.name;\n      });\n      const joinColumnName = joinColumnMetadataArg ? joinColumnMetadataArg.name : this.connection.namingStrategy.joinColumnName(relation.propertyName, referencedColumn.propertyName);\n      const relationalColumns = relation.embeddedMetadata ? relation.embeddedMetadata.columns : relation.entityMetadata.ownColumns;\n      let relationalColumn = relationalColumns.find(column => column.databaseNameWithoutPrefixes === joinColumnName);\n\n      if (!relationalColumn) {\n        relationalColumn = new ColumnMetadata({\n          connection: this.connection,\n          entityMetadata: relation.entityMetadata,\n          embeddedMetadata: relation.embeddedMetadata,\n          args: {\n            target: \"\",\n            mode: \"virtual\",\n            propertyName: relation.propertyName,\n            options: {\n              name: joinColumnName,\n              type: referencedColumn.type,\n              length: !referencedColumn.length && (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === \"aurora-mysql\") && (referencedColumn.generationStrategy === \"uuid\" || referencedColumn.type === \"uuid\") ? \"36\" : referencedColumn.length,\n              width: referencedColumn.width,\n              charset: referencedColumn.charset,\n              collation: referencedColumn.collation,\n              precision: referencedColumn.precision,\n              scale: referencedColumn.scale,\n              zerofill: referencedColumn.zerofill,\n              unsigned: referencedColumn.unsigned,\n              comment: referencedColumn.comment,\n              enum: referencedColumn.enum,\n              enumName: referencedColumn.enumName,\n              primary: relation.isPrimary,\n              nullable: relation.isNullable\n            }\n          }\n        });\n        relation.entityMetadata.registerColumn(relationalColumn);\n      }\n\n      relationalColumn.referencedColumn = referencedColumn; // its important to set it here because we need to set referenced column for user defined join column\n\n      relationalColumn.type = referencedColumn.type; // also since types of relational column and join column must be equal we override user defined column type\n\n      relationalColumn.relationMetadata = relation;\n      relationalColumn.build(this.connection);\n      return relationalColumn;\n    });\n  }\n\n}","map":{"version":3,"mappings":"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","names":["ColumnMetadata","UniqueMetadata","ForeignKeyMetadata","TypeORMError","DriverUtils","RelationJoinColumnBuilder","constructor","connection","build","joinColumns","relation","referencedColumns","collectReferencedColumns","columns","collectColumns","length","createForeignKeyConstraints","foreignKey","undefined","uniqueConstraint","name","_a","foreignKeyConstraintName","entityMetadata","referencedEntityMetadata","inverseEntityMetadata","namingStrategy","onDelete","onUpdate","deferrable","driver","options","type","every","column","isPrimary","isOneToOne","args","relationConstraintName","tableName","map","c","databaseName","target","hasAnyReferencedColumnName","find","joinColumnArgs","referencedColumnName","manyToOneWithoutJoinColumn","isManyToOne","hasJoinColumnWithoutAnyReferencedColumnName","primaryColumns","joinColumn","referencedColumn","ownColumns","propertyName","joinColumnMetadataArg","joinColumnName","relationalColumns","embeddedMetadata","relationalColumn","databaseNameWithoutPrefixes","mode","isMySQLFamily","generationStrategy","width","charset","collation","precision","scale","zerofill","unsigned","comment","enum","enumName","primary","nullable","isNullable","registerColumn","relationMetadata"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\metadata-builder\\RelationJoinColumnBuilder.ts"],"sourcesContent":["import { ColumnMetadata } from \"../metadata/ColumnMetadata\"\nimport { UniqueMetadata } from \"../metadata/UniqueMetadata\"\nimport { ForeignKeyMetadata } from \"../metadata/ForeignKeyMetadata\"\nimport { RelationMetadata } from \"../metadata/RelationMetadata\"\nimport { JoinColumnMetadataArgs } from \"../metadata-args/JoinColumnMetadataArgs\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { TypeORMError } from \"../error\"\nimport { DriverUtils } from \"../driver/DriverUtils\"\n\n/**\n * Builds join column for the many-to-one and one-to-one owner relations.\n *\n * Cases it should cover:\n * 1. when join column is set with custom name and without referenced column name\n * we need automatically set referenced column name - primary ids by default\n * @JoinColumn({ name: \"custom_name\" })\n *\n * 2. when join column is set with only referenced column name\n * we need automatically set join column name - relation name + referenced column name\n * @JoinColumn({ referencedColumnName: \"title\" })\n *\n * 3. when join column is set without both referenced column name and join column name\n * we need to automatically set both of them\n * @JoinColumn()\n *\n * 4. when join column is not set at all (as in case of @ManyToOne relation)\n * we need to create join column for it with proper referenced column name and join column name\n *\n * 5. when multiple join columns set none of referencedColumnName and name can be optional\n * both options are required\n * @JoinColumn([\n *      { name: \"category_title\", referencedColumnName: \"type\" },\n *      { name: \"category_title\", referencedColumnName: \"name\" },\n * ])\n *\n * Since for many-to-one relations having JoinColumn decorator is not required,\n * we need to go thought each many-to-one relation without join column decorator set\n * and create join column metadata args for them.\n */\nexport class RelationJoinColumnBuilder {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private connection: DataSource) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Builds a foreign key of the many-to-one or one-to-one owner relations.\n     */\n    build(\n        joinColumns: JoinColumnMetadataArgs[],\n        relation: RelationMetadata,\n    ): {\n        foreignKey: ForeignKeyMetadata | undefined\n        columns: ColumnMetadata[]\n        uniqueConstraint: UniqueMetadata | undefined\n    } {\n        const referencedColumns = this.collectReferencedColumns(\n            joinColumns,\n            relation,\n        )\n        const columns = this.collectColumns(\n            joinColumns,\n            relation,\n            referencedColumns,\n        )\n        if (!referencedColumns.length || !relation.createForeignKeyConstraints)\n            return {\n                foreignKey: undefined,\n                columns,\n                uniqueConstraint: undefined,\n            } // this case is possible for one-to-one non owning side and relations with createForeignKeyConstraints = false\n\n        const foreignKey = new ForeignKeyMetadata({\n            name: joinColumns[0]?.foreignKeyConstraintName,\n            entityMetadata: relation.entityMetadata,\n            referencedEntityMetadata: relation.inverseEntityMetadata,\n            namingStrategy: this.connection.namingStrategy,\n            columns: columns,\n            referencedColumns: referencedColumns,\n            onDelete: relation.onDelete,\n            onUpdate: relation.onUpdate,\n            deferrable: relation.deferrable,\n        })\n\n        // Oracle does not allow both primary and unique constraints on the same column\n        if (\n            this.connection.driver.options.type === \"oracle\" &&\n            columns.every((column) => column.isPrimary)\n        )\n            return { foreignKey, columns, uniqueConstraint: undefined }\n\n        // CockroachDB requires UNIQUE constraints on referenced columns\n        if (referencedColumns.length > 0 && relation.isOneToOne) {\n            const uniqueConstraint = new UniqueMetadata({\n                entityMetadata: relation.entityMetadata,\n                columns: foreignKey.columns,\n                args: {\n                    name: this.connection.namingStrategy.relationConstraintName(\n                        relation.entityMetadata.tableName,\n                        foreignKey.columns.map((c) => c.databaseName),\n                    ),\n                    target: relation.entityMetadata.target,\n                },\n            })\n            uniqueConstraint.build(this.connection.namingStrategy)\n            return { foreignKey, columns, uniqueConstraint }\n        }\n\n        return { foreignKey, columns, uniqueConstraint: undefined }\n    }\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Collects referenced columns from the given join column args.\n     */\n    protected collectReferencedColumns(\n        joinColumns: JoinColumnMetadataArgs[],\n        relation: RelationMetadata,\n    ): ColumnMetadata[] {\n        const hasAnyReferencedColumnName = joinColumns.find(\n            (joinColumnArgs) => !!joinColumnArgs.referencedColumnName,\n        )\n        const manyToOneWithoutJoinColumn =\n            joinColumns.length === 0 && relation.isManyToOne\n        const hasJoinColumnWithoutAnyReferencedColumnName =\n            joinColumns.length > 0 && !hasAnyReferencedColumnName\n\n        if (\n            manyToOneWithoutJoinColumn ||\n            hasJoinColumnWithoutAnyReferencedColumnName\n        ) {\n            // covers case3 and case1\n            return relation.inverseEntityMetadata.primaryColumns\n        } else {\n            // cases with referenced columns defined\n            return joinColumns.map((joinColumn) => {\n                const referencedColumn =\n                    relation.inverseEntityMetadata.ownColumns.find(\n                        (column) =>\n                            column.propertyName ===\n                            joinColumn.referencedColumnName,\n                    ) // todo: can we also search in relations?\n                if (!referencedColumn)\n                    throw new TypeORMError(\n                        `Referenced column ${joinColumn.referencedColumnName} was not found in entity ${relation.inverseEntityMetadata.name}`,\n                    )\n\n                return referencedColumn\n            })\n        }\n    }\n\n    /**\n     * Collects columns from the given join column args.\n     */\n    private collectColumns(\n        joinColumns: JoinColumnMetadataArgs[],\n        relation: RelationMetadata,\n        referencedColumns: ColumnMetadata[],\n    ): ColumnMetadata[] {\n        return referencedColumns.map((referencedColumn) => {\n            // in the case if relation has join column with only name set we need this check\n            const joinColumnMetadataArg = joinColumns.find((joinColumn) => {\n                return (\n                    (!joinColumn.referencedColumnName ||\n                        joinColumn.referencedColumnName ===\n                            referencedColumn.propertyName) &&\n                    !!joinColumn.name\n                )\n            })\n            const joinColumnName = joinColumnMetadataArg\n                ? joinColumnMetadataArg.name\n                : this.connection.namingStrategy.joinColumnName(\n                      relation.propertyName,\n                      referencedColumn.propertyName,\n                  )\n\n            const relationalColumns = relation.embeddedMetadata\n                ? relation.embeddedMetadata.columns\n                : relation.entityMetadata.ownColumns\n            let relationalColumn = relationalColumns.find(\n                (column) =>\n                    column.databaseNameWithoutPrefixes === joinColumnName,\n            )\n            if (!relationalColumn) {\n                relationalColumn = new ColumnMetadata({\n                    connection: this.connection,\n                    entityMetadata: relation.entityMetadata,\n                    embeddedMetadata: relation.embeddedMetadata,\n                    args: {\n                        target: \"\",\n                        mode: \"virtual\",\n                        propertyName: relation.propertyName,\n                        options: {\n                            name: joinColumnName,\n                            type: referencedColumn.type,\n                            length:\n                                !referencedColumn.length &&\n                                (DriverUtils.isMySQLFamily(\n                                    this.connection.driver,\n                                ) ||\n                                    this.connection.driver.options.type ===\n                                        \"aurora-mysql\") &&\n                                (referencedColumn.generationStrategy ===\n                                    \"uuid\" ||\n                                    referencedColumn.type === \"uuid\")\n                                    ? \"36\"\n                                    : referencedColumn.length, // fix https://github.com/typeorm/typeorm/issues/3604\n                            width: referencedColumn.width,\n                            charset: referencedColumn.charset,\n                            collation: referencedColumn.collation,\n                            precision: referencedColumn.precision,\n                            scale: referencedColumn.scale,\n                            zerofill: referencedColumn.zerofill,\n                            unsigned: referencedColumn.unsigned,\n                            comment: referencedColumn.comment,\n                            enum: referencedColumn.enum,\n                            enumName: referencedColumn.enumName,\n                            primary: relation.isPrimary,\n                            nullable: relation.isNullable,\n                        },\n                    },\n                })\n                relation.entityMetadata.registerColumn(relationalColumn)\n            }\n            relationalColumn.referencedColumn = referencedColumn // its important to set it here because we need to set referenced column for user defined join column\n            relationalColumn.type = referencedColumn.type // also since types of relational column and join column must be equal we override user defined column type\n            relationalColumn.relationMetadata = relation\n            relationalColumn.build(this.connection)\n            return relationalColumn\n        })\n    }\n}\n"]},"metadata":{},"sourceType":"module"}