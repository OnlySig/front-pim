{"ast":null,"code":"import { SubjectTopoligicalSorter } from \"./SubjectTopoligicalSorter\";\nimport { SubjectChangedColumnsComputer } from \"./SubjectChangedColumnsComputer\";\nimport { SubjectWithoutIdentifierError } from \"../error/SubjectWithoutIdentifierError\";\nimport { SubjectRemovedAndUpdatedError } from \"../error/SubjectRemovedAndUpdatedError\";\nimport { BroadcasterResult } from \"../subscriber/BroadcasterResult\";\nimport { NestedSetSubjectExecutor } from \"./tree/NestedSetSubjectExecutor\";\nimport { ClosureSubjectExecutor } from \"./tree/ClosureSubjectExecutor\";\nimport { MaterializedPathSubjectExecutor } from \"./tree/MaterializedPathSubjectExecutor\";\nimport { OrmUtils } from \"../util/OrmUtils\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\nimport { InstanceChecker } from \"../util/InstanceChecker\";\n/**\n * Executes all database operations (inserts, updated, deletes) that must be executed\n * with given persistence subjects.\n */\n\nexport class SubjectExecutor {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(queryRunner, subjects, options) {\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Indicates if executor has any operations to execute (e.g. has insert / update / delete operations to be executed).\n     */\n    this.hasExecutableOperations = false;\n    /**\n     * Subjects that must be inserted.\n     */\n\n    this.insertSubjects = [];\n    /**\n     * Subjects that must be updated.\n     */\n\n    this.updateSubjects = [];\n    /**\n     * Subjects that must be removed.\n     */\n\n    this.removeSubjects = [];\n    /**\n     * Subjects that must be soft-removed.\n     */\n\n    this.softRemoveSubjects = [];\n    /**\n     * Subjects that must be recovered.\n     */\n\n    this.recoverSubjects = [];\n    this.queryRunner = queryRunner;\n    this.allSubjects = subjects;\n    this.options = options;\n    this.validate();\n    this.recompute();\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Executes all operations over given array of subjects.\n   * Executes queries using given query runner.\n   */\n\n\n  async execute() {\n    // console.time(\"SubjectExecutor.execute\");\n    // broadcast \"before\" events before we start insert / update / remove operations\n    let broadcasterResult = undefined;\n\n    if (!this.options || this.options.listeners !== false) {\n      // console.time(\".broadcastBeforeEventsForAll\");\n      broadcasterResult = this.broadcastBeforeEventsForAll();\n      if (broadcasterResult.promises.length > 0) await Promise.all(broadcasterResult.promises); // console.timeEnd(\".broadcastBeforeEventsForAll\");\n    } // since event listeners and subscribers can call save methods and/or trigger entity changes we need to recompute operational subjects\n    // recompute only in the case if any listener or subscriber was really executed\n\n\n    if (broadcasterResult && broadcasterResult.count > 0) {\n      // console.time(\".recompute\");\n      this.insertSubjects.forEach(subject => subject.recompute());\n      this.updateSubjects.forEach(subject => subject.recompute());\n      this.removeSubjects.forEach(subject => subject.recompute());\n      this.softRemoveSubjects.forEach(subject => subject.recompute());\n      this.recoverSubjects.forEach(subject => subject.recompute());\n      this.recompute(); // console.timeEnd(\".recompute\");\n    } // make sure our insert subjects are sorted (using topological sorting) to make cascade inserts work properly\n    // console.timeEnd(\"prepare\");\n    // execute all insert operations\n    // console.time(\".insertion\");\n\n\n    this.insertSubjects = new SubjectTopoligicalSorter(this.insertSubjects).sort(\"insert\");\n    await this.executeInsertOperations(); // console.timeEnd(\".insertion\");\n    // recompute update operations since insertion can create updation operations for the\n    // properties it wasn't able to handle on its own (referenced columns)\n\n    this.updateSubjects = this.allSubjects.filter(subject => subject.mustBeUpdated); // execute update operations\n    // console.time(\".updation\");\n\n    await this.executeUpdateOperations(); // console.timeEnd(\".updation\");\n    // make sure our remove subjects are sorted (using topological sorting) when multiple entities are passed for the removal\n    // console.time(\".removal\");\n\n    this.removeSubjects = new SubjectTopoligicalSorter(this.removeSubjects).sort(\"delete\");\n    await this.executeRemoveOperations(); // console.timeEnd(\".removal\");\n    // recompute soft-remove operations\n\n    this.softRemoveSubjects = this.allSubjects.filter(subject => subject.mustBeSoftRemoved); // execute soft-remove operations\n\n    await this.executeSoftRemoveOperations(); // recompute recover operations\n\n    this.recoverSubjects = this.allSubjects.filter(subject => subject.mustBeRecovered); // execute recover operations\n\n    await this.executeRecoverOperations(); // update all special columns in persisted entities, like inserted id or remove ids from the removed entities\n    // console.time(\".updateSpecialColumnsInPersistedEntities\");\n\n    await this.updateSpecialColumnsInPersistedEntities(); // console.timeEnd(\".updateSpecialColumnsInPersistedEntities\");\n    // finally broadcast \"after\" events after we finish insert / update / remove operations\n\n    if (!this.options || this.options.listeners !== false) {\n      // console.time(\".broadcastAfterEventsForAll\");\n      broadcasterResult = this.broadcastAfterEventsForAll();\n      if (broadcasterResult.promises.length > 0) await Promise.all(broadcasterResult.promises); // console.timeEnd(\".broadcastAfterEventsForAll\");\n    } // console.timeEnd(\"SubjectExecutor.execute\");\n\n  } // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Validates all given subjects.\n   */\n\n\n  validate() {\n    this.allSubjects.forEach(subject => {\n      if (subject.mustBeUpdated && subject.mustBeRemoved) throw new SubjectRemovedAndUpdatedError(subject);\n    });\n  }\n  /**\n   * Performs entity re-computations - finds changed columns, re-builds insert/update/remove subjects.\n   */\n\n\n  recompute() {\n    new SubjectChangedColumnsComputer().compute(this.allSubjects);\n    this.insertSubjects = this.allSubjects.filter(subject => subject.mustBeInserted);\n    this.updateSubjects = this.allSubjects.filter(subject => subject.mustBeUpdated);\n    this.removeSubjects = this.allSubjects.filter(subject => subject.mustBeRemoved);\n    this.softRemoveSubjects = this.allSubjects.filter(subject => subject.mustBeSoftRemoved);\n    this.recoverSubjects = this.allSubjects.filter(subject => subject.mustBeRecovered);\n    this.hasExecutableOperations = this.insertSubjects.length > 0 || this.updateSubjects.length > 0 || this.removeSubjects.length > 0 || this.softRemoveSubjects.length > 0 || this.recoverSubjects.length > 0;\n  }\n  /**\n   * Broadcasts \"BEFORE_INSERT\", \"BEFORE_UPDATE\", \"BEFORE_REMOVE\", \"BEFORE_SOFT_REMOVE\", \"BEFORE_RECOVER\" events for all given subjects.\n   */\n\n\n  broadcastBeforeEventsForAll() {\n    const result = new BroadcasterResult();\n    if (this.insertSubjects.length) this.insertSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastBeforeInsertEvent(result, subject.metadata, subject.entity));\n    if (this.updateSubjects.length) this.updateSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastBeforeUpdateEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.diffColumns, subject.diffRelations));\n    if (this.removeSubjects.length) this.removeSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastBeforeRemoveEvent(result, subject.metadata, subject.entity, subject.databaseEntity));\n    if (this.softRemoveSubjects.length) this.softRemoveSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastBeforeSoftRemoveEvent(result, subject.metadata, subject.entity, subject.databaseEntity));\n    if (this.recoverSubjects.length) this.recoverSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastBeforeRecoverEvent(result, subject.metadata, subject.entity, subject.databaseEntity));\n    return result;\n  }\n  /**\n   * Broadcasts \"AFTER_INSERT\", \"AFTER_UPDATE\", \"AFTER_REMOVE\", \"AFTER_SOFT_REMOVE\", \"AFTER_RECOVER\" events for all given subjects.\n   * Returns void if there wasn't any listener or subscriber executed.\n   * Note: this method has a performance-optimized code organization.\n   */\n\n\n  broadcastAfterEventsForAll() {\n    const result = new BroadcasterResult();\n    if (this.insertSubjects.length) this.insertSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastAfterInsertEvent(result, subject.metadata, subject.entity));\n    if (this.updateSubjects.length) this.updateSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastAfterUpdateEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.diffColumns, subject.diffRelations));\n    if (this.removeSubjects.length) this.removeSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastAfterRemoveEvent(result, subject.metadata, subject.entity, subject.databaseEntity));\n    if (this.softRemoveSubjects.length) this.softRemoveSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastAfterSoftRemoveEvent(result, subject.metadata, subject.entity, subject.databaseEntity));\n    if (this.recoverSubjects.length) this.recoverSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastAfterRecoverEvent(result, subject.metadata, subject.entity, subject.databaseEntity));\n    return result;\n  }\n  /**\n   * Executes insert operations.\n   */\n\n\n  async executeInsertOperations() {\n    // group insertion subjects to make bulk insertions\n    const [groupedInsertSubjects, groupedInsertSubjectKeys] = this.groupBulkSubjects(this.insertSubjects, \"insert\"); // then we run insertion in the sequential order which is important since we have an ordered subjects\n\n    for (const groupName of groupedInsertSubjectKeys) {\n      const subjects = groupedInsertSubjects[groupName]; // we must separately insert entities which does not have any values to insert\n      // because its not possible to insert multiple entities with only default values in bulk\n\n      const bulkInsertMaps = [];\n      const bulkInsertSubjects = [];\n      const singleInsertSubjects = [];\n\n      if (this.queryRunner.connection.driver.options.type === \"mongodb\") {\n        subjects.forEach(subject => {\n          if (subject.metadata.createDateColumn && subject.entity) {\n            subject.entity[subject.metadata.createDateColumn.databaseName] = new Date();\n          }\n\n          if (subject.metadata.updateDateColumn && subject.entity) {\n            subject.entity[subject.metadata.updateDateColumn.databaseName] = new Date();\n          }\n\n          subject.createValueSetAndPopChangeMap();\n          bulkInsertSubjects.push(subject);\n          bulkInsertMaps.push(subject.entity);\n        });\n      } else if (this.queryRunner.connection.driver.options.type === \"oracle\") {\n        subjects.forEach(subject => {\n          singleInsertSubjects.push(subject);\n        });\n      } else {\n        subjects.forEach(subject => {\n          // we do not insert in bulk in following cases:\n          // - when there is no values in insert (only defaults are inserted), since we cannot use DEFAULT VALUES expression for multiple inserted rows\n          // - when entity is a tree table, since tree tables require extra operation per each inserted row\n          // - when oracle is used, since oracle's bulk insertion is very bad\n          if (subject.changeMaps.length === 0 || subject.metadata.treeType || this.queryRunner.connection.driver.options.type === \"oracle\" || this.queryRunner.connection.driver.options.type === \"sap\") {\n            singleInsertSubjects.push(subject);\n          } else {\n            bulkInsertSubjects.push(subject);\n            bulkInsertMaps.push(subject.createValueSetAndPopChangeMap());\n          }\n        });\n      } // for mongodb we have a bit different insertion logic\n\n\n      if (InstanceChecker.isMongoEntityManager(this.queryRunner.manager)) {\n        const insertResult = await this.queryRunner.manager.insert(subjects[0].metadata.target, bulkInsertMaps);\n        subjects.forEach((subject, index) => {\n          subject.identifier = insertResult.identifiers[index];\n          subject.generatedMap = insertResult.generatedMaps[index];\n          subject.insertedValueSet = bulkInsertMaps[index];\n        });\n      } else {\n        // here we execute our insertion query\n        // we need to enable entity updation because we DO need to have updated insertedMap\n        // which is not same object as our entity that's why we don't need to worry about our entity to get dirty\n        // also, we disable listeners because we call them on our own in persistence layer\n        if (bulkInsertMaps.length > 0) {\n          const insertResult = await this.queryRunner.manager.createQueryBuilder().insert().into(subjects[0].metadata.target).values(bulkInsertMaps).updateEntity(this.options && this.options.reload === false ? false : true).callListeners(false).execute();\n          bulkInsertSubjects.forEach((subject, index) => {\n            subject.identifier = insertResult.identifiers[index];\n            subject.generatedMap = insertResult.generatedMaps[index];\n            subject.insertedValueSet = bulkInsertMaps[index];\n          });\n        } // insert subjects which must be inserted in separate requests (all default values)\n\n\n        if (singleInsertSubjects.length > 0) {\n          for (const subject of singleInsertSubjects) {\n            subject.insertedValueSet = subject.createValueSetAndPopChangeMap(); // important to have because query builder sets inserted values into it\n            // for nested set we execute additional queries\n\n            if (subject.metadata.treeType === \"nested-set\") await new NestedSetSubjectExecutor(this.queryRunner).insert(subject);\n            await this.queryRunner.manager.createQueryBuilder().insert().into(subject.metadata.target).values(subject.insertedValueSet).updateEntity(this.options && this.options.reload === false ? false : true).callListeners(false).execute().then(insertResult => {\n              subject.identifier = insertResult.identifiers[0];\n              subject.generatedMap = insertResult.generatedMaps[0];\n            }); // for tree tables we execute additional queries\n\n            if (subject.metadata.treeType === \"closure-table\") {\n              await new ClosureSubjectExecutor(this.queryRunner).insert(subject);\n            } else if (subject.metadata.treeType === \"materialized-path\") {\n              await new MaterializedPathSubjectExecutor(this.queryRunner).insert(subject);\n            }\n          }\n        }\n      }\n\n      subjects.forEach(subject => {\n        if (subject.generatedMap) {\n          subject.metadata.columns.forEach(column => {\n            const value = column.getEntityValue(subject.generatedMap);\n\n            if (value !== undefined && value !== null) {\n              const preparedValue = this.queryRunner.connection.driver.prepareHydratedValue(value, column);\n              column.setEntityValue(subject.generatedMap, preparedValue);\n            }\n          });\n        }\n      });\n    }\n  }\n  /**\n   * Updates all given subjects in the database.\n   */\n\n\n  async executeUpdateOperations() {\n    const updateSubject = async subject => {\n      if (!subject.identifier) throw new SubjectWithoutIdentifierError(subject); // for mongodb we have a bit different updation logic\n\n      if (InstanceChecker.isMongoEntityManager(this.queryRunner.manager)) {\n        const partialEntity = this.cloneMongoSubjectEntity(subject);\n\n        if (subject.metadata.objectIdColumn && subject.metadata.objectIdColumn.propertyName) {\n          delete partialEntity[subject.metadata.objectIdColumn.propertyName];\n        }\n\n        if (subject.metadata.createDateColumn && subject.metadata.createDateColumn.propertyName) {\n          delete partialEntity[subject.metadata.createDateColumn.propertyName];\n        }\n\n        if (subject.metadata.updateDateColumn && subject.metadata.updateDateColumn.propertyName) {\n          partialEntity[subject.metadata.updateDateColumn.propertyName] = new Date();\n        }\n\n        const manager = this.queryRunner.manager;\n        await manager.update(subject.metadata.target, subject.identifier, partialEntity);\n      } else {\n        const updateMap = subject.createValueSetAndPopChangeMap(); // for tree tables we execute additional queries\n\n        switch (subject.metadata.treeType) {\n          case \"nested-set\":\n            await new NestedSetSubjectExecutor(this.queryRunner).update(subject);\n            break;\n\n          case \"closure-table\":\n            await new ClosureSubjectExecutor(this.queryRunner).update(subject);\n            break;\n\n          case \"materialized-path\":\n            await new MaterializedPathSubjectExecutor(this.queryRunner).update(subject);\n            break;\n        } // here we execute our updation query\n        // we need to enable entity updation because we update a subject identifier\n        // which is not same object as our entity that's why we don't need to worry about our entity to get dirty\n        // also, we disable listeners because we call them on our own in persistence layer\n\n\n        const updateQueryBuilder = this.queryRunner.manager.createQueryBuilder().update(subject.metadata.target).set(updateMap).updateEntity(this.options && this.options.reload === false ? false : true).callListeners(false);\n\n        if (subject.entity) {\n          updateQueryBuilder.whereEntity(subject.identifier);\n        } else {\n          // in this case identifier is just conditions object to update by\n          updateQueryBuilder.where(subject.identifier);\n        }\n\n        const updateResult = await updateQueryBuilder.execute();\n        let updateGeneratedMap = updateResult.generatedMaps[0];\n\n        if (updateGeneratedMap) {\n          subject.metadata.columns.forEach(column => {\n            const value = column.getEntityValue(updateGeneratedMap);\n\n            if (value !== undefined && value !== null) {\n              const preparedValue = this.queryRunner.connection.driver.prepareHydratedValue(value, column);\n              column.setEntityValue(updateGeneratedMap, preparedValue);\n            }\n          });\n\n          if (!subject.generatedMap) {\n            subject.generatedMap = {};\n          }\n\n          Object.assign(subject.generatedMap, updateGeneratedMap);\n        }\n      }\n    }; // Nested sets need to be updated one by one\n    // Split array in two, one with nested set subjects and the other with the remaining subjects\n\n\n    const nestedSetSubjects = [];\n    const remainingSubjects = [];\n\n    for (const subject of this.updateSubjects) {\n      if (subject.metadata.treeType === \"nested-set\") {\n        nestedSetSubjects.push(subject);\n      } else {\n        remainingSubjects.push(subject);\n      }\n    } // Run nested set updates one by one\n\n\n    const nestedSetPromise = new Promise(async (ok, fail) => {\n      for (const subject of nestedSetSubjects) {\n        try {\n          await updateSubject(subject);\n        } catch (error) {\n          fail(error);\n        }\n      }\n\n      ok();\n    }); // Run all remaining subjects in parallel\n\n    await Promise.all([...remainingSubjects.map(updateSubject), nestedSetPromise]);\n  }\n  /**\n   * Removes all given subjects from the database.\n   *\n   * todo: we need to apply topological sort here as well\n   */\n\n\n  async executeRemoveOperations() {\n    // group insertion subjects to make bulk insertions\n    const [groupedRemoveSubjects, groupedRemoveSubjectKeys] = this.groupBulkSubjects(this.removeSubjects, \"delete\");\n\n    for (const groupName of groupedRemoveSubjectKeys) {\n      const subjects = groupedRemoveSubjects[groupName];\n      const deleteMaps = subjects.map(subject => {\n        if (!subject.identifier) throw new SubjectWithoutIdentifierError(subject);\n        return subject.identifier;\n      }); // for mongodb we have a bit different updation logic\n\n      if (InstanceChecker.isMongoEntityManager(this.queryRunner.manager)) {\n        const manager = this.queryRunner.manager;\n        await manager.delete(subjects[0].metadata.target, deleteMaps);\n      } else {\n        // for tree tables we execute additional queries\n        switch (subjects[0].metadata.treeType) {\n          case \"nested-set\":\n            await new NestedSetSubjectExecutor(this.queryRunner).remove(subjects);\n            break;\n\n          case \"closure-table\":\n            await new ClosureSubjectExecutor(this.queryRunner).remove(subjects);\n            break;\n        } // here we execute our deletion query\n        // we don't need to specify entities and set update entity to true since the only thing query builder\n        // will do for use is a primary keys deletion which is handled by us later once persistence is finished\n        // also, we disable listeners because we call them on our own in persistence layer\n\n\n        await this.queryRunner.manager.createQueryBuilder().delete().from(subjects[0].metadata.target).where(deleteMaps).callListeners(false).execute();\n      }\n    }\n  }\n\n  cloneMongoSubjectEntity(subject) {\n    const target = {};\n\n    if (subject.entity) {\n      for (const column of subject.metadata.columns) {\n        OrmUtils.mergeDeep(target, column.getEntityValueMap(subject.entity));\n      }\n    }\n\n    return target;\n  }\n  /**\n   * Soft-removes all given subjects in the database.\n   */\n\n\n  async executeSoftRemoveOperations() {\n    await Promise.all(this.softRemoveSubjects.map(async subject => {\n      if (!subject.identifier) throw new SubjectWithoutIdentifierError(subject);\n      let updateResult; // for mongodb we have a bit different updation logic\n\n      if (InstanceChecker.isMongoEntityManager(this.queryRunner.manager)) {\n        const partialEntity = this.cloneMongoSubjectEntity(subject);\n\n        if (subject.metadata.objectIdColumn && subject.metadata.objectIdColumn.propertyName) {\n          delete partialEntity[subject.metadata.objectIdColumn.propertyName];\n        }\n\n        if (subject.metadata.createDateColumn && subject.metadata.createDateColumn.propertyName) {\n          delete partialEntity[subject.metadata.createDateColumn.propertyName];\n        }\n\n        if (subject.metadata.updateDateColumn && subject.metadata.updateDateColumn.propertyName) {\n          partialEntity[subject.metadata.updateDateColumn.propertyName] = new Date();\n        }\n\n        if (subject.metadata.deleteDateColumn && subject.metadata.deleteDateColumn.propertyName) {\n          partialEntity[subject.metadata.deleteDateColumn.propertyName] = new Date();\n        }\n\n        const manager = this.queryRunner.manager;\n        updateResult = await manager.update(subject.metadata.target, subject.identifier, partialEntity);\n      } else {\n        // here we execute our soft-deletion query\n        // we need to enable entity soft-deletion because we update a subject identifier\n        // which is not same object as our entity that's why we don't need to worry about our entity to get dirty\n        // also, we disable listeners because we call them on our own in persistence layer\n        const softDeleteQueryBuilder = this.queryRunner.manager.createQueryBuilder().softDelete().from(subject.metadata.target).updateEntity(this.options && this.options.reload === false ? false : true).callListeners(false);\n\n        if (subject.entity) {\n          softDeleteQueryBuilder.whereEntity(subject.identifier);\n        } else {\n          // in this case identifier is just conditions object to update by\n          softDeleteQueryBuilder.where(subject.identifier);\n        }\n\n        updateResult = await softDeleteQueryBuilder.execute();\n      }\n\n      subject.generatedMap = updateResult.generatedMaps[0];\n\n      if (subject.generatedMap) {\n        subject.metadata.columns.forEach(column => {\n          const value = column.getEntityValue(subject.generatedMap);\n\n          if (value !== undefined && value !== null) {\n            const preparedValue = this.queryRunner.connection.driver.prepareHydratedValue(value, column);\n            column.setEntityValue(subject.generatedMap, preparedValue);\n          }\n        });\n      } // experiments, remove probably, need to implement tree tables children removal\n      // if (subject.updatedRelationMaps.length > 0) {\n      //     await Promise.all(subject.updatedRelationMaps.map(async updatedRelation => {\n      //         if (!updatedRelation.relation.isTreeParent) return;\n      //         if (!updatedRelation.value !== null) return;\n      //\n      //         if (subject.metadata.treeType === \"closure-table\") {\n      //             await new ClosureSubjectExecutor(this.queryRunner).deleteChildrenOf(subject);\n      //         }\n      //     }));\n      // }\n\n    }));\n  }\n  /**\n   * Recovers all given subjects in the database.\n   */\n\n\n  async executeRecoverOperations() {\n    await Promise.all(this.recoverSubjects.map(async subject => {\n      if (!subject.identifier) throw new SubjectWithoutIdentifierError(subject);\n      let updateResult; // for mongodb we have a bit different updation logic\n\n      if (InstanceChecker.isMongoEntityManager(this.queryRunner.manager)) {\n        const partialEntity = this.cloneMongoSubjectEntity(subject);\n\n        if (subject.metadata.objectIdColumn && subject.metadata.objectIdColumn.propertyName) {\n          delete partialEntity[subject.metadata.objectIdColumn.propertyName];\n        }\n\n        if (subject.metadata.createDateColumn && subject.metadata.createDateColumn.propertyName) {\n          delete partialEntity[subject.metadata.createDateColumn.propertyName];\n        }\n\n        if (subject.metadata.updateDateColumn && subject.metadata.updateDateColumn.propertyName) {\n          partialEntity[subject.metadata.updateDateColumn.propertyName] = new Date();\n        }\n\n        if (subject.metadata.deleteDateColumn && subject.metadata.deleteDateColumn.propertyName) {\n          partialEntity[subject.metadata.deleteDateColumn.propertyName] = null;\n        }\n\n        const manager = this.queryRunner.manager;\n        updateResult = await manager.update(subject.metadata.target, subject.identifier, partialEntity);\n      } else {\n        // here we execute our restory query\n        // we need to enable entity restory because we update a subject identifier\n        // which is not same object as our entity that's why we don't need to worry about our entity to get dirty\n        // also, we disable listeners because we call them on our own in persistence layer\n        const softDeleteQueryBuilder = this.queryRunner.manager.createQueryBuilder().restore().from(subject.metadata.target).updateEntity(this.options && this.options.reload === false ? false : true).callListeners(false);\n\n        if (subject.entity) {\n          softDeleteQueryBuilder.whereEntity(subject.identifier);\n        } else {\n          // in this case identifier is just conditions object to update by\n          softDeleteQueryBuilder.where(subject.identifier);\n        }\n\n        updateResult = await softDeleteQueryBuilder.execute();\n      }\n\n      subject.generatedMap = updateResult.generatedMaps[0];\n\n      if (subject.generatedMap) {\n        subject.metadata.columns.forEach(column => {\n          const value = column.getEntityValue(subject.generatedMap);\n\n          if (value !== undefined && value !== null) {\n            const preparedValue = this.queryRunner.connection.driver.prepareHydratedValue(value, column);\n            column.setEntityValue(subject.generatedMap, preparedValue);\n          }\n        });\n      } // experiments, remove probably, need to implement tree tables children removal\n      // if (subject.updatedRelationMaps.length > 0) {\n      //     await Promise.all(subject.updatedRelationMaps.map(async updatedRelation => {\n      //         if (!updatedRelation.relation.isTreeParent) return;\n      //         if (!updatedRelation.value !== null) return;\n      //\n      //         if (subject.metadata.treeType === \"closure-table\") {\n      //             await new ClosureSubjectExecutor(this.queryRunner).deleteChildrenOf(subject);\n      //         }\n      //     }));\n      // }\n\n    }));\n  }\n  /**\n   * Updates all special columns of the saving entities (create date, update date, version, etc.).\n   * Also updates nullable columns and columns with default values.\n   */\n\n\n  updateSpecialColumnsInPersistedEntities() {\n    // update inserted entity properties\n    if (this.insertSubjects.length) this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.insertSubjects); // update updated entity properties\n\n    if (this.updateSubjects.length) this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.updateSubjects); // update soft-removed entity properties\n\n    if (this.softRemoveSubjects.length) this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.softRemoveSubjects); // update recovered entity properties\n\n    if (this.recoverSubjects.length) this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.recoverSubjects); // remove ids from the entities that were removed\n\n    if (this.removeSubjects.length) {\n      this.removeSubjects.forEach(subject => {\n        if (!subject.entity) return;\n        subject.metadata.primaryColumns.forEach(primaryColumn => {\n          primaryColumn.setEntityValue(subject.entity, undefined);\n        });\n      });\n    } // other post-persist updations\n\n\n    this.allSubjects.forEach(subject => {\n      if (!subject.entity) return;\n      subject.metadata.relationIds.forEach(relationId => {\n        relationId.setValue(subject.entity);\n      }); // mongo _id remove\n\n      if (InstanceChecker.isMongoEntityManager(this.queryRunner.manager)) {\n        if (subject.metadata.objectIdColumn && subject.metadata.objectIdColumn.databaseName && subject.metadata.objectIdColumn.databaseName !== subject.metadata.objectIdColumn.propertyName) {\n          delete subject.entity[subject.metadata.objectIdColumn.databaseName];\n        }\n      }\n    });\n  }\n  /**\n   * Updates all special columns of the saving entities (create date, update date, version, etc.).\n   * Also updates nullable columns and columns with default values.\n   */\n\n\n  updateSpecialColumnsInInsertedAndUpdatedEntities(subjects) {\n    subjects.forEach(subject => {\n      if (!subject.entity) return; // set values to \"null\" for nullable columns that did not have values\n\n      subject.metadata.columns.forEach(column => {\n        // if table inheritance is used make sure this column is not child's column\n        if (subject.metadata.childEntityMetadatas.length > 0 && subject.metadata.childEntityMetadatas.map(metadata => metadata.target).indexOf(column.target) !== -1) return; // entities does not have virtual columns\n\n        if (column.isVirtual) return; // update nullable columns\n\n        if (column.isNullable) {\n          const columnValue = column.getEntityValue(subject.entity);\n          if (columnValue === undefined) column.setEntityValue(subject.entity, null);\n        } // update relational columns\n\n\n        if (subject.updatedRelationMaps.length > 0) {\n          subject.updatedRelationMaps.forEach(updatedRelationMap => {\n            updatedRelationMap.relation.joinColumns.forEach(column => {\n              if (column.isVirtual === true) return;\n              column.setEntityValue(subject.entity, ObjectUtils.isObject(updatedRelationMap.value) ? column.referencedColumn.getEntityValue(updatedRelationMap.value) : updatedRelationMap.value);\n            });\n          });\n        }\n      }); // merge into entity all generated values returned by a database\n\n      if (subject.generatedMap) this.queryRunner.manager.merge(subject.metadata.target, subject.entity, subject.generatedMap);\n    });\n  }\n  /**\n   * Groups subjects by metadata names (by tables) to make bulk insertions and deletions possible.\n   * However there are some limitations with bulk insertions of data into tables with generated (increment) columns\n   * in some drivers. Some drivers like mysql and sqlite does not support returning multiple generated columns\n   * after insertion and can only return a single generated column value, that's why its not possible to do bulk insertion,\n   * because it breaks insertion result's generatedMap and leads to problems when this subject is used in other subjects saves.\n   * That's why we only support bulking in junction tables for those drivers.\n   *\n   * Other drivers like postgres and sql server support RETURNING / OUTPUT statement which allows to return generated\n   * id for each inserted row, that's why bulk insertion is not limited to junction tables in there.\n   */\n\n\n  groupBulkSubjects(subjects, type) {\n    const group = {};\n    const keys = [];\n    const hasReturningDependColumns = subjects.some(subject => {\n      return subject.metadata.getInsertionReturningColumns().length > 0;\n    });\n    const groupingAllowed = type === \"delete\" || this.queryRunner.connection.driver.isReturningSqlSupported(\"insert\") || hasReturningDependColumns === false;\n    subjects.forEach((subject, index) => {\n      const key = groupingAllowed || subject.metadata.isJunction ? subject.metadata.name : subject.metadata.name + \"_\" + index;\n\n      if (!group[key]) {\n        group[key] = [subject];\n        keys.push(key);\n      } else {\n        group[key].push(subject);\n      }\n    });\n    return [group, keys];\n  }\n\n}","map":{"version":3,"mappings":"AAEA,SAASA,wBAAT,QAAyC,4BAAzC;AACA,SAASC,6BAAT,QAA8C,iCAA9C;AACA,SAASC,6BAAT,QAA8C,wCAA9C;AACA,SAASC,6BAAT,QAA8C,wCAA9C;AAKA,SAASC,iBAAT,QAAkC,iCAAlC;AACA,SAASC,wBAAT,QAAyC,iCAAzC;AACA,SAASC,sBAAT,QAAuC,+BAAvC;AACA,SAASC,+BAAT,QAAgD,wCAAhD;AACA,SAASC,QAAT,QAAyB,kBAAzB;AAEA,SAASC,WAAT,QAA4B,qBAA5B;AACA,SAASC,eAAT,QAAgC,yBAAhC;AAEA;;;;;AAIA,OAAM,MAAOC,eAAP,CAAsB;EAsDxB;EACA;EACA;EAEAC,YACIC,WADJ,EAEIC,QAFJ,EAGIC,OAHJ,EAGyC;IA5DzC;IACA;IACA;;IAEA;;;IAGA,+BAAmC,KAAnC;IAqBA;;;;IAGU,sBAA4B,EAA5B;IAEV;;;;IAGU,sBAA4B,EAA5B;IAEV;;;;IAGU,sBAA4B,EAA5B;IAEV;;;;IAGU,0BAAgC,EAAhC;IAEV;;;;IAGU,uBAA6B,EAA7B;IAWN,KAAKF,WAAL,GAAmBA,WAAnB;IACA,KAAKG,WAAL,GAAmBF,QAAnB;IACA,KAAKC,OAAL,GAAeA,OAAf;IACA,KAAKE,QAAL;IACA,KAAKC,SAAL;EACH,CApEuB,CAsExB;EACA;EACA;;EAEA;;;;;;EAIa,MAAPC,OAAO;IACT;IAEA;IACA,IAAIC,iBAAiB,GAAkCC,SAAvD;;IACA,IAAI,CAAC,KAAKN,OAAN,IAAiB,KAAKA,OAAL,CAAaO,SAAb,KAA2B,KAAhD,EAAuD;MACnD;MACAF,iBAAiB,GAAG,KAAKG,2BAAL,EAApB;MACA,IAAIH,iBAAiB,CAACI,QAAlB,CAA2BC,MAA3B,GAAoC,CAAxC,EACI,MAAMC,OAAO,CAACC,GAAR,CAAYP,iBAAiB,CAACI,QAA9B,CAAN,CAJ+C,CAKnD;IACH,CAXQ,CAaT;IACA;;;IACA,IAAIJ,iBAAiB,IAAIA,iBAAiB,CAACQ,KAAlB,GAA0B,CAAnD,EAAsD;MAClD;MACA,KAAKC,cAAL,CAAoBC,OAApB,CAA6BC,OAAD,IAAaA,OAAO,CAACb,SAAR,EAAzC;MACA,KAAKc,cAAL,CAAoBF,OAApB,CAA6BC,OAAD,IAAaA,OAAO,CAACb,SAAR,EAAzC;MACA,KAAKe,cAAL,CAAoBH,OAApB,CAA6BC,OAAD,IAAaA,OAAO,CAACb,SAAR,EAAzC;MACA,KAAKgB,kBAAL,CAAwBJ,OAAxB,CAAiCC,OAAD,IAAaA,OAAO,CAACb,SAAR,EAA7C;MACA,KAAKiB,eAAL,CAAqBL,OAArB,CAA8BC,OAAD,IAAaA,OAAO,CAACb,SAAR,EAA1C;MACA,KAAKA,SAAL,GAPkD,CAQlD;IACH,CAxBQ,CA0BT;IAEA;IAEA;IACA;;;IACA,KAAKW,cAAL,GAAsB,IAAI7B,wBAAJ,CAClB,KAAK6B,cADa,EAEpBO,IAFoB,CAEf,QAFe,CAAtB;IAGA,MAAM,KAAKC,uBAAL,EAAN,CAnCS,CAoCT;IAEA;IACA;;IACA,KAAKL,cAAL,GAAsB,KAAKhB,WAAL,CAAiBsB,MAAjB,CACjBP,OAAD,IAAaA,OAAO,CAACQ,aADH,CAAtB,CAxCS,CA4CT;IACA;;IACA,MAAM,KAAKC,uBAAL,EAAN,CA9CS,CA+CT;IAEA;IACA;;IACA,KAAKP,cAAL,GAAsB,IAAIjC,wBAAJ,CAClB,KAAKiC,cADa,EAEpBG,IAFoB,CAEf,QAFe,CAAtB;IAGA,MAAM,KAAKK,uBAAL,EAAN,CAtDS,CAuDT;IAEA;;IACA,KAAKP,kBAAL,GAA0B,KAAKlB,WAAL,CAAiBsB,MAAjB,CACrBP,OAAD,IAAaA,OAAO,CAACW,iBADC,CAA1B,CA1DS,CA8DT;;IACA,MAAM,KAAKC,2BAAL,EAAN,CA/DS,CAiET;;IACA,KAAKR,eAAL,GAAuB,KAAKnB,WAAL,CAAiBsB,MAAjB,CAClBP,OAAD,IAAaA,OAAO,CAACa,eADF,CAAvB,CAlES,CAsET;;IACA,MAAM,KAAKC,wBAAL,EAAN,CAvES,CAyET;IACA;;IACA,MAAM,KAAKC,uCAAL,EAAN,CA3ES,CA4ET;IAEA;;IACA,IAAI,CAAC,KAAK/B,OAAN,IAAiB,KAAKA,OAAL,CAAaO,SAAb,KAA2B,KAAhD,EAAuD;MACnD;MACAF,iBAAiB,GAAG,KAAK2B,0BAAL,EAApB;MACA,IAAI3B,iBAAiB,CAACI,QAAlB,CAA2BC,MAA3B,GAAoC,CAAxC,EACI,MAAMC,OAAO,CAACC,GAAR,CAAYP,iBAAiB,CAACI,QAA9B,CAAN,CAJ+C,CAKnD;IACH,CArFQ,CAsFT;;EACH,CArKuB,CAuKxB;EACA;EACA;;EAEA;;;;;EAGUP,QAAQ;IACd,KAAKD,WAAL,CAAiBc,OAAjB,CAA0BC,OAAD,IAAY;MACjC,IAAIA,OAAO,CAACQ,aAAR,IAAyBR,OAAO,CAACiB,aAArC,EACI,MAAM,IAAI7C,6BAAJ,CAAkC4B,OAAlC,CAAN;IACP,CAHD;EAIH;EAED;;;;;EAGUb,SAAS;IACf,IAAIjB,6BAAJ,GAAoCgD,OAApC,CAA4C,KAAKjC,WAAjD;IACA,KAAKa,cAAL,GAAsB,KAAKb,WAAL,CAAiBsB,MAAjB,CACjBP,OAAD,IAAaA,OAAO,CAACmB,cADH,CAAtB;IAGA,KAAKlB,cAAL,GAAsB,KAAKhB,WAAL,CAAiBsB,MAAjB,CACjBP,OAAD,IAAaA,OAAO,CAACQ,aADH,CAAtB;IAGA,KAAKN,cAAL,GAAsB,KAAKjB,WAAL,CAAiBsB,MAAjB,CACjBP,OAAD,IAAaA,OAAO,CAACiB,aADH,CAAtB;IAGA,KAAKd,kBAAL,GAA0B,KAAKlB,WAAL,CAAiBsB,MAAjB,CACrBP,OAAD,IAAaA,OAAO,CAACW,iBADC,CAA1B;IAGA,KAAKP,eAAL,GAAuB,KAAKnB,WAAL,CAAiBsB,MAAjB,CAClBP,OAAD,IAAaA,OAAO,CAACa,eADF,CAAvB;IAGA,KAAKO,uBAAL,GACI,KAAKtB,cAAL,CAAoBJ,MAApB,GAA6B,CAA7B,IACA,KAAKO,cAAL,CAAoBP,MAApB,GAA6B,CAD7B,IAEA,KAAKQ,cAAL,CAAoBR,MAApB,GAA6B,CAF7B,IAGA,KAAKS,kBAAL,CAAwBT,MAAxB,GAAiC,CAHjC,IAIA,KAAKU,eAAL,CAAqBV,MAArB,GAA8B,CALlC;EAMH;EAED;;;;;EAGUF,2BAA2B;IACjC,MAAM6B,MAAM,GAAG,IAAIhD,iBAAJ,EAAf;IACA,IAAI,KAAKyB,cAAL,CAAoBJ,MAAxB,EACI,KAAKI,cAAL,CAAoBC,OAApB,CAA6BC,OAAD,IACxB,KAAKlB,WAAL,CAAiBwC,WAAjB,CAA6BC,0BAA7B,CACIF,MADJ,EAEIrB,OAAO,CAACwB,QAFZ,EAGIxB,OAAO,CAACyB,MAHZ,CADJ;IAOJ,IAAI,KAAKxB,cAAL,CAAoBP,MAAxB,EACI,KAAKO,cAAL,CAAoBF,OAApB,CAA6BC,OAAD,IACxB,KAAKlB,WAAL,CAAiBwC,WAAjB,CAA6BI,0BAA7B,CACIL,MADJ,EAEIrB,OAAO,CAACwB,QAFZ,EAGIxB,OAAO,CAACyB,MAHZ,EAIIzB,OAAO,CAAC2B,cAJZ,EAKI3B,OAAO,CAAC4B,WALZ,EAMI5B,OAAO,CAAC6B,aANZ,CADJ;IAUJ,IAAI,KAAK3B,cAAL,CAAoBR,MAAxB,EACI,KAAKQ,cAAL,CAAoBH,OAApB,CAA6BC,OAAD,IACxB,KAAKlB,WAAL,CAAiBwC,WAAjB,CAA6BQ,0BAA7B,CACIT,MADJ,EAEIrB,OAAO,CAACwB,QAFZ,EAGIxB,OAAO,CAACyB,MAHZ,EAIIzB,OAAO,CAAC2B,cAJZ,CADJ;IAQJ,IAAI,KAAKxB,kBAAL,CAAwBT,MAA5B,EACI,KAAKS,kBAAL,CAAwBJ,OAAxB,CAAiCC,OAAD,IAC5B,KAAKlB,WAAL,CAAiBwC,WAAjB,CAA6BS,8BAA7B,CACIV,MADJ,EAEIrB,OAAO,CAACwB,QAFZ,EAGIxB,OAAO,CAACyB,MAHZ,EAIIzB,OAAO,CAAC2B,cAJZ,CADJ;IAQJ,IAAI,KAAKvB,eAAL,CAAqBV,MAAzB,EACI,KAAKU,eAAL,CAAqBL,OAArB,CAA8BC,OAAD,IACzB,KAAKlB,WAAL,CAAiBwC,WAAjB,CAA6BU,2BAA7B,CACIX,MADJ,EAEIrB,OAAO,CAACwB,QAFZ,EAGIxB,OAAO,CAACyB,MAHZ,EAIIzB,OAAO,CAAC2B,cAJZ,CADJ;IAQJ,OAAON,MAAP;EACH;EAED;;;;;;;EAKUL,0BAA0B;IAChC,MAAMK,MAAM,GAAG,IAAIhD,iBAAJ,EAAf;IACA,IAAI,KAAKyB,cAAL,CAAoBJ,MAAxB,EACI,KAAKI,cAAL,CAAoBC,OAApB,CAA6BC,OAAD,IACxB,KAAKlB,WAAL,CAAiBwC,WAAjB,CAA6BW,yBAA7B,CACIZ,MADJ,EAEIrB,OAAO,CAACwB,QAFZ,EAGIxB,OAAO,CAACyB,MAHZ,CADJ;IAOJ,IAAI,KAAKxB,cAAL,CAAoBP,MAAxB,EACI,KAAKO,cAAL,CAAoBF,OAApB,CAA6BC,OAAD,IACxB,KAAKlB,WAAL,CAAiBwC,WAAjB,CAA6BY,yBAA7B,CACIb,MADJ,EAEIrB,OAAO,CAACwB,QAFZ,EAGIxB,OAAO,CAACyB,MAHZ,EAIIzB,OAAO,CAAC2B,cAJZ,EAKI3B,OAAO,CAAC4B,WALZ,EAMI5B,OAAO,CAAC6B,aANZ,CADJ;IAUJ,IAAI,KAAK3B,cAAL,CAAoBR,MAAxB,EACI,KAAKQ,cAAL,CAAoBH,OAApB,CAA6BC,OAAD,IACxB,KAAKlB,WAAL,CAAiBwC,WAAjB,CAA6Ba,yBAA7B,CACId,MADJ,EAEIrB,OAAO,CAACwB,QAFZ,EAGIxB,OAAO,CAACyB,MAHZ,EAIIzB,OAAO,CAAC2B,cAJZ,CADJ;IAQJ,IAAI,KAAKxB,kBAAL,CAAwBT,MAA5B,EACI,KAAKS,kBAAL,CAAwBJ,OAAxB,CAAiCC,OAAD,IAC5B,KAAKlB,WAAL,CAAiBwC,WAAjB,CAA6Bc,6BAA7B,CACIf,MADJ,EAEIrB,OAAO,CAACwB,QAFZ,EAGIxB,OAAO,CAACyB,MAHZ,EAIIzB,OAAO,CAAC2B,cAJZ,CADJ;IAQJ,IAAI,KAAKvB,eAAL,CAAqBV,MAAzB,EACI,KAAKU,eAAL,CAAqBL,OAArB,CAA8BC,OAAD,IACzB,KAAKlB,WAAL,CAAiBwC,WAAjB,CAA6Be,0BAA7B,CACIhB,MADJ,EAEIrB,OAAO,CAACwB,QAFZ,EAGIxB,OAAO,CAACyB,MAHZ,EAIIzB,OAAO,CAAC2B,cAJZ,CADJ;IAQJ,OAAON,MAAP;EACH;EAED;;;;;EAGuC,MAAvBf,uBAAuB;IACnC;IACA,MAAM,CAACgC,qBAAD,EAAwBC,wBAAxB,IACF,KAAKC,iBAAL,CAAuB,KAAK1C,cAA5B,EAA4C,QAA5C,CADJ,CAFmC,CAKnC;;IACA,KAAK,MAAM2C,SAAX,IAAwBF,wBAAxB,EAAkD;MAC9C,MAAMxD,QAAQ,GAAGuD,qBAAqB,CAACG,SAAD,CAAtC,CAD8C,CAG9C;MACA;;MACA,MAAMC,cAAc,GAAoB,EAAxC;MACA,MAAMC,kBAAkB,GAAc,EAAtC;MACA,MAAMC,oBAAoB,GAAc,EAAxC;;MACA,IAAI,KAAK9D,WAAL,CAAiB+D,UAAjB,CAA4BC,MAA5B,CAAmC9D,OAAnC,CAA2C+D,IAA3C,KAAoD,SAAxD,EAAmE;QAC/DhE,QAAQ,CAACgB,OAAT,CAAkBC,OAAD,IAAY;UACzB,IAAIA,OAAO,CAACwB,QAAR,CAAiBwB,gBAAjB,IAAqChD,OAAO,CAACyB,MAAjD,EAAyD;YACrDzB,OAAO,CAACyB,MAAR,CACIzB,OAAO,CAACwB,QAAR,CAAiBwB,gBAAjB,CAAkCC,YADtC,IAEI,IAAIC,IAAJ,EAFJ;UAGH;;UAED,IAAIlD,OAAO,CAACwB,QAAR,CAAiB2B,gBAAjB,IAAqCnD,OAAO,CAACyB,MAAjD,EAAyD;YACrDzB,OAAO,CAACyB,MAAR,CACIzB,OAAO,CAACwB,QAAR,CAAiB2B,gBAAjB,CAAkCF,YADtC,IAEI,IAAIC,IAAJ,EAFJ;UAGH;;UAEDlD,OAAO,CAACoD,6BAAR;UAEAT,kBAAkB,CAACU,IAAnB,CAAwBrD,OAAxB;UACA0C,cAAc,CAACW,IAAf,CAAoBrD,OAAO,CAACyB,MAA5B;QACH,CAjBD;MAkBH,CAnBD,MAmBO,IACH,KAAK3C,WAAL,CAAiB+D,UAAjB,CAA4BC,MAA5B,CAAmC9D,OAAnC,CAA2C+D,IAA3C,KAAoD,QADjD,EAEL;QACEhE,QAAQ,CAACgB,OAAT,CAAkBC,OAAD,IAAY;UACzB4C,oBAAoB,CAACS,IAArB,CAA0BrD,OAA1B;QACH,CAFD;MAGH,CANM,MAMA;QACHjB,QAAQ,CAACgB,OAAT,CAAkBC,OAAD,IAAY;UACzB;UACA;UACA;UACA;UACA,IACIA,OAAO,CAACsD,UAAR,CAAmB5D,MAAnB,KAA8B,CAA9B,IACAM,OAAO,CAACwB,QAAR,CAAiB+B,QADjB,IAEA,KAAKzE,WAAL,CAAiB+D,UAAjB,CAA4BC,MAA5B,CAAmC9D,OAAnC,CAA2C+D,IAA3C,KACI,QAHJ,IAIA,KAAKjE,WAAL,CAAiB+D,UAAjB,CAA4BC,MAA5B,CAAmC9D,OAAnC,CAA2C+D,IAA3C,KACI,KANR,EAOE;YACEH,oBAAoB,CAACS,IAArB,CAA0BrD,OAA1B;UACH,CATD,MASO;YACH2C,kBAAkB,CAACU,IAAnB,CAAwBrD,OAAxB;YACA0C,cAAc,CAACW,IAAf,CACIrD,OAAO,CAACoD,6BAAR,EADJ;UAGH;QACJ,CApBD;MAqBH,CAvD6C,CAyD9C;;;MACA,IACIzE,eAAe,CAAC6E,oBAAhB,CAAqC,KAAK1E,WAAL,CAAiB2E,OAAtD,CADJ,EAEE;QACE,MAAMC,YAAY,GAAG,MAAM,KAAK5E,WAAL,CAAiB2E,OAAjB,CAAyBE,MAAzB,CACvB5E,QAAQ,CAAC,CAAD,CAAR,CAAYyC,QAAZ,CAAqBoC,MADE,EAEvBlB,cAFuB,CAA3B;QAIA3D,QAAQ,CAACgB,OAAT,CAAiB,CAACC,OAAD,EAAU6D,KAAV,KAAmB;UAChC7D,OAAO,CAAC8D,UAAR,GAAqBJ,YAAY,CAACK,WAAb,CAAyBF,KAAzB,CAArB;UACA7D,OAAO,CAACgE,YAAR,GAAuBN,YAAY,CAACO,aAAb,CAA2BJ,KAA3B,CAAvB;UACA7D,OAAO,CAACkE,gBAAR,GAA2BxB,cAAc,CAACmB,KAAD,CAAzC;QACH,CAJD;MAKH,CAZD,MAYO;QACH;QACA;QACA;QACA;QACA,IAAInB,cAAc,CAAChD,MAAf,GAAwB,CAA5B,EAA+B;UAC3B,MAAMgE,YAAY,GAAG,MAAM,KAAK5E,WAAL,CAAiB2E,OAAjB,CACtBU,kBADsB,GAEtBR,MAFsB,GAGtBS,IAHsB,CAGjBrF,QAAQ,CAAC,CAAD,CAAR,CAAYyC,QAAZ,CAAqBoC,MAHJ,EAItBS,MAJsB,CAIf3B,cAJe,EAKtB4B,YALsB,CAMnB,KAAKtF,OAAL,IAAgB,KAAKA,OAAL,CAAauF,MAAb,KAAwB,KAAxC,GACM,KADN,GAEM,IARa,EAUtBC,aAVsB,CAUR,KAVQ,EAWtBpF,OAXsB,EAA3B;UAaAuD,kBAAkB,CAAC5C,OAAnB,CAA2B,CAACC,OAAD,EAAU6D,KAAV,KAAmB;YAC1C7D,OAAO,CAAC8D,UAAR,GAAqBJ,YAAY,CAACK,WAAb,CAAyBF,KAAzB,CAArB;YACA7D,OAAO,CAACgE,YAAR,GAAuBN,YAAY,CAACO,aAAb,CAA2BJ,KAA3B,CAAvB;YACA7D,OAAO,CAACkE,gBAAR,GAA2BxB,cAAc,CAACmB,KAAD,CAAzC;UACH,CAJD;QAKH,CAxBE,CA0BH;;;QACA,IAAIjB,oBAAoB,CAAClD,MAArB,GAA8B,CAAlC,EAAqC;UACjC,KAAK,MAAMM,OAAX,IAAsB4C,oBAAtB,EAA4C;YACxC5C,OAAO,CAACkE,gBAAR,GACIlE,OAAO,CAACoD,6BAAR,EADJ,CADwC,CAEI;YAE5C;;YACA,IAAIpD,OAAO,CAACwB,QAAR,CAAiB+B,QAAjB,KAA8B,YAAlC,EACI,MAAM,IAAIjF,wBAAJ,CACF,KAAKQ,WADH,EAEJ6E,MAFI,CAEG3D,OAFH,CAAN;YAIJ,MAAM,KAAKlB,WAAL,CAAiB2E,OAAjB,CACDU,kBADC,GAEDR,MAFC,GAGDS,IAHC,CAGIpE,OAAO,CAACwB,QAAR,CAAiBoC,MAHrB,EAIDS,MAJC,CAIMrE,OAAO,CAACkE,gBAJd,EAKDI,YALC,CAME,KAAKtF,OAAL,IAAgB,KAAKA,OAAL,CAAauF,MAAb,KAAwB,KAAxC,GACM,KADN,GAEM,IARR,EAUDC,aAVC,CAUa,KAVb,EAWDpF,OAXC,GAYDqF,IAZC,CAYKf,YAAD,IAAiB;cACnB1D,OAAO,CAAC8D,UAAR,GAAqBJ,YAAY,CAACK,WAAb,CAAyB,CAAzB,CAArB;cACA/D,OAAO,CAACgE,YAAR,GACIN,YAAY,CAACO,aAAb,CAA2B,CAA3B,CADJ;YAEH,CAhBC,CAAN,CAVwC,CA4BxC;;YACA,IAAIjE,OAAO,CAACwB,QAAR,CAAiB+B,QAAjB,KAA8B,eAAlC,EAAmD;cAC/C,MAAM,IAAIhF,sBAAJ,CACF,KAAKO,WADH,EAEJ6E,MAFI,CAEG3D,OAFH,CAAN;YAGH,CAJD,MAIO,IACHA,OAAO,CAACwB,QAAR,CAAiB+B,QAAjB,KAA8B,mBAD3B,EAEL;cACE,MAAM,IAAI/E,+BAAJ,CACF,KAAKM,WADH,EAEJ6E,MAFI,CAEG3D,OAFH,CAAN;YAGH;UACJ;QACJ;MACJ;;MAEDjB,QAAQ,CAACgB,OAAT,CAAkBC,OAAD,IAAY;QACzB,IAAIA,OAAO,CAACgE,YAAZ,EAA0B;UACtBhE,OAAO,CAACwB,QAAR,CAAiBkD,OAAjB,CAAyB3E,OAAzB,CAAkC4E,MAAD,IAAW;YACxC,MAAMC,KAAK,GAAGD,MAAM,CAACE,cAAP,CACV7E,OAAO,CAACgE,YADE,CAAd;;YAGA,IAAIY,KAAK,KAAKtF,SAAV,IAAuBsF,KAAK,KAAK,IAArC,EAA2C;cACvC,MAAME,aAAa,GACf,KAAKhG,WAAL,CAAiB+D,UAAjB,CAA4BC,MAA5B,CAAmCiC,oBAAnC,CACIH,KADJ,EAEID,MAFJ,CADJ;cAKAA,MAAM,CAACK,cAAP,CACIhF,OAAO,CAACgE,YADZ,EAEIc,aAFJ;YAIH;UACJ,CAfD;QAgBH;MACJ,CAnBD;IAoBH;EACJ;EAED;;;;;EAGuC,MAAvBrE,uBAAuB;IACnC,MAAMwE,aAAa,GAAG,MAAOjF,OAAP,IAA2B;MAC7C,IAAI,CAACA,OAAO,CAAC8D,UAAb,EACI,MAAM,IAAI3F,6BAAJ,CAAkC6B,OAAlC,CAAN,CAFyC,CAI7C;;MACA,IACIrB,eAAe,CAAC6E,oBAAhB,CAAqC,KAAK1E,WAAL,CAAiB2E,OAAtD,CADJ,EAEE;QACE,MAAMyB,aAAa,GAAG,KAAKC,uBAAL,CAA6BnF,OAA7B,CAAtB;;QACA,IACIA,OAAO,CAACwB,QAAR,CAAiB4D,cAAjB,IACApF,OAAO,CAACwB,QAAR,CAAiB4D,cAAjB,CAAgCC,YAFpC,EAGE;UACE,OAAOH,aAAa,CAChBlF,OAAO,CAACwB,QAAR,CAAiB4D,cAAjB,CAAgCC,YADhB,CAApB;QAGH;;QAED,IACIrF,OAAO,CAACwB,QAAR,CAAiBwB,gBAAjB,IACAhD,OAAO,CAACwB,QAAR,CAAiBwB,gBAAjB,CAAkCqC,YAFtC,EAGE;UACE,OAAOH,aAAa,CAChBlF,OAAO,CAACwB,QAAR,CAAiBwB,gBAAjB,CAAkCqC,YADlB,CAApB;QAGH;;QAED,IACIrF,OAAO,CAACwB,QAAR,CAAiB2B,gBAAjB,IACAnD,OAAO,CAACwB,QAAR,CAAiB2B,gBAAjB,CAAkCkC,YAFtC,EAGE;UACEH,aAAa,CACTlF,OAAO,CAACwB,QAAR,CAAiB2B,gBAAjB,CAAkCkC,YADzB,CAAb,GAEI,IAAInC,IAAJ,EAFJ;QAGH;;QAED,MAAMO,OAAO,GAAG,KAAK3E,WAAL,CAAiB2E,OAAjC;QAEA,MAAMA,OAAO,CAAC6B,MAAR,CACFtF,OAAO,CAACwB,QAAR,CAAiBoC,MADf,EAEF5D,OAAO,CAAC8D,UAFN,EAGFoB,aAHE,CAAN;MAKH,CAtCD,MAsCO;QACH,MAAMK,SAAS,GACXvF,OAAO,CAACoD,6BAAR,EADJ,CADG,CAIH;;QACA,QAAQpD,OAAO,CAACwB,QAAR,CAAiB+B,QAAzB;UACI,KAAK,YAAL;YACI,MAAM,IAAIjF,wBAAJ,CACF,KAAKQ,WADH,EAEJwG,MAFI,CAEGtF,OAFH,CAAN;YAGA;;UAEJ,KAAK,eAAL;YACI,MAAM,IAAIzB,sBAAJ,CACF,KAAKO,WADH,EAEJwG,MAFI,CAEGtF,OAFH,CAAN;YAGA;;UAEJ,KAAK,mBAAL;YACI,MAAM,IAAIxB,+BAAJ,CACF,KAAKM,WADH,EAEJwG,MAFI,CAEGtF,OAFH,CAAN;YAGA;QAjBR,CALG,CAyBH;QACA;QACA;QACA;;;QACA,MAAMwF,kBAAkB,GAAG,KAAK1G,WAAL,CAAiB2E,OAAjB,CACtBU,kBADsB,GAEtBmB,MAFsB,CAEftF,OAAO,CAACwB,QAAR,CAAiBoC,MAFF,EAGtB6B,GAHsB,CAGlBF,SAHkB,EAItBjB,YAJsB,CAKnB,KAAKtF,OAAL,IAAgB,KAAKA,OAAL,CAAauF,MAAb,KAAwB,KAAxC,GACM,KADN,GAEM,IAPa,EAStBC,aATsB,CASR,KATQ,CAA3B;;QAWA,IAAIxE,OAAO,CAACyB,MAAZ,EAAoB;UAChB+D,kBAAkB,CAACE,WAAnB,CAA+B1F,OAAO,CAAC8D,UAAvC;QACH,CAFD,MAEO;UACH;UACA0B,kBAAkB,CAACG,KAAnB,CAAyB3F,OAAO,CAAC8D,UAAjC;QACH;;QAED,MAAM8B,YAAY,GAAG,MAAMJ,kBAAkB,CAACpG,OAAnB,EAA3B;QACA,IAAIyG,kBAAkB,GAAGD,YAAY,CAAC3B,aAAb,CAA2B,CAA3B,CAAzB;;QACA,IAAI4B,kBAAJ,EAAwB;UACpB7F,OAAO,CAACwB,QAAR,CAAiBkD,OAAjB,CAAyB3E,OAAzB,CAAkC4E,MAAD,IAAW;YACxC,MAAMC,KAAK,GAAGD,MAAM,CAACE,cAAP,CAAsBgB,kBAAtB,CAAd;;YACA,IAAIjB,KAAK,KAAKtF,SAAV,IAAuBsF,KAAK,KAAK,IAArC,EAA2C;cACvC,MAAME,aAAa,GACf,KAAKhG,WAAL,CAAiB+D,UAAjB,CAA4BC,MAA5B,CAAmCiC,oBAAnC,CACIH,KADJ,EAEID,MAFJ,CADJ;cAKAA,MAAM,CAACK,cAAP,CACIa,kBADJ,EAEIf,aAFJ;YAIH;UACJ,CAbD;;UAcA,IAAI,CAAC9E,OAAO,CAACgE,YAAb,EAA2B;YACvBhE,OAAO,CAACgE,YAAR,GAAuB,EAAvB;UACH;;UACD8B,MAAM,CAACC,MAAP,CAAc/F,OAAO,CAACgE,YAAtB,EAAoC6B,kBAApC;QACH;MACJ;IACJ,CAjHD,CADmC,CAoHnC;IACA;;;IACA,MAAMG,iBAAiB,GAAc,EAArC;IACA,MAAMC,iBAAiB,GAAc,EAArC;;IAEA,KAAK,MAAMjG,OAAX,IAAsB,KAAKC,cAA3B,EAA2C;MACvC,IAAID,OAAO,CAACwB,QAAR,CAAiB+B,QAAjB,KAA8B,YAAlC,EAAgD;QAC5CyC,iBAAiB,CAAC3C,IAAlB,CAAuBrD,OAAvB;MACH,CAFD,MAEO;QACHiG,iBAAiB,CAAC5C,IAAlB,CAAuBrD,OAAvB;MACH;IACJ,CA/HkC,CAiInC;;;IACA,MAAMkG,gBAAgB,GAAG,IAAIvG,OAAJ,CAAkB,OAAOwG,EAAP,EAAWC,IAAX,KAAmB;MAC1D,KAAK,MAAMpG,OAAX,IAAsBgG,iBAAtB,EAAyC;QACrC,IAAI;UACA,MAAMf,aAAa,CAACjF,OAAD,CAAnB;QACH,CAFD,CAEE,OAAOqG,KAAP,EAAc;UACZD,IAAI,CAACC,KAAD,CAAJ;QACH;MACJ;;MACDF,EAAE;IACL,CATwB,CAAzB,CAlImC,CA6InC;;IACA,MAAMxG,OAAO,CAACC,GAAR,CAAY,CACd,GAAGqG,iBAAiB,CAACK,GAAlB,CAAsBrB,aAAtB,CADW,EAEdiB,gBAFc,CAAZ,CAAN;EAIH;EAED;;;;;;;EAKuC,MAAvBxF,uBAAuB;IACnC;IACA,MAAM,CAAC6F,qBAAD,EAAwBC,wBAAxB,IACF,KAAKhE,iBAAL,CAAuB,KAAKtC,cAA5B,EAA4C,QAA5C,CADJ;;IAGA,KAAK,MAAMuC,SAAX,IAAwB+D,wBAAxB,EAAkD;MAC9C,MAAMzH,QAAQ,GAAGwH,qBAAqB,CAAC9D,SAAD,CAAtC;MACA,MAAMgE,UAAU,GAAG1H,QAAQ,CAACuH,GAAT,CAActG,OAAD,IAAY;QACxC,IAAI,CAACA,OAAO,CAAC8D,UAAb,EACI,MAAM,IAAI3F,6BAAJ,CAAkC6B,OAAlC,CAAN;QAEJ,OAAOA,OAAO,CAAC8D,UAAf;MACH,CALkB,CAAnB,CAF8C,CAS9C;;MACA,IACInF,eAAe,CAAC6E,oBAAhB,CAAqC,KAAK1E,WAAL,CAAiB2E,OAAtD,CADJ,EAEE;QACE,MAAMA,OAAO,GAAG,KAAK3E,WAAL,CAAiB2E,OAAjC;QACA,MAAMA,OAAO,CAACiD,MAAR,CAAe3H,QAAQ,CAAC,CAAD,CAAR,CAAYyC,QAAZ,CAAqBoC,MAApC,EAA4C6C,UAA5C,CAAN;MACH,CALD,MAKO;QACH;QACA,QAAQ1H,QAAQ,CAAC,CAAD,CAAR,CAAYyC,QAAZ,CAAqB+B,QAA7B;UACI,KAAK,YAAL;YACI,MAAM,IAAIjF,wBAAJ,CACF,KAAKQ,WADH,EAEJ6H,MAFI,CAEG5H,QAFH,CAAN;YAGA;;UAEJ,KAAK,eAAL;YACI,MAAM,IAAIR,sBAAJ,CACF,KAAKO,WADH,EAEJ6H,MAFI,CAEG5H,QAFH,CAAN;YAGA;QAXR,CAFG,CAgBH;QACA;QACA;QACA;;;QACA,MAAM,KAAKD,WAAL,CAAiB2E,OAAjB,CACDU,kBADC,GAEDuC,MAFC,GAGDE,IAHC,CAGI7H,QAAQ,CAAC,CAAD,CAAR,CAAYyC,QAAZ,CAAqBoC,MAHzB,EAID+B,KAJC,CAIKc,UAJL,EAKDjC,aALC,CAKa,KALb,EAMDpF,OANC,EAAN;MAOH;IACJ;EACJ;;EAEO+F,uBAAuB,CAACnF,OAAD,EAAiB;IAC5C,MAAM4D,MAAM,GAAkB,EAA9B;;IAEA,IAAI5D,OAAO,CAACyB,MAAZ,EAAoB;MAChB,KAAK,MAAMkD,MAAX,IAAqB3E,OAAO,CAACwB,QAAR,CAAiBkD,OAAtC,EAA+C;QAC3CjG,QAAQ,CAACoI,SAAT,CACIjD,MADJ,EAEIe,MAAM,CAACmC,iBAAP,CAAyB9G,OAAO,CAACyB,MAAjC,CAFJ;MAIH;IACJ;;IAED,OAAOmC,MAAP;EACH;EAED;;;;;EAG2C,MAA3BhD,2BAA2B;IACvC,MAAMjB,OAAO,CAACC,GAAR,CACF,KAAKO,kBAAL,CAAwBmG,GAAxB,CAA4B,MAAOtG,OAAP,IAAkB;MAC1C,IAAI,CAACA,OAAO,CAAC8D,UAAb,EACI,MAAM,IAAI3F,6BAAJ,CAAkC6B,OAAlC,CAAN;MAEJ,IAAI4F,YAAJ,CAJ0C,CAM1C;;MACA,IACIjH,eAAe,CAAC6E,oBAAhB,CACI,KAAK1E,WAAL,CAAiB2E,OADrB,CADJ,EAIE;QACE,MAAMyB,aAAa,GAAG,KAAKC,uBAAL,CAA6BnF,OAA7B,CAAtB;;QACA,IACIA,OAAO,CAACwB,QAAR,CAAiB4D,cAAjB,IACApF,OAAO,CAACwB,QAAR,CAAiB4D,cAAjB,CAAgCC,YAFpC,EAGE;UACE,OAAOH,aAAa,CAChBlF,OAAO,CAACwB,QAAR,CAAiB4D,cAAjB,CAAgCC,YADhB,CAApB;QAGH;;QAED,IACIrF,OAAO,CAACwB,QAAR,CAAiBwB,gBAAjB,IACAhD,OAAO,CAACwB,QAAR,CAAiBwB,gBAAjB,CAAkCqC,YAFtC,EAGE;UACE,OAAOH,aAAa,CAChBlF,OAAO,CAACwB,QAAR,CAAiBwB,gBAAjB,CAAkCqC,YADlB,CAApB;QAGH;;QAED,IACIrF,OAAO,CAACwB,QAAR,CAAiB2B,gBAAjB,IACAnD,OAAO,CAACwB,QAAR,CAAiB2B,gBAAjB,CAAkCkC,YAFtC,EAGE;UACEH,aAAa,CACTlF,OAAO,CAACwB,QAAR,CAAiB2B,gBAAjB,CAAkCkC,YADzB,CAAb,GAEI,IAAInC,IAAJ,EAFJ;QAGH;;QAED,IACIlD,OAAO,CAACwB,QAAR,CAAiBuF,gBAAjB,IACA/G,OAAO,CAACwB,QAAR,CAAiBuF,gBAAjB,CAAkC1B,YAFtC,EAGE;UACEH,aAAa,CACTlF,OAAO,CAACwB,QAAR,CAAiBuF,gBAAjB,CAAkC1B,YADzB,CAAb,GAEI,IAAInC,IAAJ,EAFJ;QAGH;;QAED,MAAMO,OAAO,GAAG,KAAK3E,WAAL,CACX2E,OADL;QAGAmC,YAAY,GAAG,MAAMnC,OAAO,CAAC6B,MAAR,CACjBtF,OAAO,CAACwB,QAAR,CAAiBoC,MADA,EAEjB5D,OAAO,CAAC8D,UAFS,EAGjBoB,aAHiB,CAArB;MAKH,CAlDD,MAkDO;QACH;QACA;QACA;QACA;QACA,MAAM8B,sBAAsB,GAAG,KAAKlI,WAAL,CAAiB2E,OAAjB,CAC1BU,kBAD0B,GAE1B8C,UAF0B,GAG1BL,IAH0B,CAGrB5G,OAAO,CAACwB,QAAR,CAAiBoC,MAHI,EAI1BU,YAJ0B,CAKvB,KAAKtF,OAAL,IAAgB,KAAKA,OAAL,CAAauF,MAAb,KAAwB,KAAxC,GACM,KADN,GAEM,IAPiB,EAS1BC,aAT0B,CASZ,KATY,CAA/B;;QAWA,IAAIxE,OAAO,CAACyB,MAAZ,EAAoB;UAChBuF,sBAAsB,CAACtB,WAAvB,CAAmC1F,OAAO,CAAC8D,UAA3C;QACH,CAFD,MAEO;UACH;UACAkD,sBAAsB,CAACrB,KAAvB,CAA6B3F,OAAO,CAAC8D,UAArC;QACH;;QAED8B,YAAY,GAAG,MAAMoB,sBAAsB,CAAC5H,OAAvB,EAArB;MACH;;MAEDY,OAAO,CAACgE,YAAR,GAAuB4B,YAAY,CAAC3B,aAAb,CAA2B,CAA3B,CAAvB;;MACA,IAAIjE,OAAO,CAACgE,YAAZ,EAA0B;QACtBhE,OAAO,CAACwB,QAAR,CAAiBkD,OAAjB,CAAyB3E,OAAzB,CAAkC4E,MAAD,IAAW;UACxC,MAAMC,KAAK,GAAGD,MAAM,CAACE,cAAP,CACV7E,OAAO,CAACgE,YADE,CAAd;;UAGA,IAAIY,KAAK,KAAKtF,SAAV,IAAuBsF,KAAK,KAAK,IAArC,EAA2C;YACvC,MAAME,aAAa,GACf,KAAKhG,WAAL,CAAiB+D,UAAjB,CAA4BC,MAA5B,CAAmCiC,oBAAnC,CACIH,KADJ,EAEID,MAFJ,CADJ;YAKAA,MAAM,CAACK,cAAP,CACIhF,OAAO,CAACgE,YADZ,EAEIc,aAFJ;UAIH;QACJ,CAfD;MAgBH,CArGyC,CAuG1C;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;;IACH,CAlHD,CADE,CAAN;EAqHH;EAED;;;;;EAGwC,MAAxBhE,wBAAwB;IACpC,MAAMnB,OAAO,CAACC,GAAR,CACF,KAAKQ,eAAL,CAAqBkG,GAArB,CAAyB,MAAOtG,OAAP,IAAkB;MACvC,IAAI,CAACA,OAAO,CAAC8D,UAAb,EACI,MAAM,IAAI3F,6BAAJ,CAAkC6B,OAAlC,CAAN;MAEJ,IAAI4F,YAAJ,CAJuC,CAMvC;;MACA,IACIjH,eAAe,CAAC6E,oBAAhB,CACI,KAAK1E,WAAL,CAAiB2E,OADrB,CADJ,EAIE;QACE,MAAMyB,aAAa,GAAG,KAAKC,uBAAL,CAA6BnF,OAA7B,CAAtB;;QACA,IACIA,OAAO,CAACwB,QAAR,CAAiB4D,cAAjB,IACApF,OAAO,CAACwB,QAAR,CAAiB4D,cAAjB,CAAgCC,YAFpC,EAGE;UACE,OAAOH,aAAa,CAChBlF,OAAO,CAACwB,QAAR,CAAiB4D,cAAjB,CAAgCC,YADhB,CAApB;QAGH;;QAED,IACIrF,OAAO,CAACwB,QAAR,CAAiBwB,gBAAjB,IACAhD,OAAO,CAACwB,QAAR,CAAiBwB,gBAAjB,CAAkCqC,YAFtC,EAGE;UACE,OAAOH,aAAa,CAChBlF,OAAO,CAACwB,QAAR,CAAiBwB,gBAAjB,CAAkCqC,YADlB,CAApB;QAGH;;QAED,IACIrF,OAAO,CAACwB,QAAR,CAAiB2B,gBAAjB,IACAnD,OAAO,CAACwB,QAAR,CAAiB2B,gBAAjB,CAAkCkC,YAFtC,EAGE;UACEH,aAAa,CACTlF,OAAO,CAACwB,QAAR,CAAiB2B,gBAAjB,CAAkCkC,YADzB,CAAb,GAEI,IAAInC,IAAJ,EAFJ;QAGH;;QAED,IACIlD,OAAO,CAACwB,QAAR,CAAiBuF,gBAAjB,IACA/G,OAAO,CAACwB,QAAR,CAAiBuF,gBAAjB,CAAkC1B,YAFtC,EAGE;UACEH,aAAa,CACTlF,OAAO,CAACwB,QAAR,CAAiBuF,gBAAjB,CAAkC1B,YADzB,CAAb,GAEI,IAFJ;QAGH;;QAED,MAAM5B,OAAO,GAAG,KAAK3E,WAAL,CACX2E,OADL;QAGAmC,YAAY,GAAG,MAAMnC,OAAO,CAAC6B,MAAR,CACjBtF,OAAO,CAACwB,QAAR,CAAiBoC,MADA,EAEjB5D,OAAO,CAAC8D,UAFS,EAGjBoB,aAHiB,CAArB;MAKH,CAlDD,MAkDO;QACH;QACA;QACA;QACA;QACA,MAAM8B,sBAAsB,GAAG,KAAKlI,WAAL,CAAiB2E,OAAjB,CAC1BU,kBAD0B,GAE1B+C,OAF0B,GAG1BN,IAH0B,CAGrB5G,OAAO,CAACwB,QAAR,CAAiBoC,MAHI,EAI1BU,YAJ0B,CAKvB,KAAKtF,OAAL,IAAgB,KAAKA,OAAL,CAAauF,MAAb,KAAwB,KAAxC,GACM,KADN,GAEM,IAPiB,EAS1BC,aAT0B,CASZ,KATY,CAA/B;;QAWA,IAAIxE,OAAO,CAACyB,MAAZ,EAAoB;UAChBuF,sBAAsB,CAACtB,WAAvB,CAAmC1F,OAAO,CAAC8D,UAA3C;QACH,CAFD,MAEO;UACH;UACAkD,sBAAsB,CAACrB,KAAvB,CAA6B3F,OAAO,CAAC8D,UAArC;QACH;;QAED8B,YAAY,GAAG,MAAMoB,sBAAsB,CAAC5H,OAAvB,EAArB;MACH;;MAEDY,OAAO,CAACgE,YAAR,GAAuB4B,YAAY,CAAC3B,aAAb,CAA2B,CAA3B,CAAvB;;MACA,IAAIjE,OAAO,CAACgE,YAAZ,EAA0B;QACtBhE,OAAO,CAACwB,QAAR,CAAiBkD,OAAjB,CAAyB3E,OAAzB,CAAkC4E,MAAD,IAAW;UACxC,MAAMC,KAAK,GAAGD,MAAM,CAACE,cAAP,CACV7E,OAAO,CAACgE,YADE,CAAd;;UAGA,IAAIY,KAAK,KAAKtF,SAAV,IAAuBsF,KAAK,KAAK,IAArC,EAA2C;YACvC,MAAME,aAAa,GACf,KAAKhG,WAAL,CAAiB+D,UAAjB,CAA4BC,MAA5B,CAAmCiC,oBAAnC,CACIH,KADJ,EAEID,MAFJ,CADJ;YAKAA,MAAM,CAACK,cAAP,CACIhF,OAAO,CAACgE,YADZ,EAEIc,aAFJ;UAIH;QACJ,CAfD;MAgBH,CArGsC,CAuGvC;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;;IACH,CAlHD,CADE,CAAN;EAqHH;EAED;;;;;;EAIU/D,uCAAuC;IAC7C;IACA,IAAI,KAAKjB,cAAL,CAAoBJ,MAAxB,EACI,KAAKyH,gDAAL,CACI,KAAKrH,cADT,EAHyC,CAO7C;;IACA,IAAI,KAAKG,cAAL,CAAoBP,MAAxB,EACI,KAAKyH,gDAAL,CACI,KAAKlH,cADT,EATyC,CAa7C;;IACA,IAAI,KAAKE,kBAAL,CAAwBT,MAA5B,EACI,KAAKyH,gDAAL,CACI,KAAKhH,kBADT,EAfyC,CAmB7C;;IACA,IAAI,KAAKC,eAAL,CAAqBV,MAAzB,EACI,KAAKyH,gDAAL,CACI,KAAK/G,eADT,EArByC,CAyB7C;;IACA,IAAI,KAAKF,cAAL,CAAoBR,MAAxB,EAAgC;MAC5B,KAAKQ,cAAL,CAAoBH,OAApB,CAA6BC,OAAD,IAAY;QACpC,IAAI,CAACA,OAAO,CAACyB,MAAb,EAAqB;QAErBzB,OAAO,CAACwB,QAAR,CAAiB4F,cAAjB,CAAgCrH,OAAhC,CAAyCsH,aAAD,IAAkB;UACtDA,aAAa,CAACrC,cAAd,CAA6BhF,OAAO,CAACyB,MAArC,EAA8CnC,SAA9C;QACH,CAFD;MAGH,CAND;IAOH,CAlC4C,CAoC7C;;;IACA,KAAKL,WAAL,CAAiBc,OAAjB,CAA0BC,OAAD,IAAY;MACjC,IAAI,CAACA,OAAO,CAACyB,MAAb,EAAqB;MAErBzB,OAAO,CAACwB,QAAR,CAAiB8F,WAAjB,CAA6BvH,OAA7B,CAAsCwH,UAAD,IAAe;QAChDA,UAAU,CAACC,QAAX,CAAoBxH,OAAO,CAACyB,MAA5B;MACH,CAFD,EAHiC,CAOjC;;MACA,IACI9C,eAAe,CAAC6E,oBAAhB,CAAqC,KAAK1E,WAAL,CAAiB2E,OAAtD,CADJ,EAEE;QACE,IACIzD,OAAO,CAACwB,QAAR,CAAiB4D,cAAjB,IACApF,OAAO,CAACwB,QAAR,CAAiB4D,cAAjB,CAAgCnC,YADhC,IAEAjD,OAAO,CAACwB,QAAR,CAAiB4D,cAAjB,CAAgCnC,YAAhC,KACIjD,OAAO,CAACwB,QAAR,CAAiB4D,cAAjB,CAAgCC,YAJxC,EAKE;UACE,OAAOrF,OAAO,CAACyB,MAAR,CACHzB,OAAO,CAACwB,QAAR,CAAiB4D,cAAjB,CAAgCnC,YAD7B,CAAP;QAGH;MACJ;IACJ,CAtBD;EAuBH;EAED;;;;;;EAIUkE,gDAAgD,CACtDpI,QADsD,EACnC;IAEnBA,QAAQ,CAACgB,OAAT,CAAkBC,OAAD,IAAY;MACzB,IAAI,CAACA,OAAO,CAACyB,MAAb,EAAqB,OADI,CAGzB;;MACAzB,OAAO,CAACwB,QAAR,CAAiBkD,OAAjB,CAAyB3E,OAAzB,CAAkC4E,MAAD,IAAW;QACxC;QACA,IACI3E,OAAO,CAACwB,QAAR,CAAiBiG,oBAAjB,CAAsC/H,MAAtC,GAA+C,CAA/C,IACAM,OAAO,CAACwB,QAAR,CAAiBiG,oBAAjB,CACKnB,GADL,CACU9E,QAAD,IAAcA,QAAQ,CAACoC,MADhC,EAEK8D,OAFL,CAEa/C,MAAM,CAACf,MAFpB,MAEgC,CAAC,CAJrC,EAMI,OARoC,CAUxC;;QACA,IAAIe,MAAM,CAACgD,SAAX,EAAsB,OAXkB,CAaxC;;QACA,IAAIhD,MAAM,CAACiD,UAAX,EAAuB;UACnB,MAAMC,WAAW,GAAGlD,MAAM,CAACE,cAAP,CAAsB7E,OAAO,CAACyB,MAA9B,CAApB;UACA,IAAIoG,WAAW,KAAKvI,SAApB,EACIqF,MAAM,CAACK,cAAP,CAAsBhF,OAAO,CAACyB,MAA9B,EAAuC,IAAvC;QACP,CAlBuC,CAoBxC;;;QACA,IAAIzB,OAAO,CAAC8H,mBAAR,CAA4BpI,MAA5B,GAAqC,CAAzC,EAA4C;UACxCM,OAAO,CAAC8H,mBAAR,CAA4B/H,OAA5B,CACKgI,kBAAD,IAAuB;YACnBA,kBAAkB,CAACC,QAAnB,CAA4BC,WAA5B,CAAwClI,OAAxC,CACK4E,MAAD,IAAW;cACP,IAAIA,MAAM,CAACgD,SAAP,KAAqB,IAAzB,EAA+B;cAE/BhD,MAAM,CAACK,cAAP,CACIhF,OAAO,CAACyB,MADZ,EAEI/C,WAAW,CAACwJ,QAAZ,CACIH,kBAAkB,CAACnD,KADvB,IAGMD,MAAM,CAACwD,gBAAP,CAAyBtD,cAAzB,CACIkD,kBAAkB,CAACnD,KADvB,CAHN,GAMMmD,kBAAkB,CAACnD,KAR7B;YAUH,CAdL;UAgBH,CAlBL;QAoBH;MACJ,CA3CD,EAJyB,CAiDzB;;MACA,IAAI5E,OAAO,CAACgE,YAAZ,EACI,KAAKlF,WAAL,CAAiB2E,OAAjB,CAAyB2E,KAAzB,CACIpI,OAAO,CAACwB,QAAR,CAAiBoC,MADrB,EAEI5D,OAAO,CAACyB,MAFZ,EAGIzB,OAAO,CAACgE,YAHZ;IAKP,CAxDD;EAyDH;EAED;;;;;;;;;;;;;EAWUxB,iBAAiB,CACvBzD,QADuB,EAEvBgE,IAFuB,EAEE;IAEzB,MAAMsF,KAAK,GAAiC,EAA5C;IACA,MAAMC,IAAI,GAAa,EAAvB;IACA,MAAMC,yBAAyB,GAAGxJ,QAAQ,CAACyJ,IAAT,CAAexI,OAAD,IAAY;MACxD,OAAOA,OAAO,CAACwB,QAAR,CAAiBiH,4BAAjB,GAAgD/I,MAAhD,GAAyD,CAAhE;IACH,CAFiC,CAAlC;IAGA,MAAMgJ,eAAe,GACjB3F,IAAI,KAAK,QAAT,IACA,KAAKjE,WAAL,CAAiB+D,UAAjB,CAA4BC,MAA5B,CAAmC6F,uBAAnC,CACI,QADJ,CADA,IAIAJ,yBAAyB,KAAK,KALlC;IAOAxJ,QAAQ,CAACgB,OAAT,CAAiB,CAACC,OAAD,EAAU6D,KAAV,KAAmB;MAChC,MAAM+E,GAAG,GACLF,eAAe,IAAI1I,OAAO,CAACwB,QAAR,CAAiBqH,UAApC,GACM7I,OAAO,CAACwB,QAAR,CAAiBsH,IADvB,GAEM9I,OAAO,CAACwB,QAAR,CAAiBsH,IAAjB,GAAwB,GAAxB,GAA8BjF,KAHxC;;MAIA,IAAI,CAACwE,KAAK,CAACO,GAAD,CAAV,EAAiB;QACbP,KAAK,CAACO,GAAD,CAAL,GAAa,CAAC5I,OAAD,CAAb;QACAsI,IAAI,CAACjF,IAAL,CAAUuF,GAAV;MACH,CAHD,MAGO;QACHP,KAAK,CAACO,GAAD,CAAL,CAAWvF,IAAX,CAAgBrD,OAAhB;MACH;IACJ,CAXD;IAaA,OAAO,CAACqI,KAAD,EAAQC,IAAR,CAAP;EACH;;AA9mCuB","names":["SubjectTopoligicalSorter","SubjectChangedColumnsComputer","SubjectWithoutIdentifierError","SubjectRemovedAndUpdatedError","BroadcasterResult","NestedSetSubjectExecutor","ClosureSubjectExecutor","MaterializedPathSubjectExecutor","OrmUtils","ObjectUtils","InstanceChecker","SubjectExecutor","constructor","queryRunner","subjects","options","allSubjects","validate","recompute","execute","broadcasterResult","undefined","listeners","broadcastBeforeEventsForAll","promises","length","Promise","all","count","insertSubjects","forEach","subject","updateSubjects","removeSubjects","softRemoveSubjects","recoverSubjects","sort","executeInsertOperations","filter","mustBeUpdated","executeUpdateOperations","executeRemoveOperations","mustBeSoftRemoved","executeSoftRemoveOperations","mustBeRecovered","executeRecoverOperations","updateSpecialColumnsInPersistedEntities","broadcastAfterEventsForAll","mustBeRemoved","compute","mustBeInserted","hasExecutableOperations","result","broadcaster","broadcastBeforeInsertEvent","metadata","entity","broadcastBeforeUpdateEvent","databaseEntity","diffColumns","diffRelations","broadcastBeforeRemoveEvent","broadcastBeforeSoftRemoveEvent","broadcastBeforeRecoverEvent","broadcastAfterInsertEvent","broadcastAfterUpdateEvent","broadcastAfterRemoveEvent","broadcastAfterSoftRemoveEvent","broadcastAfterRecoverEvent","groupedInsertSubjects","groupedInsertSubjectKeys","groupBulkSubjects","groupName","bulkInsertMaps","bulkInsertSubjects","singleInsertSubjects","connection","driver","type","createDateColumn","databaseName","Date","updateDateColumn","createValueSetAndPopChangeMap","push","changeMaps","treeType","isMongoEntityManager","manager","insertResult","insert","target","index","identifier","identifiers","generatedMap","generatedMaps","insertedValueSet","createQueryBuilder","into","values","updateEntity","reload","callListeners","then","columns","column","value","getEntityValue","preparedValue","prepareHydratedValue","setEntityValue","updateSubject","partialEntity","cloneMongoSubjectEntity","objectIdColumn","propertyName","update","updateMap","updateQueryBuilder","set","whereEntity","where","updateResult","updateGeneratedMap","Object","assign","nestedSetSubjects","remainingSubjects","nestedSetPromise","ok","fail","error","map","groupedRemoveSubjects","groupedRemoveSubjectKeys","deleteMaps","delete","remove","from","mergeDeep","getEntityValueMap","deleteDateColumn","softDeleteQueryBuilder","softDelete","restore","updateSpecialColumnsInInsertedAndUpdatedEntities","primaryColumns","primaryColumn","relationIds","relationId","setValue","childEntityMetadatas","indexOf","isVirtual","isNullable","columnValue","updatedRelationMaps","updatedRelationMap","relation","joinColumns","isObject","referencedColumn","merge","group","keys","hasReturningDependColumns","some","getInsertionReturningColumns","groupingAllowed","isReturningSqlSupported","key","isJunction","name"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\persistence\\SubjectExecutor.ts"],"sourcesContent":["import { QueryRunner } from \"../query-runner/QueryRunner\"\nimport { Subject } from \"./Subject\"\nimport { SubjectTopoligicalSorter } from \"./SubjectTopoligicalSorter\"\nimport { SubjectChangedColumnsComputer } from \"./SubjectChangedColumnsComputer\"\nimport { SubjectWithoutIdentifierError } from \"../error/SubjectWithoutIdentifierError\"\nimport { SubjectRemovedAndUpdatedError } from \"../error/SubjectRemovedAndUpdatedError\"\nimport { MongoEntityManager } from \"../entity-manager/MongoEntityManager\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { SaveOptions } from \"../repository/SaveOptions\"\nimport { RemoveOptions } from \"../repository/RemoveOptions\"\nimport { BroadcasterResult } from \"../subscriber/BroadcasterResult\"\nimport { NestedSetSubjectExecutor } from \"./tree/NestedSetSubjectExecutor\"\nimport { ClosureSubjectExecutor } from \"./tree/ClosureSubjectExecutor\"\nimport { MaterializedPathSubjectExecutor } from \"./tree/MaterializedPathSubjectExecutor\"\nimport { OrmUtils } from \"../util/OrmUtils\"\nimport { UpdateResult } from \"../query-builder/result/UpdateResult\"\nimport { ObjectUtils } from \"../util/ObjectUtils\"\nimport { InstanceChecker } from \"../util/InstanceChecker\"\n\n/**\n * Executes all database operations (inserts, updated, deletes) that must be executed\n * with given persistence subjects.\n */\nexport class SubjectExecutor {\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Indicates if executor has any operations to execute (e.g. has insert / update / delete operations to be executed).\n     */\n    hasExecutableOperations: boolean = false\n\n    // -------------------------------------------------------------------------\n    // Protected Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * QueryRunner used to execute all queries with a given subjects.\n     */\n    protected queryRunner: QueryRunner\n\n    /**\n     * Persistence options.\n     */\n    protected options?: SaveOptions & RemoveOptions\n\n    /**\n     * All subjects that needs to be operated.\n     */\n    protected allSubjects: Subject[]\n\n    /**\n     * Subjects that must be inserted.\n     */\n    protected insertSubjects: Subject[] = []\n\n    /**\n     * Subjects that must be updated.\n     */\n    protected updateSubjects: Subject[] = []\n\n    /**\n     * Subjects that must be removed.\n     */\n    protected removeSubjects: Subject[] = []\n\n    /**\n     * Subjects that must be soft-removed.\n     */\n    protected softRemoveSubjects: Subject[] = []\n\n    /**\n     * Subjects that must be recovered.\n     */\n    protected recoverSubjects: Subject[] = []\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        queryRunner: QueryRunner,\n        subjects: Subject[],\n        options?: SaveOptions & RemoveOptions,\n    ) {\n        this.queryRunner = queryRunner\n        this.allSubjects = subjects\n        this.options = options\n        this.validate()\n        this.recompute()\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Executes all operations over given array of subjects.\n     * Executes queries using given query runner.\n     */\n    async execute(): Promise<void> {\n        // console.time(\"SubjectExecutor.execute\");\n\n        // broadcast \"before\" events before we start insert / update / remove operations\n        let broadcasterResult: BroadcasterResult | undefined = undefined\n        if (!this.options || this.options.listeners !== false) {\n            // console.time(\".broadcastBeforeEventsForAll\");\n            broadcasterResult = this.broadcastBeforeEventsForAll()\n            if (broadcasterResult.promises.length > 0)\n                await Promise.all(broadcasterResult.promises)\n            // console.timeEnd(\".broadcastBeforeEventsForAll\");\n        }\n\n        // since event listeners and subscribers can call save methods and/or trigger entity changes we need to recompute operational subjects\n        // recompute only in the case if any listener or subscriber was really executed\n        if (broadcasterResult && broadcasterResult.count > 0) {\n            // console.time(\".recompute\");\n            this.insertSubjects.forEach((subject) => subject.recompute())\n            this.updateSubjects.forEach((subject) => subject.recompute())\n            this.removeSubjects.forEach((subject) => subject.recompute())\n            this.softRemoveSubjects.forEach((subject) => subject.recompute())\n            this.recoverSubjects.forEach((subject) => subject.recompute())\n            this.recompute()\n            // console.timeEnd(\".recompute\");\n        }\n\n        // make sure our insert subjects are sorted (using topological sorting) to make cascade inserts work properly\n\n        // console.timeEnd(\"prepare\");\n\n        // execute all insert operations\n        // console.time(\".insertion\");\n        this.insertSubjects = new SubjectTopoligicalSorter(\n            this.insertSubjects,\n        ).sort(\"insert\")\n        await this.executeInsertOperations()\n        // console.timeEnd(\".insertion\");\n\n        // recompute update operations since insertion can create updation operations for the\n        // properties it wasn't able to handle on its own (referenced columns)\n        this.updateSubjects = this.allSubjects.filter(\n            (subject) => subject.mustBeUpdated,\n        )\n\n        // execute update operations\n        // console.time(\".updation\");\n        await this.executeUpdateOperations()\n        // console.timeEnd(\".updation\");\n\n        // make sure our remove subjects are sorted (using topological sorting) when multiple entities are passed for the removal\n        // console.time(\".removal\");\n        this.removeSubjects = new SubjectTopoligicalSorter(\n            this.removeSubjects,\n        ).sort(\"delete\")\n        await this.executeRemoveOperations()\n        // console.timeEnd(\".removal\");\n\n        // recompute soft-remove operations\n        this.softRemoveSubjects = this.allSubjects.filter(\n            (subject) => subject.mustBeSoftRemoved,\n        )\n\n        // execute soft-remove operations\n        await this.executeSoftRemoveOperations()\n\n        // recompute recover operations\n        this.recoverSubjects = this.allSubjects.filter(\n            (subject) => subject.mustBeRecovered,\n        )\n\n        // execute recover operations\n        await this.executeRecoverOperations()\n\n        // update all special columns in persisted entities, like inserted id or remove ids from the removed entities\n        // console.time(\".updateSpecialColumnsInPersistedEntities\");\n        await this.updateSpecialColumnsInPersistedEntities()\n        // console.timeEnd(\".updateSpecialColumnsInPersistedEntities\");\n\n        // finally broadcast \"after\" events after we finish insert / update / remove operations\n        if (!this.options || this.options.listeners !== false) {\n            // console.time(\".broadcastAfterEventsForAll\");\n            broadcasterResult = this.broadcastAfterEventsForAll()\n            if (broadcasterResult.promises.length > 0)\n                await Promise.all(broadcasterResult.promises)\n            // console.timeEnd(\".broadcastAfterEventsForAll\");\n        }\n        // console.timeEnd(\"SubjectExecutor.execute\");\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Validates all given subjects.\n     */\n    protected validate() {\n        this.allSubjects.forEach((subject) => {\n            if (subject.mustBeUpdated && subject.mustBeRemoved)\n                throw new SubjectRemovedAndUpdatedError(subject)\n        })\n    }\n\n    /**\n     * Performs entity re-computations - finds changed columns, re-builds insert/update/remove subjects.\n     */\n    protected recompute(): void {\n        new SubjectChangedColumnsComputer().compute(this.allSubjects)\n        this.insertSubjects = this.allSubjects.filter(\n            (subject) => subject.mustBeInserted,\n        )\n        this.updateSubjects = this.allSubjects.filter(\n            (subject) => subject.mustBeUpdated,\n        )\n        this.removeSubjects = this.allSubjects.filter(\n            (subject) => subject.mustBeRemoved,\n        )\n        this.softRemoveSubjects = this.allSubjects.filter(\n            (subject) => subject.mustBeSoftRemoved,\n        )\n        this.recoverSubjects = this.allSubjects.filter(\n            (subject) => subject.mustBeRecovered,\n        )\n        this.hasExecutableOperations =\n            this.insertSubjects.length > 0 ||\n            this.updateSubjects.length > 0 ||\n            this.removeSubjects.length > 0 ||\n            this.softRemoveSubjects.length > 0 ||\n            this.recoverSubjects.length > 0\n    }\n\n    /**\n     * Broadcasts \"BEFORE_INSERT\", \"BEFORE_UPDATE\", \"BEFORE_REMOVE\", \"BEFORE_SOFT_REMOVE\", \"BEFORE_RECOVER\" events for all given subjects.\n     */\n    protected broadcastBeforeEventsForAll(): BroadcasterResult {\n        const result = new BroadcasterResult()\n        if (this.insertSubjects.length)\n            this.insertSubjects.forEach((subject) =>\n                this.queryRunner.broadcaster.broadcastBeforeInsertEvent(\n                    result,\n                    subject.metadata,\n                    subject.entity!,\n                ),\n            )\n        if (this.updateSubjects.length)\n            this.updateSubjects.forEach((subject) =>\n                this.queryRunner.broadcaster.broadcastBeforeUpdateEvent(\n                    result,\n                    subject.metadata,\n                    subject.entity!,\n                    subject.databaseEntity,\n                    subject.diffColumns,\n                    subject.diffRelations,\n                ),\n            )\n        if (this.removeSubjects.length)\n            this.removeSubjects.forEach((subject) =>\n                this.queryRunner.broadcaster.broadcastBeforeRemoveEvent(\n                    result,\n                    subject.metadata,\n                    subject.entity!,\n                    subject.databaseEntity,\n                ),\n            )\n        if (this.softRemoveSubjects.length)\n            this.softRemoveSubjects.forEach((subject) =>\n                this.queryRunner.broadcaster.broadcastBeforeSoftRemoveEvent(\n                    result,\n                    subject.metadata,\n                    subject.entity!,\n                    subject.databaseEntity,\n                ),\n            )\n        if (this.recoverSubjects.length)\n            this.recoverSubjects.forEach((subject) =>\n                this.queryRunner.broadcaster.broadcastBeforeRecoverEvent(\n                    result,\n                    subject.metadata,\n                    subject.entity!,\n                    subject.databaseEntity,\n                ),\n            )\n        return result\n    }\n\n    /**\n     * Broadcasts \"AFTER_INSERT\", \"AFTER_UPDATE\", \"AFTER_REMOVE\", \"AFTER_SOFT_REMOVE\", \"AFTER_RECOVER\" events for all given subjects.\n     * Returns void if there wasn't any listener or subscriber executed.\n     * Note: this method has a performance-optimized code organization.\n     */\n    protected broadcastAfterEventsForAll(): BroadcasterResult {\n        const result = new BroadcasterResult()\n        if (this.insertSubjects.length)\n            this.insertSubjects.forEach((subject) =>\n                this.queryRunner.broadcaster.broadcastAfterInsertEvent(\n                    result,\n                    subject.metadata,\n                    subject.entity!,\n                ),\n            )\n        if (this.updateSubjects.length)\n            this.updateSubjects.forEach((subject) =>\n                this.queryRunner.broadcaster.broadcastAfterUpdateEvent(\n                    result,\n                    subject.metadata,\n                    subject.entity!,\n                    subject.databaseEntity,\n                    subject.diffColumns,\n                    subject.diffRelations,\n                ),\n            )\n        if (this.removeSubjects.length)\n            this.removeSubjects.forEach((subject) =>\n                this.queryRunner.broadcaster.broadcastAfterRemoveEvent(\n                    result,\n                    subject.metadata,\n                    subject.entity!,\n                    subject.databaseEntity,\n                ),\n            )\n        if (this.softRemoveSubjects.length)\n            this.softRemoveSubjects.forEach((subject) =>\n                this.queryRunner.broadcaster.broadcastAfterSoftRemoveEvent(\n                    result,\n                    subject.metadata,\n                    subject.entity!,\n                    subject.databaseEntity,\n                ),\n            )\n        if (this.recoverSubjects.length)\n            this.recoverSubjects.forEach((subject) =>\n                this.queryRunner.broadcaster.broadcastAfterRecoverEvent(\n                    result,\n                    subject.metadata,\n                    subject.entity!,\n                    subject.databaseEntity,\n                ),\n            )\n        return result\n    }\n\n    /**\n     * Executes insert operations.\n     */\n    protected async executeInsertOperations(): Promise<void> {\n        // group insertion subjects to make bulk insertions\n        const [groupedInsertSubjects, groupedInsertSubjectKeys] =\n            this.groupBulkSubjects(this.insertSubjects, \"insert\")\n\n        // then we run insertion in the sequential order which is important since we have an ordered subjects\n        for (const groupName of groupedInsertSubjectKeys) {\n            const subjects = groupedInsertSubjects[groupName]\n\n            // we must separately insert entities which does not have any values to insert\n            // because its not possible to insert multiple entities with only default values in bulk\n            const bulkInsertMaps: ObjectLiteral[] = []\n            const bulkInsertSubjects: Subject[] = []\n            const singleInsertSubjects: Subject[] = []\n            if (this.queryRunner.connection.driver.options.type === \"mongodb\") {\n                subjects.forEach((subject) => {\n                    if (subject.metadata.createDateColumn && subject.entity) {\n                        subject.entity[\n                            subject.metadata.createDateColumn.databaseName\n                        ] = new Date()\n                    }\n\n                    if (subject.metadata.updateDateColumn && subject.entity) {\n                        subject.entity[\n                            subject.metadata.updateDateColumn.databaseName\n                        ] = new Date()\n                    }\n\n                    subject.createValueSetAndPopChangeMap()\n\n                    bulkInsertSubjects.push(subject)\n                    bulkInsertMaps.push(subject.entity!)\n                })\n            } else if (\n                this.queryRunner.connection.driver.options.type === \"oracle\"\n            ) {\n                subjects.forEach((subject) => {\n                    singleInsertSubjects.push(subject)\n                })\n            } else {\n                subjects.forEach((subject) => {\n                    // we do not insert in bulk in following cases:\n                    // - when there is no values in insert (only defaults are inserted), since we cannot use DEFAULT VALUES expression for multiple inserted rows\n                    // - when entity is a tree table, since tree tables require extra operation per each inserted row\n                    // - when oracle is used, since oracle's bulk insertion is very bad\n                    if (\n                        subject.changeMaps.length === 0 ||\n                        subject.metadata.treeType ||\n                        this.queryRunner.connection.driver.options.type ===\n                            \"oracle\" ||\n                        this.queryRunner.connection.driver.options.type ===\n                            \"sap\"\n                    ) {\n                        singleInsertSubjects.push(subject)\n                    } else {\n                        bulkInsertSubjects.push(subject)\n                        bulkInsertMaps.push(\n                            subject.createValueSetAndPopChangeMap(),\n                        )\n                    }\n                })\n            }\n\n            // for mongodb we have a bit different insertion logic\n            if (\n                InstanceChecker.isMongoEntityManager(this.queryRunner.manager)\n            ) {\n                const insertResult = await this.queryRunner.manager.insert(\n                    subjects[0].metadata.target,\n                    bulkInsertMaps,\n                )\n                subjects.forEach((subject, index) => {\n                    subject.identifier = insertResult.identifiers[index]\n                    subject.generatedMap = insertResult.generatedMaps[index]\n                    subject.insertedValueSet = bulkInsertMaps[index]\n                })\n            } else {\n                // here we execute our insertion query\n                // we need to enable entity updation because we DO need to have updated insertedMap\n                // which is not same object as our entity that's why we don't need to worry about our entity to get dirty\n                // also, we disable listeners because we call them on our own in persistence layer\n                if (bulkInsertMaps.length > 0) {\n                    const insertResult = await this.queryRunner.manager\n                        .createQueryBuilder()\n                        .insert()\n                        .into(subjects[0].metadata.target)\n                        .values(bulkInsertMaps)\n                        .updateEntity(\n                            this.options && this.options.reload === false\n                                ? false\n                                : true,\n                        )\n                        .callListeners(false)\n                        .execute()\n\n                    bulkInsertSubjects.forEach((subject, index) => {\n                        subject.identifier = insertResult.identifiers[index]\n                        subject.generatedMap = insertResult.generatedMaps[index]\n                        subject.insertedValueSet = bulkInsertMaps[index]\n                    })\n                }\n\n                // insert subjects which must be inserted in separate requests (all default values)\n                if (singleInsertSubjects.length > 0) {\n                    for (const subject of singleInsertSubjects) {\n                        subject.insertedValueSet =\n                            subject.createValueSetAndPopChangeMap() // important to have because query builder sets inserted values into it\n\n                        // for nested set we execute additional queries\n                        if (subject.metadata.treeType === \"nested-set\")\n                            await new NestedSetSubjectExecutor(\n                                this.queryRunner,\n                            ).insert(subject)\n\n                        await this.queryRunner.manager\n                            .createQueryBuilder()\n                            .insert()\n                            .into(subject.metadata.target)\n                            .values(subject.insertedValueSet)\n                            .updateEntity(\n                                this.options && this.options.reload === false\n                                    ? false\n                                    : true,\n                            )\n                            .callListeners(false)\n                            .execute()\n                            .then((insertResult) => {\n                                subject.identifier = insertResult.identifiers[0]\n                                subject.generatedMap =\n                                    insertResult.generatedMaps[0]\n                            })\n\n                        // for tree tables we execute additional queries\n                        if (subject.metadata.treeType === \"closure-table\") {\n                            await new ClosureSubjectExecutor(\n                                this.queryRunner,\n                            ).insert(subject)\n                        } else if (\n                            subject.metadata.treeType === \"materialized-path\"\n                        ) {\n                            await new MaterializedPathSubjectExecutor(\n                                this.queryRunner,\n                            ).insert(subject)\n                        }\n                    }\n                }\n            }\n\n            subjects.forEach((subject) => {\n                if (subject.generatedMap) {\n                    subject.metadata.columns.forEach((column) => {\n                        const value = column.getEntityValue(\n                            subject.generatedMap!,\n                        )\n                        if (value !== undefined && value !== null) {\n                            const preparedValue =\n                                this.queryRunner.connection.driver.prepareHydratedValue(\n                                    value,\n                                    column,\n                                )\n                            column.setEntityValue(\n                                subject.generatedMap!,\n                                preparedValue,\n                            )\n                        }\n                    })\n                }\n            })\n        }\n    }\n\n    /**\n     * Updates all given subjects in the database.\n     */\n    protected async executeUpdateOperations(): Promise<void> {\n        const updateSubject = async (subject: Subject) => {\n            if (!subject.identifier)\n                throw new SubjectWithoutIdentifierError(subject)\n\n            // for mongodb we have a bit different updation logic\n            if (\n                InstanceChecker.isMongoEntityManager(this.queryRunner.manager)\n            ) {\n                const partialEntity = this.cloneMongoSubjectEntity(subject)\n                if (\n                    subject.metadata.objectIdColumn &&\n                    subject.metadata.objectIdColumn.propertyName\n                ) {\n                    delete partialEntity[\n                        subject.metadata.objectIdColumn.propertyName\n                    ]\n                }\n\n                if (\n                    subject.metadata.createDateColumn &&\n                    subject.metadata.createDateColumn.propertyName\n                ) {\n                    delete partialEntity[\n                        subject.metadata.createDateColumn.propertyName\n                    ]\n                }\n\n                if (\n                    subject.metadata.updateDateColumn &&\n                    subject.metadata.updateDateColumn.propertyName\n                ) {\n                    partialEntity[\n                        subject.metadata.updateDateColumn.propertyName\n                    ] = new Date()\n                }\n\n                const manager = this.queryRunner.manager as MongoEntityManager\n\n                await manager.update(\n                    subject.metadata.target,\n                    subject.identifier,\n                    partialEntity,\n                )\n            } else {\n                const updateMap: ObjectLiteral =\n                    subject.createValueSetAndPopChangeMap()\n\n                // for tree tables we execute additional queries\n                switch (subject.metadata.treeType) {\n                    case \"nested-set\":\n                        await new NestedSetSubjectExecutor(\n                            this.queryRunner,\n                        ).update(subject)\n                        break\n\n                    case \"closure-table\":\n                        await new ClosureSubjectExecutor(\n                            this.queryRunner,\n                        ).update(subject)\n                        break\n\n                    case \"materialized-path\":\n                        await new MaterializedPathSubjectExecutor(\n                            this.queryRunner,\n                        ).update(subject)\n                        break\n                }\n\n                // here we execute our updation query\n                // we need to enable entity updation because we update a subject identifier\n                // which is not same object as our entity that's why we don't need to worry about our entity to get dirty\n                // also, we disable listeners because we call them on our own in persistence layer\n                const updateQueryBuilder = this.queryRunner.manager\n                    .createQueryBuilder()\n                    .update(subject.metadata.target)\n                    .set(updateMap)\n                    .updateEntity(\n                        this.options && this.options.reload === false\n                            ? false\n                            : true,\n                    )\n                    .callListeners(false)\n\n                if (subject.entity) {\n                    updateQueryBuilder.whereEntity(subject.identifier)\n                } else {\n                    // in this case identifier is just conditions object to update by\n                    updateQueryBuilder.where(subject.identifier)\n                }\n\n                const updateResult = await updateQueryBuilder.execute()\n                let updateGeneratedMap = updateResult.generatedMaps[0]\n                if (updateGeneratedMap) {\n                    subject.metadata.columns.forEach((column) => {\n                        const value = column.getEntityValue(updateGeneratedMap!)\n                        if (value !== undefined && value !== null) {\n                            const preparedValue =\n                                this.queryRunner.connection.driver.prepareHydratedValue(\n                                    value,\n                                    column,\n                                )\n                            column.setEntityValue(\n                                updateGeneratedMap!,\n                                preparedValue,\n                            )\n                        }\n                    })\n                    if (!subject.generatedMap) {\n                        subject.generatedMap = {}\n                    }\n                    Object.assign(subject.generatedMap, updateGeneratedMap)\n                }\n            }\n        }\n\n        // Nested sets need to be updated one by one\n        // Split array in two, one with nested set subjects and the other with the remaining subjects\n        const nestedSetSubjects: Subject[] = []\n        const remainingSubjects: Subject[] = []\n\n        for (const subject of this.updateSubjects) {\n            if (subject.metadata.treeType === \"nested-set\") {\n                nestedSetSubjects.push(subject)\n            } else {\n                remainingSubjects.push(subject)\n            }\n        }\n\n        // Run nested set updates one by one\n        const nestedSetPromise = new Promise<void>(async (ok, fail) => {\n            for (const subject of nestedSetSubjects) {\n                try {\n                    await updateSubject(subject)\n                } catch (error) {\n                    fail(error)\n                }\n            }\n            ok()\n        })\n\n        // Run all remaining subjects in parallel\n        await Promise.all([\n            ...remainingSubjects.map(updateSubject),\n            nestedSetPromise,\n        ])\n    }\n\n    /**\n     * Removes all given subjects from the database.\n     *\n     * todo: we need to apply topological sort here as well\n     */\n    protected async executeRemoveOperations(): Promise<void> {\n        // group insertion subjects to make bulk insertions\n        const [groupedRemoveSubjects, groupedRemoveSubjectKeys] =\n            this.groupBulkSubjects(this.removeSubjects, \"delete\")\n\n        for (const groupName of groupedRemoveSubjectKeys) {\n            const subjects = groupedRemoveSubjects[groupName]\n            const deleteMaps = subjects.map((subject) => {\n                if (!subject.identifier)\n                    throw new SubjectWithoutIdentifierError(subject)\n\n                return subject.identifier\n            })\n\n            // for mongodb we have a bit different updation logic\n            if (\n                InstanceChecker.isMongoEntityManager(this.queryRunner.manager)\n            ) {\n                const manager = this.queryRunner.manager as MongoEntityManager\n                await manager.delete(subjects[0].metadata.target, deleteMaps)\n            } else {\n                // for tree tables we execute additional queries\n                switch (subjects[0].metadata.treeType) {\n                    case \"nested-set\":\n                        await new NestedSetSubjectExecutor(\n                            this.queryRunner,\n                        ).remove(subjects)\n                        break\n\n                    case \"closure-table\":\n                        await new ClosureSubjectExecutor(\n                            this.queryRunner,\n                        ).remove(subjects)\n                        break\n                }\n\n                // here we execute our deletion query\n                // we don't need to specify entities and set update entity to true since the only thing query builder\n                // will do for use is a primary keys deletion which is handled by us later once persistence is finished\n                // also, we disable listeners because we call them on our own in persistence layer\n                await this.queryRunner.manager\n                    .createQueryBuilder()\n                    .delete()\n                    .from(subjects[0].metadata.target)\n                    .where(deleteMaps)\n                    .callListeners(false)\n                    .execute()\n            }\n        }\n    }\n\n    private cloneMongoSubjectEntity(subject: Subject): ObjectLiteral {\n        const target: ObjectLiteral = {}\n\n        if (subject.entity) {\n            for (const column of subject.metadata.columns) {\n                OrmUtils.mergeDeep(\n                    target,\n                    column.getEntityValueMap(subject.entity),\n                )\n            }\n        }\n\n        return target\n    }\n\n    /**\n     * Soft-removes all given subjects in the database.\n     */\n    protected async executeSoftRemoveOperations(): Promise<void> {\n        await Promise.all(\n            this.softRemoveSubjects.map(async (subject) => {\n                if (!subject.identifier)\n                    throw new SubjectWithoutIdentifierError(subject)\n\n                let updateResult: UpdateResult\n\n                // for mongodb we have a bit different updation logic\n                if (\n                    InstanceChecker.isMongoEntityManager(\n                        this.queryRunner.manager,\n                    )\n                ) {\n                    const partialEntity = this.cloneMongoSubjectEntity(subject)\n                    if (\n                        subject.metadata.objectIdColumn &&\n                        subject.metadata.objectIdColumn.propertyName\n                    ) {\n                        delete partialEntity[\n                            subject.metadata.objectIdColumn.propertyName\n                        ]\n                    }\n\n                    if (\n                        subject.metadata.createDateColumn &&\n                        subject.metadata.createDateColumn.propertyName\n                    ) {\n                        delete partialEntity[\n                            subject.metadata.createDateColumn.propertyName\n                        ]\n                    }\n\n                    if (\n                        subject.metadata.updateDateColumn &&\n                        subject.metadata.updateDateColumn.propertyName\n                    ) {\n                        partialEntity[\n                            subject.metadata.updateDateColumn.propertyName\n                        ] = new Date()\n                    }\n\n                    if (\n                        subject.metadata.deleteDateColumn &&\n                        subject.metadata.deleteDateColumn.propertyName\n                    ) {\n                        partialEntity[\n                            subject.metadata.deleteDateColumn.propertyName\n                        ] = new Date()\n                    }\n\n                    const manager = this.queryRunner\n                        .manager as MongoEntityManager\n\n                    updateResult = await manager.update(\n                        subject.metadata.target,\n                        subject.identifier,\n                        partialEntity,\n                    )\n                } else {\n                    // here we execute our soft-deletion query\n                    // we need to enable entity soft-deletion because we update a subject identifier\n                    // which is not same object as our entity that's why we don't need to worry about our entity to get dirty\n                    // also, we disable listeners because we call them on our own in persistence layer\n                    const softDeleteQueryBuilder = this.queryRunner.manager\n                        .createQueryBuilder()\n                        .softDelete()\n                        .from(subject.metadata.target)\n                        .updateEntity(\n                            this.options && this.options.reload === false\n                                ? false\n                                : true,\n                        )\n                        .callListeners(false)\n\n                    if (subject.entity) {\n                        softDeleteQueryBuilder.whereEntity(subject.identifier)\n                    } else {\n                        // in this case identifier is just conditions object to update by\n                        softDeleteQueryBuilder.where(subject.identifier)\n                    }\n\n                    updateResult = await softDeleteQueryBuilder.execute()\n                }\n\n                subject.generatedMap = updateResult.generatedMaps[0]\n                if (subject.generatedMap) {\n                    subject.metadata.columns.forEach((column) => {\n                        const value = column.getEntityValue(\n                            subject.generatedMap!,\n                        )\n                        if (value !== undefined && value !== null) {\n                            const preparedValue =\n                                this.queryRunner.connection.driver.prepareHydratedValue(\n                                    value,\n                                    column,\n                                )\n                            column.setEntityValue(\n                                subject.generatedMap!,\n                                preparedValue,\n                            )\n                        }\n                    })\n                }\n\n                // experiments, remove probably, need to implement tree tables children removal\n                // if (subject.updatedRelationMaps.length > 0) {\n                //     await Promise.all(subject.updatedRelationMaps.map(async updatedRelation => {\n                //         if (!updatedRelation.relation.isTreeParent) return;\n                //         if (!updatedRelation.value !== null) return;\n                //\n                //         if (subject.metadata.treeType === \"closure-table\") {\n                //             await new ClosureSubjectExecutor(this.queryRunner).deleteChildrenOf(subject);\n                //         }\n                //     }));\n                // }\n            }),\n        )\n    }\n\n    /**\n     * Recovers all given subjects in the database.\n     */\n    protected async executeRecoverOperations(): Promise<void> {\n        await Promise.all(\n            this.recoverSubjects.map(async (subject) => {\n                if (!subject.identifier)\n                    throw new SubjectWithoutIdentifierError(subject)\n\n                let updateResult: UpdateResult\n\n                // for mongodb we have a bit different updation logic\n                if (\n                    InstanceChecker.isMongoEntityManager(\n                        this.queryRunner.manager,\n                    )\n                ) {\n                    const partialEntity = this.cloneMongoSubjectEntity(subject)\n                    if (\n                        subject.metadata.objectIdColumn &&\n                        subject.metadata.objectIdColumn.propertyName\n                    ) {\n                        delete partialEntity[\n                            subject.metadata.objectIdColumn.propertyName\n                        ]\n                    }\n\n                    if (\n                        subject.metadata.createDateColumn &&\n                        subject.metadata.createDateColumn.propertyName\n                    ) {\n                        delete partialEntity[\n                            subject.metadata.createDateColumn.propertyName\n                        ]\n                    }\n\n                    if (\n                        subject.metadata.updateDateColumn &&\n                        subject.metadata.updateDateColumn.propertyName\n                    ) {\n                        partialEntity[\n                            subject.metadata.updateDateColumn.propertyName\n                        ] = new Date()\n                    }\n\n                    if (\n                        subject.metadata.deleteDateColumn &&\n                        subject.metadata.deleteDateColumn.propertyName\n                    ) {\n                        partialEntity[\n                            subject.metadata.deleteDateColumn.propertyName\n                        ] = null\n                    }\n\n                    const manager = this.queryRunner\n                        .manager as MongoEntityManager\n\n                    updateResult = await manager.update(\n                        subject.metadata.target,\n                        subject.identifier,\n                        partialEntity,\n                    )\n                } else {\n                    // here we execute our restory query\n                    // we need to enable entity restory because we update a subject identifier\n                    // which is not same object as our entity that's why we don't need to worry about our entity to get dirty\n                    // also, we disable listeners because we call them on our own in persistence layer\n                    const softDeleteQueryBuilder = this.queryRunner.manager\n                        .createQueryBuilder()\n                        .restore()\n                        .from(subject.metadata.target)\n                        .updateEntity(\n                            this.options && this.options.reload === false\n                                ? false\n                                : true,\n                        )\n                        .callListeners(false)\n\n                    if (subject.entity) {\n                        softDeleteQueryBuilder.whereEntity(subject.identifier)\n                    } else {\n                        // in this case identifier is just conditions object to update by\n                        softDeleteQueryBuilder.where(subject.identifier)\n                    }\n\n                    updateResult = await softDeleteQueryBuilder.execute()\n                }\n\n                subject.generatedMap = updateResult.generatedMaps[0]\n                if (subject.generatedMap) {\n                    subject.metadata.columns.forEach((column) => {\n                        const value = column.getEntityValue(\n                            subject.generatedMap!,\n                        )\n                        if (value !== undefined && value !== null) {\n                            const preparedValue =\n                                this.queryRunner.connection.driver.prepareHydratedValue(\n                                    value,\n                                    column,\n                                )\n                            column.setEntityValue(\n                                subject.generatedMap!,\n                                preparedValue,\n                            )\n                        }\n                    })\n                }\n\n                // experiments, remove probably, need to implement tree tables children removal\n                // if (subject.updatedRelationMaps.length > 0) {\n                //     await Promise.all(subject.updatedRelationMaps.map(async updatedRelation => {\n                //         if (!updatedRelation.relation.isTreeParent) return;\n                //         if (!updatedRelation.value !== null) return;\n                //\n                //         if (subject.metadata.treeType === \"closure-table\") {\n                //             await new ClosureSubjectExecutor(this.queryRunner).deleteChildrenOf(subject);\n                //         }\n                //     }));\n                // }\n            }),\n        )\n    }\n\n    /**\n     * Updates all special columns of the saving entities (create date, update date, version, etc.).\n     * Also updates nullable columns and columns with default values.\n     */\n    protected updateSpecialColumnsInPersistedEntities(): void {\n        // update inserted entity properties\n        if (this.insertSubjects.length)\n            this.updateSpecialColumnsInInsertedAndUpdatedEntities(\n                this.insertSubjects,\n            )\n\n        // update updated entity properties\n        if (this.updateSubjects.length)\n            this.updateSpecialColumnsInInsertedAndUpdatedEntities(\n                this.updateSubjects,\n            )\n\n        // update soft-removed entity properties\n        if (this.softRemoveSubjects.length)\n            this.updateSpecialColumnsInInsertedAndUpdatedEntities(\n                this.softRemoveSubjects,\n            )\n\n        // update recovered entity properties\n        if (this.recoverSubjects.length)\n            this.updateSpecialColumnsInInsertedAndUpdatedEntities(\n                this.recoverSubjects,\n            )\n\n        // remove ids from the entities that were removed\n        if (this.removeSubjects.length) {\n            this.removeSubjects.forEach((subject) => {\n                if (!subject.entity) return\n\n                subject.metadata.primaryColumns.forEach((primaryColumn) => {\n                    primaryColumn.setEntityValue(subject.entity!, undefined)\n                })\n            })\n        }\n\n        // other post-persist updations\n        this.allSubjects.forEach((subject) => {\n            if (!subject.entity) return\n\n            subject.metadata.relationIds.forEach((relationId) => {\n                relationId.setValue(subject.entity!)\n            })\n\n            // mongo _id remove\n            if (\n                InstanceChecker.isMongoEntityManager(this.queryRunner.manager)\n            ) {\n                if (\n                    subject.metadata.objectIdColumn &&\n                    subject.metadata.objectIdColumn.databaseName &&\n                    subject.metadata.objectIdColumn.databaseName !==\n                        subject.metadata.objectIdColumn.propertyName\n                ) {\n                    delete subject.entity[\n                        subject.metadata.objectIdColumn.databaseName\n                    ]\n                }\n            }\n        })\n    }\n\n    /**\n     * Updates all special columns of the saving entities (create date, update date, version, etc.).\n     * Also updates nullable columns and columns with default values.\n     */\n    protected updateSpecialColumnsInInsertedAndUpdatedEntities(\n        subjects: Subject[],\n    ): void {\n        subjects.forEach((subject) => {\n            if (!subject.entity) return\n\n            // set values to \"null\" for nullable columns that did not have values\n            subject.metadata.columns.forEach((column) => {\n                // if table inheritance is used make sure this column is not child's column\n                if (\n                    subject.metadata.childEntityMetadatas.length > 0 &&\n                    subject.metadata.childEntityMetadatas\n                        .map((metadata) => metadata.target)\n                        .indexOf(column.target) !== -1\n                )\n                    return\n\n                // entities does not have virtual columns\n                if (column.isVirtual) return\n\n                // update nullable columns\n                if (column.isNullable) {\n                    const columnValue = column.getEntityValue(subject.entity!)\n                    if (columnValue === undefined)\n                        column.setEntityValue(subject.entity!, null)\n                }\n\n                // update relational columns\n                if (subject.updatedRelationMaps.length > 0) {\n                    subject.updatedRelationMaps.forEach(\n                        (updatedRelationMap) => {\n                            updatedRelationMap.relation.joinColumns.forEach(\n                                (column) => {\n                                    if (column.isVirtual === true) return\n\n                                    column.setEntityValue(\n                                        subject.entity!,\n                                        ObjectUtils.isObject(\n                                            updatedRelationMap.value,\n                                        )\n                                            ? column.referencedColumn!.getEntityValue(\n                                                  updatedRelationMap.value,\n                                              )\n                                            : updatedRelationMap.value,\n                                    )\n                                },\n                            )\n                        },\n                    )\n                }\n            })\n\n            // merge into entity all generated values returned by a database\n            if (subject.generatedMap)\n                this.queryRunner.manager.merge(\n                    subject.metadata.target as any,\n                    subject.entity,\n                    subject.generatedMap,\n                )\n        })\n    }\n\n    /**\n     * Groups subjects by metadata names (by tables) to make bulk insertions and deletions possible.\n     * However there are some limitations with bulk insertions of data into tables with generated (increment) columns\n     * in some drivers. Some drivers like mysql and sqlite does not support returning multiple generated columns\n     * after insertion and can only return a single generated column value, that's why its not possible to do bulk insertion,\n     * because it breaks insertion result's generatedMap and leads to problems when this subject is used in other subjects saves.\n     * That's why we only support bulking in junction tables for those drivers.\n     *\n     * Other drivers like postgres and sql server support RETURNING / OUTPUT statement which allows to return generated\n     * id for each inserted row, that's why bulk insertion is not limited to junction tables in there.\n     */\n    protected groupBulkSubjects(\n        subjects: Subject[],\n        type: \"insert\" | \"delete\",\n    ): [{ [key: string]: Subject[] }, string[]] {\n        const group: { [key: string]: Subject[] } = {}\n        const keys: string[] = []\n        const hasReturningDependColumns = subjects.some((subject) => {\n            return subject.metadata.getInsertionReturningColumns().length > 0\n        })\n        const groupingAllowed =\n            type === \"delete\" ||\n            this.queryRunner.connection.driver.isReturningSqlSupported(\n                \"insert\",\n            ) ||\n            hasReturningDependColumns === false\n\n        subjects.forEach((subject, index) => {\n            const key =\n                groupingAllowed || subject.metadata.isJunction\n                    ? subject.metadata.name\n                    : subject.metadata.name + \"_\" + index\n            if (!group[key]) {\n                group[key] = [subject]\n                keys.push(key)\n            } else {\n                group[key].push(subject)\n            }\n        })\n\n        return [group, keys]\n    }\n}\n"]},"metadata":{},"sourceType":"module"}