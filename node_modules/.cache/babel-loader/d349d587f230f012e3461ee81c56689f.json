{"ast":null,"code":"import { Subject } from \"../Subject\";\nimport { ObjectUtils } from \"../../util/ObjectUtils\";\n/**\n * Finds all cascade operations of the given subject and cascade operations of the found cascaded subjects,\n * e.g. builds a cascade tree and creates a subjects for them.\n */\n\nexport class CascadesSubjectBuilder {\n  // ---------------------------------------------------------------------\n  // Constructor\n  // ---------------------------------------------------------------------\n  constructor(allSubjects) {\n    this.allSubjects = allSubjects;\n  } // ---------------------------------------------------------------------\n  // Public Methods\n  // ---------------------------------------------------------------------\n\n  /**\n   * Builds a cascade subjects tree and pushes them in into the given array of subjects.\n   */\n\n\n  build(subject, operationType) {\n    subject.metadata.extractRelationValuesFromEntity(subject.entity, subject.metadata.relations) // todo: we can create EntityMetadata.cascadeRelations\n    .forEach(_ref => {\n      let [relation, relationEntity, relationEntityMetadata] = _ref;\n      // we need only defined values and insert, update, soft-remove or recover cascades of the relation should be set\n      if (relationEntity === undefined || relationEntity === null || !relation.isCascadeInsert && !relation.isCascadeUpdate && !relation.isCascadeSoftRemove && !relation.isCascadeRecover) return; // if relation entity is just a relation id set (for example post.tag = 1)\n      // then we don't really need to check cascades since there is no object to insert or update\n\n      if (!ObjectUtils.isObject(relationEntity)) return; // if we already has this entity in list of operated subjects then skip it to avoid recursion\n\n      const alreadyExistRelationEntitySubject = this.findByPersistEntityLike(relationEntityMetadata.target, relationEntity);\n\n      if (alreadyExistRelationEntitySubject) {\n        if (alreadyExistRelationEntitySubject.canBeInserted === false) // if its not marked for insertion yet\n          alreadyExistRelationEntitySubject.canBeInserted = relation.isCascadeInsert === true && operationType === \"save\";\n        if (alreadyExistRelationEntitySubject.canBeUpdated === false) // if its not marked for update yet\n          alreadyExistRelationEntitySubject.canBeUpdated = relation.isCascadeUpdate === true && operationType === \"save\";\n        if (alreadyExistRelationEntitySubject.canBeSoftRemoved === false) // if its not marked for removal yet\n          alreadyExistRelationEntitySubject.canBeSoftRemoved = relation.isCascadeSoftRemove === true && operationType === \"soft-remove\";\n        if (alreadyExistRelationEntitySubject.canBeRecovered === false) // if its not marked for recovery yet\n          alreadyExistRelationEntitySubject.canBeRecovered = relation.isCascadeRecover === true && operationType === \"recover\";\n        return;\n      } // mark subject with what we can do with it\n      // and add to the array of subjects to load only if there is no same entity there already\n\n\n      const relationEntitySubject = new Subject({\n        metadata: relationEntityMetadata,\n        parentSubject: subject,\n        entity: relationEntity,\n        canBeInserted: relation.isCascadeInsert === true && operationType === \"save\",\n        canBeUpdated: relation.isCascadeUpdate === true && operationType === \"save\",\n        canBeSoftRemoved: relation.isCascadeSoftRemove === true && operationType === \"soft-remove\",\n        canBeRecovered: relation.isCascadeRecover === true && operationType === \"recover\"\n      });\n      this.allSubjects.push(relationEntitySubject); // go recursively and find other entities we need to insert/update\n\n      this.build(relationEntitySubject, operationType);\n    });\n  } // ---------------------------------------------------------------------\n  // Protected Methods\n  // ---------------------------------------------------------------------\n\n  /**\n   * Finds subject where entity like given subject's entity.\n   * Comparison made by entity id.\n   */\n\n\n  findByPersistEntityLike(entityTarget, entity) {\n    return this.allSubjects.find(subject => {\n      if (!subject.entity) return false;\n      if (subject.entity === entity) return true;\n      return subject.metadata.target === entityTarget && subject.metadata.compareEntities(subject.entityWithFulfilledIds, entity);\n    });\n  }\n\n}","map":{"version":3,"mappings":"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","names":["Subject","ObjectUtils","CascadesSubjectBuilder","constructor","allSubjects","build","subject","operationType","metadata","extractRelationValuesFromEntity","entity","relations","forEach","relation","relationEntity","relationEntityMetadata","undefined","isCascadeInsert","isCascadeUpdate","isCascadeSoftRemove","isCascadeRecover","isObject","alreadyExistRelationEntitySubject","findByPersistEntityLike","target","canBeInserted","canBeUpdated","canBeSoftRemoved","canBeRecovered","relationEntitySubject","parentSubject","push","entityTarget","find","compareEntities","entityWithFulfilledIds"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\persistence\\subject-builder\\CascadesSubjectBuilder.ts"],"sourcesContent":["import { Subject } from \"../Subject\"\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { ObjectUtils } from \"../../util/ObjectUtils\"\n\n/**\n * Finds all cascade operations of the given subject and cascade operations of the found cascaded subjects,\n * e.g. builds a cascade tree and creates a subjects for them.\n */\nexport class CascadesSubjectBuilder {\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(protected allSubjects: Subject[]) {}\n\n    // ---------------------------------------------------------------------\n    // Public Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Builds a cascade subjects tree and pushes them in into the given array of subjects.\n     */\n    build(\n        subject: Subject,\n        operationType: \"save\" | \"remove\" | \"soft-remove\" | \"recover\",\n    ) {\n        subject.metadata\n            .extractRelationValuesFromEntity(\n                subject.entity!,\n                subject.metadata.relations,\n            ) // todo: we can create EntityMetadata.cascadeRelations\n            .forEach(([relation, relationEntity, relationEntityMetadata]) => {\n                // we need only defined values and insert, update, soft-remove or recover cascades of the relation should be set\n                if (\n                    relationEntity === undefined ||\n                    relationEntity === null ||\n                    (!relation.isCascadeInsert &&\n                        !relation.isCascadeUpdate &&\n                        !relation.isCascadeSoftRemove &&\n                        !relation.isCascadeRecover)\n                )\n                    return\n\n                // if relation entity is just a relation id set (for example post.tag = 1)\n                // then we don't really need to check cascades since there is no object to insert or update\n                if (!ObjectUtils.isObject(relationEntity)) return\n\n                // if we already has this entity in list of operated subjects then skip it to avoid recursion\n                const alreadyExistRelationEntitySubject =\n                    this.findByPersistEntityLike(\n                        relationEntityMetadata.target,\n                        relationEntity,\n                    )\n                if (alreadyExistRelationEntitySubject) {\n                    if (\n                        alreadyExistRelationEntitySubject.canBeInserted ===\n                        false\n                    )\n                        // if its not marked for insertion yet\n                        alreadyExistRelationEntitySubject.canBeInserted =\n                            relation.isCascadeInsert === true &&\n                            operationType === \"save\"\n                    if (\n                        alreadyExistRelationEntitySubject.canBeUpdated === false\n                    )\n                        // if its not marked for update yet\n                        alreadyExistRelationEntitySubject.canBeUpdated =\n                            relation.isCascadeUpdate === true &&\n                            operationType === \"save\"\n                    if (\n                        alreadyExistRelationEntitySubject.canBeSoftRemoved ===\n                        false\n                    )\n                        // if its not marked for removal yet\n                        alreadyExistRelationEntitySubject.canBeSoftRemoved =\n                            relation.isCascadeSoftRemove === true &&\n                            operationType === \"soft-remove\"\n                    if (\n                        alreadyExistRelationEntitySubject.canBeRecovered ===\n                        false\n                    )\n                        // if its not marked for recovery yet\n                        alreadyExistRelationEntitySubject.canBeRecovered =\n                            relation.isCascadeRecover === true &&\n                            operationType === \"recover\"\n                    return\n                }\n\n                // mark subject with what we can do with it\n                // and add to the array of subjects to load only if there is no same entity there already\n                const relationEntitySubject = new Subject({\n                    metadata: relationEntityMetadata,\n                    parentSubject: subject,\n                    entity: relationEntity,\n                    canBeInserted:\n                        relation.isCascadeInsert === true &&\n                        operationType === \"save\",\n                    canBeUpdated:\n                        relation.isCascadeUpdate === true &&\n                        operationType === \"save\",\n                    canBeSoftRemoved:\n                        relation.isCascadeSoftRemove === true &&\n                        operationType === \"soft-remove\",\n                    canBeRecovered:\n                        relation.isCascadeRecover === true &&\n                        operationType === \"recover\",\n                })\n                this.allSubjects.push(relationEntitySubject)\n\n                // go recursively and find other entities we need to insert/update\n                this.build(relationEntitySubject, operationType)\n            })\n    }\n\n    // ---------------------------------------------------------------------\n    // Protected Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Finds subject where entity like given subject's entity.\n     * Comparison made by entity id.\n     */\n    protected findByPersistEntityLike(\n        entityTarget: Function | string,\n        entity: ObjectLiteral,\n    ): Subject | undefined {\n        return this.allSubjects.find((subject) => {\n            if (!subject.entity) return false\n\n            if (subject.entity === entity) return true\n\n            return (\n                subject.metadata.target === entityTarget &&\n                subject.metadata.compareEntities(\n                    subject.entityWithFulfilledIds!,\n                    entity,\n                )\n            )\n        })\n    }\n}\n"]},"metadata":{},"sourceType":"module"}