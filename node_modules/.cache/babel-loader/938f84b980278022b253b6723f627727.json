{"ast":null,"code":"import { QueryFailedError } from \"../../error/QueryFailedError\";\nimport { QueryRunnerAlreadyReleasedError } from \"../../error/QueryRunnerAlreadyReleasedError\";\nimport { TransactionNotStartedError } from \"../../error/TransactionNotStartedError\";\nimport { BaseQueryRunner } from \"../../query-runner/BaseQueryRunner\";\nimport { Table } from \"../../schema-builder/table/Table\";\nimport { TableCheck } from \"../../schema-builder/table/TableCheck\";\nimport { TableColumn } from \"../../schema-builder/table/TableColumn\";\nimport { TableForeignKey } from \"../../schema-builder/table/TableForeignKey\";\nimport { TableIndex } from \"../../schema-builder/table/TableIndex\";\nimport { TableUnique } from \"../../schema-builder/table/TableUnique\";\nimport { View } from \"../../schema-builder/view/View\";\nimport { Broadcaster } from \"../../subscriber/Broadcaster\";\nimport { OrmUtils } from \"../../util/OrmUtils\";\nimport { Query } from \"../Query\";\nimport { TypeORMError } from \"../../error\";\nimport { QueryResult } from \"../../query-runner/QueryResult\";\nimport { MetadataTableType } from \"../types/MetadataTableType\";\n/**\n * Runs queries on a single postgres database connection.\n */\n\nexport class SpannerQueryRunner extends BaseQueryRunner {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(driver, mode) {\n    super();\n    this.driver = driver;\n    this.connection = driver.connection;\n    this.mode = mode;\n    this.broadcaster = new Broadcaster(this);\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Creates/uses database connection from the connection pool to perform further operations.\n   * Returns obtained database connection.\n   */\n\n\n  async connect() {\n    if (this.session) {\n      return Promise.resolve(this.session);\n    }\n\n    const [session] = await this.driver.instanceDatabase.createSession({});\n    this.session = session;\n    this.sessionTransaction = await session.transaction();\n    return this.session;\n  }\n  /**\n   * Releases used database connection.\n   * You cannot use query runner methods once its released.\n   */\n\n\n  async release() {\n    this.isReleased = true;\n\n    if (this.session) {\n      await this.session.delete();\n    }\n\n    this.session = undefined;\n    return Promise.resolve();\n  }\n  /**\n   * Starts transaction.\n   */\n\n\n  async startTransaction(isolationLevel) {\n    this.isTransactionActive = true;\n\n    try {\n      await this.broadcaster.broadcast(\"BeforeTransactionStart\");\n    } catch (err) {\n      this.isTransactionActive = false;\n      throw err;\n    }\n\n    await this.connect();\n    await this.sessionTransaction.begin();\n    this.connection.logger.logQuery(\"START TRANSACTION\");\n    await this.broadcaster.broadcast(\"AfterTransactionStart\");\n  }\n  /**\n   * Commits transaction.\n   * Error will be thrown if transaction was not started.\n   */\n\n\n  async commitTransaction() {\n    if (!this.isTransactionActive || !this.sessionTransaction) throw new TransactionNotStartedError();\n    await this.broadcaster.broadcast(\"BeforeTransactionCommit\");\n    await this.sessionTransaction.commit();\n    this.connection.logger.logQuery(\"COMMIT\");\n    this.isTransactionActive = false;\n    await this.broadcaster.broadcast(\"AfterTransactionCommit\");\n  }\n  /**\n   * Rollbacks transaction.\n   * Error will be thrown if transaction was not started.\n   */\n\n\n  async rollbackTransaction() {\n    if (!this.isTransactionActive || !this.sessionTransaction) throw new TransactionNotStartedError();\n    await this.broadcaster.broadcast(\"BeforeTransactionRollback\");\n    await this.sessionTransaction.rollback();\n    this.connection.logger.logQuery(\"ROLLBACK\");\n    this.isTransactionActive = false;\n    await this.broadcaster.broadcast(\"AfterTransactionRollback\");\n  }\n  /**\n   * Executes a given SQL query.\n   */\n\n\n  async query(query, parameters) {\n    let useStructuredResult = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (this.isReleased) throw new QueryRunnerAlreadyReleasedError();\n\n    try {\n      const queryStartTime = +new Date();\n      await this.connect();\n      let rawResult = undefined;\n      const isSelect = query.startsWith(\"SELECT\");\n      const executor = isSelect && !this.isTransactionActive ? this.driver.instanceDatabase : this.sessionTransaction;\n\n      if (!this.isTransactionActive && !isSelect) {\n        await this.sessionTransaction.begin();\n      }\n\n      try {\n        this.driver.connection.logger.logQuery(query, parameters, this);\n        rawResult = await executor.run({\n          sql: query,\n          params: parameters ? parameters.reduce((params, value, index) => {\n            params[\"param\" + index] = value;\n            return params;\n          }, {}) : undefined,\n          json: true\n        });\n\n        if (!this.isTransactionActive && !isSelect) {\n          await this.sessionTransaction.commit();\n        }\n      } catch (error) {\n        try {\n          // we throw original error even if rollback thrown an error\n          if (!this.isTransactionActive && !isSelect) await this.sessionTransaction.rollback();\n        } catch (rollbackError) {}\n\n        throw error;\n      } // log slow queries if maxQueryExecution time is set\n\n\n      const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;\n      const queryEndTime = +new Date();\n      const queryExecutionTime = queryEndTime - queryStartTime;\n      if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);\n      const result = new QueryResult();\n      result.raw = rawResult;\n      result.records = rawResult ? rawResult[0] : [];\n\n      if (rawResult && rawResult[1] && rawResult[1].rowCountExact) {\n        result.affected = parseInt(rawResult[1].rowCountExact);\n      }\n\n      if (!useStructuredResult) {\n        return result.records;\n      }\n\n      return result;\n    } catch (err) {\n      this.driver.connection.logger.logQueryError(err, query, parameters, this);\n      throw new QueryFailedError(query, parameters, err);\n    } finally {}\n  }\n  /**\n   * Update database schema.\n   * Used for creating/altering/dropping tables, columns, indexes, etc.\n   *\n   * DDL changing queries should be executed by `updateSchema()` method.\n   */\n\n\n  async updateDDL(query, parameters) {\n    if (this.isReleased) throw new QueryRunnerAlreadyReleasedError();\n    this.driver.connection.logger.logQuery(query, parameters, this);\n\n    try {\n      const queryStartTime = +new Date();\n      const [operation] = await this.driver.instanceDatabase.updateSchema(query);\n      await operation.promise(); // log slow queries if maxQueryExecution time is set\n\n      const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;\n      const queryEndTime = +new Date();\n      const queryExecutionTime = queryEndTime - queryStartTime;\n      if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);\n    } catch (err) {\n      this.driver.connection.logger.logQueryError(err, query, parameters, this);\n      throw new QueryFailedError(query, parameters, err);\n    }\n  }\n  /**\n   * Returns raw data stream.\n   */\n\n\n  async stream(query, parameters, onEnd, onError) {\n    if (this.isReleased) throw new QueryRunnerAlreadyReleasedError();\n\n    try {\n      this.driver.connection.logger.logQuery(query, parameters, this);\n      const request = {\n        sql: query,\n        params: parameters ? parameters.reduce((params, value, index) => {\n          params[\"param\" + index] = value;\n          return params;\n        }, {}) : undefined,\n        json: true\n      };\n      const stream = this.driver.instanceDatabase.runStream(request);\n\n      if (onEnd) {\n        stream.on(\"end\", onEnd);\n      }\n\n      if (onError) {\n        stream.on(\"error\", onError);\n      }\n\n      return stream;\n    } catch (err) {\n      this.driver.connection.logger.logQueryError(err, query, parameters, this);\n      throw new QueryFailedError(query, parameters, err);\n    }\n  }\n  /**\n   * Returns all available database names including system databases.\n   */\n\n\n  async getDatabases() {\n    return Promise.resolve([]);\n  }\n  /**\n   * Returns all available schema names including system schemas.\n   * If database parameter specified, returns schemas of that database.\n   */\n\n\n  async getSchemas(database) {\n    return Promise.resolve([]);\n  }\n  /**\n   * Checks if database with the given name exist.\n   */\n\n\n  async hasDatabase(database) {\n    throw new TypeORMError(`Check database queries are not supported by Spanner driver.`);\n  }\n  /**\n   * Loads currently using database\n   */\n\n\n  async getCurrentDatabase() {\n    throw new TypeORMError(`Check database queries are not supported by Spanner driver.`);\n  }\n  /**\n   * Checks if schema with the given name exist.\n   */\n\n\n  async hasSchema(schema) {\n    const result = await this.query(`SELECT * FROM \"information_schema\".\"schemata\" WHERE \"schema_name\" = '${schema}'`);\n    return result.length ? true : false;\n  }\n  /**\n   * Loads currently using database schema\n   */\n\n\n  async getCurrentSchema() {\n    throw new TypeORMError(`Check schema queries are not supported by Spanner driver.`);\n  }\n  /**\n   * Checks if table with the given name exist in the database.\n   */\n\n\n  async hasTable(tableOrName) {\n    const tableName = tableOrName instanceof Table ? tableOrName.name : tableOrName;\n    const sql = `SELECT * FROM \\`INFORMATION_SCHEMA\\`.\\`TABLES\\` ` + `WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' AND \\`TABLE_TYPE\\` = 'BASE TABLE' ` + `AND \\`TABLE_NAME\\` = '${tableName}'`;\n    const result = await this.query(sql);\n    return result.length ? true : false;\n  }\n  /**\n   * Checks if column with the given name exist in the given table.\n   */\n\n\n  async hasColumn(tableOrName, columnName) {\n    const tableName = tableOrName instanceof Table ? tableOrName.name : tableOrName;\n    const sql = `SELECT * FROM \\`INFORMATION_SCHEMA\\`.\\`COLUMNS\\` ` + `WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' ` + `AND \\`TABLE_NAME\\` = '${tableName}' AND \\`COLUMN_NAME\\` = '${columnName}'`;\n    const result = await this.query(sql);\n    return result.length ? true : false;\n  }\n  /**\n   * Creates a new database.\n   * Note: Spanner does not support database creation inside a transaction block.\n   */\n\n\n  async createDatabase(database, ifNotExist) {\n    if (ifNotExist) {\n      const databaseAlreadyExists = await this.hasDatabase(database);\n      if (databaseAlreadyExists) return Promise.resolve();\n    }\n\n    const up = `CREATE DATABASE \"${database}\"`;\n    const down = `DROP DATABASE \"${database}\"`;\n    await this.executeQueries(new Query(up), new Query(down));\n  }\n  /**\n   * Drops database.\n   * Note: Spanner does not support database dropping inside a transaction block.\n   */\n\n\n  async dropDatabase(database, ifExist) {\n    const up = ifExist ? `DROP DATABASE IF EXISTS \"${database}\"` : `DROP DATABASE \"${database}\"`;\n    const down = `CREATE DATABASE \"${database}\"`;\n    await this.executeQueries(new Query(up), new Query(down));\n  }\n  /**\n   * Creates a new table schema.\n   */\n\n\n  async createSchema(schemaPath, ifNotExist) {\n    return Promise.resolve();\n  }\n  /**\n   * Drops table schema.\n   */\n\n\n  async dropSchema(schemaPath, ifExist, isCascade) {\n    return Promise.resolve();\n  }\n  /**\n   * Creates a new table.\n   */\n\n\n  async createTable(table) {\n    let ifNotExist = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let createForeignKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let createIndices = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n    if (ifNotExist) {\n      const isTableExist = await this.hasTable(table);\n      if (isTableExist) return Promise.resolve();\n    }\n\n    const upQueries = [];\n    const downQueries = [];\n    upQueries.push(this.createTableSql(table, createForeignKeys));\n    downQueries.push(this.dropTableSql(table)); // if createForeignKeys is true, we must drop created foreign keys in down query.\n    // createTable does not need separate method to create foreign keys, because it create fk's in the same query with table creation.\n\n    if (createForeignKeys) table.foreignKeys.forEach(foreignKey => downQueries.push(this.dropForeignKeySql(table, foreignKey)));\n\n    if (createIndices) {\n      table.indices.forEach(index => {\n        // new index may be passed without name. In this case we generate index name manually.\n        if (!index.name) index.name = this.connection.namingStrategy.indexName(table, index.columnNames, index.where);\n        upQueries.push(this.createIndexSql(table, index));\n        downQueries.push(this.dropIndexSql(table, index));\n      });\n    } // if table has column with generated type, we must add the expression to the metadata table\n\n\n    const generatedColumns = table.columns.filter(column => column.generatedType && column.asExpression);\n\n    for (const column of generatedColumns) {\n      const insertQuery = this.insertTypeormMetadataSql({\n        table: table.name,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name,\n        value: column.asExpression\n      });\n      const deleteQuery = this.deleteTypeormMetadataSql({\n        table: table.name,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name\n      });\n      upQueries.push(insertQuery);\n      downQueries.push(deleteQuery);\n    }\n\n    await this.executeQueries(upQueries, downQueries);\n  }\n  /**\n   * Drops the table.\n   */\n\n\n  async dropTable(target, ifExist) {\n    let dropForeignKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let dropIndices = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n    // It needs because if table does not exist and dropForeignKeys or dropIndices is true, we don't need\n    // to perform drop queries for foreign keys and indices.\n    if (ifExist) {\n      const isTableExist = await this.hasTable(target);\n      if (!isTableExist) return Promise.resolve();\n    } // if dropTable called with dropForeignKeys = true, we must create foreign keys in down query.\n\n\n    const createForeignKeys = dropForeignKeys;\n    const tablePath = this.getTablePath(target);\n    const table = await this.getCachedTable(tablePath);\n    const upQueries = [];\n    const downQueries = [];\n\n    if (dropIndices) {\n      table.indices.forEach(index => {\n        upQueries.push(this.dropIndexSql(table, index));\n        downQueries.push(this.createIndexSql(table, index));\n      });\n    }\n\n    if (dropForeignKeys) table.foreignKeys.forEach(foreignKey => upQueries.push(this.dropForeignKeySql(table, foreignKey)));\n    upQueries.push(this.dropTableSql(table));\n    downQueries.push(this.createTableSql(table, createForeignKeys)); // if table had columns with generated type, we must remove the expression from the metadata table\n\n    const generatedColumns = table.columns.filter(column => column.generatedType && column.asExpression);\n\n    for (const column of generatedColumns) {\n      const deleteQuery = this.deleteTypeormMetadataSql({\n        table: table.name,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name\n      });\n      const insertQuery = this.insertTypeormMetadataSql({\n        table: table.name,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name,\n        value: column.asExpression\n      });\n      upQueries.push(deleteQuery);\n      downQueries.push(insertQuery);\n    }\n\n    await this.executeQueries(upQueries, downQueries);\n  }\n  /**\n   * Creates a new view.\n   */\n\n\n  async createView(view) {\n    const upQueries = [];\n    const downQueries = [];\n    upQueries.push(this.createViewSql(view));\n    upQueries.push(await this.insertViewDefinitionSql(view));\n    downQueries.push(this.dropViewSql(view));\n    downQueries.push(await this.deleteViewDefinitionSql(view));\n    await this.executeQueries(upQueries, downQueries);\n  }\n  /**\n   * Drops the view.\n   */\n\n\n  async dropView(target) {\n    const viewName = target instanceof View ? target.name : target;\n    const view = await this.getCachedView(viewName);\n    const upQueries = [];\n    const downQueries = [];\n    upQueries.push(await this.deleteViewDefinitionSql(view));\n    upQueries.push(this.dropViewSql(view));\n    downQueries.push(await this.insertViewDefinitionSql(view));\n    downQueries.push(this.createViewSql(view));\n    await this.executeQueries(upQueries, downQueries);\n  }\n  /**\n   * Renames the given table.\n   */\n\n\n  async renameTable(oldTableOrName, newTableName) {\n    throw new TypeORMError(`Rename table queries are not supported by Spanner driver.`);\n  }\n  /**\n   * Creates a new column from the column in the table.\n   */\n\n\n  async addColumn(tableOrName, column) {\n    const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n    const clonedTable = table.clone();\n    const upQueries = [];\n    const downQueries = [];\n    upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(column)}`));\n    downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN ${this.driver.escape(column.name)}`)); // create column index\n\n    const columnIndex = clonedTable.indices.find(index => index.columnNames.length === 1 && index.columnNames[0] === column.name);\n\n    if (columnIndex) {\n      upQueries.push(this.createIndexSql(table, columnIndex));\n      downQueries.push(this.dropIndexSql(table, columnIndex));\n    } else if (column.isUnique) {\n      const uniqueIndex = new TableIndex({\n        name: this.connection.namingStrategy.indexName(table, [column.name]),\n        columnNames: [column.name],\n        isUnique: true\n      });\n      clonedTable.indices.push(uniqueIndex);\n      clonedTable.uniques.push(new TableUnique({\n        name: uniqueIndex.name,\n        columnNames: uniqueIndex.columnNames\n      }));\n      upQueries.push(this.createIndexSql(table, uniqueIndex));\n      downQueries.push(this.dropIndexSql(table, uniqueIndex));\n    }\n\n    if (column.generatedType && column.asExpression) {\n      const insertQuery = this.insertTypeormMetadataSql({\n        table: table.name,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name,\n        value: column.asExpression\n      });\n      const deleteQuery = this.deleteTypeormMetadataSql({\n        table: table.name,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name\n      });\n      upQueries.push(insertQuery);\n      downQueries.push(deleteQuery);\n    }\n\n    await this.executeQueries(upQueries, downQueries);\n    clonedTable.addColumn(column);\n    this.replaceCachedTable(table, clonedTable);\n  }\n  /**\n   * Creates a new columns from the column in the table.\n   */\n\n\n  async addColumns(tableOrName, columns) {\n    for (const column of columns) {\n      await this.addColumn(tableOrName, column);\n    }\n  }\n  /**\n   * Renames column in the given table.\n   */\n\n\n  async renameColumn(tableOrName, oldTableColumnOrName, newTableColumnOrName) {\n    const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n    const oldColumn = oldTableColumnOrName instanceof TableColumn ? oldTableColumnOrName : table.columns.find(c => c.name === oldTableColumnOrName);\n    if (!oldColumn) throw new TypeORMError(`Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`);\n    let newColumn;\n\n    if (newTableColumnOrName instanceof TableColumn) {\n      newColumn = newTableColumnOrName;\n    } else {\n      newColumn = oldColumn.clone();\n      newColumn.name = newTableColumnOrName;\n    }\n\n    return this.changeColumn(table, oldColumn, newColumn);\n  }\n  /**\n   * Changes a column in the table.\n   */\n\n\n  async changeColumn(tableOrName, oldTableColumnOrName, newColumn) {\n    const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n    let clonedTable = table.clone();\n    const upQueries = [];\n    const downQueries = [];\n    const oldColumn = oldTableColumnOrName instanceof TableColumn ? oldTableColumnOrName : table.columns.find(column => column.name === oldTableColumnOrName);\n    if (!oldColumn) throw new TypeORMError(`Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`);\n\n    if (oldColumn.name !== newColumn.name || oldColumn.type !== newColumn.type || oldColumn.length !== newColumn.length || oldColumn.isArray !== newColumn.isArray || oldColumn.generatedType !== newColumn.generatedType || oldColumn.asExpression !== newColumn.asExpression) {\n      // To avoid data conversion, we just recreate column\n      await this.dropColumn(table, oldColumn);\n      await this.addColumn(table, newColumn); // update cloned table\n\n      clonedTable = table.clone();\n    } else {\n      if (newColumn.precision !== oldColumn.precision || newColumn.scale !== oldColumn.scale) {\n        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" TYPE ${this.driver.createFullType(newColumn)}`));\n        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" TYPE ${this.driver.createFullType(oldColumn)}`));\n      }\n\n      if (oldColumn.isNullable !== newColumn.isNullable) {\n        if (newColumn.isNullable) {\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" DROP NOT NULL`));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" SET NOT NULL`));\n        } else {\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" SET NOT NULL`));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" DROP NOT NULL`));\n        }\n      }\n\n      if (newColumn.isUnique !== oldColumn.isUnique) {\n        if (newColumn.isUnique === true) {\n          const uniqueIndex = new TableIndex({\n            name: this.connection.namingStrategy.indexName(table, [newColumn.name]),\n            columnNames: [newColumn.name],\n            isUnique: true\n          });\n          clonedTable.indices.push(uniqueIndex);\n          clonedTable.uniques.push(new TableUnique({\n            name: uniqueIndex.name,\n            columnNames: uniqueIndex.columnNames\n          }));\n          upQueries.push(this.createIndexSql(table, uniqueIndex));\n          downQueries.push(this.dropIndexSql(table, uniqueIndex));\n        } else {\n          const uniqueIndex = clonedTable.indices.find(index => {\n            return index.columnNames.length === 1 && index.isUnique === true && !!index.columnNames.find(columnName => columnName === newColumn.name);\n          });\n          clonedTable.indices.splice(clonedTable.indices.indexOf(uniqueIndex), 1);\n          const tableUnique = clonedTable.uniques.find(unique => unique.name === uniqueIndex.name);\n          clonedTable.uniques.splice(clonedTable.uniques.indexOf(tableUnique), 1);\n          upQueries.push(this.dropIndexSql(table, uniqueIndex));\n          downQueries.push(this.createIndexSql(table, uniqueIndex));\n        }\n      }\n    }\n\n    await this.executeQueries(upQueries, downQueries);\n    this.replaceCachedTable(table, clonedTable);\n  }\n  /**\n   * Changes a column in the table.\n   */\n\n\n  async changeColumns(tableOrName, changedColumns) {\n    for (const {\n      oldColumn,\n      newColumn\n    } of changedColumns) {\n      await this.changeColumn(tableOrName, oldColumn, newColumn);\n    }\n  }\n  /**\n   * Drops column in the table.\n   */\n\n\n  async dropColumn(tableOrName, columnOrName) {\n    const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n    const column = columnOrName instanceof TableColumn ? columnOrName : table.findColumnByName(columnOrName);\n    if (!column) throw new TypeORMError(`Column \"${columnOrName}\" was not found in table \"${table.name}\"`);\n    const clonedTable = table.clone();\n    const upQueries = [];\n    const downQueries = []; // drop column index\n\n    const columnIndex = clonedTable.indices.find(index => index.columnNames.length === 1 && index.columnNames[0] === column.name);\n\n    if (columnIndex) {\n      clonedTable.indices.splice(clonedTable.indices.indexOf(columnIndex), 1);\n      upQueries.push(this.dropIndexSql(table, columnIndex));\n      downQueries.push(this.createIndexSql(table, columnIndex));\n    } // drop column check\n\n\n    const columnCheck = clonedTable.checks.find(check => !!check.columnNames && check.columnNames.length === 1 && check.columnNames[0] === column.name);\n\n    if (columnCheck) {\n      clonedTable.checks.splice(clonedTable.checks.indexOf(columnCheck), 1);\n      upQueries.push(this.dropCheckConstraintSql(table, columnCheck));\n      downQueries.push(this.createCheckConstraintSql(table, columnCheck));\n    }\n\n    upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN ${this.driver.escape(column.name)}`));\n    downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(column)}`));\n\n    if (column.generatedType && column.asExpression) {\n      const deleteQuery = this.deleteTypeormMetadataSql({\n        table: table.name,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name\n      });\n      const insertQuery = this.insertTypeormMetadataSql({\n        table: table.name,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name,\n        value: column.asExpression\n      });\n      upQueries.push(deleteQuery);\n      downQueries.push(insertQuery);\n    }\n\n    await this.executeQueries(upQueries, downQueries);\n    clonedTable.removeColumn(column);\n    this.replaceCachedTable(table, clonedTable);\n  }\n  /**\n   * Drops the columns in the table.\n   */\n\n\n  async dropColumns(tableOrName, columns) {\n    for (const column of columns) {\n      await this.dropColumn(tableOrName, column);\n    }\n  }\n  /**\n   * Creates a new primary key.\n   *\n   * Not supported in Spanner.\n   * @see https://cloud.google.com/spanner/docs/schema-and-data-model#notes_about_key_columns\n   */\n\n\n  async createPrimaryKey(tableOrName, columnNames) {\n    throw new Error(\"The keys of a table can't change; you can't add a key column to an existing table or remove a key column from an existing table.\");\n  }\n  /**\n   * Updates composite primary keys.\n   */\n\n\n  async updatePrimaryKeys(tableOrName, columns) {\n    throw new Error(\"The keys of a table can't change; you can't add a key column to an existing table or remove a key column from an existing table.\");\n  }\n  /**\n   * Creates a new primary key.\n   *\n   * Not supported in Spanner.\n   * @see https://cloud.google.com/spanner/docs/schema-and-data-model#notes_about_key_columns\n   */\n\n\n  async dropPrimaryKey(tableOrName) {\n    throw new Error(\"The keys of a table can't change; you can't add a key column to an existing table or remove a key column from an existing table.\");\n  }\n  /**\n   * Creates new unique constraint.\n   */\n\n\n  async createUniqueConstraint(tableOrName, uniqueConstraint) {\n    throw new TypeORMError(`Spanner does not support unique constraints. Use unique index instead.`);\n  }\n  /**\n   * Creates new unique constraints.\n   */\n\n\n  async createUniqueConstraints(tableOrName, uniqueConstraints) {\n    throw new TypeORMError(`Spanner does not support unique constraints. Use unique index instead.`);\n  }\n  /**\n   * Drops unique constraint.\n   */\n\n\n  async dropUniqueConstraint(tableOrName, uniqueOrName) {\n    throw new TypeORMError(`Spanner does not support unique constraints. Use unique index instead.`);\n  }\n  /**\n   * Drops unique constraints.\n   */\n\n\n  async dropUniqueConstraints(tableOrName, uniqueConstraints) {\n    throw new TypeORMError(`Spanner does not support unique constraints. Use unique index instead.`);\n  }\n  /**\n   * Creates new check constraint.\n   */\n\n\n  async createCheckConstraint(tableOrName, checkConstraint) {\n    const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName); // new check constraint may be passed without name. In this case we generate unique name manually.\n\n    if (!checkConstraint.name) checkConstraint.name = this.connection.namingStrategy.checkConstraintName(table, checkConstraint.expression);\n    const up = this.createCheckConstraintSql(table, checkConstraint);\n    const down = this.dropCheckConstraintSql(table, checkConstraint);\n    await this.executeQueries(up, down);\n    table.addCheckConstraint(checkConstraint);\n  }\n  /**\n   * Creates new check constraints.\n   */\n\n\n  async createCheckConstraints(tableOrName, checkConstraints) {\n    const promises = checkConstraints.map(checkConstraint => this.createCheckConstraint(tableOrName, checkConstraint));\n    await Promise.all(promises);\n  }\n  /**\n   * Drops check constraint.\n   */\n\n\n  async dropCheckConstraint(tableOrName, checkOrName) {\n    const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n    const checkConstraint = checkOrName instanceof TableCheck ? checkOrName : table.checks.find(c => c.name === checkOrName);\n    if (!checkConstraint) throw new TypeORMError(`Supplied check constraint was not found in table ${table.name}`);\n    const up = this.dropCheckConstraintSql(table, checkConstraint);\n    const down = this.createCheckConstraintSql(table, checkConstraint);\n    await this.executeQueries(up, down);\n    table.removeCheckConstraint(checkConstraint);\n  }\n  /**\n   * Drops check constraints.\n   */\n\n\n  async dropCheckConstraints(tableOrName, checkConstraints) {\n    const promises = checkConstraints.map(checkConstraint => this.dropCheckConstraint(tableOrName, checkConstraint));\n    await Promise.all(promises);\n  }\n  /**\n   * Creates new exclusion constraint.\n   */\n\n\n  async createExclusionConstraint(tableOrName, exclusionConstraint) {\n    throw new TypeORMError(`Spanner does not support exclusion constraints.`);\n  }\n  /**\n   * Creates new exclusion constraints.\n   */\n\n\n  async createExclusionConstraints(tableOrName, exclusionConstraints) {\n    throw new TypeORMError(`Spanner does not support exclusion constraints.`);\n  }\n  /**\n   * Drops exclusion constraint.\n   */\n\n\n  async dropExclusionConstraint(tableOrName, exclusionOrName) {\n    throw new TypeORMError(`Spanner does not support exclusion constraints.`);\n  }\n  /**\n   * Drops exclusion constraints.\n   */\n\n\n  async dropExclusionConstraints(tableOrName, exclusionConstraints) {\n    throw new TypeORMError(`Spanner does not support exclusion constraints.`);\n  }\n  /**\n   * Creates a new foreign key.\n   */\n\n\n  async createForeignKey(tableOrName, foreignKey) {\n    const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName); // new FK may be passed without name. In this case we generate FK name manually.\n\n    if (!foreignKey.name) foreignKey.name = this.connection.namingStrategy.foreignKeyName(table, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);\n    const up = this.createForeignKeySql(table, foreignKey);\n    const down = this.dropForeignKeySql(table, foreignKey);\n    await this.executeQueries(up, down);\n    table.addForeignKey(foreignKey);\n  }\n  /**\n   * Creates a new foreign keys.\n   */\n\n\n  async createForeignKeys(tableOrName, foreignKeys) {\n    for (const foreignKey of foreignKeys) {\n      await this.createForeignKey(tableOrName, foreignKey);\n    }\n  }\n  /**\n   * Drops a foreign key from the table.\n   */\n\n\n  async dropForeignKey(tableOrName, foreignKeyOrName) {\n    const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n    const foreignKey = foreignKeyOrName instanceof TableForeignKey ? foreignKeyOrName : table.foreignKeys.find(fk => fk.name === foreignKeyOrName);\n    if (!foreignKey) throw new TypeORMError(`Supplied foreign key was not found in table ${table.name}`);\n    const up = this.dropForeignKeySql(table, foreignKey);\n    const down = this.createForeignKeySql(table, foreignKey);\n    await this.executeQueries(up, down);\n    table.removeForeignKey(foreignKey);\n  }\n  /**\n   * Drops a foreign keys from the table.\n   */\n\n\n  async dropForeignKeys(tableOrName, foreignKeys) {\n    for (const foreignKey of foreignKeys) {\n      await this.dropForeignKey(tableOrName, foreignKey);\n    }\n  }\n  /**\n   * Creates a new index.\n   */\n\n\n  async createIndex(tableOrName, index) {\n    const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName); // new index may be passed without name. In this case we generate index name manually.\n\n    if (!index.name) index.name = this.generateIndexName(table, index);\n    const up = this.createIndexSql(table, index);\n    const down = this.dropIndexSql(table, index);\n    await this.executeQueries(up, down);\n    table.addIndex(index);\n  }\n  /**\n   * Creates a new indices\n   */\n\n\n  async createIndices(tableOrName, indices) {\n    for (const index of indices) {\n      await this.createIndex(tableOrName, index);\n    }\n  }\n  /**\n   * Drops an index from the table.\n   */\n\n\n  async dropIndex(tableOrName, indexOrName) {\n    const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n    const index = indexOrName instanceof TableIndex ? indexOrName : table.indices.find(i => i.name === indexOrName);\n    if (!index) throw new TypeORMError(`Supplied index ${indexOrName} was not found in table ${table.name}`); // new index may be passed without name. In this case we generate index name manually.\n\n    if (!index.name) index.name = this.generateIndexName(table, index);\n    const up = this.dropIndexSql(table, index);\n    const down = this.createIndexSql(table, index);\n    await this.executeQueries(up, down);\n    table.removeIndex(index);\n  }\n  /**\n   * Drops an indices from the table.\n   */\n\n\n  async dropIndices(tableOrName, indices) {\n    for (const index of indices) {\n      await this.dropIndex(tableOrName, index);\n    }\n  }\n  /**\n   * Clears all table contents.\n   * Spanner does not support TRUNCATE TABLE statement, so we use DELETE FROM.\n   */\n\n\n  async clearTable(tableName) {\n    await this.query(`DELETE FROM ${this.escapePath(tableName)} WHERE true`);\n  }\n  /**\n   * Removes all tables from the currently connected database.\n   */\n\n\n  async clearDatabase() {\n    // drop index queries\n    const selectIndexDropsQuery = `SELECT concat('DROP INDEX \\`', INDEX_NAME, '\\`') AS \\`query\\` ` + `FROM \\`INFORMATION_SCHEMA\\`.\\`INDEXES\\` ` + `WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' AND \\`INDEX_TYPE\\` = 'INDEX' AND \\`SPANNER_IS_MANAGED\\` = false`;\n    const dropIndexQueries = await this.query(selectIndexDropsQuery); // drop foreign key queries\n\n    const selectFKDropsQuery = `SELECT concat('ALTER TABLE \\`', TABLE_NAME, '\\`', ' DROP CONSTRAINT \\`', CONSTRAINT_NAME, '\\`') AS \\`query\\` ` + `FROM \\`INFORMATION_SCHEMA\\`.\\`TABLE_CONSTRAINTS\\` ` + `WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' AND \\`CONSTRAINT_TYPE\\` = 'FOREIGN KEY'`;\n    const dropFKQueries = await this.query(selectFKDropsQuery); // drop view queries\n    // const selectViewDropsQuery = `SELECT concat('DROP VIEW \\`', TABLE_NAME, '\\`') AS \\`query\\` FROM \\`INFORMATION_SCHEMA\\`.\\`VIEWS\\``\n    // const dropViewQueries: ObjectLiteral[] = await this.query(\n    //     selectViewDropsQuery,\n    // )\n    // drop table queries\n\n    const dropTablesQuery = `SELECT concat('DROP TABLE \\`', TABLE_NAME, '\\`') AS \\`query\\` ` + `FROM \\`INFORMATION_SCHEMA\\`.\\`TABLES\\` ` + `WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' AND \\`TABLE_TYPE\\` = 'BASE TABLE'`;\n    const dropTableQueries = await this.query(dropTablesQuery);\n    if (!dropIndexQueries.length && !dropFKQueries.length && // !dropViewQueries.length &&\n    !dropTableQueries.length) return;\n    const isAnotherTransactionActive = this.isTransactionActive;\n    if (!isAnotherTransactionActive) await this.startTransaction();\n\n    try {\n      for (let query of dropIndexQueries) {\n        await this.updateDDL(query[\"query\"]);\n      }\n\n      for (let query of dropFKQueries) {\n        await this.updateDDL(query[\"query\"]);\n      } // for (let query of dropViewQueries) {\n      //     await this.updateDDL(query[\"query\"])\n      // }\n\n\n      for (let query of dropTableQueries) {\n        await this.updateDDL(query[\"query\"]);\n      }\n\n      await this.commitTransaction();\n    } catch (error) {\n      try {\n        // we throw original error even if rollback thrown an error\n        if (!isAnotherTransactionActive) await this.rollbackTransaction();\n      } catch (rollbackError) {}\n\n      throw error;\n    }\n  } // -------------------------------------------------------------------------\n  // Override Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Executes up sql queries.\n   */\n\n\n  async executeMemoryUpSql() {\n    for (const {\n      query,\n      parameters\n    } of this.sqlInMemory.upQueries) {\n      if (this.isDMLQuery(query)) {\n        await this.query(query, parameters);\n      } else {\n        await this.updateDDL(query, parameters);\n      }\n    }\n  }\n  /**\n   * Executes down sql queries.\n   */\n\n\n  async executeMemoryDownSql() {\n    for (const {\n      query,\n      parameters\n    } of this.sqlInMemory.downQueries.reverse()) {\n      if (this.isDMLQuery(query)) {\n        await this.query(query, parameters);\n      } else {\n        await this.updateDDL(query, parameters);\n      }\n    }\n  } // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n\n  async loadViews(viewNames) {\n    // const hasTable = await this.hasTable(this.getTypeormMetadataTableName())\n    // if (!hasTable) {\n    //     return []\n    // }\n    //\n    // if (!viewNames) {\n    //     viewNames = []\n    // }\n    //\n    // const escapedViewNames = viewNames\n    //     .map((viewName) => `'${viewName}'`)\n    //     .join(\", \")\n    //\n    // const query =\n    //     `SELECT \\`T\\`.*, \\`V\\`.\\`VIEW_DEFINITION\\` FROM ${this.escapePath(\n    //         this.getTypeormMetadataTableName(),\n    //     )} \\`T\\` ` +\n    //     `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`VIEWS\\` \\`V\\` ON \\`V\\`.\\`TABLE_NAME\\` = \\`T\\`.\\`NAME\\` ` +\n    //     `WHERE \\`T\\`.\\`TYPE\\` = '${MetadataTableType.VIEW}' ${\n    //         viewNames.length\n    //             ? ` AND \\`T\\`.\\`NAME\\` IN (${escapedViewNames})`\n    //             : \"\"\n    //     }`\n    // const dbViews = await this.query(query)\n    // return dbViews.map((dbView: any) => {\n    //     const view = new View()\n    //     view.database = dbView[\"NAME\"]\n    //     view.name = this.driver.buildTableName(dbView[\"NAME\"])\n    //     view.expression = dbView[\"NAME\"]\n    //     return view\n    // })\n    return Promise.resolve([]);\n  }\n  /**\n   * Loads all tables (with given names) from the database and creates a Table from them.\n   */\n\n\n  async loadTables(tableNames) {\n    if (tableNames && tableNames.length === 0) {\n      return [];\n    }\n\n    const dbTables = [];\n\n    if (!tableNames || !tableNames.length) {\n      // Since we don't have any of this data we have to do a scan\n      const tablesSql = `SELECT \\`TABLE_NAME\\` ` + `FROM \\`INFORMATION_SCHEMA\\`.\\`TABLES\\` ` + `WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' AND \\`TABLE_TYPE\\` = 'BASE TABLE'`;\n      dbTables.push(...(await this.query(tablesSql)));\n    } else {\n      const tablesSql = `SELECT \\`TABLE_NAME\\` ` + `FROM \\`INFORMATION_SCHEMA\\`.\\`TABLES\\` ` + `WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' AND \\`TABLE_TYPE\\` = 'BASE TABLE' ` + `AND \\`TABLE_NAME\\` IN (${tableNames.map(tableName => `'${tableName}'`).join(\", \")})`;\n      dbTables.push(...(await this.query(tablesSql)));\n    } // if tables were not found in the db, no need to proceed\n\n\n    if (!dbTables.length) return [];\n    const loadedTableNames = dbTables.map(dbTable => `'${dbTable.TABLE_NAME}'`).join(\", \");\n    const columnsSql = `SELECT * FROM \\`INFORMATION_SCHEMA\\`.\\`COLUMNS\\` WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' AND \\`TABLE_NAME\\` IN (${loadedTableNames})`;\n    const primaryKeySql = `SELECT \\`KCU\\`.\\`TABLE_NAME\\`, \\`KCU\\`.\\`COLUMN_NAME\\` ` + `FROM \\`INFORMATION_SCHEMA\\`.\\`TABLE_CONSTRAINTS\\` \\`TC\\` ` + `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`KEY_COLUMN_USAGE\\` \\`KCU\\` ON \\`KCU\\`.\\`CONSTRAINT_NAME\\` = \\`TC\\`.\\`CONSTRAINT_NAME\\` ` + `WHERE \\`TC\\`.\\`TABLE_CATALOG\\` = '' AND \\`TC\\`.\\`TABLE_SCHEMA\\` = '' AND \\`TC\\`.\\`CONSTRAINT_TYPE\\` = 'PRIMARY KEY' ` + `AND \\`TC\\`.\\`TABLE_NAME\\` IN (${loadedTableNames})`;\n    const indicesSql = `SELECT \\`I\\`.\\`TABLE_NAME\\`, \\`I\\`.\\`INDEX_NAME\\`, \\`I\\`.\\`IS_UNIQUE\\`, \\`I\\`.\\`IS_NULL_FILTERED\\`, \\`IC\\`.\\`COLUMN_NAME\\` ` + `FROM \\`INFORMATION_SCHEMA\\`.\\`INDEXES\\` \\`I\\` ` + `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`INDEX_COLUMNS\\` \\`IC\\` ON \\`IC\\`.\\`INDEX_NAME\\` = \\`I\\`.\\`INDEX_NAME\\` ` + `AND \\`IC\\`.\\`TABLE_NAME\\` = \\`I\\`.\\`TABLE_NAME\\` ` + `WHERE \\`I\\`.\\`TABLE_CATALOG\\` = '' AND \\`I\\`.\\`TABLE_SCHEMA\\` = '' AND \\`I\\`.\\`TABLE_NAME\\` IN (${loadedTableNames}) ` + `AND \\`I\\`.\\`INDEX_TYPE\\` = 'INDEX' AND \\`I\\`.\\`SPANNER_IS_MANAGED\\` = false`;\n    const checksSql = `SELECT \\`TC\\`.\\`TABLE_NAME\\`, \\`TC\\`.\\`CONSTRAINT_NAME\\`, \\`CC\\`.\\`CHECK_CLAUSE\\`, \\`CCU\\`.\\`COLUMN_NAME\\`` + `FROM \\`INFORMATION_SCHEMA\\`.\\`TABLE_CONSTRAINTS\\` \\`TC\\` ` + `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`CONSTRAINT_COLUMN_USAGE\\` \\`CCU\\` ON \\`CCU\\`.\\`CONSTRAINT_NAME\\` = \\`TC\\`.\\`CONSTRAINT_NAME\\` ` + `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`CHECK_CONSTRAINTS\\` \\`CC\\` ON \\`CC\\`.\\`CONSTRAINT_NAME\\` = \\`TC\\`.\\`CONSTRAINT_NAME\\` ` + `WHERE \\`TC\\`.\\`TABLE_CATALOG\\` = '' AND \\`TC\\`.\\`TABLE_SCHEMA\\` = '' AND \\`TC\\`.\\`CONSTRAINT_TYPE\\` = 'CHECK' ` + `AND \\`TC\\`.\\`TABLE_NAME\\` IN (${loadedTableNames}) AND \\`TC\\`.\\`CONSTRAINT_NAME\\` NOT LIKE 'CK_IS_NOT_NULL%'`;\n    const foreignKeysSql = `SELECT \\`TC\\`.\\`TABLE_NAME\\`, \\`TC\\`.\\`CONSTRAINT_NAME\\`, \\`KCU\\`.\\`COLUMN_NAME\\`, ` + `\\`CTU\\`.\\`TABLE_NAME\\` AS \\`REFERENCED_TABLE_NAME\\`, \\`CCU\\`.\\`COLUMN_NAME\\` AS \\`REFERENCED_COLUMN_NAME\\`, ` + `\\`RC\\`.\\`UPDATE_RULE\\`, \\`RC\\`.\\`DELETE_RULE\\` ` + `FROM \\`INFORMATION_SCHEMA\\`.\\`TABLE_CONSTRAINTS\\` \\`TC\\` ` + `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`KEY_COLUMN_USAGE\\` \\`KCU\\` ON \\`KCU\\`.\\`CONSTRAINT_NAME\\` = \\`TC\\`.\\`CONSTRAINT_NAME\\` ` + `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`CONSTRAINT_TABLE_USAGE\\` \\`CTU\\` ON \\`CTU\\`.\\`CONSTRAINT_NAME\\` = \\`TC\\`.\\`CONSTRAINT_NAME\\` ` + `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`REFERENTIAL_CONSTRAINTS\\` \\`RC\\` ON \\`RC\\`.\\`CONSTRAINT_NAME\\` = \\`TC\\`.\\`CONSTRAINT_NAME\\` ` + `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`CONSTRAINT_COLUMN_USAGE\\` \\`CCU\\` ON \\`CCU\\`.\\`CONSTRAINT_NAME\\` = \\`TC\\`.\\`CONSTRAINT_NAME\\` ` + `WHERE \\`TC\\`.\\`TABLE_CATALOG\\` = '' AND \\`TC\\`.\\`TABLE_SCHEMA\\` = '' AND \\`TC\\`.\\`CONSTRAINT_TYPE\\` = 'FOREIGN KEY' ` + `AND \\`TC\\`.\\`TABLE_NAME\\` IN (${loadedTableNames})`;\n    const [dbColumns, dbPrimaryKeys, dbIndices, dbChecks, dbForeignKeys] = await Promise.all([this.query(columnsSql), this.query(primaryKeySql), this.query(indicesSql), this.query(checksSql), this.query(foreignKeysSql)]); // create tables for loaded tables\n\n    return Promise.all(dbTables.map(async dbTable => {\n      const table = new Table();\n      table.name = this.driver.buildTableName(dbTable[\"TABLE_NAME\"]); // create columns from the loaded columns\n\n      table.columns = await Promise.all(dbColumns.filter(dbColumn => dbColumn[\"TABLE_NAME\"] === dbTable[\"TABLE_NAME\"]).map(async dbColumn => {\n        const columnUniqueIndices = dbIndices.filter(dbIndex => {\n          return dbIndex[\"TABLE_NAME\"] === dbTable[\"TABLE_NAME\"] && dbIndex[\"COLUMN_NAME\"] === dbColumn[\"COLUMN_NAME\"] && dbIndex[\"IS_UNIQUE\"] === true;\n        });\n        const tableMetadata = this.connection.entityMetadatas.find(metadata => this.getTablePath(table) === this.getTablePath(metadata));\n        const hasIgnoredIndex = columnUniqueIndices.length > 0 && tableMetadata && tableMetadata.indices.some(index => {\n          return columnUniqueIndices.some(uniqueIndex => {\n            return index.name === uniqueIndex[\"INDEX_NAME\"] && index.synchronize === false;\n          });\n        });\n        const isConstraintComposite = columnUniqueIndices.every(uniqueIndex => {\n          return dbIndices.some(dbIndex => dbIndex[\"INDEX_NAME\"] === uniqueIndex[\"INDEX_NAME\"] && dbIndex[\"COLUMN_NAME\"] !== dbColumn[\"COLUMN_NAME\"]);\n        });\n        const tableColumn = new TableColumn();\n        tableColumn.name = dbColumn[\"COLUMN_NAME\"];\n        let fullType = dbColumn[\"SPANNER_TYPE\"].toLowerCase();\n\n        if (fullType.indexOf(\"array\") !== -1) {\n          tableColumn.isArray = true;\n          fullType = fullType.substring(fullType.indexOf(\"<\") + 1, fullType.indexOf(\">\"));\n        }\n\n        if (fullType.indexOf(\"(\") !== -1) {\n          tableColumn.type = fullType.substring(0, fullType.indexOf(\"(\"));\n        } else {\n          tableColumn.type = fullType;\n        }\n\n        if (this.driver.withLengthColumnTypes.indexOf(tableColumn.type) !== -1) {\n          tableColumn.length = fullType.substring(fullType.indexOf(\"(\") + 1, fullType.indexOf(\")\"));\n        }\n\n        if (dbColumn[\"IS_GENERATED\"] === \"ALWAYS\") {\n          tableColumn.asExpression = dbColumn[\"GENERATION_EXPRESSION\"];\n          tableColumn.generatedType = \"STORED\"; // We cannot relay on information_schema.columns.generation_expression, because it is formatted different.\n\n          const asExpressionQuery = await this.selectTypeormMetadataSql({\n            table: dbTable[\"TABLE_NAME\"],\n            type: MetadataTableType.GENERATED_COLUMN,\n            name: tableColumn.name\n          });\n          const results = await this.query(asExpressionQuery.query, asExpressionQuery.parameters);\n\n          if (results[0] && results[0].value) {\n            tableColumn.asExpression = results[0].value;\n          } else {\n            tableColumn.asExpression = \"\";\n          }\n        }\n\n        tableColumn.isUnique = columnUniqueIndices.length > 0 && !hasIgnoredIndex && !isConstraintComposite;\n        tableColumn.isNullable = dbColumn[\"IS_NULLABLE\"] === \"YES\";\n        tableColumn.isPrimary = dbPrimaryKeys.some(dbPrimaryKey => {\n          return dbPrimaryKey[\"TABLE_NAME\"] === dbColumn[\"TABLE_NAME\"] && dbPrimaryKey[\"COLUMN_NAME\"] === dbColumn[\"COLUMN_NAME\"];\n        });\n        return tableColumn;\n      }));\n      const tableForeignKeys = dbForeignKeys.filter(dbForeignKey => {\n        return dbForeignKey[\"TABLE_NAME\"] === dbTable[\"TABLE_NAME\"];\n      });\n      table.foreignKeys = OrmUtils.uniq(tableForeignKeys, dbForeignKey => dbForeignKey[\"CONSTRAINT_NAME\"]).map(dbForeignKey => {\n        const foreignKeys = tableForeignKeys.filter(dbFk => dbFk[\"CONSTRAINT_NAME\"] === dbForeignKey[\"CONSTRAINT_NAME\"]);\n        return new TableForeignKey({\n          name: dbForeignKey[\"CONSTRAINT_NAME\"],\n          columnNames: OrmUtils.uniq(foreignKeys.map(dbFk => dbFk[\"COLUMN_NAME\"])),\n          referencedDatabase: dbForeignKey[\"REFERENCED_TABLE_SCHEMA\"],\n          referencedTableName: dbForeignKey[\"REFERENCED_TABLE_NAME\"],\n          referencedColumnNames: OrmUtils.uniq(foreignKeys.map(dbFk => dbFk[\"REFERENCED_COLUMN_NAME\"])),\n          onDelete: dbForeignKey[\"DELETE_RULE\"],\n          onUpdate: dbForeignKey[\"UPDATE_RULE\"]\n        });\n      });\n      const tableIndices = dbIndices.filter(dbIndex => dbIndex[\"TABLE_NAME\"] === dbTable[\"TABLE_NAME\"]);\n      table.indices = OrmUtils.uniq(tableIndices, dbIndex => dbIndex[\"INDEX_NAME\"]).map(constraint => {\n        const indices = tableIndices.filter(index => {\n          return index[\"INDEX_NAME\"] === constraint[\"INDEX_NAME\"];\n        });\n        return new TableIndex({\n          table: table,\n          name: constraint[\"INDEX_NAME\"],\n          columnNames: indices.map(i => i[\"COLUMN_NAME\"]),\n          isUnique: constraint[\"IS_UNIQUE\"],\n          isNullFiltered: constraint[\"IS_NULL_FILTERED\"]\n        });\n      });\n      const tableChecks = dbChecks.filter(dbCheck => dbCheck[\"TABLE_NAME\"] === dbTable[\"TABLE_NAME\"]);\n      table.checks = OrmUtils.uniq(tableChecks, dbIndex => dbIndex[\"CONSTRAINT_NAME\"]).map(constraint => {\n        const checks = tableChecks.filter(dbC => dbC[\"CONSTRAINT_NAME\"] === constraint[\"CONSTRAINT_NAME\"]);\n        return new TableCheck({\n          name: constraint[\"CONSTRAINT_NAME\"],\n          columnNames: checks.map(c => c[\"COLUMN_NAME\"]),\n          expression: constraint[\"CHECK_CLAUSE\"]\n        });\n      });\n      return table;\n    }));\n  }\n  /**\n   * Builds create table sql.\n   */\n\n\n  createTableSql(table, createForeignKeys) {\n    const columnDefinitions = table.columns.map(column => this.buildCreateColumnSql(column)).join(\", \");\n    let sql = `CREATE TABLE ${this.escapePath(table)} (${columnDefinitions}`; // we create unique indexes instead of unique constraints, because Spanner does not have unique constraints.\n    // if we mark column as Unique, it means that we create UNIQUE INDEX.\n\n    table.columns.filter(column => column.isUnique).forEach(column => {\n      const isUniqueIndexExist = table.indices.some(index => {\n        return index.columnNames.length === 1 && !!index.isUnique && index.columnNames.indexOf(column.name) !== -1;\n      });\n      const isUniqueConstraintExist = table.uniques.some(unique => {\n        return unique.columnNames.length === 1 && unique.columnNames.indexOf(column.name) !== -1;\n      });\n      if (!isUniqueIndexExist && !isUniqueConstraintExist) table.indices.push(new TableIndex({\n        name: this.connection.namingStrategy.uniqueConstraintName(table, [column.name]),\n        columnNames: [column.name],\n        isUnique: true\n      }));\n    }); // as Spanner does not have unique constraints, we must create table indices from table uniques and mark them as unique.\n\n    if (table.uniques.length > 0) {\n      table.uniques.forEach(unique => {\n        const uniqueExist = table.indices.some(index => index.name === unique.name);\n\n        if (!uniqueExist) {\n          table.indices.push(new TableIndex({\n            name: unique.name,\n            columnNames: unique.columnNames,\n            isUnique: true\n          }));\n        }\n      });\n    }\n\n    if (table.checks.length > 0) {\n      const checksSql = table.checks.map(check => {\n        const checkName = check.name ? check.name : this.connection.namingStrategy.checkConstraintName(table, check.expression);\n        return `CONSTRAINT \\`${checkName}\\` CHECK (${check.expression})`;\n      }).join(\", \");\n      sql += `, ${checksSql}`;\n    }\n\n    if (table.foreignKeys.length > 0 && createForeignKeys) {\n      const foreignKeysSql = table.foreignKeys.map(fk => {\n        const columnNames = fk.columnNames.map(columnName => `\\`${columnName}\\``).join(\", \");\n        if (!fk.name) fk.name = this.connection.namingStrategy.foreignKeyName(table, fk.columnNames, this.getTablePath(fk), fk.referencedColumnNames);\n        const referencedColumnNames = fk.referencedColumnNames.map(columnName => `\\`${columnName}\\``).join(\", \");\n        return `CONSTRAINT \\`${fk.name}\\` FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(fk))} (${referencedColumnNames})`;\n      }).join(\", \");\n      sql += `, ${foreignKeysSql}`;\n    }\n\n    sql += `)`;\n    const primaryColumns = table.columns.filter(column => column.isPrimary);\n\n    if (primaryColumns.length > 0) {\n      const columnNames = primaryColumns.map(column => this.driver.escape(column.name)).join(\", \");\n      sql += ` PRIMARY KEY (${columnNames})`;\n    }\n\n    return new Query(sql);\n  }\n  /**\n   * Builds drop table sql.\n   */\n\n\n  dropTableSql(tableOrPath) {\n    return new Query(`DROP TABLE ${this.escapePath(tableOrPath)}`);\n  }\n\n  createViewSql(view) {\n    const materializedClause = view.materialized ? \"MATERIALIZED \" : \"\";\n    const viewName = this.escapePath(view);\n    const expression = typeof view.expression === \"string\" ? view.expression : view.expression(this.connection).getQuery();\n    return new Query(`CREATE ${materializedClause}VIEW ${viewName} SQL SECURITY INVOKER AS ${expression}`);\n  }\n\n  async insertViewDefinitionSql(view) {\n    let {\n      schema,\n      tableName: name\n    } = this.driver.parseTableName(view);\n    const type = view.materialized ? MetadataTableType.MATERIALIZED_VIEW : MetadataTableType.VIEW;\n    const expression = typeof view.expression === \"string\" ? view.expression.trim() : view.expression(this.connection).getQuery();\n    return this.insertTypeormMetadataSql({\n      type,\n      schema,\n      name,\n      value: expression\n    });\n  }\n  /**\n   * Builds drop view sql.\n   */\n\n\n  dropViewSql(view) {\n    const materializedClause = view.materialized ? \"MATERIALIZED \" : \"\";\n    return new Query(`DROP ${materializedClause}VIEW ${this.escapePath(view)}`);\n  }\n  /**\n   * Builds remove view sql.\n   */\n\n\n  async deleteViewDefinitionSql(view) {\n    let {\n      schema,\n      tableName: name\n    } = this.driver.parseTableName(view);\n    const type = view.materialized ? MetadataTableType.MATERIALIZED_VIEW : MetadataTableType.VIEW;\n    return this.deleteTypeormMetadataSql({\n      type,\n      schema,\n      name\n    });\n  }\n  /**\n   * Builds create index sql.\n   */\n\n\n  createIndexSql(table, index) {\n    const columns = index.columnNames.map(columnName => this.driver.escape(columnName)).join(\", \");\n    let indexType = \"\";\n    if (index.isUnique) indexType += \"UNIQUE \";\n    if (index.isNullFiltered) indexType += \"NULL_FILTERED \";\n    return new Query(`CREATE ${indexType}INDEX \\`${index.name}\\` ON ${this.escapePath(table)} (${columns})`);\n  }\n  /**\n   * Builds drop index sql.\n   */\n\n\n  dropIndexSql(table, indexOrName) {\n    let indexName = indexOrName instanceof TableIndex ? indexOrName.name : indexOrName;\n    return new Query(`DROP INDEX \\`${indexName}\\``);\n  }\n  /**\n   * Builds create check constraint sql.\n   */\n\n\n  createCheckConstraintSql(table, checkConstraint) {\n    return new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \\`${checkConstraint.name}\\` CHECK (${checkConstraint.expression})`);\n  }\n  /**\n   * Builds drop check constraint sql.\n   */\n\n\n  dropCheckConstraintSql(table, checkOrName) {\n    const checkName = checkOrName instanceof TableCheck ? checkOrName.name : checkOrName;\n    return new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \\`${checkName}\\``);\n  }\n  /**\n   * Builds create foreign key sql.\n   */\n\n\n  createForeignKeySql(table, foreignKey) {\n    const columnNames = foreignKey.columnNames.map(column => this.driver.escape(column)).join(\", \");\n    const referencedColumnNames = foreignKey.referencedColumnNames.map(column => this.driver.escape(column)).join(\",\");\n    let sql = `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \\`${foreignKey.name}\\` FOREIGN KEY (${columnNames}) ` + `REFERENCES ${this.escapePath(this.getTablePath(foreignKey))} (${referencedColumnNames})`;\n    return new Query(sql);\n  }\n  /**\n   * Builds drop foreign key sql.\n   */\n\n\n  dropForeignKeySql(table, foreignKeyOrName) {\n    const foreignKeyName = foreignKeyOrName instanceof TableForeignKey ? foreignKeyOrName.name : foreignKeyOrName;\n    return new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \\`${foreignKeyName}\\``);\n  }\n  /**\n   * Escapes given table or view path.\n   */\n\n\n  escapePath(target) {\n    const {\n      tableName\n    } = this.driver.parseTableName(target);\n    return `\\`${tableName}\\``;\n  }\n  /**\n   * Builds a part of query to create/change a column.\n   */\n\n\n  buildCreateColumnSql(column) {\n    let c = `${this.driver.escape(column.name)} ${this.connection.driver.createFullType(column)}`; // Spanner supports only STORED generated column type\n\n    if (column.generatedType === \"STORED\" && column.asExpression) {\n      c += ` AS (${column.asExpression}) STORED`;\n    } else {\n      if (!column.isNullable) c += \" NOT NULL\";\n    }\n\n    return c;\n  }\n  /**\n   * Executes sql used special for schema build.\n   */\n\n\n  async executeQueries(upQueries, downQueries) {\n    if (upQueries instanceof Query) upQueries = [upQueries];\n    if (downQueries instanceof Query) downQueries = [downQueries];\n    this.sqlInMemory.upQueries.push(...upQueries);\n    this.sqlInMemory.downQueries.push(...downQueries); // if sql-in-memory mode is enabled then simply store sql in memory and return\n\n    if (this.sqlMemoryMode === true) return Promise.resolve();\n\n    for (const {\n      query,\n      parameters\n    } of upQueries) {\n      if (this.isDMLQuery(query)) {\n        await this.query(query, parameters);\n      } else {\n        await this.updateDDL(query, parameters);\n      }\n    }\n  }\n\n  isDMLQuery(query) {\n    return query.startsWith(\"INSERT\") || query.startsWith(\"UPDATE\") || query.startsWith(\"DELETE\");\n  }\n\n}","map":{"version":3,"mappings":"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","names":["QueryFailedError","QueryRunnerAlreadyReleasedError","TransactionNotStartedError","BaseQueryRunner","Table","TableCheck","TableColumn","TableForeignKey","TableIndex","TableUnique","View","Broadcaster","OrmUtils","Query","TypeORMError","QueryResult","MetadataTableType","SpannerQueryRunner","constructor","driver","mode","connection","broadcaster","connect","session","Promise","resolve","instanceDatabase","createSession","sessionTransaction","transaction","release","isReleased","delete","undefined","startTransaction","isolationLevel","isTransactionActive","broadcast","err","begin","logger","logQuery","commitTransaction","commit","rollbackTransaction","rollback","query","parameters","useStructuredResult","queryStartTime","Date","rawResult","isSelect","startsWith","executor","run","sql","params","reduce","value","index","json","error","rollbackError","maxQueryExecutionTime","options","queryEndTime","queryExecutionTime","logQuerySlow","result","raw","records","rowCountExact","affected","parseInt","logQueryError","updateDDL","operation","updateSchema","promise","stream","onEnd","onError","request","runStream","on","getDatabases","getSchemas","database","hasDatabase","getCurrentDatabase","hasSchema","schema","length","getCurrentSchema","hasTable","tableOrName","tableName","name","hasColumn","columnName","createDatabase","ifNotExist","databaseAlreadyExists","up","down","executeQueries","dropDatabase","ifExist","createSchema","schemaPath","dropSchema","isCascade","createTable","table","createForeignKeys","createIndices","isTableExist","upQueries","downQueries","push","createTableSql","dropTableSql","foreignKeys","forEach","foreignKey","dropForeignKeySql","indices","namingStrategy","indexName","columnNames","where","createIndexSql","dropIndexSql","generatedColumns","columns","filter","column","generatedType","asExpression","insertQuery","insertTypeormMetadataSql","type","GENERATED_COLUMN","deleteQuery","deleteTypeormMetadataSql","dropTable","target","dropForeignKeys","dropIndices","tablePath","getTablePath","getCachedTable","createView","view","createViewSql","insertViewDefinitionSql","dropViewSql","deleteViewDefinitionSql","dropView","viewName","getCachedView","renameTable","oldTableOrName","newTableName","addColumn","clonedTable","clone","escapePath","buildCreateColumnSql","escape","columnIndex","find","isUnique","uniqueIndex","uniques","replaceCachedTable","addColumns","renameColumn","oldTableColumnOrName","newTableColumnOrName","oldColumn","c","newColumn","changeColumn","isArray","dropColumn","precision","scale","createFullType","isNullable","splice","indexOf","tableUnique","unique","changeColumns","changedColumns","columnOrName","findColumnByName","columnCheck","checks","check","dropCheckConstraintSql","createCheckConstraintSql","removeColumn","dropColumns","createPrimaryKey","Error","updatePrimaryKeys","dropPrimaryKey","createUniqueConstraint","uniqueConstraint","createUniqueConstraints","uniqueConstraints","dropUniqueConstraint","uniqueOrName","dropUniqueConstraints","createCheckConstraint","checkConstraint","checkConstraintName","expression","addCheckConstraint","createCheckConstraints","checkConstraints","promises","map","all","dropCheckConstraint","checkOrName","removeCheckConstraint","dropCheckConstraints","createExclusionConstraint","exclusionConstraint","createExclusionConstraints","exclusionConstraints","dropExclusionConstraint","exclusionOrName","dropExclusionConstraints","createForeignKey","foreignKeyName","referencedColumnNames","createForeignKeySql","addForeignKey","dropForeignKey","foreignKeyOrName","fk","removeForeignKey","createIndex","generateIndexName","addIndex","dropIndex","indexOrName","i","removeIndex","clearTable","clearDatabase","selectIndexDropsQuery","dropIndexQueries","selectFKDropsQuery","dropFKQueries","dropTablesQuery","dropTableQueries","isAnotherTransactionActive","executeMemoryUpSql","sqlInMemory","isDMLQuery","executeMemoryDownSql","reverse","loadViews","viewNames","loadTables","tableNames","dbTables","tablesSql","join","loadedTableNames","dbTable","TABLE_NAME","columnsSql","primaryKeySql","indicesSql","checksSql","foreignKeysSql","dbColumns","dbPrimaryKeys","dbIndices","dbChecks","dbForeignKeys","buildTableName","dbColumn","columnUniqueIndices","dbIndex","tableMetadata","entityMetadatas","metadata","hasIgnoredIndex","some","synchronize","isConstraintComposite","every","tableColumn","fullType","toLowerCase","substring","withLengthColumnTypes","asExpressionQuery","selectTypeormMetadataSql","results","isPrimary","dbPrimaryKey","tableForeignKeys","dbForeignKey","uniq","dbFk","referencedDatabase","referencedTableName","onDelete","onUpdate","tableIndices","constraint","isNullFiltered","tableChecks","dbCheck","dbC","columnDefinitions","isUniqueIndexExist","isUniqueConstraintExist","uniqueConstraintName","uniqueExist","checkName","primaryColumns","tableOrPath","materializedClause","materialized","getQuery","parseTableName","MATERIALIZED_VIEW","VIEW","trim","indexType","sqlMemoryMode"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\driver\\spanner\\SpannerQueryRunner.ts"],"sourcesContent":["import { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { QueryFailedError } from \"../../error/QueryFailedError\"\nimport { QueryRunnerAlreadyReleasedError } from \"../../error/QueryRunnerAlreadyReleasedError\"\nimport { TransactionNotStartedError } from \"../../error/TransactionNotStartedError\"\nimport { ColumnType } from \"../types/ColumnTypes\"\nimport { ReadStream } from \"../../platform/PlatformTools\"\nimport { BaseQueryRunner } from \"../../query-runner/BaseQueryRunner\"\nimport { QueryRunner } from \"../../query-runner/QueryRunner\"\nimport { TableIndexOptions } from \"../../schema-builder/options/TableIndexOptions\"\nimport { Table } from \"../../schema-builder/table/Table\"\nimport { TableCheck } from \"../../schema-builder/table/TableCheck\"\nimport { TableColumn } from \"../../schema-builder/table/TableColumn\"\nimport { TableExclusion } from \"../../schema-builder/table/TableExclusion\"\nimport { TableForeignKey } from \"../../schema-builder/table/TableForeignKey\"\nimport { TableIndex } from \"../../schema-builder/table/TableIndex\"\nimport { TableUnique } from \"../../schema-builder/table/TableUnique\"\nimport { View } from \"../../schema-builder/view/View\"\nimport { Broadcaster } from \"../../subscriber/Broadcaster\"\nimport { OrmUtils } from \"../../util/OrmUtils\"\nimport { Query } from \"../Query\"\nimport { IsolationLevel } from \"../types/IsolationLevel\"\nimport { ReplicationMode } from \"../types/ReplicationMode\"\nimport { TypeORMError } from \"../../error\"\nimport { QueryResult } from \"../../query-runner/QueryResult\"\nimport { MetadataTableType } from \"../types/MetadataTableType\"\nimport { SpannerDriver } from \"./SpannerDriver\"\n\n/**\n * Runs queries on a single postgres database connection.\n */\nexport class SpannerQueryRunner extends BaseQueryRunner implements QueryRunner {\n    // -------------------------------------------------------------------------\n    // Public Implemented Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Database driver used by connection.\n     */\n    driver: SpannerDriver\n\n    /**\n     * Real database connection from a connection pool used to perform queries.\n     */\n    protected session?: any\n\n    /**\n     * Transaction currently executed by this session.\n     */\n    protected sessionTransaction?: any\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(driver: SpannerDriver, mode: ReplicationMode) {\n        super()\n        this.driver = driver\n        this.connection = driver.connection\n        this.mode = mode\n        this.broadcaster = new Broadcaster(this)\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates/uses database connection from the connection pool to perform further operations.\n     * Returns obtained database connection.\n     */\n    async connect(): Promise<any> {\n        if (this.session) {\n            return Promise.resolve(this.session)\n        }\n\n        const [session] = await this.driver.instanceDatabase.createSession({})\n        this.session = session\n        this.sessionTransaction = await session.transaction()\n        return this.session\n    }\n\n    /**\n     * Releases used database connection.\n     * You cannot use query runner methods once its released.\n     */\n    async release(): Promise<void> {\n        this.isReleased = true\n        if (this.session) {\n            await this.session.delete()\n        }\n        this.session = undefined\n        return Promise.resolve()\n    }\n\n    /**\n     * Starts transaction.\n     */\n    async startTransaction(isolationLevel?: IsolationLevel): Promise<void> {\n        this.isTransactionActive = true\n        try {\n            await this.broadcaster.broadcast(\"BeforeTransactionStart\")\n        } catch (err) {\n            this.isTransactionActive = false\n            throw err\n        }\n\n        await this.connect()\n        await this.sessionTransaction.begin()\n        this.connection.logger.logQuery(\"START TRANSACTION\")\n\n        await this.broadcaster.broadcast(\"AfterTransactionStart\")\n    }\n\n    /**\n     * Commits transaction.\n     * Error will be thrown if transaction was not started.\n     */\n    async commitTransaction(): Promise<void> {\n        if (!this.isTransactionActive || !this.sessionTransaction)\n            throw new TransactionNotStartedError()\n\n        await this.broadcaster.broadcast(\"BeforeTransactionCommit\")\n\n        await this.sessionTransaction.commit()\n        this.connection.logger.logQuery(\"COMMIT\")\n        this.isTransactionActive = false\n\n        await this.broadcaster.broadcast(\"AfterTransactionCommit\")\n    }\n\n    /**\n     * Rollbacks transaction.\n     * Error will be thrown if transaction was not started.\n     */\n    async rollbackTransaction(): Promise<void> {\n        if (!this.isTransactionActive || !this.sessionTransaction)\n            throw new TransactionNotStartedError()\n\n        await this.broadcaster.broadcast(\"BeforeTransactionRollback\")\n\n        await this.sessionTransaction.rollback()\n        this.connection.logger.logQuery(\"ROLLBACK\")\n        this.isTransactionActive = false\n\n        await this.broadcaster.broadcast(\"AfterTransactionRollback\")\n    }\n\n    /**\n     * Executes a given SQL query.\n     */\n    async query(\n        query: string,\n        parameters?: any[],\n        useStructuredResult: boolean = false,\n    ): Promise<any> {\n        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError()\n\n        try {\n            const queryStartTime = +new Date()\n            await this.connect()\n            let rawResult:\n                | [\n                      any[],\n                      {\n                          queryPlan: null\n                          queryStats: null\n                          rowCountExact: string\n                          rowCount: string\n                      },\n                      { rowType: { fields: [] }; transaction: null },\n                  ]\n                | undefined = undefined\n            const isSelect = query.startsWith(\"SELECT\")\n            const executor =\n                isSelect && !this.isTransactionActive\n                    ? this.driver.instanceDatabase\n                    : this.sessionTransaction\n\n            if (!this.isTransactionActive && !isSelect) {\n                await this.sessionTransaction.begin()\n            }\n\n            try {\n                this.driver.connection.logger.logQuery(query, parameters, this)\n                rawResult = await executor.run({\n                    sql: query,\n                    params: parameters\n                        ? parameters.reduce((params, value, index) => {\n                              params[\"param\" + index] = value\n                              return params\n                          }, {} as ObjectLiteral)\n                        : undefined,\n                    json: true,\n                })\n                if (!this.isTransactionActive && !isSelect) {\n                    await this.sessionTransaction.commit()\n                }\n            } catch (error) {\n                try {\n                    // we throw original error even if rollback thrown an error\n                    if (!this.isTransactionActive && !isSelect)\n                        await this.sessionTransaction.rollback()\n                } catch (rollbackError) {}\n                throw error\n            }\n\n            // log slow queries if maxQueryExecution time is set\n            const maxQueryExecutionTime =\n                this.driver.options.maxQueryExecutionTime\n            const queryEndTime = +new Date()\n            const queryExecutionTime = queryEndTime - queryStartTime\n            if (\n                maxQueryExecutionTime &&\n                queryExecutionTime > maxQueryExecutionTime\n            )\n                this.driver.connection.logger.logQuerySlow(\n                    queryExecutionTime,\n                    query,\n                    parameters,\n                    this,\n                )\n\n            const result = new QueryResult()\n\n            result.raw = rawResult\n            result.records = rawResult ? rawResult[0] : []\n            if (rawResult && rawResult[1] && rawResult[1].rowCountExact) {\n                result.affected = parseInt(rawResult[1].rowCountExact)\n            }\n\n            if (!useStructuredResult) {\n                return result.records\n            }\n\n            return result\n        } catch (err) {\n            this.driver.connection.logger.logQueryError(\n                err,\n                query,\n                parameters,\n                this,\n            )\n            throw new QueryFailedError(query, parameters, err)\n        } finally {\n        }\n    }\n\n    /**\n     * Update database schema.\n     * Used for creating/altering/dropping tables, columns, indexes, etc.\n     *\n     * DDL changing queries should be executed by `updateSchema()` method.\n     */\n    async updateDDL(query: string, parameters?: any[]): Promise<void> {\n        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError()\n\n        this.driver.connection.logger.logQuery(query, parameters, this)\n        try {\n            const queryStartTime = +new Date()\n            const [operation] = await this.driver.instanceDatabase.updateSchema(\n                query,\n            )\n            await operation.promise()\n            // log slow queries if maxQueryExecution time is set\n            const maxQueryExecutionTime =\n                this.driver.options.maxQueryExecutionTime\n            const queryEndTime = +new Date()\n            const queryExecutionTime = queryEndTime - queryStartTime\n            if (\n                maxQueryExecutionTime &&\n                queryExecutionTime > maxQueryExecutionTime\n            )\n                this.driver.connection.logger.logQuerySlow(\n                    queryExecutionTime,\n                    query,\n                    parameters,\n                    this,\n                )\n        } catch (err) {\n            this.driver.connection.logger.logQueryError(\n                err,\n                query,\n                parameters,\n                this,\n            )\n            throw new QueryFailedError(query, parameters, err)\n        }\n    }\n\n    /**\n     * Returns raw data stream.\n     */\n    async stream(\n        query: string,\n        parameters?: any[],\n        onEnd?: Function,\n        onError?: Function,\n    ): Promise<ReadStream> {\n        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError()\n\n        try {\n            this.driver.connection.logger.logQuery(query, parameters, this)\n            const request = {\n                sql: query,\n                params: parameters\n                    ? parameters.reduce((params, value, index) => {\n                          params[\"param\" + index] = value\n                          return params\n                      }, {} as ObjectLiteral)\n                    : undefined,\n                json: true,\n            }\n            const stream = this.driver.instanceDatabase.runStream(request)\n\n            if (onEnd) {\n                stream.on(\"end\", onEnd)\n            }\n\n            if (onError) {\n                stream.on(\"error\", onError)\n            }\n\n            return stream\n        } catch (err) {\n            this.driver.connection.logger.logQueryError(\n                err,\n                query,\n                parameters,\n                this,\n            )\n            throw new QueryFailedError(query, parameters, err)\n        }\n    }\n\n    /**\n     * Returns all available database names including system databases.\n     */\n    async getDatabases(): Promise<string[]> {\n        return Promise.resolve([])\n    }\n\n    /**\n     * Returns all available schema names including system schemas.\n     * If database parameter specified, returns schemas of that database.\n     */\n    async getSchemas(database?: string): Promise<string[]> {\n        return Promise.resolve([])\n    }\n\n    /**\n     * Checks if database with the given name exist.\n     */\n    async hasDatabase(database: string): Promise<boolean> {\n        throw new TypeORMError(\n            `Check database queries are not supported by Spanner driver.`,\n        )\n    }\n\n    /**\n     * Loads currently using database\n     */\n    async getCurrentDatabase(): Promise<string> {\n        throw new TypeORMError(\n            `Check database queries are not supported by Spanner driver.`,\n        )\n    }\n\n    /**\n     * Checks if schema with the given name exist.\n     */\n    async hasSchema(schema: string): Promise<boolean> {\n        const result = await this.query(\n            `SELECT * FROM \"information_schema\".\"schemata\" WHERE \"schema_name\" = '${schema}'`,\n        )\n        return result.length ? true : false\n    }\n\n    /**\n     * Loads currently using database schema\n     */\n    async getCurrentSchema(): Promise<string> {\n        throw new TypeORMError(\n            `Check schema queries are not supported by Spanner driver.`,\n        )\n    }\n\n    /**\n     * Checks if table with the given name exist in the database.\n     */\n    async hasTable(tableOrName: Table | string): Promise<boolean> {\n        const tableName =\n            tableOrName instanceof Table ? tableOrName.name : tableOrName\n        const sql =\n            `SELECT * FROM \\`INFORMATION_SCHEMA\\`.\\`TABLES\\` ` +\n            `WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' AND \\`TABLE_TYPE\\` = 'BASE TABLE' ` +\n            `AND \\`TABLE_NAME\\` = '${tableName}'`\n        const result = await this.query(sql)\n        return result.length ? true : false\n    }\n\n    /**\n     * Checks if column with the given name exist in the given table.\n     */\n    async hasColumn(\n        tableOrName: Table | string,\n        columnName: string,\n    ): Promise<boolean> {\n        const tableName =\n            tableOrName instanceof Table ? tableOrName.name : tableOrName\n        const sql =\n            `SELECT * FROM \\`INFORMATION_SCHEMA\\`.\\`COLUMNS\\` ` +\n            `WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' ` +\n            `AND \\`TABLE_NAME\\` = '${tableName}' AND \\`COLUMN_NAME\\` = '${columnName}'`\n        const result = await this.query(sql)\n        return result.length ? true : false\n    }\n\n    /**\n     * Creates a new database.\n     * Note: Spanner does not support database creation inside a transaction block.\n     */\n    async createDatabase(\n        database: string,\n        ifNotExist?: boolean,\n    ): Promise<void> {\n        if (ifNotExist) {\n            const databaseAlreadyExists = await this.hasDatabase(database)\n\n            if (databaseAlreadyExists) return Promise.resolve()\n        }\n\n        const up = `CREATE DATABASE \"${database}\"`\n        const down = `DROP DATABASE \"${database}\"`\n        await this.executeQueries(new Query(up), new Query(down))\n    }\n\n    /**\n     * Drops database.\n     * Note: Spanner does not support database dropping inside a transaction block.\n     */\n    async dropDatabase(database: string, ifExist?: boolean): Promise<void> {\n        const up = ifExist\n            ? `DROP DATABASE IF EXISTS \"${database}\"`\n            : `DROP DATABASE \"${database}\"`\n        const down = `CREATE DATABASE \"${database}\"`\n        await this.executeQueries(new Query(up), new Query(down))\n    }\n\n    /**\n     * Creates a new table schema.\n     */\n    async createSchema(\n        schemaPath: string,\n        ifNotExist?: boolean,\n    ): Promise<void> {\n        return Promise.resolve()\n    }\n\n    /**\n     * Drops table schema.\n     */\n    async dropSchema(\n        schemaPath: string,\n        ifExist?: boolean,\n        isCascade?: boolean,\n    ): Promise<void> {\n        return Promise.resolve()\n    }\n\n    /**\n     * Creates a new table.\n     */\n    async createTable(\n        table: Table,\n        ifNotExist: boolean = false,\n        createForeignKeys: boolean = true,\n        createIndices: boolean = true,\n    ): Promise<void> {\n        if (ifNotExist) {\n            const isTableExist = await this.hasTable(table)\n            if (isTableExist) return Promise.resolve()\n        }\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        upQueries.push(this.createTableSql(table, createForeignKeys))\n        downQueries.push(this.dropTableSql(table))\n\n        // if createForeignKeys is true, we must drop created foreign keys in down query.\n        // createTable does not need separate method to create foreign keys, because it create fk's in the same query with table creation.\n        if (createForeignKeys)\n            table.foreignKeys.forEach((foreignKey) =>\n                downQueries.push(this.dropForeignKeySql(table, foreignKey)),\n            )\n\n        if (createIndices) {\n            table.indices.forEach((index) => {\n                // new index may be passed without name. In this case we generate index name manually.\n                if (!index.name)\n                    index.name = this.connection.namingStrategy.indexName(\n                        table,\n                        index.columnNames,\n                        index.where,\n                    )\n                upQueries.push(this.createIndexSql(table, index))\n                downQueries.push(this.dropIndexSql(table, index))\n            })\n        }\n\n        // if table has column with generated type, we must add the expression to the metadata table\n        const generatedColumns = table.columns.filter(\n            (column) => column.generatedType && column.asExpression,\n        )\n\n        for (const column of generatedColumns) {\n            const insertQuery = this.insertTypeormMetadataSql({\n                table: table.name,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n                value: column.asExpression,\n            })\n\n            const deleteQuery = this.deleteTypeormMetadataSql({\n                table: table.name,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n            })\n\n            upQueries.push(insertQuery)\n            downQueries.push(deleteQuery)\n        }\n\n        await this.executeQueries(upQueries, downQueries)\n    }\n\n    /**\n     * Drops the table.\n     */\n    async dropTable(\n        target: Table | string,\n        ifExist?: boolean,\n        dropForeignKeys: boolean = true,\n        dropIndices: boolean = true,\n    ): Promise<void> {\n        // It needs because if table does not exist and dropForeignKeys or dropIndices is true, we don't need\n        // to perform drop queries for foreign keys and indices.\n        if (ifExist) {\n            const isTableExist = await this.hasTable(target)\n            if (!isTableExist) return Promise.resolve()\n        }\n\n        // if dropTable called with dropForeignKeys = true, we must create foreign keys in down query.\n        const createForeignKeys: boolean = dropForeignKeys\n        const tablePath = this.getTablePath(target)\n        const table = await this.getCachedTable(tablePath)\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        if (dropIndices) {\n            table.indices.forEach((index) => {\n                upQueries.push(this.dropIndexSql(table, index))\n                downQueries.push(this.createIndexSql(table, index))\n            })\n        }\n\n        if (dropForeignKeys)\n            table.foreignKeys.forEach((foreignKey) =>\n                upQueries.push(this.dropForeignKeySql(table, foreignKey)),\n            )\n\n        upQueries.push(this.dropTableSql(table))\n        downQueries.push(this.createTableSql(table, createForeignKeys))\n\n        // if table had columns with generated type, we must remove the expression from the metadata table\n        const generatedColumns = table.columns.filter(\n            (column) => column.generatedType && column.asExpression,\n        )\n\n        for (const column of generatedColumns) {\n            const deleteQuery = this.deleteTypeormMetadataSql({\n                table: table.name,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n            })\n\n            const insertQuery = this.insertTypeormMetadataSql({\n                table: table.name,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n                value: column.asExpression,\n            })\n\n            upQueries.push(deleteQuery)\n            downQueries.push(insertQuery)\n        }\n\n        await this.executeQueries(upQueries, downQueries)\n    }\n\n    /**\n     * Creates a new view.\n     */\n    async createView(view: View): Promise<void> {\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n        upQueries.push(this.createViewSql(view))\n        upQueries.push(await this.insertViewDefinitionSql(view))\n        downQueries.push(this.dropViewSql(view))\n        downQueries.push(await this.deleteViewDefinitionSql(view))\n        await this.executeQueries(upQueries, downQueries)\n    }\n\n    /**\n     * Drops the view.\n     */\n    async dropView(target: View | string): Promise<void> {\n        const viewName = target instanceof View ? target.name : target\n        const view = await this.getCachedView(viewName)\n\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n        upQueries.push(await this.deleteViewDefinitionSql(view))\n        upQueries.push(this.dropViewSql(view))\n        downQueries.push(await this.insertViewDefinitionSql(view))\n        downQueries.push(this.createViewSql(view))\n        await this.executeQueries(upQueries, downQueries)\n    }\n\n    /**\n     * Renames the given table.\n     */\n    async renameTable(\n        oldTableOrName: Table | string,\n        newTableName: string,\n    ): Promise<void> {\n        throw new TypeORMError(\n            `Rename table queries are not supported by Spanner driver.`,\n        )\n    }\n\n    /**\n     * Creates a new column from the column in the table.\n     */\n    async addColumn(\n        tableOrName: Table | string,\n        column: TableColumn,\n    ): Promise<void> {\n        const table =\n            tableOrName instanceof Table\n                ? tableOrName\n                : await this.getCachedTable(tableOrName)\n        const clonedTable = table.clone()\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        upQueries.push(\n            new Query(\n                `ALTER TABLE ${this.escapePath(\n                    table,\n                )} ADD ${this.buildCreateColumnSql(column)}`,\n            ),\n        )\n        downQueries.push(\n            new Query(\n                `ALTER TABLE ${this.escapePath(\n                    table,\n                )} DROP COLUMN ${this.driver.escape(column.name)}`,\n            ),\n        )\n\n        // create column index\n        const columnIndex = clonedTable.indices.find(\n            (index) =>\n                index.columnNames.length === 1 &&\n                index.columnNames[0] === column.name,\n        )\n        if (columnIndex) {\n            upQueries.push(this.createIndexSql(table, columnIndex))\n            downQueries.push(this.dropIndexSql(table, columnIndex))\n        } else if (column.isUnique) {\n            const uniqueIndex = new TableIndex({\n                name: this.connection.namingStrategy.indexName(table, [\n                    column.name,\n                ]),\n                columnNames: [column.name],\n                isUnique: true,\n            })\n            clonedTable.indices.push(uniqueIndex)\n            clonedTable.uniques.push(\n                new TableUnique({\n                    name: uniqueIndex.name,\n                    columnNames: uniqueIndex.columnNames,\n                }),\n            )\n\n            upQueries.push(this.createIndexSql(table, uniqueIndex))\n            downQueries.push(this.dropIndexSql(table, uniqueIndex))\n        }\n\n        if (column.generatedType && column.asExpression) {\n            const insertQuery = this.insertTypeormMetadataSql({\n                table: table.name,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n                value: column.asExpression,\n            })\n\n            const deleteQuery = this.deleteTypeormMetadataSql({\n                table: table.name,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n            })\n\n            upQueries.push(insertQuery)\n            downQueries.push(deleteQuery)\n        }\n\n        await this.executeQueries(upQueries, downQueries)\n\n        clonedTable.addColumn(column)\n        this.replaceCachedTable(table, clonedTable)\n    }\n\n    /**\n     * Creates a new columns from the column in the table.\n     */\n    async addColumns(\n        tableOrName: Table | string,\n        columns: TableColumn[],\n    ): Promise<void> {\n        for (const column of columns) {\n            await this.addColumn(tableOrName, column)\n        }\n    }\n\n    /**\n     * Renames column in the given table.\n     */\n    async renameColumn(\n        tableOrName: Table | string,\n        oldTableColumnOrName: TableColumn | string,\n        newTableColumnOrName: TableColumn | string,\n    ): Promise<void> {\n        const table =\n            tableOrName instanceof Table\n                ? tableOrName\n                : await this.getCachedTable(tableOrName)\n        const oldColumn =\n            oldTableColumnOrName instanceof TableColumn\n                ? oldTableColumnOrName\n                : table.columns.find((c) => c.name === oldTableColumnOrName)\n        if (!oldColumn)\n            throw new TypeORMError(\n                `Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`,\n            )\n\n        let newColumn\n        if (newTableColumnOrName instanceof TableColumn) {\n            newColumn = newTableColumnOrName\n        } else {\n            newColumn = oldColumn.clone()\n            newColumn.name = newTableColumnOrName\n        }\n\n        return this.changeColumn(table, oldColumn, newColumn)\n    }\n\n    /**\n     * Changes a column in the table.\n     */\n    async changeColumn(\n        tableOrName: Table | string,\n        oldTableColumnOrName: TableColumn | string,\n        newColumn: TableColumn,\n    ): Promise<void> {\n        const table =\n            tableOrName instanceof Table\n                ? tableOrName\n                : await this.getCachedTable(tableOrName)\n        let clonedTable = table.clone()\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        const oldColumn =\n            oldTableColumnOrName instanceof TableColumn\n                ? oldTableColumnOrName\n                : table.columns.find(\n                      (column) => column.name === oldTableColumnOrName,\n                  )\n        if (!oldColumn)\n            throw new TypeORMError(\n                `Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`,\n            )\n\n        if (\n            oldColumn.name !== newColumn.name ||\n            oldColumn.type !== newColumn.type ||\n            oldColumn.length !== newColumn.length ||\n            oldColumn.isArray !== newColumn.isArray ||\n            oldColumn.generatedType !== newColumn.generatedType ||\n            oldColumn.asExpression !== newColumn.asExpression\n        ) {\n            // To avoid data conversion, we just recreate column\n            await this.dropColumn(table, oldColumn)\n            await this.addColumn(table, newColumn)\n\n            // update cloned table\n            clonedTable = table.clone()\n        } else {\n            if (\n                newColumn.precision !== oldColumn.precision ||\n                newColumn.scale !== oldColumn.scale\n            ) {\n                upQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${\n                            newColumn.name\n                        }\" TYPE ${this.driver.createFullType(newColumn)}`,\n                    ),\n                )\n                downQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${\n                            newColumn.name\n                        }\" TYPE ${this.driver.createFullType(oldColumn)}`,\n                    ),\n                )\n            }\n\n            if (oldColumn.isNullable !== newColumn.isNullable) {\n                if (newColumn.isNullable) {\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ALTER COLUMN \"${oldColumn.name}\" DROP NOT NULL`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ALTER COLUMN \"${oldColumn.name}\" SET NOT NULL`,\n                        ),\n                    )\n                } else {\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ALTER COLUMN \"${oldColumn.name}\" SET NOT NULL`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ALTER COLUMN \"${oldColumn.name}\" DROP NOT NULL`,\n                        ),\n                    )\n                }\n            }\n\n            if (newColumn.isUnique !== oldColumn.isUnique) {\n                if (newColumn.isUnique === true) {\n                    const uniqueIndex = new TableIndex({\n                        name: this.connection.namingStrategy.indexName(table, [\n                            newColumn.name,\n                        ]),\n                        columnNames: [newColumn.name],\n                        isUnique: true,\n                    })\n                    clonedTable.indices.push(uniqueIndex)\n                    clonedTable.uniques.push(\n                        new TableUnique({\n                            name: uniqueIndex.name,\n                            columnNames: uniqueIndex.columnNames,\n                        }),\n                    )\n\n                    upQueries.push(this.createIndexSql(table, uniqueIndex))\n                    downQueries.push(this.dropIndexSql(table, uniqueIndex))\n                } else {\n                    const uniqueIndex = clonedTable.indices.find((index) => {\n                        return (\n                            index.columnNames.length === 1 &&\n                            index.isUnique === true &&\n                            !!index.columnNames.find(\n                                (columnName) => columnName === newColumn.name,\n                            )\n                        )\n                    })\n                    clonedTable.indices.splice(\n                        clonedTable.indices.indexOf(uniqueIndex!),\n                        1,\n                    )\n\n                    const tableUnique = clonedTable.uniques.find(\n                        (unique) => unique.name === uniqueIndex!.name,\n                    )\n                    clonedTable.uniques.splice(\n                        clonedTable.uniques.indexOf(tableUnique!),\n                        1,\n                    )\n\n                    upQueries.push(this.dropIndexSql(table, uniqueIndex!))\n                    downQueries.push(this.createIndexSql(table, uniqueIndex!))\n                }\n            }\n        }\n\n        await this.executeQueries(upQueries, downQueries)\n        this.replaceCachedTable(table, clonedTable)\n    }\n\n    /**\n     * Changes a column in the table.\n     */\n    async changeColumns(\n        tableOrName: Table | string,\n        changedColumns: { newColumn: TableColumn; oldColumn: TableColumn }[],\n    ): Promise<void> {\n        for (const { oldColumn, newColumn } of changedColumns) {\n            await this.changeColumn(tableOrName, oldColumn, newColumn)\n        }\n    }\n\n    /**\n     * Drops column in the table.\n     */\n    async dropColumn(\n        tableOrName: Table | string,\n        columnOrName: TableColumn | string,\n    ): Promise<void> {\n        const table =\n            tableOrName instanceof Table\n                ? tableOrName\n                : await this.getCachedTable(tableOrName)\n        const column =\n            columnOrName instanceof TableColumn\n                ? columnOrName\n                : table.findColumnByName(columnOrName)\n        if (!column)\n            throw new TypeORMError(\n                `Column \"${columnOrName}\" was not found in table \"${table.name}\"`,\n            )\n\n        const clonedTable = table.clone()\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        // drop column index\n        const columnIndex = clonedTable.indices.find(\n            (index) =>\n                index.columnNames.length === 1 &&\n                index.columnNames[0] === column.name,\n        )\n        if (columnIndex) {\n            clonedTable.indices.splice(\n                clonedTable.indices.indexOf(columnIndex),\n                1,\n            )\n            upQueries.push(this.dropIndexSql(table, columnIndex))\n            downQueries.push(this.createIndexSql(table, columnIndex))\n        }\n\n        // drop column check\n        const columnCheck = clonedTable.checks.find(\n            (check) =>\n                !!check.columnNames &&\n                check.columnNames.length === 1 &&\n                check.columnNames[0] === column.name,\n        )\n        if (columnCheck) {\n            clonedTable.checks.splice(\n                clonedTable.checks.indexOf(columnCheck),\n                1,\n            )\n            upQueries.push(this.dropCheckConstraintSql(table, columnCheck))\n            downQueries.push(this.createCheckConstraintSql(table, columnCheck))\n        }\n\n        upQueries.push(\n            new Query(\n                `ALTER TABLE ${this.escapePath(\n                    table,\n                )} DROP COLUMN ${this.driver.escape(column.name)}`,\n            ),\n        )\n        downQueries.push(\n            new Query(\n                `ALTER TABLE ${this.escapePath(\n                    table,\n                )} ADD ${this.buildCreateColumnSql(column)}`,\n            ),\n        )\n\n        if (column.generatedType && column.asExpression) {\n            const deleteQuery = this.deleteTypeormMetadataSql({\n                table: table.name,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n            })\n            const insertQuery = this.insertTypeormMetadataSql({\n                table: table.name,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n                value: column.asExpression,\n            })\n\n            upQueries.push(deleteQuery)\n            downQueries.push(insertQuery)\n        }\n\n        await this.executeQueries(upQueries, downQueries)\n\n        clonedTable.removeColumn(column)\n        this.replaceCachedTable(table, clonedTable)\n    }\n\n    /**\n     * Drops the columns in the table.\n     */\n    async dropColumns(\n        tableOrName: Table | string,\n        columns: TableColumn[] | string[],\n    ): Promise<void> {\n        for (const column of columns) {\n            await this.dropColumn(tableOrName, column)\n        }\n    }\n\n    /**\n     * Creates a new primary key.\n     *\n     * Not supported in Spanner.\n     * @see https://cloud.google.com/spanner/docs/schema-and-data-model#notes_about_key_columns\n     */\n    async createPrimaryKey(\n        tableOrName: Table | string,\n        columnNames: string[],\n    ): Promise<void> {\n        throw new Error(\n            \"The keys of a table can't change; you can't add a key column to an existing table or remove a key column from an existing table.\",\n        )\n    }\n\n    /**\n     * Updates composite primary keys.\n     */\n    async updatePrimaryKeys(\n        tableOrName: Table | string,\n        columns: TableColumn[],\n    ): Promise<void> {\n        throw new Error(\n            \"The keys of a table can't change; you can't add a key column to an existing table or remove a key column from an existing table.\",\n        )\n    }\n\n    /**\n     * Creates a new primary key.\n     *\n     * Not supported in Spanner.\n     * @see https://cloud.google.com/spanner/docs/schema-and-data-model#notes_about_key_columns\n     */\n    async dropPrimaryKey(tableOrName: Table | string): Promise<void> {\n        throw new Error(\n            \"The keys of a table can't change; you can't add a key column to an existing table or remove a key column from an existing table.\",\n        )\n    }\n\n    /**\n     * Creates new unique constraint.\n     */\n    async createUniqueConstraint(\n        tableOrName: Table | string,\n        uniqueConstraint: TableUnique,\n    ): Promise<void> {\n        throw new TypeORMError(\n            `Spanner does not support unique constraints. Use unique index instead.`,\n        )\n    }\n\n    /**\n     * Creates new unique constraints.\n     */\n    async createUniqueConstraints(\n        tableOrName: Table | string,\n        uniqueConstraints: TableUnique[],\n    ): Promise<void> {\n        throw new TypeORMError(\n            `Spanner does not support unique constraints. Use unique index instead.`,\n        )\n    }\n\n    /**\n     * Drops unique constraint.\n     */\n    async dropUniqueConstraint(\n        tableOrName: Table | string,\n        uniqueOrName: TableUnique | string,\n    ): Promise<void> {\n        throw new TypeORMError(\n            `Spanner does not support unique constraints. Use unique index instead.`,\n        )\n    }\n\n    /**\n     * Drops unique constraints.\n     */\n    async dropUniqueConstraints(\n        tableOrName: Table | string,\n        uniqueConstraints: TableUnique[],\n    ): Promise<void> {\n        throw new TypeORMError(\n            `Spanner does not support unique constraints. Use unique index instead.`,\n        )\n    }\n\n    /**\n     * Creates new check constraint.\n     */\n    async createCheckConstraint(\n        tableOrName: Table | string,\n        checkConstraint: TableCheck,\n    ): Promise<void> {\n        const table =\n            tableOrName instanceof Table\n                ? tableOrName\n                : await this.getCachedTable(tableOrName)\n\n        // new check constraint may be passed without name. In this case we generate unique name manually.\n        if (!checkConstraint.name)\n            checkConstraint.name =\n                this.connection.namingStrategy.checkConstraintName(\n                    table,\n                    checkConstraint.expression!,\n                )\n\n        const up = this.createCheckConstraintSql(table, checkConstraint)\n        const down = this.dropCheckConstraintSql(table, checkConstraint)\n        await this.executeQueries(up, down)\n        table.addCheckConstraint(checkConstraint)\n    }\n\n    /**\n     * Creates new check constraints.\n     */\n    async createCheckConstraints(\n        tableOrName: Table | string,\n        checkConstraints: TableCheck[],\n    ): Promise<void> {\n        const promises = checkConstraints.map((checkConstraint) =>\n            this.createCheckConstraint(tableOrName, checkConstraint),\n        )\n        await Promise.all(promises)\n    }\n\n    /**\n     * Drops check constraint.\n     */\n    async dropCheckConstraint(\n        tableOrName: Table | string,\n        checkOrName: TableCheck | string,\n    ): Promise<void> {\n        const table =\n            tableOrName instanceof Table\n                ? tableOrName\n                : await this.getCachedTable(tableOrName)\n        const checkConstraint =\n            checkOrName instanceof TableCheck\n                ? checkOrName\n                : table.checks.find((c) => c.name === checkOrName)\n        if (!checkConstraint)\n            throw new TypeORMError(\n                `Supplied check constraint was not found in table ${table.name}`,\n            )\n\n        const up = this.dropCheckConstraintSql(table, checkConstraint)\n        const down = this.createCheckConstraintSql(table, checkConstraint)\n        await this.executeQueries(up, down)\n        table.removeCheckConstraint(checkConstraint)\n    }\n\n    /**\n     * Drops check constraints.\n     */\n    async dropCheckConstraints(\n        tableOrName: Table | string,\n        checkConstraints: TableCheck[],\n    ): Promise<void> {\n        const promises = checkConstraints.map((checkConstraint) =>\n            this.dropCheckConstraint(tableOrName, checkConstraint),\n        )\n        await Promise.all(promises)\n    }\n\n    /**\n     * Creates new exclusion constraint.\n     */\n    async createExclusionConstraint(\n        tableOrName: Table | string,\n        exclusionConstraint: TableExclusion,\n    ): Promise<void> {\n        throw new TypeORMError(\n            `Spanner does not support exclusion constraints.`,\n        )\n    }\n\n    /**\n     * Creates new exclusion constraints.\n     */\n    async createExclusionConstraints(\n        tableOrName: Table | string,\n        exclusionConstraints: TableExclusion[],\n    ): Promise<void> {\n        throw new TypeORMError(\n            `Spanner does not support exclusion constraints.`,\n        )\n    }\n\n    /**\n     * Drops exclusion constraint.\n     */\n    async dropExclusionConstraint(\n        tableOrName: Table | string,\n        exclusionOrName: TableExclusion | string,\n    ): Promise<void> {\n        throw new TypeORMError(\n            `Spanner does not support exclusion constraints.`,\n        )\n    }\n\n    /**\n     * Drops exclusion constraints.\n     */\n    async dropExclusionConstraints(\n        tableOrName: Table | string,\n        exclusionConstraints: TableExclusion[],\n    ): Promise<void> {\n        throw new TypeORMError(\n            `Spanner does not support exclusion constraints.`,\n        )\n    }\n\n    /**\n     * Creates a new foreign key.\n     */\n    async createForeignKey(\n        tableOrName: Table | string,\n        foreignKey: TableForeignKey,\n    ): Promise<void> {\n        const table =\n            tableOrName instanceof Table\n                ? tableOrName\n                : await this.getCachedTable(tableOrName)\n\n        // new FK may be passed without name. In this case we generate FK name manually.\n        if (!foreignKey.name)\n            foreignKey.name = this.connection.namingStrategy.foreignKeyName(\n                table,\n                foreignKey.columnNames,\n                this.getTablePath(foreignKey),\n                foreignKey.referencedColumnNames,\n            )\n\n        const up = this.createForeignKeySql(table, foreignKey)\n        const down = this.dropForeignKeySql(table, foreignKey)\n        await this.executeQueries(up, down)\n        table.addForeignKey(foreignKey)\n    }\n\n    /**\n     * Creates a new foreign keys.\n     */\n    async createForeignKeys(\n        tableOrName: Table | string,\n        foreignKeys: TableForeignKey[],\n    ): Promise<void> {\n        for (const foreignKey of foreignKeys) {\n            await this.createForeignKey(tableOrName, foreignKey)\n        }\n    }\n\n    /**\n     * Drops a foreign key from the table.\n     */\n    async dropForeignKey(\n        tableOrName: Table | string,\n        foreignKeyOrName: TableForeignKey | string,\n    ): Promise<void> {\n        const table =\n            tableOrName instanceof Table\n                ? tableOrName\n                : await this.getCachedTable(tableOrName)\n        const foreignKey =\n            foreignKeyOrName instanceof TableForeignKey\n                ? foreignKeyOrName\n                : table.foreignKeys.find((fk) => fk.name === foreignKeyOrName)\n        if (!foreignKey)\n            throw new TypeORMError(\n                `Supplied foreign key was not found in table ${table.name}`,\n            )\n\n        const up = this.dropForeignKeySql(table, foreignKey)\n        const down = this.createForeignKeySql(table, foreignKey)\n        await this.executeQueries(up, down)\n        table.removeForeignKey(foreignKey)\n    }\n\n    /**\n     * Drops a foreign keys from the table.\n     */\n    async dropForeignKeys(\n        tableOrName: Table | string,\n        foreignKeys: TableForeignKey[],\n    ): Promise<void> {\n        for (const foreignKey of foreignKeys) {\n            await this.dropForeignKey(tableOrName, foreignKey)\n        }\n    }\n\n    /**\n     * Creates a new index.\n     */\n    async createIndex(\n        tableOrName: Table | string,\n        index: TableIndex,\n    ): Promise<void> {\n        const table =\n            tableOrName instanceof Table\n                ? tableOrName\n                : await this.getCachedTable(tableOrName)\n\n        // new index may be passed without name. In this case we generate index name manually.\n        if (!index.name) index.name = this.generateIndexName(table, index)\n\n        const up = this.createIndexSql(table, index)\n        const down = this.dropIndexSql(table, index)\n        await this.executeQueries(up, down)\n        table.addIndex(index)\n    }\n\n    /**\n     * Creates a new indices\n     */\n    async createIndices(\n        tableOrName: Table | string,\n        indices: TableIndex[],\n    ): Promise<void> {\n        for (const index of indices) {\n            await this.createIndex(tableOrName, index)\n        }\n    }\n\n    /**\n     * Drops an index from the table.\n     */\n    async dropIndex(\n        tableOrName: Table | string,\n        indexOrName: TableIndex | string,\n    ): Promise<void> {\n        const table =\n            tableOrName instanceof Table\n                ? tableOrName\n                : await this.getCachedTable(tableOrName)\n        const index =\n            indexOrName instanceof TableIndex\n                ? indexOrName\n                : table.indices.find((i) => i.name === indexOrName)\n        if (!index)\n            throw new TypeORMError(\n                `Supplied index ${indexOrName} was not found in table ${table.name}`,\n            )\n\n        // new index may be passed without name. In this case we generate index name manually.\n        if (!index.name) index.name = this.generateIndexName(table, index)\n\n        const up = this.dropIndexSql(table, index)\n        const down = this.createIndexSql(table, index)\n        await this.executeQueries(up, down)\n        table.removeIndex(index)\n    }\n\n    /**\n     * Drops an indices from the table.\n     */\n    async dropIndices(\n        tableOrName: Table | string,\n        indices: TableIndex[],\n    ): Promise<void> {\n        for (const index of indices) {\n            await this.dropIndex(tableOrName, index)\n        }\n    }\n\n    /**\n     * Clears all table contents.\n     * Spanner does not support TRUNCATE TABLE statement, so we use DELETE FROM.\n     */\n    async clearTable(tableName: string): Promise<void> {\n        await this.query(`DELETE FROM ${this.escapePath(tableName)} WHERE true`)\n    }\n\n    /**\n     * Removes all tables from the currently connected database.\n     */\n    async clearDatabase(): Promise<void> {\n        // drop index queries\n        const selectIndexDropsQuery =\n            `SELECT concat('DROP INDEX \\`', INDEX_NAME, '\\`') AS \\`query\\` ` +\n            `FROM \\`INFORMATION_SCHEMA\\`.\\`INDEXES\\` ` +\n            `WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' AND \\`INDEX_TYPE\\` = 'INDEX' AND \\`SPANNER_IS_MANAGED\\` = false`\n        const dropIndexQueries: ObjectLiteral[] = await this.query(\n            selectIndexDropsQuery,\n        )\n\n        // drop foreign key queries\n        const selectFKDropsQuery =\n            `SELECT concat('ALTER TABLE \\`', TABLE_NAME, '\\`', ' DROP CONSTRAINT \\`', CONSTRAINT_NAME, '\\`') AS \\`query\\` ` +\n            `FROM \\`INFORMATION_SCHEMA\\`.\\`TABLE_CONSTRAINTS\\` ` +\n            `WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' AND \\`CONSTRAINT_TYPE\\` = 'FOREIGN KEY'`\n        const dropFKQueries: ObjectLiteral[] = await this.query(\n            selectFKDropsQuery,\n        )\n\n        // drop view queries\n        // const selectViewDropsQuery = `SELECT concat('DROP VIEW \\`', TABLE_NAME, '\\`') AS \\`query\\` FROM \\`INFORMATION_SCHEMA\\`.\\`VIEWS\\``\n        // const dropViewQueries: ObjectLiteral[] = await this.query(\n        //     selectViewDropsQuery,\n        // )\n\n        // drop table queries\n        const dropTablesQuery =\n            `SELECT concat('DROP TABLE \\`', TABLE_NAME, '\\`') AS \\`query\\` ` +\n            `FROM \\`INFORMATION_SCHEMA\\`.\\`TABLES\\` ` +\n            `WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' AND \\`TABLE_TYPE\\` = 'BASE TABLE'`\n        const dropTableQueries: ObjectLiteral[] = await this.query(\n            dropTablesQuery,\n        )\n\n        if (\n            !dropIndexQueries.length &&\n            !dropFKQueries.length &&\n            // !dropViewQueries.length &&\n            !dropTableQueries.length\n        )\n            return\n\n        const isAnotherTransactionActive = this.isTransactionActive\n        if (!isAnotherTransactionActive) await this.startTransaction()\n        try {\n            for (let query of dropIndexQueries) {\n                await this.updateDDL(query[\"query\"])\n            }\n            for (let query of dropFKQueries) {\n                await this.updateDDL(query[\"query\"])\n            }\n\n            // for (let query of dropViewQueries) {\n            //     await this.updateDDL(query[\"query\"])\n            // }\n\n            for (let query of dropTableQueries) {\n                await this.updateDDL(query[\"query\"])\n            }\n\n            await this.commitTransaction()\n        } catch (error) {\n            try {\n                // we throw original error even if rollback thrown an error\n                if (!isAnotherTransactionActive)\n                    await this.rollbackTransaction()\n            } catch (rollbackError) {}\n            throw error\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Override Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Executes up sql queries.\n     */\n    async executeMemoryUpSql(): Promise<void> {\n        for (const { query, parameters } of this.sqlInMemory.upQueries) {\n            if (this.isDMLQuery(query)) {\n                await this.query(query, parameters)\n            } else {\n                await this.updateDDL(query, parameters)\n            }\n        }\n    }\n\n    /**\n     * Executes down sql queries.\n     */\n    async executeMemoryDownSql(): Promise<void> {\n        for (const {\n            query,\n            parameters,\n        } of this.sqlInMemory.downQueries.reverse()) {\n            if (this.isDMLQuery(query)) {\n                await this.query(query, parameters)\n            } else {\n                await this.updateDDL(query, parameters)\n            }\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    protected async loadViews(viewNames?: string[]): Promise<View[]> {\n        // const hasTable = await this.hasTable(this.getTypeormMetadataTableName())\n        // if (!hasTable) {\n        //     return []\n        // }\n        //\n        // if (!viewNames) {\n        //     viewNames = []\n        // }\n        //\n        // const escapedViewNames = viewNames\n        //     .map((viewName) => `'${viewName}'`)\n        //     .join(\", \")\n        //\n        // const query =\n        //     `SELECT \\`T\\`.*, \\`V\\`.\\`VIEW_DEFINITION\\` FROM ${this.escapePath(\n        //         this.getTypeormMetadataTableName(),\n        //     )} \\`T\\` ` +\n        //     `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`VIEWS\\` \\`V\\` ON \\`V\\`.\\`TABLE_NAME\\` = \\`T\\`.\\`NAME\\` ` +\n        //     `WHERE \\`T\\`.\\`TYPE\\` = '${MetadataTableType.VIEW}' ${\n        //         viewNames.length\n        //             ? ` AND \\`T\\`.\\`NAME\\` IN (${escapedViewNames})`\n        //             : \"\"\n        //     }`\n        // const dbViews = await this.query(query)\n        // return dbViews.map((dbView: any) => {\n        //     const view = new View()\n        //     view.database = dbView[\"NAME\"]\n        //     view.name = this.driver.buildTableName(dbView[\"NAME\"])\n        //     view.expression = dbView[\"NAME\"]\n        //     return view\n        // })\n\n        return Promise.resolve([])\n    }\n\n    /**\n     * Loads all tables (with given names) from the database and creates a Table from them.\n     */\n    protected async loadTables(tableNames?: string[]): Promise<Table[]> {\n        if (tableNames && tableNames.length === 0) {\n            return []\n        }\n\n        const dbTables: { TABLE_NAME: string }[] = []\n\n        if (!tableNames || !tableNames.length) {\n            // Since we don't have any of this data we have to do a scan\n            const tablesSql =\n                `SELECT \\`TABLE_NAME\\` ` +\n                `FROM \\`INFORMATION_SCHEMA\\`.\\`TABLES\\` ` +\n                `WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' AND \\`TABLE_TYPE\\` = 'BASE TABLE'`\n            dbTables.push(...(await this.query(tablesSql)))\n        } else {\n            const tablesSql =\n                `SELECT \\`TABLE_NAME\\` ` +\n                `FROM \\`INFORMATION_SCHEMA\\`.\\`TABLES\\` ` +\n                `WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' AND \\`TABLE_TYPE\\` = 'BASE TABLE' ` +\n                `AND \\`TABLE_NAME\\` IN (${tableNames\n                    .map((tableName) => `'${tableName}'`)\n                    .join(\", \")})`\n\n            dbTables.push(...(await this.query(tablesSql)))\n        }\n\n        // if tables were not found in the db, no need to proceed\n        if (!dbTables.length) return []\n\n        const loadedTableNames = dbTables\n            .map((dbTable) => `'${dbTable.TABLE_NAME}'`)\n            .join(\", \")\n\n        const columnsSql = `SELECT * FROM \\`INFORMATION_SCHEMA\\`.\\`COLUMNS\\` WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' AND \\`TABLE_NAME\\` IN (${loadedTableNames})`\n\n        const primaryKeySql =\n            `SELECT \\`KCU\\`.\\`TABLE_NAME\\`, \\`KCU\\`.\\`COLUMN_NAME\\` ` +\n            `FROM \\`INFORMATION_SCHEMA\\`.\\`TABLE_CONSTRAINTS\\` \\`TC\\` ` +\n            `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`KEY_COLUMN_USAGE\\` \\`KCU\\` ON \\`KCU\\`.\\`CONSTRAINT_NAME\\` = \\`TC\\`.\\`CONSTRAINT_NAME\\` ` +\n            `WHERE \\`TC\\`.\\`TABLE_CATALOG\\` = '' AND \\`TC\\`.\\`TABLE_SCHEMA\\` = '' AND \\`TC\\`.\\`CONSTRAINT_TYPE\\` = 'PRIMARY KEY' ` +\n            `AND \\`TC\\`.\\`TABLE_NAME\\` IN (${loadedTableNames})`\n\n        const indicesSql =\n            `SELECT \\`I\\`.\\`TABLE_NAME\\`, \\`I\\`.\\`INDEX_NAME\\`, \\`I\\`.\\`IS_UNIQUE\\`, \\`I\\`.\\`IS_NULL_FILTERED\\`, \\`IC\\`.\\`COLUMN_NAME\\` ` +\n            `FROM \\`INFORMATION_SCHEMA\\`.\\`INDEXES\\` \\`I\\` ` +\n            `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`INDEX_COLUMNS\\` \\`IC\\` ON \\`IC\\`.\\`INDEX_NAME\\` = \\`I\\`.\\`INDEX_NAME\\` ` +\n            `AND \\`IC\\`.\\`TABLE_NAME\\` = \\`I\\`.\\`TABLE_NAME\\` ` +\n            `WHERE \\`I\\`.\\`TABLE_CATALOG\\` = '' AND \\`I\\`.\\`TABLE_SCHEMA\\` = '' AND \\`I\\`.\\`TABLE_NAME\\` IN (${loadedTableNames}) ` +\n            `AND \\`I\\`.\\`INDEX_TYPE\\` = 'INDEX' AND \\`I\\`.\\`SPANNER_IS_MANAGED\\` = false`\n\n        const checksSql =\n            `SELECT \\`TC\\`.\\`TABLE_NAME\\`, \\`TC\\`.\\`CONSTRAINT_NAME\\`, \\`CC\\`.\\`CHECK_CLAUSE\\`, \\`CCU\\`.\\`COLUMN_NAME\\`` +\n            `FROM \\`INFORMATION_SCHEMA\\`.\\`TABLE_CONSTRAINTS\\` \\`TC\\` ` +\n            `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`CONSTRAINT_COLUMN_USAGE\\` \\`CCU\\` ON \\`CCU\\`.\\`CONSTRAINT_NAME\\` = \\`TC\\`.\\`CONSTRAINT_NAME\\` ` +\n            `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`CHECK_CONSTRAINTS\\` \\`CC\\` ON \\`CC\\`.\\`CONSTRAINT_NAME\\` = \\`TC\\`.\\`CONSTRAINT_NAME\\` ` +\n            `WHERE \\`TC\\`.\\`TABLE_CATALOG\\` = '' AND \\`TC\\`.\\`TABLE_SCHEMA\\` = '' AND \\`TC\\`.\\`CONSTRAINT_TYPE\\` = 'CHECK' ` +\n            `AND \\`TC\\`.\\`TABLE_NAME\\` IN (${loadedTableNames}) AND \\`TC\\`.\\`CONSTRAINT_NAME\\` NOT LIKE 'CK_IS_NOT_NULL%'`\n\n        const foreignKeysSql =\n            `SELECT \\`TC\\`.\\`TABLE_NAME\\`, \\`TC\\`.\\`CONSTRAINT_NAME\\`, \\`KCU\\`.\\`COLUMN_NAME\\`, ` +\n            `\\`CTU\\`.\\`TABLE_NAME\\` AS \\`REFERENCED_TABLE_NAME\\`, \\`CCU\\`.\\`COLUMN_NAME\\` AS \\`REFERENCED_COLUMN_NAME\\`, ` +\n            `\\`RC\\`.\\`UPDATE_RULE\\`, \\`RC\\`.\\`DELETE_RULE\\` ` +\n            `FROM \\`INFORMATION_SCHEMA\\`.\\`TABLE_CONSTRAINTS\\` \\`TC\\` ` +\n            `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`KEY_COLUMN_USAGE\\` \\`KCU\\` ON \\`KCU\\`.\\`CONSTRAINT_NAME\\` = \\`TC\\`.\\`CONSTRAINT_NAME\\` ` +\n            `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`CONSTRAINT_TABLE_USAGE\\` \\`CTU\\` ON \\`CTU\\`.\\`CONSTRAINT_NAME\\` = \\`TC\\`.\\`CONSTRAINT_NAME\\` ` +\n            `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`REFERENTIAL_CONSTRAINTS\\` \\`RC\\` ON \\`RC\\`.\\`CONSTRAINT_NAME\\` = \\`TC\\`.\\`CONSTRAINT_NAME\\` ` +\n            `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`CONSTRAINT_COLUMN_USAGE\\` \\`CCU\\` ON \\`CCU\\`.\\`CONSTRAINT_NAME\\` = \\`TC\\`.\\`CONSTRAINT_NAME\\` ` +\n            `WHERE \\`TC\\`.\\`TABLE_CATALOG\\` = '' AND \\`TC\\`.\\`TABLE_SCHEMA\\` = '' AND \\`TC\\`.\\`CONSTRAINT_TYPE\\` = 'FOREIGN KEY' ` +\n            `AND \\`TC\\`.\\`TABLE_NAME\\` IN (${loadedTableNames})`\n\n        const [\n            dbColumns,\n            dbPrimaryKeys,\n            dbIndices,\n            dbChecks,\n            dbForeignKeys,\n        ]: ObjectLiteral[][] = await Promise.all([\n            this.query(columnsSql),\n            this.query(primaryKeySql),\n            this.query(indicesSql),\n            this.query(checksSql),\n            this.query(foreignKeysSql),\n        ])\n\n        // create tables for loaded tables\n        return Promise.all(\n            dbTables.map(async (dbTable) => {\n                const table = new Table()\n\n                table.name = this.driver.buildTableName(dbTable[\"TABLE_NAME\"])\n\n                // create columns from the loaded columns\n                table.columns = await Promise.all(\n                    dbColumns\n                        .filter(\n                            (dbColumn) =>\n                                dbColumn[\"TABLE_NAME\"] ===\n                                dbTable[\"TABLE_NAME\"],\n                        )\n                        .map(async (dbColumn) => {\n                            const columnUniqueIndices = dbIndices.filter(\n                                (dbIndex) => {\n                                    return (\n                                        dbIndex[\"TABLE_NAME\"] ===\n                                            dbTable[\"TABLE_NAME\"] &&\n                                        dbIndex[\"COLUMN_NAME\"] ===\n                                            dbColumn[\"COLUMN_NAME\"] &&\n                                        dbIndex[\"IS_UNIQUE\"] === true\n                                    )\n                                },\n                            )\n\n                            const tableMetadata =\n                                this.connection.entityMetadatas.find(\n                                    (metadata) =>\n                                        this.getTablePath(table) ===\n                                        this.getTablePath(metadata),\n                                )\n                            const hasIgnoredIndex =\n                                columnUniqueIndices.length > 0 &&\n                                tableMetadata &&\n                                tableMetadata.indices.some((index) => {\n                                    return columnUniqueIndices.some(\n                                        (uniqueIndex) => {\n                                            return (\n                                                index.name ===\n                                                    uniqueIndex[\"INDEX_NAME\"] &&\n                                                index.synchronize === false\n                                            )\n                                        },\n                                    )\n                                })\n\n                            const isConstraintComposite =\n                                columnUniqueIndices.every((uniqueIndex) => {\n                                    return dbIndices.some(\n                                        (dbIndex) =>\n                                            dbIndex[\"INDEX_NAME\"] ===\n                                                uniqueIndex[\"INDEX_NAME\"] &&\n                                            dbIndex[\"COLUMN_NAME\"] !==\n                                                dbColumn[\"COLUMN_NAME\"],\n                                    )\n                                })\n\n                            const tableColumn = new TableColumn()\n                            tableColumn.name = dbColumn[\"COLUMN_NAME\"]\n\n                            let fullType =\n                                dbColumn[\"SPANNER_TYPE\"].toLowerCase()\n                            if (fullType.indexOf(\"array\") !== -1) {\n                                tableColumn.isArray = true\n                                fullType = fullType.substring(\n                                    fullType.indexOf(\"<\") + 1,\n                                    fullType.indexOf(\">\"),\n                                )\n                            }\n\n                            if (fullType.indexOf(\"(\") !== -1) {\n                                tableColumn.type = fullType.substring(\n                                    0,\n                                    fullType.indexOf(\"(\"),\n                                )\n                            } else {\n                                tableColumn.type = fullType\n                            }\n\n                            if (\n                                this.driver.withLengthColumnTypes.indexOf(\n                                    tableColumn.type as ColumnType,\n                                ) !== -1\n                            ) {\n                                tableColumn.length = fullType.substring(\n                                    fullType.indexOf(\"(\") + 1,\n                                    fullType.indexOf(\")\"),\n                                )\n                            }\n\n                            if (dbColumn[\"IS_GENERATED\"] === \"ALWAYS\") {\n                                tableColumn.asExpression =\n                                    dbColumn[\"GENERATION_EXPRESSION\"]\n                                tableColumn.generatedType = \"STORED\"\n\n                                // We cannot relay on information_schema.columns.generation_expression, because it is formatted different.\n                                const asExpressionQuery =\n                                    await this.selectTypeormMetadataSql({\n                                        table: dbTable[\"TABLE_NAME\"],\n                                        type: MetadataTableType.GENERATED_COLUMN,\n                                        name: tableColumn.name,\n                                    })\n\n                                const results = await this.query(\n                                    asExpressionQuery.query,\n                                    asExpressionQuery.parameters,\n                                )\n\n                                if (results[0] && results[0].value) {\n                                    tableColumn.asExpression = results[0].value\n                                } else {\n                                    tableColumn.asExpression = \"\"\n                                }\n                            }\n\n                            tableColumn.isUnique =\n                                columnUniqueIndices.length > 0 &&\n                                !hasIgnoredIndex &&\n                                !isConstraintComposite\n                            tableColumn.isNullable =\n                                dbColumn[\"IS_NULLABLE\"] === \"YES\"\n                            tableColumn.isPrimary = dbPrimaryKeys.some(\n                                (dbPrimaryKey) => {\n                                    return (\n                                        dbPrimaryKey[\"TABLE_NAME\"] ===\n                                            dbColumn[\"TABLE_NAME\"] &&\n                                        dbPrimaryKey[\"COLUMN_NAME\"] ===\n                                            dbColumn[\"COLUMN_NAME\"]\n                                    )\n                                },\n                            )\n\n                            return tableColumn\n                        }),\n                )\n\n                const tableForeignKeys = dbForeignKeys.filter(\n                    (dbForeignKey) => {\n                        return (\n                            dbForeignKey[\"TABLE_NAME\"] === dbTable[\"TABLE_NAME\"]\n                        )\n                    },\n                )\n\n                table.foreignKeys = OrmUtils.uniq(\n                    tableForeignKeys,\n                    (dbForeignKey) => dbForeignKey[\"CONSTRAINT_NAME\"],\n                ).map((dbForeignKey) => {\n                    const foreignKeys = tableForeignKeys.filter(\n                        (dbFk) =>\n                            dbFk[\"CONSTRAINT_NAME\"] ===\n                            dbForeignKey[\"CONSTRAINT_NAME\"],\n                    )\n                    return new TableForeignKey({\n                        name: dbForeignKey[\"CONSTRAINT_NAME\"],\n                        columnNames: OrmUtils.uniq(\n                            foreignKeys.map((dbFk) => dbFk[\"COLUMN_NAME\"]),\n                        ),\n                        referencedDatabase:\n                            dbForeignKey[\"REFERENCED_TABLE_SCHEMA\"],\n                        referencedTableName:\n                            dbForeignKey[\"REFERENCED_TABLE_NAME\"],\n                        referencedColumnNames: OrmUtils.uniq(\n                            foreignKeys.map(\n                                (dbFk) => dbFk[\"REFERENCED_COLUMN_NAME\"],\n                            ),\n                        ),\n                        onDelete: dbForeignKey[\"DELETE_RULE\"],\n                        onUpdate: dbForeignKey[\"UPDATE_RULE\"],\n                    })\n                })\n\n                const tableIndices = dbIndices.filter(\n                    (dbIndex) =>\n                        dbIndex[\"TABLE_NAME\"] === dbTable[\"TABLE_NAME\"],\n                )\n\n                table.indices = OrmUtils.uniq(\n                    tableIndices,\n                    (dbIndex) => dbIndex[\"INDEX_NAME\"],\n                ).map((constraint) => {\n                    const indices = tableIndices.filter((index) => {\n                        return index[\"INDEX_NAME\"] === constraint[\"INDEX_NAME\"]\n                    })\n\n                    return new TableIndex(<TableIndexOptions>{\n                        table: table,\n                        name: constraint[\"INDEX_NAME\"],\n                        columnNames: indices.map((i) => i[\"COLUMN_NAME\"]),\n                        isUnique: constraint[\"IS_UNIQUE\"],\n                        isNullFiltered: constraint[\"IS_NULL_FILTERED\"],\n                    })\n                })\n\n                const tableChecks = dbChecks.filter(\n                    (dbCheck) =>\n                        dbCheck[\"TABLE_NAME\"] === dbTable[\"TABLE_NAME\"],\n                )\n\n                table.checks = OrmUtils.uniq(\n                    tableChecks,\n                    (dbIndex) => dbIndex[\"CONSTRAINT_NAME\"],\n                ).map((constraint) => {\n                    const checks = tableChecks.filter(\n                        (dbC) =>\n                            dbC[\"CONSTRAINT_NAME\"] ===\n                            constraint[\"CONSTRAINT_NAME\"],\n                    )\n                    return new TableCheck({\n                        name: constraint[\"CONSTRAINT_NAME\"],\n                        columnNames: checks.map((c) => c[\"COLUMN_NAME\"]),\n                        expression: constraint[\"CHECK_CLAUSE\"],\n                    })\n                })\n\n                return table\n            }),\n        )\n    }\n\n    /**\n     * Builds create table sql.\n     */\n    protected createTableSql(table: Table, createForeignKeys?: boolean): Query {\n        const columnDefinitions = table.columns\n            .map((column) => this.buildCreateColumnSql(column))\n            .join(\", \")\n        let sql = `CREATE TABLE ${this.escapePath(table)} (${columnDefinitions}`\n\n        // we create unique indexes instead of unique constraints, because Spanner does not have unique constraints.\n        // if we mark column as Unique, it means that we create UNIQUE INDEX.\n        table.columns\n            .filter((column) => column.isUnique)\n            .forEach((column) => {\n                const isUniqueIndexExist = table.indices.some((index) => {\n                    return (\n                        index.columnNames.length === 1 &&\n                        !!index.isUnique &&\n                        index.columnNames.indexOf(column.name) !== -1\n                    )\n                })\n                const isUniqueConstraintExist = table.uniques.some((unique) => {\n                    return (\n                        unique.columnNames.length === 1 &&\n                        unique.columnNames.indexOf(column.name) !== -1\n                    )\n                })\n                if (!isUniqueIndexExist && !isUniqueConstraintExist)\n                    table.indices.push(\n                        new TableIndex({\n                            name: this.connection.namingStrategy.uniqueConstraintName(\n                                table,\n                                [column.name],\n                            ),\n                            columnNames: [column.name],\n                            isUnique: true,\n                        }),\n                    )\n            })\n\n        // as Spanner does not have unique constraints, we must create table indices from table uniques and mark them as unique.\n        if (table.uniques.length > 0) {\n            table.uniques.forEach((unique) => {\n                const uniqueExist = table.indices.some(\n                    (index) => index.name === unique.name,\n                )\n                if (!uniqueExist) {\n                    table.indices.push(\n                        new TableIndex({\n                            name: unique.name,\n                            columnNames: unique.columnNames,\n                            isUnique: true,\n                        }),\n                    )\n                }\n            })\n        }\n\n        if (table.checks.length > 0) {\n            const checksSql = table.checks\n                .map((check) => {\n                    const checkName = check.name\n                        ? check.name\n                        : this.connection.namingStrategy.checkConstraintName(\n                              table,\n                              check.expression!,\n                          )\n                    return `CONSTRAINT \\`${checkName}\\` CHECK (${check.expression})`\n                })\n                .join(\", \")\n\n            sql += `, ${checksSql}`\n        }\n\n        if (table.foreignKeys.length > 0 && createForeignKeys) {\n            const foreignKeysSql = table.foreignKeys\n                .map((fk) => {\n                    const columnNames = fk.columnNames\n                        .map((columnName) => `\\`${columnName}\\``)\n                        .join(\", \")\n                    if (!fk.name)\n                        fk.name = this.connection.namingStrategy.foreignKeyName(\n                            table,\n                            fk.columnNames,\n                            this.getTablePath(fk),\n                            fk.referencedColumnNames,\n                        )\n                    const referencedColumnNames = fk.referencedColumnNames\n                        .map((columnName) => `\\`${columnName}\\``)\n                        .join(\", \")\n\n                    return `CONSTRAINT \\`${\n                        fk.name\n                    }\\` FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(\n                        this.getTablePath(fk),\n                    )} (${referencedColumnNames})`\n                })\n                .join(\", \")\n\n            sql += `, ${foreignKeysSql}`\n        }\n\n        sql += `)`\n\n        const primaryColumns = table.columns.filter(\n            (column) => column.isPrimary,\n        )\n        if (primaryColumns.length > 0) {\n            const columnNames = primaryColumns\n                .map((column) => this.driver.escape(column.name))\n                .join(\", \")\n            sql += ` PRIMARY KEY (${columnNames})`\n        }\n\n        return new Query(sql)\n    }\n\n    /**\n     * Builds drop table sql.\n     */\n    protected dropTableSql(tableOrPath: Table | string): Query {\n        return new Query(`DROP TABLE ${this.escapePath(tableOrPath)}`)\n    }\n\n    protected createViewSql(view: View): Query {\n        const materializedClause = view.materialized ? \"MATERIALIZED \" : \"\"\n        const viewName = this.escapePath(view)\n\n        const expression =\n            typeof view.expression === \"string\"\n                ? view.expression\n                : view.expression(this.connection).getQuery()\n        return new Query(\n            `CREATE ${materializedClause}VIEW ${viewName} SQL SECURITY INVOKER AS ${expression}`,\n        )\n    }\n\n    protected async insertViewDefinitionSql(view: View): Promise<Query> {\n        let { schema, tableName: name } = this.driver.parseTableName(view)\n\n        const type = view.materialized\n            ? MetadataTableType.MATERIALIZED_VIEW\n            : MetadataTableType.VIEW\n        const expression =\n            typeof view.expression === \"string\"\n                ? view.expression.trim()\n                : view.expression(this.connection).getQuery()\n        return this.insertTypeormMetadataSql({\n            type,\n            schema,\n            name,\n            value: expression,\n        })\n    }\n\n    /**\n     * Builds drop view sql.\n     */\n    protected dropViewSql(view: View): Query {\n        const materializedClause = view.materialized ? \"MATERIALIZED \" : \"\"\n        return new Query(\n            `DROP ${materializedClause}VIEW ${this.escapePath(view)}`,\n        )\n    }\n\n    /**\n     * Builds remove view sql.\n     */\n    protected async deleteViewDefinitionSql(view: View): Promise<Query> {\n        let { schema, tableName: name } = this.driver.parseTableName(view)\n\n        const type = view.materialized\n            ? MetadataTableType.MATERIALIZED_VIEW\n            : MetadataTableType.VIEW\n        return this.deleteTypeormMetadataSql({ type, schema, name })\n    }\n\n    /**\n     * Builds create index sql.\n     */\n    protected createIndexSql(table: Table, index: TableIndex): Query {\n        const columns = index.columnNames\n            .map((columnName) => this.driver.escape(columnName))\n            .join(\", \")\n        let indexType = \"\"\n        if (index.isUnique) indexType += \"UNIQUE \"\n        if (index.isNullFiltered) indexType += \"NULL_FILTERED \"\n\n        return new Query(\n            `CREATE ${indexType}INDEX \\`${index.name}\\` ON ${this.escapePath(\n                table,\n            )} (${columns})`,\n        )\n    }\n\n    /**\n     * Builds drop index sql.\n     */\n    protected dropIndexSql(\n        table: Table,\n        indexOrName: TableIndex | string,\n    ): Query {\n        let indexName =\n            indexOrName instanceof TableIndex ? indexOrName.name : indexOrName\n        return new Query(`DROP INDEX \\`${indexName}\\``)\n    }\n\n    /**\n     * Builds create check constraint sql.\n     */\n    protected createCheckConstraintSql(\n        table: Table,\n        checkConstraint: TableCheck,\n    ): Query {\n        return new Query(\n            `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \\`${\n                checkConstraint.name\n            }\\` CHECK (${checkConstraint.expression})`,\n        )\n    }\n\n    /**\n     * Builds drop check constraint sql.\n     */\n    protected dropCheckConstraintSql(\n        table: Table,\n        checkOrName: TableCheck | string,\n    ): Query {\n        const checkName =\n            checkOrName instanceof TableCheck ? checkOrName.name : checkOrName\n        return new Query(\n            `ALTER TABLE ${this.escapePath(\n                table,\n            )} DROP CONSTRAINT \\`${checkName}\\``,\n        )\n    }\n\n    /**\n     * Builds create foreign key sql.\n     */\n    protected createForeignKeySql(\n        table: Table,\n        foreignKey: TableForeignKey,\n    ): Query {\n        const columnNames = foreignKey.columnNames\n            .map((column) => this.driver.escape(column))\n            .join(\", \")\n        const referencedColumnNames = foreignKey.referencedColumnNames\n            .map((column) => this.driver.escape(column))\n            .join(\",\")\n        let sql =\n            `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \\`${\n                foreignKey.name\n            }\\` FOREIGN KEY (${columnNames}) ` +\n            `REFERENCES ${this.escapePath(\n                this.getTablePath(foreignKey),\n            )} (${referencedColumnNames})`\n\n        return new Query(sql)\n    }\n\n    /**\n     * Builds drop foreign key sql.\n     */\n    protected dropForeignKeySql(\n        table: Table,\n        foreignKeyOrName: TableForeignKey | string,\n    ): Query {\n        const foreignKeyName =\n            foreignKeyOrName instanceof TableForeignKey\n                ? foreignKeyOrName.name\n                : foreignKeyOrName\n        return new Query(\n            `ALTER TABLE ${this.escapePath(\n                table,\n            )} DROP CONSTRAINT \\`${foreignKeyName}\\``,\n        )\n    }\n\n    /**\n     * Escapes given table or view path.\n     */\n    protected escapePath(target: Table | View | string): string {\n        const { tableName } = this.driver.parseTableName(target)\n        return `\\`${tableName}\\``\n    }\n\n    /**\n     * Builds a part of query to create/change a column.\n     */\n    protected buildCreateColumnSql(column: TableColumn) {\n        let c = `${this.driver.escape(\n            column.name,\n        )} ${this.connection.driver.createFullType(column)}`\n\n        // Spanner supports only STORED generated column type\n        if (column.generatedType === \"STORED\" && column.asExpression) {\n            c += ` AS (${column.asExpression}) STORED`\n        } else {\n            if (!column.isNullable) c += \" NOT NULL\"\n        }\n\n        return c\n    }\n\n    /**\n     * Executes sql used special for schema build.\n     */\n    protected async executeQueries(\n        upQueries: Query | Query[],\n        downQueries: Query | Query[],\n    ): Promise<void> {\n        if (upQueries instanceof Query) upQueries = [upQueries]\n        if (downQueries instanceof Query) downQueries = [downQueries]\n\n        this.sqlInMemory.upQueries.push(...upQueries)\n        this.sqlInMemory.downQueries.push(...downQueries)\n\n        // if sql-in-memory mode is enabled then simply store sql in memory and return\n        if (this.sqlMemoryMode === true)\n            return Promise.resolve() as Promise<any>\n\n        for (const { query, parameters } of upQueries) {\n            if (this.isDMLQuery(query)) {\n                await this.query(query, parameters)\n            } else {\n                await this.updateDDL(query, parameters)\n            }\n        }\n    }\n\n    protected isDMLQuery(query: string): boolean {\n        return (\n            query.startsWith(\"INSERT\") ||\n            query.startsWith(\"UPDATE\") ||\n            query.startsWith(\"DELETE\")\n        )\n    }\n}\n"]},"metadata":{},"sourceType":"module"}