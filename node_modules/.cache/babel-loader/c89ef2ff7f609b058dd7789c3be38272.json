{"ast":null,"code":"import { BroadcasterResult } from \"./BroadcasterResult\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\n/**\n * Broadcaster provides a helper methods to broadcast events to the subscribers.\n */\n\nexport class Broadcaster {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(queryRunner) {\n    this.queryRunner = queryRunner;\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n\n  async broadcast(event) {\n    const result = new BroadcasterResult();\n    const broadcastFunction = this[`broadcast${event}Event`];\n\n    if (typeof broadcastFunction === \"function\") {\n      ;\n\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      broadcastFunction.call(this, result, ...args);\n    }\n\n    await result.wait();\n  }\n  /**\n   * Broadcasts \"BEFORE_INSERT\" event.\n   * Before insert event is executed before entity is being inserted to the database for the first time.\n   * All subscribers and entity listeners who listened to this event will be executed at this point.\n   * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n   *\n   * Note: this method has a performance-optimized code organization, do not change code structure.\n   */\n\n\n  broadcastBeforeInsertEvent(result, metadata, entity) {\n    if (entity && metadata.beforeInsertListeners.length) {\n      metadata.beforeInsertListeners.forEach(listener => {\n        if (listener.isAllowed(entity)) {\n          const executionResult = listener.execute(entity);\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.beforeInsert) {\n          const executionResult = subscriber.beforeInsert({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager,\n            entity: entity,\n            metadata: metadata\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"BEFORE_UPDATE\" event.\n   * Before update event is executed before entity is being updated in the database.\n   * All subscribers and entity listeners who listened to this event will be executed at this point.\n   * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n   *\n   * Note: this method has a performance-optimized code organization, do not change code structure.\n   */\n\n\n  broadcastBeforeUpdateEvent(result, metadata, entity, databaseEntity, updatedColumns, updatedRelations) {\n    // todo: send relations too?\n    if (entity && metadata.beforeUpdateListeners.length) {\n      metadata.beforeUpdateListeners.forEach(listener => {\n        if (listener.isAllowed(entity)) {\n          const executionResult = listener.execute(entity);\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.beforeUpdate) {\n          const executionResult = subscriber.beforeUpdate({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager,\n            entity: entity,\n            metadata: metadata,\n            databaseEntity: databaseEntity,\n            updatedColumns: updatedColumns || [],\n            updatedRelations: updatedRelations || []\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"BEFORE_REMOVE\" event.\n   * Before remove event is executed before entity is being removed from the database.\n   * All subscribers and entity listeners who listened to this event will be executed at this point.\n   * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n   *\n   * Note: this method has a performance-optimized code organization, do not change code structure.\n   */\n\n\n  broadcastBeforeRemoveEvent(result, metadata, entity, databaseEntity) {\n    if (entity && metadata.beforeRemoveListeners.length) {\n      metadata.beforeRemoveListeners.forEach(listener => {\n        if (listener.isAllowed(entity)) {\n          const executionResult = listener.execute(entity);\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.beforeRemove) {\n          const executionResult = subscriber.beforeRemove({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager,\n            entity: entity,\n            metadata: metadata,\n            databaseEntity: databaseEntity,\n            entityId: metadata.getEntityIdMixedMap(databaseEntity)\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"BEFORE_SOFT_REMOVE\" event.\n   * Before soft remove event is executed before entity is being soft removed from the database.\n   * All subscribers and entity listeners who listened to this event will be executed at this point.\n   * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n   *\n   * Note: this method has a performance-optimized code organization, do not change code structure.\n   */\n\n\n  broadcastBeforeSoftRemoveEvent(result, metadata, entity, databaseEntity) {\n    if (entity && metadata.beforeSoftRemoveListeners.length) {\n      metadata.beforeSoftRemoveListeners.forEach(listener => {\n        if (listener.isAllowed(entity)) {\n          const executionResult = listener.execute(entity);\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.beforeSoftRemove) {\n          const executionResult = subscriber.beforeSoftRemove({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager,\n            entity: entity,\n            metadata: metadata,\n            databaseEntity: databaseEntity,\n            entityId: metadata.getEntityIdMixedMap(databaseEntity)\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"BEFORE_RECOVER\" event.\n   * Before recover event is executed before entity is being recovered in the database.\n   * All subscribers and entity listeners who listened to this event will be executed at this point.\n   * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n   *\n   * Note: this method has a performance-optimized code organization, do not change code structure.\n   */\n\n\n  broadcastBeforeRecoverEvent(result, metadata, entity, databaseEntity) {\n    if (entity && metadata.beforeRecoverListeners.length) {\n      metadata.beforeRecoverListeners.forEach(listener => {\n        if (listener.isAllowed(entity)) {\n          const executionResult = listener.execute(entity);\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.beforeRecover) {\n          const executionResult = subscriber.beforeRecover({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager,\n            entity: entity,\n            metadata: metadata,\n            databaseEntity: databaseEntity,\n            entityId: metadata.getEntityIdMixedMap(databaseEntity)\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"AFTER_INSERT\" event.\n   * After insert event is executed after entity is being persisted to the database for the first time.\n   * All subscribers and entity listeners who listened to this event will be executed at this point.\n   * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n   *\n   * Note: this method has a performance-optimized code organization, do not change code structure.\n   */\n\n\n  broadcastAfterInsertEvent(result, metadata, entity) {\n    if (entity && metadata.afterInsertListeners.length) {\n      metadata.afterInsertListeners.forEach(listener => {\n        if (listener.isAllowed(entity)) {\n          const executionResult = listener.execute(entity);\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterInsert) {\n          const executionResult = subscriber.afterInsert({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager,\n            entity: entity,\n            metadata: metadata\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"BEFORE_TRANSACTION_START\" event.\n   */\n\n\n  broadcastBeforeTransactionStartEvent(result) {\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (subscriber.beforeTransactionStart) {\n          const executionResult = subscriber.beforeTransactionStart({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"AFTER_TRANSACTION_START\" event.\n   */\n\n\n  broadcastAfterTransactionStartEvent(result) {\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (subscriber.afterTransactionStart) {\n          const executionResult = subscriber.afterTransactionStart({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"BEFORE_TRANSACTION_COMMIT\" event.\n   */\n\n\n  broadcastBeforeTransactionCommitEvent(result) {\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (subscriber.beforeTransactionCommit) {\n          const executionResult = subscriber.beforeTransactionCommit({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"AFTER_TRANSACTION_COMMIT\" event.\n   */\n\n\n  broadcastAfterTransactionCommitEvent(result) {\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (subscriber.afterTransactionCommit) {\n          const executionResult = subscriber.afterTransactionCommit({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"BEFORE_TRANSACTION_ROLLBACK\" event.\n   */\n\n\n  broadcastBeforeTransactionRollbackEvent(result) {\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (subscriber.beforeTransactionRollback) {\n          const executionResult = subscriber.beforeTransactionRollback({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"AFTER_TRANSACTION_ROLLBACK\" event.\n   */\n\n\n  broadcastAfterTransactionRollbackEvent(result) {\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (subscriber.afterTransactionRollback) {\n          const executionResult = subscriber.afterTransactionRollback({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"AFTER_UPDATE\" event.\n   * After update event is executed after entity is being updated in the database.\n   * All subscribers and entity listeners who listened to this event will be executed at this point.\n   * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n   *\n   * Note: this method has a performance-optimized code organization, do not change code structure.\n   */\n\n\n  broadcastAfterUpdateEvent(result, metadata, entity, databaseEntity, updatedColumns, updatedRelations) {\n    if (entity && metadata.afterUpdateListeners.length) {\n      metadata.afterUpdateListeners.forEach(listener => {\n        if (listener.isAllowed(entity)) {\n          const executionResult = listener.execute(entity);\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterUpdate) {\n          const executionResult = subscriber.afterUpdate({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager,\n            entity: entity,\n            metadata: metadata,\n            databaseEntity: databaseEntity,\n            updatedColumns: updatedColumns || [],\n            updatedRelations: updatedRelations || []\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"AFTER_REMOVE\" event.\n   * After remove event is executed after entity is being removed from the database.\n   * All subscribers and entity listeners who listened to this event will be executed at this point.\n   * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n   *\n   * Note: this method has a performance-optimized code organization, do not change code structure.\n   */\n\n\n  broadcastAfterRemoveEvent(result, metadata, entity, databaseEntity) {\n    if (entity && metadata.afterRemoveListeners.length) {\n      metadata.afterRemoveListeners.forEach(listener => {\n        if (listener.isAllowed(entity)) {\n          const executionResult = listener.execute(entity);\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterRemove) {\n          const executionResult = subscriber.afterRemove({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager,\n            entity: entity,\n            metadata: metadata,\n            databaseEntity: databaseEntity,\n            entityId: metadata.getEntityIdMixedMap(databaseEntity)\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"AFTER_SOFT_REMOVE\" event.\n   * After soft remove event is executed after entity is being soft removed from the database.\n   * All subscribers and entity listeners who listened to this event will be executed at this point.\n   * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n   *\n   * Note: this method has a performance-optimized code organization, do not change code structure.\n   */\n\n\n  broadcastAfterSoftRemoveEvent(result, metadata, entity, databaseEntity) {\n    if (entity && metadata.afterSoftRemoveListeners.length) {\n      metadata.afterSoftRemoveListeners.forEach(listener => {\n        if (listener.isAllowed(entity)) {\n          const executionResult = listener.execute(entity);\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterSoftRemove) {\n          const executionResult = subscriber.afterSoftRemove({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager,\n            entity: entity,\n            metadata: metadata,\n            databaseEntity: databaseEntity,\n            entityId: metadata.getEntityIdMixedMap(databaseEntity)\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"AFTER_RECOVER\" event.\n   * After recover event is executed after entity is being recovered in the database.\n   * All subscribers and entity listeners who listened to this event will be executed at this point.\n   * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n   *\n   * Note: this method has a performance-optimized code organization, do not change code structure.\n   */\n\n\n  broadcastAfterRecoverEvent(result, metadata, entity, databaseEntity) {\n    if (entity && metadata.afterRecoverListeners.length) {\n      metadata.afterRecoverListeners.forEach(listener => {\n        if (listener.isAllowed(entity)) {\n          const executionResult = listener.execute(entity);\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterRecover) {\n          const executionResult = subscriber.afterRecover({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager,\n            entity: entity,\n            metadata: metadata,\n            databaseEntity: databaseEntity,\n            entityId: metadata.getEntityIdMixedMap(databaseEntity)\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * @deprecated Use `broadcastLoadForAllEvent`\n   */\n\n\n  broadcastLoadEventsForAll(result, metadata, entities) {\n    return this.broadcastLoadEvent(result, metadata, entities);\n  }\n  /**\n   * Broadcasts \"AFTER_LOAD\" event for all given entities, and their sub-entities.\n   * After load event is executed after entity has been loaded from the database.\n   * All subscribers and entity listeners who listened to this event will be executed at this point.\n   * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n   *\n   * Note: this method has a performance-optimized code organization, do not change code structure.\n   */\n\n\n  broadcastLoadEvent(result, metadata, entities) {\n    // Calculate which subscribers are fitting for the given entity type\n    const fittingSubscribers = this.queryRunner.connection.subscribers.filter(subscriber => this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterLoad);\n\n    if (metadata.relations.length || metadata.afterLoadListeners.length || fittingSubscribers.length) {\n      // todo: check why need this?\n      const nonPromiseEntities = entities.filter(entity => !(entity instanceof Promise)); // collect load events for all children entities that were loaded with the main entity\n\n      if (metadata.relations.length) {\n        metadata.relations.forEach(relation => {\n          nonPromiseEntities.forEach(entity => {\n            // in lazy relations we cannot simply access to entity property because it will cause a getter and a database query\n            if (relation.isLazy && !entity.hasOwnProperty(relation.propertyName)) return;\n            const value = relation.getEntityValue(entity);\n            if (ObjectUtils.isObject(value)) this.broadcastLoadEvent(result, relation.inverseEntityMetadata, Array.isArray(value) ? value : [value]);\n          });\n        });\n      }\n\n      if (metadata.afterLoadListeners.length) {\n        metadata.afterLoadListeners.forEach(listener => {\n          nonPromiseEntities.forEach(entity => {\n            if (listener.isAllowed(entity)) {\n              const executionResult = listener.execute(entity);\n              if (executionResult instanceof Promise) result.promises.push(executionResult);\n              result.count++;\n            }\n          });\n        });\n      }\n\n      fittingSubscribers.forEach(subscriber => {\n        nonPromiseEntities.forEach(entity => {\n          const executionResult = subscriber.afterLoad(entity, {\n            entity,\n            metadata,\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        });\n      });\n    }\n  } // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Checks if subscriber's methods can be executed by checking if its don't listen to the particular entity,\n   * or listens our entity.\n   */\n\n\n  isAllowedSubscriber(subscriber, target) {\n    return !subscriber.listenTo || !subscriber.listenTo() || subscriber.listenTo() === Object || subscriber.listenTo() === target || subscriber.listenTo().isPrototypeOf(target);\n  }\n\n}","map":{"version":3,"mappings":"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","names":["BroadcasterResult","ObjectUtils","Broadcaster","constructor","queryRunner","broadcast","event","result","broadcastFunction","args","call","wait","broadcastBeforeInsertEvent","metadata","entity","beforeInsertListeners","length","forEach","listener","isAllowed","executionResult","execute","Promise","promises","push","count","connection","subscribers","subscriber","isAllowedSubscriber","target","beforeInsert","manager","broadcastBeforeUpdateEvent","databaseEntity","updatedColumns","updatedRelations","beforeUpdateListeners","beforeUpdate","broadcastBeforeRemoveEvent","beforeRemoveListeners","beforeRemove","entityId","getEntityIdMixedMap","broadcastBeforeSoftRemoveEvent","beforeSoftRemoveListeners","beforeSoftRemove","broadcastBeforeRecoverEvent","beforeRecoverListeners","beforeRecover","broadcastAfterInsertEvent","afterInsertListeners","afterInsert","broadcastBeforeTransactionStartEvent","beforeTransactionStart","broadcastAfterTransactionStartEvent","afterTransactionStart","broadcastBeforeTransactionCommitEvent","beforeTransactionCommit","broadcastAfterTransactionCommitEvent","afterTransactionCommit","broadcastBeforeTransactionRollbackEvent","beforeTransactionRollback","broadcastAfterTransactionRollbackEvent","afterTransactionRollback","broadcastAfterUpdateEvent","afterUpdateListeners","afterUpdate","broadcastAfterRemoveEvent","afterRemoveListeners","afterRemove","broadcastAfterSoftRemoveEvent","afterSoftRemoveListeners","afterSoftRemove","broadcastAfterRecoverEvent","afterRecoverListeners","afterRecover","broadcastLoadEventsForAll","entities","broadcastLoadEvent","fittingSubscribers","filter","afterLoad","relations","afterLoadListeners","nonPromiseEntities","relation","isLazy","hasOwnProperty","propertyName","value","getEntityValue","isObject","inverseEntityMetadata","Array","isArray","listenTo","Object","isPrototypeOf"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\subscriber\\Broadcaster.ts"],"sourcesContent":["import { EntitySubscriberInterface } from \"./EntitySubscriberInterface\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\nimport { EntityMetadata } from \"../metadata/EntityMetadata\"\nimport { BroadcasterResult } from \"./BroadcasterResult\"\nimport { ColumnMetadata } from \"../metadata/ColumnMetadata\"\nimport { RelationMetadata } from \"../metadata/RelationMetadata\"\nimport { ObjectUtils } from \"../util/ObjectUtils\"\n\ninterface BroadcasterEvents {\n    BeforeTransactionCommit: () => void\n    AfterTransactionCommit: () => void\n    BeforeTransactionStart: () => void\n    AfterTransactionStart: () => void\n    BeforeTransactionRollback: () => void\n    AfterTransactionRollback: () => void\n\n    BeforeUpdate: (\n        metadata: EntityMetadata,\n        entity?: ObjectLiteral,\n        databaseEntity?: ObjectLiteral,\n        updatedColumns?: ColumnMetadata[],\n        updatedRelations?: RelationMetadata[],\n    ) => void\n    AfterUpdate: (\n        metadata: EntityMetadata,\n        entity?: ObjectLiteral,\n        databaseEntity?: ObjectLiteral,\n        updatedColumns?: ColumnMetadata[],\n        updatedRelations?: RelationMetadata[],\n    ) => void\n\n    BeforeInsert: (\n        metadata: EntityMetadata,\n        entity: ObjectLiteral | undefined,\n    ) => void\n    AfterInsert: (\n        metadata: EntityMetadata,\n        entity: ObjectLiteral | undefined,\n    ) => void\n\n    BeforeRemove: (\n        metadata: EntityMetadata,\n        entity?: ObjectLiteral,\n        databaseEntity?: ObjectLiteral,\n    ) => void\n    AfterRemove: (\n        metadata: EntityMetadata,\n        entity?: ObjectLiteral,\n        databaseEntity?: ObjectLiteral,\n    ) => void\n\n    BeforeSoftRemove: (\n        metadata: EntityMetadata,\n        entity?: ObjectLiteral,\n        databaseEntity?: ObjectLiteral,\n    ) => void\n    AfterSoftRemove: (\n        metadata: EntityMetadata,\n        entity?: ObjectLiteral,\n        databaseEntity?: ObjectLiteral,\n    ) => void\n\n    BeforeRecover: (\n        metadata: EntityMetadata,\n        entity?: ObjectLiteral,\n        databaseEntity?: ObjectLiteral,\n    ) => void\n    AfterRecover: (\n        metadata: EntityMetadata,\n        entity?: ObjectLiteral,\n        databaseEntity?: ObjectLiteral,\n    ) => void\n\n    Load: (metadata: EntityMetadata, entities: ObjectLiteral[]) => void\n}\n\n/**\n * Broadcaster provides a helper methods to broadcast events to the subscribers.\n */\nexport class Broadcaster {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private queryRunner: QueryRunner) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    async broadcast<U extends keyof BroadcasterEvents>(\n        event: U,\n        ...args: Parameters<BroadcasterEvents[U]>\n    ): Promise<void> {\n        const result = new BroadcasterResult()\n\n        const broadcastFunction = this[`broadcast${event}Event` as keyof this]\n\n        if (typeof broadcastFunction === \"function\") {\n            ;(broadcastFunction as any).call(this, result, ...args)\n        }\n\n        await result.wait()\n    }\n\n    /**\n     * Broadcasts \"BEFORE_INSERT\" event.\n     * Before insert event is executed before entity is being inserted to the database for the first time.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastBeforeInsertEvent(\n        result: BroadcasterResult,\n        metadata: EntityMetadata,\n        entity: undefined | ObjectLiteral,\n    ): void {\n        if (entity && metadata.beforeInsertListeners.length) {\n            metadata.beforeInsertListeners.forEach((listener) => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity)\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (\n                    this.isAllowedSubscriber(subscriber, metadata.target) &&\n                    subscriber.beforeInsert\n                ) {\n                    const executionResult = subscriber.beforeInsert({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata,\n                    })\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n    }\n\n    /**\n     * Broadcasts \"BEFORE_UPDATE\" event.\n     * Before update event is executed before entity is being updated in the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastBeforeUpdateEvent(\n        result: BroadcasterResult,\n        metadata: EntityMetadata,\n        entity?: ObjectLiteral,\n        databaseEntity?: ObjectLiteral,\n        updatedColumns?: ColumnMetadata[],\n        updatedRelations?: RelationMetadata[],\n    ): void {\n        // todo: send relations too?\n        if (entity && metadata.beforeUpdateListeners.length) {\n            metadata.beforeUpdateListeners.forEach((listener) => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity)\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (\n                    this.isAllowedSubscriber(subscriber, metadata.target) &&\n                    subscriber.beforeUpdate\n                ) {\n                    const executionResult = subscriber.beforeUpdate({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata,\n                        databaseEntity: databaseEntity,\n                        updatedColumns: updatedColumns || [],\n                        updatedRelations: updatedRelations || [],\n                    })\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n    }\n\n    /**\n     * Broadcasts \"BEFORE_REMOVE\" event.\n     * Before remove event is executed before entity is being removed from the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastBeforeRemoveEvent(\n        result: BroadcasterResult,\n        metadata: EntityMetadata,\n        entity?: ObjectLiteral,\n        databaseEntity?: ObjectLiteral,\n    ): void {\n        if (entity && metadata.beforeRemoveListeners.length) {\n            metadata.beforeRemoveListeners.forEach((listener) => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity)\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (\n                    this.isAllowedSubscriber(subscriber, metadata.target) &&\n                    subscriber.beforeRemove\n                ) {\n                    const executionResult = subscriber.beforeRemove({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata,\n                        databaseEntity: databaseEntity,\n                        entityId: metadata.getEntityIdMixedMap(databaseEntity),\n                    })\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n    }\n\n    /**\n     * Broadcasts \"BEFORE_SOFT_REMOVE\" event.\n     * Before soft remove event is executed before entity is being soft removed from the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastBeforeSoftRemoveEvent(\n        result: BroadcasterResult,\n        metadata: EntityMetadata,\n        entity?: ObjectLiteral,\n        databaseEntity?: ObjectLiteral,\n    ): void {\n        if (entity && metadata.beforeSoftRemoveListeners.length) {\n            metadata.beforeSoftRemoveListeners.forEach((listener) => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity)\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (\n                    this.isAllowedSubscriber(subscriber, metadata.target) &&\n                    subscriber.beforeSoftRemove\n                ) {\n                    const executionResult = subscriber.beforeSoftRemove({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata,\n                        databaseEntity: databaseEntity,\n                        entityId: metadata.getEntityIdMixedMap(databaseEntity),\n                    })\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n    }\n\n    /**\n     * Broadcasts \"BEFORE_RECOVER\" event.\n     * Before recover event is executed before entity is being recovered in the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastBeforeRecoverEvent(\n        result: BroadcasterResult,\n        metadata: EntityMetadata,\n        entity?: ObjectLiteral,\n        databaseEntity?: ObjectLiteral,\n    ): void {\n        if (entity && metadata.beforeRecoverListeners.length) {\n            metadata.beforeRecoverListeners.forEach((listener) => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity)\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (\n                    this.isAllowedSubscriber(subscriber, metadata.target) &&\n                    subscriber.beforeRecover\n                ) {\n                    const executionResult = subscriber.beforeRecover({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata,\n                        databaseEntity: databaseEntity,\n                        entityId: metadata.getEntityIdMixedMap(databaseEntity),\n                    })\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n    }\n\n    /**\n     * Broadcasts \"AFTER_INSERT\" event.\n     * After insert event is executed after entity is being persisted to the database for the first time.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastAfterInsertEvent(\n        result: BroadcasterResult,\n        metadata: EntityMetadata,\n        entity?: ObjectLiteral,\n    ): void {\n        if (entity && metadata.afterInsertListeners.length) {\n            metadata.afterInsertListeners.forEach((listener) => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity)\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (\n                    this.isAllowedSubscriber(subscriber, metadata.target) &&\n                    subscriber.afterInsert\n                ) {\n                    const executionResult = subscriber.afterInsert({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata,\n                    })\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n    }\n\n    /**\n     * Broadcasts \"BEFORE_TRANSACTION_START\" event.\n     */\n    broadcastBeforeTransactionStartEvent(result: BroadcasterResult): void {\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (subscriber.beforeTransactionStart) {\n                    const executionResult = subscriber.beforeTransactionStart({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                    })\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n    }\n\n    /**\n     * Broadcasts \"AFTER_TRANSACTION_START\" event.\n     */\n    broadcastAfterTransactionStartEvent(result: BroadcasterResult): void {\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (subscriber.afterTransactionStart) {\n                    const executionResult = subscriber.afterTransactionStart({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                    })\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n    }\n\n    /**\n     * Broadcasts \"BEFORE_TRANSACTION_COMMIT\" event.\n     */\n    broadcastBeforeTransactionCommitEvent(result: BroadcasterResult): void {\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (subscriber.beforeTransactionCommit) {\n                    const executionResult = subscriber.beforeTransactionCommit({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                    })\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n    }\n\n    /**\n     * Broadcasts \"AFTER_TRANSACTION_COMMIT\" event.\n     */\n    broadcastAfterTransactionCommitEvent(result: BroadcasterResult): void {\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (subscriber.afterTransactionCommit) {\n                    const executionResult = subscriber.afterTransactionCommit({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                    })\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n    }\n\n    /**\n     * Broadcasts \"BEFORE_TRANSACTION_ROLLBACK\" event.\n     */\n    broadcastBeforeTransactionRollbackEvent(result: BroadcasterResult): void {\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (subscriber.beforeTransactionRollback) {\n                    const executionResult =\n                        subscriber.beforeTransactionRollback({\n                            connection: this.queryRunner.connection,\n                            queryRunner: this.queryRunner,\n                            manager: this.queryRunner.manager,\n                        })\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n    }\n\n    /**\n     * Broadcasts \"AFTER_TRANSACTION_ROLLBACK\" event.\n     */\n    broadcastAfterTransactionRollbackEvent(result: BroadcasterResult): void {\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (subscriber.afterTransactionRollback) {\n                    const executionResult = subscriber.afterTransactionRollback(\n                        {\n                            connection: this.queryRunner.connection,\n                            queryRunner: this.queryRunner,\n                            manager: this.queryRunner.manager,\n                        },\n                    )\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n    }\n\n    /**\n     * Broadcasts \"AFTER_UPDATE\" event.\n     * After update event is executed after entity is being updated in the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastAfterUpdateEvent(\n        result: BroadcasterResult,\n        metadata: EntityMetadata,\n        entity?: ObjectLiteral,\n        databaseEntity?: ObjectLiteral,\n        updatedColumns?: ColumnMetadata[],\n        updatedRelations?: RelationMetadata[],\n    ): void {\n        if (entity && metadata.afterUpdateListeners.length) {\n            metadata.afterUpdateListeners.forEach((listener) => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity)\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (\n                    this.isAllowedSubscriber(subscriber, metadata.target) &&\n                    subscriber.afterUpdate\n                ) {\n                    const executionResult = subscriber.afterUpdate({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata,\n                        databaseEntity: databaseEntity,\n                        updatedColumns: updatedColumns || [],\n                        updatedRelations: updatedRelations || [],\n                    })\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n    }\n\n    /**\n     * Broadcasts \"AFTER_REMOVE\" event.\n     * After remove event is executed after entity is being removed from the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastAfterRemoveEvent(\n        result: BroadcasterResult,\n        metadata: EntityMetadata,\n        entity?: ObjectLiteral,\n        databaseEntity?: ObjectLiteral,\n    ): void {\n        if (entity && metadata.afterRemoveListeners.length) {\n            metadata.afterRemoveListeners.forEach((listener) => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity)\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (\n                    this.isAllowedSubscriber(subscriber, metadata.target) &&\n                    subscriber.afterRemove\n                ) {\n                    const executionResult = subscriber.afterRemove({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata,\n                        databaseEntity: databaseEntity,\n                        entityId: metadata.getEntityIdMixedMap(databaseEntity),\n                    })\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n    }\n\n    /**\n     * Broadcasts \"AFTER_SOFT_REMOVE\" event.\n     * After soft remove event is executed after entity is being soft removed from the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastAfterSoftRemoveEvent(\n        result: BroadcasterResult,\n        metadata: EntityMetadata,\n        entity?: ObjectLiteral,\n        databaseEntity?: ObjectLiteral,\n    ): void {\n        if (entity && metadata.afterSoftRemoveListeners.length) {\n            metadata.afterSoftRemoveListeners.forEach((listener) => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity)\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (\n                    this.isAllowedSubscriber(subscriber, metadata.target) &&\n                    subscriber.afterSoftRemove\n                ) {\n                    const executionResult = subscriber.afterSoftRemove({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata,\n                        databaseEntity: databaseEntity,\n                        entityId: metadata.getEntityIdMixedMap(databaseEntity),\n                    })\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n    }\n\n    /**\n     * Broadcasts \"AFTER_RECOVER\" event.\n     * After recover event is executed after entity is being recovered in the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastAfterRecoverEvent(\n        result: BroadcasterResult,\n        metadata: EntityMetadata,\n        entity?: ObjectLiteral,\n        databaseEntity?: ObjectLiteral,\n    ): void {\n        if (entity && metadata.afterRecoverListeners.length) {\n            metadata.afterRecoverListeners.forEach((listener) => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity)\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (\n                    this.isAllowedSubscriber(subscriber, metadata.target) &&\n                    subscriber.afterRecover\n                ) {\n                    const executionResult = subscriber.afterRecover({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata,\n                        databaseEntity: databaseEntity,\n                        entityId: metadata.getEntityIdMixedMap(databaseEntity),\n                    })\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n    }\n\n    /**\n     * @deprecated Use `broadcastLoadForAllEvent`\n     */\n    broadcastLoadEventsForAll(\n        result: BroadcasterResult,\n        metadata: EntityMetadata,\n        entities: ObjectLiteral[],\n    ): void {\n        return this.broadcastLoadEvent(result, metadata, entities)\n    }\n\n    /**\n     * Broadcasts \"AFTER_LOAD\" event for all given entities, and their sub-entities.\n     * After load event is executed after entity has been loaded from the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastLoadEvent(\n        result: BroadcasterResult,\n        metadata: EntityMetadata,\n        entities: ObjectLiteral[],\n    ): void {\n        // Calculate which subscribers are fitting for the given entity type\n        const fittingSubscribers =\n            this.queryRunner.connection.subscribers.filter(\n                (subscriber) =>\n                    this.isAllowedSubscriber(subscriber, metadata.target) &&\n                    subscriber.afterLoad,\n            )\n\n        if (\n            metadata.relations.length ||\n            metadata.afterLoadListeners.length ||\n            fittingSubscribers.length\n        ) {\n            // todo: check why need this?\n            const nonPromiseEntities = entities.filter(\n                (entity) => !(entity instanceof Promise),\n            )\n\n            // collect load events for all children entities that were loaded with the main entity\n            if (metadata.relations.length) {\n                metadata.relations.forEach((relation) => {\n                    nonPromiseEntities.forEach((entity) => {\n                        // in lazy relations we cannot simply access to entity property because it will cause a getter and a database query\n                        if (\n                            relation.isLazy &&\n                            !entity.hasOwnProperty(relation.propertyName)\n                        )\n                            return\n\n                        const value = relation.getEntityValue(entity)\n                        if (ObjectUtils.isObject(value))\n                            this.broadcastLoadEvent(\n                                result,\n                                relation.inverseEntityMetadata,\n                                Array.isArray(value) ? value : [value],\n                            )\n                    })\n                })\n            }\n\n            if (metadata.afterLoadListeners.length) {\n                metadata.afterLoadListeners.forEach((listener) => {\n                    nonPromiseEntities.forEach((entity) => {\n                        if (listener.isAllowed(entity)) {\n                            const executionResult = listener.execute(entity)\n                            if (executionResult instanceof Promise)\n                                result.promises.push(executionResult)\n                            result.count++\n                        }\n                    })\n                })\n            }\n\n            fittingSubscribers.forEach((subscriber) => {\n                nonPromiseEntities.forEach((entity) => {\n                    const executionResult = subscriber.afterLoad!(entity, {\n                        entity,\n                        metadata,\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                    })\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                })\n            })\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Checks if subscriber's methods can be executed by checking if its don't listen to the particular entity,\n     * or listens our entity.\n     */\n    protected isAllowedSubscriber(\n        subscriber: EntitySubscriberInterface<any>,\n        target: Function | string,\n    ): boolean {\n        return (\n            !subscriber.listenTo ||\n            !subscriber.listenTo() ||\n            subscriber.listenTo() === Object ||\n            subscriber.listenTo() === target ||\n            subscriber.listenTo().isPrototypeOf(target)\n        )\n    }\n}\n"]},"metadata":{},"sourceType":"module"}