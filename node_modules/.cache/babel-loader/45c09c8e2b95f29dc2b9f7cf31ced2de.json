{"ast":null,"code":"import { getMetadataArgsStorage } from \"../../globals\";\n/**\n * Marks a entity property as a parent of the tree.\n * \"Tree parent\" indicates who owns (is a parent) of this entity in tree structure.\n */\n\nexport function TreeParent(options) {\n  return function (object, propertyName) {\n    if (!options) options = {}; // now try to determine it its lazy relation\n\n    const reflectedType = Reflect && Reflect.getMetadata ? Reflect.getMetadata(\"design:type\", object, propertyName) : undefined;\n    const isLazy = reflectedType && typeof reflectedType.name === \"string\" && reflectedType.name.toLowerCase() === \"promise\" || false;\n    getMetadataArgsStorage().relations.push({\n      isTreeParent: true,\n      target: object.constructor,\n      propertyName: propertyName,\n      isLazy: isLazy,\n      relationType: \"many-to-one\",\n      type: () => object.constructor,\n      options: options\n    });\n  };\n}","map":{"version":3,"mappings":"AAAA,SAASA,sBAAT,QAAuC,eAAvC;AAKA;;;;;AAIA,OAAM,SAAUC,UAAV,CAAqBC,OAArB,EAEL;EACG,OAAO,UAAUC,MAAV,EAA0BC,YAA1B,EAA8C;IACjD,IAAI,CAACF,OAAL,EAAcA,OAAO,GAAG,EAAV,CADmC,CAGjD;;IACA,MAAMG,aAAa,GACfC,OAAO,IAAKA,OAAe,CAACC,WAA5B,GACMD,OAAO,CAACC,WAAR,CAAoB,aAApB,EAAmCJ,MAAnC,EAA2CC,YAA3C,CADN,GAEMI,SAHV;IAIA,MAAMC,MAAM,GACPJ,aAAa,IACV,OAAOA,aAAa,CAACK,IAArB,KAA8B,QADjC,IAEGL,aAAa,CAACK,IAAd,CAAmBC,WAAnB,OAAqC,SAFzC,IAGA,KAJJ;IAMAX,sBAAsB,GAAGY,SAAzB,CAAmCC,IAAnC,CAAwC;MACpCC,YAAY,EAAE,IADsB;MAEpCC,MAAM,EAAEZ,MAAM,CAACa,WAFqB;MAGpCZ,YAAY,EAAEA,YAHsB;MAIpCK,MAAM,EAAEA,MAJ4B;MAKpCQ,YAAY,EAAE,aALsB;MAMpCC,IAAI,EAAE,MAAMf,MAAM,CAACa,WANiB;MAOpCd,OAAO,EAAEA;IAP2B,CAAxC;EASH,CAvBD;AAwBH","names":["getMetadataArgsStorage","TreeParent","options","object","propertyName","reflectedType","Reflect","getMetadata","undefined","isLazy","name","toLowerCase","relations","push","isTreeParent","target","constructor","relationType","type"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\decorator\\tree\\TreeParent.ts"],"sourcesContent":["import { getMetadataArgsStorage } from \"../../globals\"\nimport { RelationMetadataArgs } from \"../../metadata-args/RelationMetadataArgs\"\nimport { OnDeleteType } from \"../../metadata/types/OnDeleteType\"\nimport { RelationOptions } from \"../options/RelationOptions\"\n\n/**\n * Marks a entity property as a parent of the tree.\n * \"Tree parent\" indicates who owns (is a parent) of this entity in tree structure.\n */\nexport function TreeParent(options?: {\n    onDelete?: OnDeleteType\n}): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        if (!options) options = {} as RelationOptions\n\n        // now try to determine it its lazy relation\n        const reflectedType =\n            Reflect && (Reflect as any).getMetadata\n                ? Reflect.getMetadata(\"design:type\", object, propertyName)\n                : undefined\n        const isLazy =\n            (reflectedType &&\n                typeof reflectedType.name === \"string\" &&\n                reflectedType.name.toLowerCase() === \"promise\") ||\n            false\n\n        getMetadataArgsStorage().relations.push({\n            isTreeParent: true,\n            target: object.constructor,\n            propertyName: propertyName,\n            isLazy: isLazy,\n            relationType: \"many-to-one\",\n            type: () => object.constructor,\n            options: options,\n        } as RelationMetadataArgs)\n    }\n}\n"]},"metadata":{},"sourceType":"module"}