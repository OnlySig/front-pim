{"ast":null,"code":"import { OrmUtils } from \"../../util/OrmUtils\";\nimport { DriverUtils } from \"../../driver/DriverUtils\";\nimport { ObjectUtils } from \"../../util/ObjectUtils\";\n/**\n * Transforms raw sql results returned from the database into entity object.\n * Entity is constructed based on its entity metadata.\n */\n\nexport class RawSqlResultsToEntityTransformer {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(expressionMap, driver, rawRelationIdResults, rawRelationCountResults, queryRunner) {\n    this.expressionMap = expressionMap;\n    this.driver = driver;\n    this.rawRelationIdResults = rawRelationIdResults;\n    this.rawRelationCountResults = rawRelationCountResults;\n    this.queryRunner = queryRunner;\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Since db returns a duplicated rows of the data where accuracies of the same object can be duplicated\n   * we need to group our result and we must have some unique id (primary key in our case)\n   */\n\n\n  transform(rawResults, alias) {\n    const group = this.group(rawResults, alias);\n    const entities = [];\n    group.forEach(results => {\n      const entity = this.transformRawResultsGroup(results, alias);\n      if (entity !== undefined && !Object.values(entity).every(value => value === null)) entities.push(entity);\n    });\n    return entities;\n  } // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Groups given raw results by ids of given alias.\n   */\n\n\n  group(rawResults, alias) {\n    const map = new Map();\n    const keys = [];\n\n    if (alias.metadata.tableType === \"view\") {\n      keys.push(...alias.metadata.columns.map(column => DriverUtils.buildAlias(this.driver, alias.name, column.databaseName)));\n    } else {\n      keys.push(...alias.metadata.primaryColumns.map(column => DriverUtils.buildAlias(this.driver, alias.name, column.databaseName)));\n    }\n\n    rawResults.forEach(rawResult => {\n      const id = keys.map(key => {\n        const keyValue = rawResult[key];\n\n        if (Buffer.isBuffer(keyValue)) {\n          return keyValue.toString(\"hex\");\n        }\n\n        if (ObjectUtils.isObject(keyValue)) {\n          return JSON.stringify(keyValue);\n        }\n\n        return keyValue;\n      }).join(\"_\"); // todo: check partial\n\n      const items = map.get(id);\n\n      if (!items) {\n        map.set(id, [rawResult]);\n      } else {\n        items.push(rawResult);\n      }\n    });\n    return map;\n  }\n  /**\n   * Transforms set of data results into single entity.\n   */\n\n\n  transformRawResultsGroup(rawResults, alias) {\n    // let hasColumns = false; // , hasEmbeddedColumns = false, hasParentColumns = false, hasParentEmbeddedColumns = false;\n    let metadata = alias.metadata;\n\n    if (metadata.discriminatorColumn) {\n      const discriminatorValues = rawResults.map(result => result[DriverUtils.buildAlias(this.driver, alias.name, alias.metadata.discriminatorColumn.databaseName)]);\n      const discriminatorMetadata = metadata.childEntityMetadatas.find(childEntityMetadata => {\n        return typeof discriminatorValues.find(value => value === childEntityMetadata.discriminatorValue) !== \"undefined\";\n      });\n      if (discriminatorMetadata) metadata = discriminatorMetadata;\n    }\n\n    let entity = metadata.create(this.queryRunner, {\n      fromDeserializer: true,\n      pojo: this.expressionMap.options.indexOf(\"create-pojo\") !== -1\n    }); // get value from columns selections and put them into newly created entity\n\n    const hasColumns = this.transformColumns(rawResults, alias, entity, metadata);\n    const hasRelations = this.transformJoins(rawResults, entity, alias, metadata);\n    const hasRelationIds = this.transformRelationIds(rawResults, alias, entity, metadata);\n    const hasRelationCounts = this.transformRelationCounts(rawResults, alias, entity); // if we have at least one selected column then return this entity\n    // since entity must have at least primary columns to be really selected and transformed into entity\n\n    if (hasColumns) return entity; // if we don't have any selected column we should not return entity,\n    // except for the case when entity only contain a primary column as a relation to another entity\n    // in this case its absolutely possible our entity to not have any columns except a single relation\n\n    const hasOnlyVirtualPrimaryColumns = metadata.primaryColumns.filter(column => column.isVirtual === false).length === 0; // todo: create metadata.hasOnlyVirtualPrimaryColumns\n\n    if (hasOnlyVirtualPrimaryColumns && (hasRelations || hasRelationIds || hasRelationCounts)) return entity;\n    return undefined;\n  } // get value from columns selections and put them into object\n\n\n  transformColumns(rawResults, alias, entity, metadata) {\n    let hasData = false;\n    metadata.columns.forEach(column => {\n      // if table inheritance is used make sure this column is not child's column\n      if (metadata.childEntityMetadatas.length > 0 && metadata.childEntityMetadatas.findIndex(childMetadata => childMetadata.target === column.target) !== -1) return;\n      const value = rawResults[0][DriverUtils.buildAlias(this.driver, alias.name, column.databaseName)];\n      if (value === undefined || column.isVirtual) return; // if user does not selected the whole entity or he used partial selection and does not select this particular column\n      // then we don't add this column and its value into the entity\n\n      if (!this.expressionMap.selects.find(select => select.selection === alias.name || select.selection === alias.name + \".\" + column.propertyPath)) return;\n      column.setEntityValue(entity, this.driver.prepareHydratedValue(value, column));\n      if (value !== null) // we don't mark it as has data because if we will have all nulls in our object - we don't need such object\n        hasData = true;\n    });\n    return hasData;\n  }\n  /**\n   * Transforms joined entities in the given raw results by a given alias and stores to the given (parent) entity\n   */\n\n\n  transformJoins(rawResults, entity, alias, metadata) {\n    let hasData = false; // let discriminatorValue: string = \"\";\n    // if (metadata.discriminatorColumn)\n    //     discriminatorValue = rawResults[0][DriverUtils.buildAlias(this.connection.driver, alias.name, alias.metadata.discriminatorColumn!.databaseName)];\n\n    this.expressionMap.joinAttributes.forEach(join => {\n      // todo: we have problem here - when inner joins are used without selects it still create empty array\n      // skip joins without metadata\n      if (!join.metadata) return; // if simple left or inner join was performed without selection then we don't need to do anything\n\n      if (!join.isSelected) return; // this check need to avoid setting properties than not belong to entity when single table inheritance used. (todo: check if we still need it)\n      // const metadata = metadata.childEntityMetadatas.find(childEntityMetadata => discriminatorValue === childEntityMetadata.discriminatorValue);\n\n      if (join.relation && !metadata.relations.find(relation => relation === join.relation)) return; // some checks to make sure this join is for current alias\n\n      if (join.mapToProperty) {\n        if (join.mapToPropertyParentAlias !== alias.name) return;\n      } else {\n        if (!join.relation || join.parentAlias !== alias.name || join.relationPropertyPath !== join.relation.propertyPath) return;\n      } // transform joined data into entities\n\n\n      let result = this.transform(rawResults, join.alias);\n      result = !join.isMany ? result[0] : result;\n      result = !join.isMany && result === undefined ? null : result; // this is needed to make relations to return null when its joined but nothing was found in the database\n\n      if (result === undefined) // if nothing was joined then simply return\n        return; // if join was mapped to some property then save result to that property\n\n      if (join.mapToPropertyPropertyName) {\n        entity[join.mapToPropertyPropertyName] = result; // todo: fix embeds\n      } else {\n        // otherwise set to relation\n        join.relation.setEntityValue(entity, result);\n      }\n\n      hasData = true;\n    });\n    return hasData;\n  }\n\n  transformRelationIds(rawSqlResults, alias, entity, metadata) {\n    let hasData = false;\n    this.rawRelationIdResults.forEach((rawRelationIdResult, index) => {\n      if (rawRelationIdResult.relationIdAttribute.parentAlias !== alias.name) return;\n      const relation = rawRelationIdResult.relationIdAttribute.relation;\n      const valueMap = this.createValueMapFromJoinColumns(relation, rawRelationIdResult.relationIdAttribute.parentAlias, rawSqlResults);\n\n      if (valueMap === undefined || valueMap === null) {\n        return;\n      } // prepare common data for this call\n\n\n      this.prepareDataForTransformRelationIds(); // Extract idMaps from prepared data by hash\n\n      const hash = this.hashEntityIds(relation, valueMap);\n      const idMaps = this.relationIdMaps[index][hash] || []; // Map data to properties\n\n      const properties = rawRelationIdResult.relationIdAttribute.mapToPropertyPropertyPath.split(\".\");\n\n      const mapToProperty = (properties, map, value) => {\n        const property = properties.shift();\n\n        if (property && properties.length === 0) {\n          map[property] = value;\n          return map;\n        }\n\n        if (property && properties.length > 0) {\n          mapToProperty(properties, map[property], value);\n        } else {\n          return map;\n        }\n      };\n\n      if (relation.isOneToOne || relation.isManyToOne) {\n        if (idMaps[0] !== undefined) {\n          mapToProperty(properties, entity, idMaps[0]);\n          hasData = true;\n        }\n      } else {\n        mapToProperty(properties, entity, idMaps);\n        hasData = hasData || idMaps.length > 0;\n      }\n    });\n    return hasData;\n  }\n\n  transformRelationCounts(rawSqlResults, alias, entity) {\n    let hasData = false;\n    this.rawRelationCountResults.filter(rawRelationCountResult => rawRelationCountResult.relationCountAttribute.parentAlias === alias.name).forEach(rawRelationCountResult => {\n      const relation = rawRelationCountResult.relationCountAttribute.relation;\n      let referenceColumnName;\n\n      if (relation.isOneToMany) {\n        referenceColumnName = relation.inverseRelation.joinColumns[0].referencedColumn.databaseName; // todo: fix joinColumns[0]\n      } else {\n        referenceColumnName = relation.isOwning ? relation.joinColumns[0].referencedColumn.databaseName : relation.inverseRelation.joinColumns[0].referencedColumn.databaseName;\n      }\n\n      const referenceColumnValue = rawSqlResults[0][DriverUtils.buildAlias(this.driver, alias.name, referenceColumnName)]; // we use zero index since its grouped data // todo: selection with alias for entity columns wont work\n\n      if (referenceColumnValue !== undefined && referenceColumnValue !== null) {\n        entity[rawRelationCountResult.relationCountAttribute.mapToPropertyPropertyName] = 0;\n        rawRelationCountResult.results.filter(result => result[\"parentId\"] === referenceColumnValue).forEach(result => {\n          entity[rawRelationCountResult.relationCountAttribute.mapToPropertyPropertyName] = parseInt(result[\"cnt\"]);\n          hasData = true;\n        });\n      }\n    });\n    return hasData;\n  }\n\n  createValueMapFromJoinColumns(relation, parentAlias, rawSqlResults) {\n    let columns;\n\n    if (relation.isManyToOne || relation.isOneToOneOwner) {\n      columns = relation.entityMetadata.primaryColumns.map(joinColumn => joinColumn);\n    } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n      columns = relation.inverseRelation.joinColumns.map(joinColumn => joinColumn);\n    } else {\n      if (relation.isOwning) {\n        columns = relation.joinColumns.map(joinColumn => joinColumn);\n      } else {\n        columns = relation.inverseRelation.inverseJoinColumns.map(joinColumn => joinColumn);\n      }\n    }\n\n    return columns.reduce((valueMap, column) => {\n      rawSqlResults.forEach(rawSqlResult => {\n        if (relation.isManyToOne || relation.isOneToOneOwner) {\n          valueMap[column.databaseName] = this.driver.prepareHydratedValue(rawSqlResult[DriverUtils.buildAlias(this.driver, parentAlias, column.databaseName)], column);\n        } else {\n          valueMap[column.databaseName] = this.driver.prepareHydratedValue(rawSqlResult[DriverUtils.buildAlias(this.driver, parentAlias, column.referencedColumn.databaseName)], column);\n        }\n      });\n      return valueMap;\n    }, {});\n  }\n\n  extractEntityPrimaryIds(relation, relationIdRawResult) {\n    let columns;\n\n    if (relation.isManyToOne || relation.isOneToOneOwner) {\n      columns = relation.entityMetadata.primaryColumns.map(joinColumn => joinColumn);\n    } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n      columns = relation.inverseRelation.joinColumns.map(joinColumn => joinColumn);\n    } else {\n      if (relation.isOwning) {\n        columns = relation.joinColumns.map(joinColumn => joinColumn);\n      } else {\n        columns = relation.inverseRelation.inverseJoinColumns.map(joinColumn => joinColumn);\n      }\n    }\n\n    return columns.reduce((data, column) => {\n      data[column.databaseName] = relationIdRawResult[column.databaseName];\n      return data;\n    }, {});\n  }\n  /*private removeVirtualColumns(entity: ObjectLiteral, alias: Alias) {\n      const virtualColumns = this.expressionMap.selects\n          .filter(select => select.virtual)\n          .map(select => select.selection.replace(alias.name + \".\", \"\"));\n       virtualColumns.forEach(virtualColumn => delete entity[virtualColumn]);\n  }*/\n\n  /** Prepare data to run #transformRelationIds, as a lot of result independent data is needed in every call */\n\n\n  prepareDataForTransformRelationIds() {\n    // Return early if the relationIdMaps were already calculated\n    if (this.relationIdMaps) {\n      return;\n    } // Ensure this prepare function is only called once\n\n\n    this.relationIdMaps = this.rawRelationIdResults.map(rawRelationIdResult => {\n      const relation = rawRelationIdResult.relationIdAttribute.relation; // Calculate column metadata\n\n      let columns;\n\n      if (relation.isManyToOne || relation.isOneToOneOwner) {\n        columns = relation.joinColumns;\n      } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n        columns = relation.inverseEntityMetadata.primaryColumns;\n      } else {\n        // ManyToMany\n        if (relation.isOwning) {\n          columns = relation.inverseJoinColumns;\n        } else {\n          columns = relation.inverseRelation.joinColumns;\n        }\n      } // Calculate the idMaps for the rawRelationIdResult\n\n\n      return rawRelationIdResult.results.reduce((agg, result) => {\n        let idMap = columns.reduce((idMap, column) => {\n          let value = result[column.databaseName];\n\n          if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n            if (column.isVirtual && column.referencedColumn && column.referencedColumn.propertyName !== column.propertyName) {\n              // if column is a relation\n              value = column.referencedColumn.createValueMap(value);\n            }\n\n            return OrmUtils.mergeDeep(idMap, column.createValueMap(value));\n          }\n\n          if (!column.isPrimary && column.referencedColumn.referencedColumn) {\n            // if column is a relation\n            value = column.referencedColumn.referencedColumn.createValueMap(value);\n          }\n\n          return OrmUtils.mergeDeep(idMap, column.referencedColumn.createValueMap(value));\n        }, {});\n\n        if (columns.length === 1 && !rawRelationIdResult.relationIdAttribute.disableMixedMap) {\n          if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n            idMap = columns[0].getEntityValue(idMap);\n          } else {\n            idMap = columns[0].referencedColumn.getEntityValue(idMap);\n          }\n        } // If an idMap is found, set it in the aggregator under the correct hash\n\n\n        if (idMap !== undefined) {\n          const hash = this.hashEntityIds(relation, result);\n\n          if (agg[hash]) {\n            agg[hash].push(idMap);\n          } else {\n            agg[hash] = [idMap];\n          }\n        }\n\n        return agg;\n      }, {});\n    });\n  }\n  /**\n   * Use a simple JSON.stringify to create a simple hash of the primary ids of an entity.\n   * As this.extractEntityPrimaryIds always creates the primary id object in the same order, if the same relation is\n   * given, a simple JSON.stringify should be enough to get a unique hash per entity!\n   */\n\n\n  hashEntityIds(relation, data) {\n    const entityPrimaryIds = this.extractEntityPrimaryIds(relation, data);\n    return JSON.stringify(entityPrimaryIds);\n  }\n\n}","map":{"version":3,"mappings":"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","names":["OrmUtils","DriverUtils","ObjectUtils","RawSqlResultsToEntityTransformer","constructor","expressionMap","driver","rawRelationIdResults","rawRelationCountResults","queryRunner","transform","rawResults","alias","group","entities","forEach","results","entity","transformRawResultsGroup","undefined","Object","values","every","value","push","map","Map","keys","metadata","tableType","columns","column","buildAlias","name","databaseName","primaryColumns","rawResult","id","key","keyValue","Buffer","isBuffer","toString","isObject","JSON","stringify","join","items","get","set","discriminatorColumn","discriminatorValues","result","discriminatorMetadata","childEntityMetadatas","find","childEntityMetadata","discriminatorValue","create","fromDeserializer","pojo","options","indexOf","hasColumns","transformColumns","hasRelations","transformJoins","hasRelationIds","transformRelationIds","hasRelationCounts","transformRelationCounts","hasOnlyVirtualPrimaryColumns","filter","isVirtual","length","hasData","findIndex","childMetadata","target","selects","select","selection","propertyPath","setEntityValue","prepareHydratedValue","joinAttributes","isSelected","relation","relations","mapToProperty","mapToPropertyParentAlias","parentAlias","relationPropertyPath","isMany","mapToPropertyPropertyName","rawSqlResults","rawRelationIdResult","index","relationIdAttribute","valueMap","createValueMapFromJoinColumns","prepareDataForTransformRelationIds","hash","hashEntityIds","idMaps","relationIdMaps","properties","mapToPropertyPropertyPath","split","property","shift","isOneToOne","isManyToOne","rawRelationCountResult","relationCountAttribute","referenceColumnName","isOneToMany","inverseRelation","joinColumns","referencedColumn","isOwning","referenceColumnValue","parseInt","isOneToOneOwner","entityMetadata","joinColumn","isOneToOneNotOwner","inverseJoinColumns","reduce","rawSqlResult","extractEntityPrimaryIds","relationIdRawResult","data","inverseEntityMetadata","agg","idMap","propertyName","createValueMap","mergeDeep","isPrimary","disableMixedMap","getEntityValue","entityPrimaryIds"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\query-builder\\transformer\\RawSqlResultsToEntityTransformer.ts"],"sourcesContent":["import { Driver } from \"../../driver/Driver\"\nimport { RelationIdLoadResult } from \"../relation-id/RelationIdLoadResult\"\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { ColumnMetadata } from \"../../metadata/ColumnMetadata\"\nimport { Alias } from \"../Alias\"\nimport { RelationCountLoadResult } from \"../relation-count/RelationCountLoadResult\"\nimport { RelationMetadata } from \"../../metadata/RelationMetadata\"\nimport { OrmUtils } from \"../../util/OrmUtils\"\nimport { QueryExpressionMap } from \"../QueryExpressionMap\"\nimport { EntityMetadata } from \"../../metadata/EntityMetadata\"\nimport { QueryRunner } from \"../..\"\nimport { DriverUtils } from \"../../driver/DriverUtils\"\nimport { ObjectUtils } from \"../../util/ObjectUtils\"\n\n/**\n * Transforms raw sql results returned from the database into entity object.\n * Entity is constructed based on its entity metadata.\n */\nexport class RawSqlResultsToEntityTransformer {\n    /**\n     * Contains a hashmap for every rawRelationIdResults given.\n     * In the hashmap you will find the idMaps of a result under the hash of this.hashEntityIds for the result.\n     */\n    private relationIdMaps: Array<{ [idHash: string]: any[] }>\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        protected expressionMap: QueryExpressionMap,\n        protected driver: Driver,\n        protected rawRelationIdResults: RelationIdLoadResult[],\n        protected rawRelationCountResults: RelationCountLoadResult[],\n        protected queryRunner?: QueryRunner,\n    ) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Since db returns a duplicated rows of the data where accuracies of the same object can be duplicated\n     * we need to group our result and we must have some unique id (primary key in our case)\n     */\n    transform(rawResults: any[], alias: Alias): any[] {\n        const group = this.group(rawResults, alias)\n        const entities: any[] = []\n        group.forEach((results) => {\n            const entity = this.transformRawResultsGroup(results, alias)\n            if (\n                entity !== undefined &&\n                !Object.values(entity).every((value) => value === null)\n            )\n                entities.push(entity)\n        })\n        return entities\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Groups given raw results by ids of given alias.\n     */\n    protected group(rawResults: any[], alias: Alias): Map<string, any[]> {\n        const map = new Map()\n        const keys: string[] = []\n        if (alias.metadata.tableType === \"view\") {\n            keys.push(\n                ...alias.metadata.columns.map((column) =>\n                    DriverUtils.buildAlias(\n                        this.driver,\n                        alias.name,\n                        column.databaseName,\n                    ),\n                ),\n            )\n        } else {\n            keys.push(\n                ...alias.metadata.primaryColumns.map((column) =>\n                    DriverUtils.buildAlias(\n                        this.driver,\n                        alias.name,\n                        column.databaseName,\n                    ),\n                ),\n            )\n        }\n        rawResults.forEach((rawResult) => {\n            const id = keys\n                .map((key) => {\n                    const keyValue = rawResult[key]\n\n                    if (Buffer.isBuffer(keyValue)) {\n                        return keyValue.toString(\"hex\")\n                    }\n\n                    if (ObjectUtils.isObject(keyValue)) {\n                        return JSON.stringify(keyValue)\n                    }\n\n                    return keyValue\n                })\n                .join(\"_\") // todo: check partial\n\n            const items = map.get(id)\n            if (!items) {\n                map.set(id, [rawResult])\n            } else {\n                items.push(rawResult)\n            }\n        })\n        return map\n    }\n\n    /**\n     * Transforms set of data results into single entity.\n     */\n    protected transformRawResultsGroup(\n        rawResults: any[],\n        alias: Alias,\n    ): ObjectLiteral | undefined {\n        // let hasColumns = false; // , hasEmbeddedColumns = false, hasParentColumns = false, hasParentEmbeddedColumns = false;\n        let metadata = alias.metadata\n\n        if (metadata.discriminatorColumn) {\n            const discriminatorValues = rawResults.map(\n                (result) =>\n                    result[\n                        DriverUtils.buildAlias(\n                            this.driver,\n                            alias.name,\n                            alias.metadata.discriminatorColumn!.databaseName,\n                        )\n                    ],\n            )\n            const discriminatorMetadata = metadata.childEntityMetadatas.find(\n                (childEntityMetadata) => {\n                    return (\n                        typeof discriminatorValues.find(\n                            (value) =>\n                                value ===\n                                childEntityMetadata.discriminatorValue,\n                        ) !== \"undefined\"\n                    )\n                },\n            )\n            if (discriminatorMetadata) metadata = discriminatorMetadata\n        }\n        let entity: any = metadata.create(this.queryRunner, {\n            fromDeserializer: true,\n            pojo: this.expressionMap.options.indexOf(\"create-pojo\") !== -1,\n        })\n\n        // get value from columns selections and put them into newly created entity\n        const hasColumns = this.transformColumns(\n            rawResults,\n            alias,\n            entity,\n            metadata,\n        )\n        const hasRelations = this.transformJoins(\n            rawResults,\n            entity,\n            alias,\n            metadata,\n        )\n        const hasRelationIds = this.transformRelationIds(\n            rawResults,\n            alias,\n            entity,\n            metadata,\n        )\n        const hasRelationCounts = this.transformRelationCounts(\n            rawResults,\n            alias,\n            entity,\n        )\n\n        // if we have at least one selected column then return this entity\n        // since entity must have at least primary columns to be really selected and transformed into entity\n        if (hasColumns) return entity\n\n        // if we don't have any selected column we should not return entity,\n        // except for the case when entity only contain a primary column as a relation to another entity\n        // in this case its absolutely possible our entity to not have any columns except a single relation\n        const hasOnlyVirtualPrimaryColumns =\n            metadata.primaryColumns.filter(\n                (column) => column.isVirtual === false,\n            ).length === 0 // todo: create metadata.hasOnlyVirtualPrimaryColumns\n        if (\n            hasOnlyVirtualPrimaryColumns &&\n            (hasRelations || hasRelationIds || hasRelationCounts)\n        )\n            return entity\n\n        return undefined\n    }\n\n    // get value from columns selections and put them into object\n    protected transformColumns(\n        rawResults: any[],\n        alias: Alias,\n        entity: ObjectLiteral,\n        metadata: EntityMetadata,\n    ): boolean {\n        let hasData = false\n        metadata.columns.forEach((column) => {\n            // if table inheritance is used make sure this column is not child's column\n            if (\n                metadata.childEntityMetadatas.length > 0 &&\n                metadata.childEntityMetadatas.findIndex(\n                    (childMetadata) => childMetadata.target === column.target,\n                ) !== -1\n            )\n                return\n\n            const value =\n                rawResults[0][\n                    DriverUtils.buildAlias(\n                        this.driver,\n                        alias.name,\n                        column.databaseName,\n                    )\n                ]\n            if (value === undefined || column.isVirtual) return\n\n            // if user does not selected the whole entity or he used partial selection and does not select this particular column\n            // then we don't add this column and its value into the entity\n            if (\n                !this.expressionMap.selects.find(\n                    (select) =>\n                        select.selection === alias.name ||\n                        select.selection ===\n                            alias.name + \".\" + column.propertyPath,\n                )\n            )\n                return\n\n            column.setEntityValue(\n                entity,\n                this.driver.prepareHydratedValue(value, column),\n            )\n            if (value !== null)\n                // we don't mark it as has data because if we will have all nulls in our object - we don't need such object\n                hasData = true\n        })\n        return hasData\n    }\n\n    /**\n     * Transforms joined entities in the given raw results by a given alias and stores to the given (parent) entity\n     */\n    protected transformJoins(\n        rawResults: any[],\n        entity: ObjectLiteral,\n        alias: Alias,\n        metadata: EntityMetadata,\n    ) {\n        let hasData = false\n\n        // let discriminatorValue: string = \"\";\n        // if (metadata.discriminatorColumn)\n        //     discriminatorValue = rawResults[0][DriverUtils.buildAlias(this.connection.driver, alias.name, alias.metadata.discriminatorColumn!.databaseName)];\n\n        this.expressionMap.joinAttributes.forEach((join) => {\n            // todo: we have problem here - when inner joins are used without selects it still create empty array\n\n            // skip joins without metadata\n            if (!join.metadata) return\n\n            // if simple left or inner join was performed without selection then we don't need to do anything\n            if (!join.isSelected) return\n\n            // this check need to avoid setting properties than not belong to entity when single table inheritance used. (todo: check if we still need it)\n            // const metadata = metadata.childEntityMetadatas.find(childEntityMetadata => discriminatorValue === childEntityMetadata.discriminatorValue);\n            if (\n                join.relation &&\n                !metadata.relations.find(\n                    (relation) => relation === join.relation,\n                )\n            )\n                return\n\n            // some checks to make sure this join is for current alias\n            if (join.mapToProperty) {\n                if (join.mapToPropertyParentAlias !== alias.name) return\n            } else {\n                if (\n                    !join.relation ||\n                    join.parentAlias !== alias.name ||\n                    join.relationPropertyPath !== join.relation!.propertyPath\n                )\n                    return\n            }\n\n            // transform joined data into entities\n            let result: any = this.transform(rawResults, join.alias)\n            result = !join.isMany ? result[0] : result\n            result = !join.isMany && result === undefined ? null : result // this is needed to make relations to return null when its joined but nothing was found in the database\n            if (result === undefined)\n                // if nothing was joined then simply return\n                return\n\n            // if join was mapped to some property then save result to that property\n            if (join.mapToPropertyPropertyName) {\n                entity[join.mapToPropertyPropertyName] = result // todo: fix embeds\n            } else {\n                // otherwise set to relation\n                join.relation!.setEntityValue(entity, result)\n            }\n\n            hasData = true\n        })\n        return hasData\n    }\n\n    protected transformRelationIds(\n        rawSqlResults: any[],\n        alias: Alias,\n        entity: ObjectLiteral,\n        metadata: EntityMetadata,\n    ): boolean {\n        let hasData = false\n        this.rawRelationIdResults.forEach((rawRelationIdResult, index) => {\n            if (\n                rawRelationIdResult.relationIdAttribute.parentAlias !==\n                alias.name\n            )\n                return\n\n            const relation = rawRelationIdResult.relationIdAttribute.relation\n            const valueMap = this.createValueMapFromJoinColumns(\n                relation,\n                rawRelationIdResult.relationIdAttribute.parentAlias,\n                rawSqlResults,\n            )\n            if (valueMap === undefined || valueMap === null) {\n                return\n            }\n\n            // prepare common data for this call\n            this.prepareDataForTransformRelationIds()\n\n            // Extract idMaps from prepared data by hash\n            const hash = this.hashEntityIds(relation, valueMap)\n            const idMaps = this.relationIdMaps[index][hash] || []\n\n            // Map data to properties\n            const properties =\n                rawRelationIdResult.relationIdAttribute.mapToPropertyPropertyPath.split(\n                    \".\",\n                )\n            const mapToProperty = (\n                properties: string[],\n                map: ObjectLiteral,\n                value: any,\n            ): any => {\n                const property = properties.shift()\n                if (property && properties.length === 0) {\n                    map[property] = value\n                    return map\n                }\n                if (property && properties.length > 0) {\n                    mapToProperty(properties, map[property], value)\n                } else {\n                    return map\n                }\n            }\n            if (relation.isOneToOne || relation.isManyToOne) {\n                if (idMaps[0] !== undefined) {\n                    mapToProperty(properties, entity, idMaps[0])\n                    hasData = true\n                }\n            } else {\n                mapToProperty(properties, entity, idMaps)\n                hasData = hasData || idMaps.length > 0\n            }\n        })\n\n        return hasData\n    }\n\n    protected transformRelationCounts(\n        rawSqlResults: any[],\n        alias: Alias,\n        entity: ObjectLiteral,\n    ): boolean {\n        let hasData = false\n        this.rawRelationCountResults\n            .filter(\n                (rawRelationCountResult) =>\n                    rawRelationCountResult.relationCountAttribute\n                        .parentAlias === alias.name,\n            )\n            .forEach((rawRelationCountResult) => {\n                const relation =\n                    rawRelationCountResult.relationCountAttribute.relation\n                let referenceColumnName: string\n\n                if (relation.isOneToMany) {\n                    referenceColumnName =\n                        relation.inverseRelation!.joinColumns[0]\n                            .referencedColumn!.databaseName // todo: fix joinColumns[0]\n                } else {\n                    referenceColumnName = relation.isOwning\n                        ? relation.joinColumns[0].referencedColumn!.databaseName\n                        : relation.inverseRelation!.joinColumns[0]\n                              .referencedColumn!.databaseName\n                }\n\n                const referenceColumnValue =\n                    rawSqlResults[0][\n                        DriverUtils.buildAlias(\n                            this.driver,\n                            alias.name,\n                            referenceColumnName,\n                        )\n                    ] // we use zero index since its grouped data // todo: selection with alias for entity columns wont work\n                if (\n                    referenceColumnValue !== undefined &&\n                    referenceColumnValue !== null\n                ) {\n                    entity[\n                        rawRelationCountResult.relationCountAttribute.mapToPropertyPropertyName\n                    ] = 0\n                    rawRelationCountResult.results\n                        .filter(\n                            (result) =>\n                                result[\"parentId\"] === referenceColumnValue,\n                        )\n                        .forEach((result) => {\n                            entity[\n                                rawRelationCountResult.relationCountAttribute.mapToPropertyPropertyName\n                            ] = parseInt(result[\"cnt\"])\n                            hasData = true\n                        })\n                }\n            })\n\n        return hasData\n    }\n\n    private createValueMapFromJoinColumns(\n        relation: RelationMetadata,\n        parentAlias: string,\n        rawSqlResults: any[],\n    ): ObjectLiteral {\n        let columns: ColumnMetadata[]\n        if (relation.isManyToOne || relation.isOneToOneOwner) {\n            columns = relation.entityMetadata.primaryColumns.map(\n                (joinColumn) => joinColumn,\n            )\n        } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n            columns = relation.inverseRelation!.joinColumns.map(\n                (joinColumn) => joinColumn,\n            )\n        } else {\n            if (relation.isOwning) {\n                columns = relation.joinColumns.map((joinColumn) => joinColumn)\n            } else {\n                columns = relation.inverseRelation!.inverseJoinColumns.map(\n                    (joinColumn) => joinColumn,\n                )\n            }\n        }\n        return columns.reduce((valueMap, column) => {\n            rawSqlResults.forEach((rawSqlResult) => {\n                if (relation.isManyToOne || relation.isOneToOneOwner) {\n                    valueMap[column.databaseName] =\n                        this.driver.prepareHydratedValue(\n                            rawSqlResult[\n                                DriverUtils.buildAlias(\n                                    this.driver,\n                                    parentAlias,\n                                    column.databaseName,\n                                )\n                            ],\n                            column,\n                        )\n                } else {\n                    valueMap[column.databaseName] =\n                        this.driver.prepareHydratedValue(\n                            rawSqlResult[\n                                DriverUtils.buildAlias(\n                                    this.driver,\n                                    parentAlias,\n                                    column.referencedColumn!.databaseName,\n                                )\n                            ],\n                            column,\n                        )\n                }\n            })\n            return valueMap\n        }, {} as ObjectLiteral)\n    }\n\n    private extractEntityPrimaryIds(\n        relation: RelationMetadata,\n        relationIdRawResult: any,\n    ) {\n        let columns: ColumnMetadata[]\n        if (relation.isManyToOne || relation.isOneToOneOwner) {\n            columns = relation.entityMetadata.primaryColumns.map(\n                (joinColumn) => joinColumn,\n            )\n        } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n            columns = relation.inverseRelation!.joinColumns.map(\n                (joinColumn) => joinColumn,\n            )\n        } else {\n            if (relation.isOwning) {\n                columns = relation.joinColumns.map((joinColumn) => joinColumn)\n            } else {\n                columns = relation.inverseRelation!.inverseJoinColumns.map(\n                    (joinColumn) => joinColumn,\n                )\n            }\n        }\n        return columns.reduce((data, column) => {\n            data[column.databaseName] = relationIdRawResult[column.databaseName]\n            return data\n        }, {} as ObjectLiteral)\n    }\n\n    /*private removeVirtualColumns(entity: ObjectLiteral, alias: Alias) {\n        const virtualColumns = this.expressionMap.selects\n            .filter(select => select.virtual)\n            .map(select => select.selection.replace(alias.name + \".\", \"\"));\n\n        virtualColumns.forEach(virtualColumn => delete entity[virtualColumn]);\n    }*/\n\n    /** Prepare data to run #transformRelationIds, as a lot of result independent data is needed in every call */\n    private prepareDataForTransformRelationIds() {\n        // Return early if the relationIdMaps were already calculated\n        if (this.relationIdMaps) {\n            return\n        }\n\n        // Ensure this prepare function is only called once\n        this.relationIdMaps = this.rawRelationIdResults.map(\n            (rawRelationIdResult) => {\n                const relation =\n                    rawRelationIdResult.relationIdAttribute.relation\n\n                // Calculate column metadata\n                let columns: ColumnMetadata[]\n                if (relation.isManyToOne || relation.isOneToOneOwner) {\n                    columns = relation.joinColumns\n                } else if (\n                    relation.isOneToMany ||\n                    relation.isOneToOneNotOwner\n                ) {\n                    columns = relation.inverseEntityMetadata.primaryColumns\n                } else {\n                    // ManyToMany\n                    if (relation.isOwning) {\n                        columns = relation.inverseJoinColumns\n                    } else {\n                        columns = relation.inverseRelation!.joinColumns\n                    }\n                }\n\n                // Calculate the idMaps for the rawRelationIdResult\n                return rawRelationIdResult.results.reduce((agg, result) => {\n                    let idMap = columns.reduce((idMap, column) => {\n                        let value = result[column.databaseName]\n                        if (\n                            relation.isOneToMany ||\n                            relation.isOneToOneNotOwner\n                        ) {\n                            if (\n                                column.isVirtual &&\n                                column.referencedColumn &&\n                                column.referencedColumn.propertyName !==\n                                    column.propertyName\n                            ) {\n                                // if column is a relation\n                                value =\n                                    column.referencedColumn.createValueMap(\n                                        value,\n                                    )\n                            }\n\n                            return OrmUtils.mergeDeep(\n                                idMap,\n                                column.createValueMap(value),\n                            )\n                        }\n                        if (\n                            !column.isPrimary &&\n                            column.referencedColumn!.referencedColumn\n                        ) {\n                            // if column is a relation\n                            value =\n                                column.referencedColumn!.referencedColumn!.createValueMap(\n                                    value,\n                                )\n                        }\n\n                        return OrmUtils.mergeDeep(\n                            idMap,\n                            column.referencedColumn!.createValueMap(value),\n                        )\n                    }, {} as ObjectLiteral)\n\n                    if (\n                        columns.length === 1 &&\n                        !rawRelationIdResult.relationIdAttribute.disableMixedMap\n                    ) {\n                        if (\n                            relation.isOneToMany ||\n                            relation.isOneToOneNotOwner\n                        ) {\n                            idMap = columns[0].getEntityValue(idMap)\n                        } else {\n                            idMap =\n                                columns[0].referencedColumn!.getEntityValue(\n                                    idMap,\n                                )\n                        }\n                    }\n\n                    // If an idMap is found, set it in the aggregator under the correct hash\n                    if (idMap !== undefined) {\n                        const hash = this.hashEntityIds(relation, result)\n\n                        if (agg[hash]) {\n                            agg[hash].push(idMap)\n                        } else {\n                            agg[hash] = [idMap]\n                        }\n                    }\n\n                    return agg\n                }, {})\n            },\n        )\n    }\n\n    /**\n     * Use a simple JSON.stringify to create a simple hash of the primary ids of an entity.\n     * As this.extractEntityPrimaryIds always creates the primary id object in the same order, if the same relation is\n     * given, a simple JSON.stringify should be enough to get a unique hash per entity!\n     */\n    private hashEntityIds(relation: RelationMetadata, data: ObjectLiteral) {\n        const entityPrimaryIds = this.extractEntityPrimaryIds(relation, data)\n        return JSON.stringify(entityPrimaryIds)\n    }\n}\n"]},"metadata":{},"sourceType":"module"}