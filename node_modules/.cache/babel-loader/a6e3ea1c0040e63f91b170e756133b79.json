{"ast":null,"code":"export class OrmUtils {\n  // -------------------------------------------------------------------------\n  // Public methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Chunks array into pieces.\n   */\n  static chunk(array, size) {\n    return Array.from(Array(Math.ceil(array.length / size)), (_, i) => {\n      return array.slice(i * size, i * size + size);\n    });\n  }\n\n  static splitClassesAndStrings(classesAndStrings) {\n    return [classesAndStrings.filter(cls => typeof cls !== \"string\"), classesAndStrings.filter(str => typeof str === \"string\")];\n  }\n\n  static groupBy(array, propertyCallback) {\n    return array.reduce((groupedArray, value) => {\n      const key = propertyCallback(value);\n      let grouped = groupedArray.find(i => i.id === key);\n\n      if (!grouped) {\n        grouped = {\n          id: key,\n          items: []\n        };\n        groupedArray.push(grouped);\n      }\n\n      grouped.items.push(value);\n      return groupedArray;\n    }, []);\n  }\n\n  static uniq(array, criteriaOrProperty) {\n    return array.reduce((uniqueArray, item) => {\n      let found = false;\n\n      if (typeof criteriaOrProperty === \"function\") {\n        const itemValue = criteriaOrProperty(item);\n        found = !!uniqueArray.find(uniqueItem => criteriaOrProperty(uniqueItem) === itemValue);\n      } else if (typeof criteriaOrProperty === \"string\") {\n        found = !!uniqueArray.find(uniqueItem => uniqueItem[criteriaOrProperty] === item[criteriaOrProperty]);\n      } else {\n        found = uniqueArray.indexOf(item) !== -1;\n      }\n\n      if (!found) uniqueArray.push(item);\n      return uniqueArray;\n    }, []);\n  } // Checks if it's an object made by Object.create(null), {} or new Object()\n\n\n  static isPlainObject(item) {\n    if (item === null || item === undefined) {\n      return false;\n    }\n\n    return !item.constructor || item.constructor === Object;\n  }\n\n  static mergeArrayKey(target, key, value, memo) {\n    // Have we seen this before?  Prevent infinite recursion.\n    if (memo.has(value)) {\n      target[key] = memo.get(value);\n      return;\n    }\n\n    if (value instanceof Promise) {\n      // Skip promises entirely.\n      // This is a hold-over from the old code & is because we don't want to pull in\n      // the lazy fields.  Ideally we'd remove these promises via another function first\n      // but for now we have to do it here.\n      return;\n    }\n\n    if (!this.isPlainObject(value) && !Array.isArray(value)) {\n      target[key] = value;\n      return;\n    }\n\n    if (!target[key]) {\n      target[key] = Array.isArray(value) ? [] : {};\n    }\n\n    memo.set(value, target[key]);\n    this.merge(target[key], value, memo);\n    memo.delete(value);\n  }\n\n  static mergeObjectKey(target, key, value, memo) {\n    // Have we seen this before?  Prevent infinite recursion.\n    if (memo.has(value)) {\n      Object.assign(target, {\n        [key]: memo.get(value)\n      });\n      return;\n    }\n\n    if (value instanceof Promise) {\n      // Skip promises entirely.\n      // This is a hold-over from the old code & is because we don't want to pull in\n      // the lazy fields.  Ideally we'd remove these promises via another function first\n      // but for now we have to do it here.\n      return;\n    }\n\n    if (!this.isPlainObject(value) && !Array.isArray(value)) {\n      Object.assign(target, {\n        [key]: value\n      });\n      return;\n    }\n\n    if (!target[key]) {\n      Object.assign(target, {\n        [key]: Array.isArray(value) ? [] : {}\n      });\n    }\n\n    memo.set(value, target[key]);\n    this.merge(target[key], value, memo);\n    memo.delete(value);\n  }\n\n  static merge(target, source) {\n    let memo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Map();\n\n    if (this.isPlainObject(target) && this.isPlainObject(source)) {\n      for (const key of Object.keys(source)) {\n        if (key === \"__proto__\") continue;\n        this.mergeObjectKey(target, key, source[key], memo);\n      }\n    }\n\n    if (Array.isArray(target) && Array.isArray(source)) {\n      for (let key = 0; key < source.length; key++) {\n        this.mergeArrayKey(target, key, source[key], memo);\n      }\n    }\n  }\n  /**\n   * Deep Object.assign.\n   */\n\n\n  static mergeDeep(target) {\n    for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      sources[_key - 1] = arguments[_key];\n    }\n\n    if (!sources.length) {\n      return target;\n    }\n\n    for (const source of sources) {\n      OrmUtils.merge(target, source);\n    }\n\n    return target;\n  }\n  /**\n   * Deep compare objects.\n   *\n   * @see http://stackoverflow.com/a/1144249\n   */\n\n\n  static deepCompare() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    let i, l, leftChain, rightChain;\n\n    if (arguments.length < 1) {\n      return true; // Die silently? Don't know how to handle such case, please help...\n      // throw \"Need two or more arguments to compare\";\n    }\n\n    for (i = 1, l = arguments.length; i < l; i++) {\n      leftChain = []; // Todo: this can be cached\n\n      rightChain = [];\n\n      if (!this.compare2Objects(leftChain, rightChain, arguments[0], arguments[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Gets deeper value of object.\n   */\n\n\n  static deepValue(obj, path) {\n    const segments = path.split(\".\");\n\n    for (let i = 0, len = segments.length; i < len; i++) {\n      obj = obj[segments[i]];\n    }\n\n    return obj;\n  }\n\n  static replaceEmptyObjectsWithBooleans(obj) {\n    for (let key in obj) {\n      if (obj[key] && typeof obj[key] === \"object\") {\n        if (Object.keys(obj[key]).length === 0) {\n          obj[key] = true;\n        } else {\n          this.replaceEmptyObjectsWithBooleans(obj[key]);\n        }\n      }\n    }\n  }\n\n  static propertyPathsToTruthyObject(paths) {\n    let obj = {};\n\n    for (let path of paths) {\n      const props = path.split(\".\");\n      if (!props.length) continue;\n\n      if (!obj[props[0]] || obj[props[0]] === true) {\n        obj[props[0]] = {};\n      }\n\n      let recursiveChild = obj[props[0]];\n\n      for (let [key, prop] of props.entries()) {\n        if (key === 0) continue;\n\n        if (recursiveChild[prop]) {\n          recursiveChild = recursiveChild[prop];\n        } else if (key === props.length - 1) {\n          recursiveChild[prop] = {};\n          recursiveChild = null;\n        } else {\n          recursiveChild[prop] = {};\n          recursiveChild = recursiveChild[prop];\n        }\n      }\n    }\n\n    this.replaceEmptyObjectsWithBooleans(obj);\n    return obj;\n  }\n  /**\n   * Check if two entity-id-maps are the same\n   */\n\n\n  static compareIds(firstId, secondId) {\n    if (firstId === undefined || firstId === null || secondId === undefined || secondId === null) return false; // Optimized version for the common case\n\n    if ((typeof firstId.id === \"string\" && typeof secondId.id === \"string\" || typeof firstId.id === \"number\" && typeof secondId.id === \"number\") && Object.keys(firstId).length === 1 && Object.keys(secondId).length === 1) {\n      return firstId.id === secondId.id;\n    }\n\n    return OrmUtils.deepCompare(firstId, secondId);\n  }\n  /**\n   * Transforms given value into boolean value.\n   */\n\n\n  static toBoolean(value) {\n    if (typeof value === \"boolean\") return value;\n    if (typeof value === \"string\") return value === \"true\" || value === \"1\";\n    if (typeof value === \"number\") return value > 0;\n    return false;\n  }\n  /**\n   * Composes an object from the given array of keys and values.\n   */\n\n\n  static zipObject(keys, values) {\n    return keys.reduce((object, column, index) => {\n      object[column] = values[index];\n      return object;\n    }, {});\n  }\n  /**\n   * Compares two arrays.\n   */\n\n\n  static isArraysEqual(arr1, arr2) {\n    if (arr1.length !== arr2.length) return false;\n    return arr1.every(element => {\n      return arr2.indexOf(element) !== -1;\n    });\n  }\n\n  static areMutuallyExclusive() {\n    for (var _len3 = arguments.length, lists = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      lists[_key3] = arguments[_key3];\n    }\n\n    const haveSharedObjects = lists.some(list => {\n      const otherLists = lists.filter(otherList => otherList !== list);\n      return list.some(item => otherLists.some(otherList => otherList.includes(item)));\n    });\n    return !haveSharedObjects;\n  } // -------------------------------------------------------------------------\n  // Private methods\n  // -------------------------------------------------------------------------\n\n\n  static compare2Objects(leftChain, rightChain, x, y) {\n    let p; // remember that NaN === NaN returns false\n    // and isNaN(undefined) returns true\n\n    if (Number.isNaN(x) && Number.isNaN(y)) return true; // Compare primitives and functions.\n    // Check if both arguments link to the same object.\n    // Especially useful on the step where we compare prototypes\n\n    if (x === y) return true; // Unequal, but either is null or undefined (use case: jsonb comparison)\n    // PR #3776, todo: add tests\n\n    if (x === null || y === null || x === undefined || y === undefined) return false; // Fix the buffer compare bug.\n    // See: https://github.com/typeorm/typeorm/issues/3654\n\n    if ((typeof x.equals === \"function\" || typeof x.equals === \"function\") && x.equals(y)) return true; // Works in case when functions are created in constructor.\n    // Comparing dates is a common scenario. Another built-ins?\n    // We can even handle functions passed across iframes\n\n    if (typeof x === \"function\" && typeof y === \"function\" || x instanceof Date && y instanceof Date || x instanceof RegExp && y instanceof RegExp || typeof x === \"string\" && typeof y === \"string\" || typeof x === \"number\" && typeof y === \"number\") return x.toString() === y.toString(); // At last checking prototypes as good as we can\n\n    if (!(typeof x === \"object\" && typeof y === \"object\")) return false;\n    if (x.isPrototypeOf(y) || y.isPrototypeOf(x)) return false;\n    if (x.constructor !== y.constructor) return false;\n    if (x.prototype !== y.prototype) return false; // Check for infinitive linking loops\n\n    if (leftChain.indexOf(x) > -1 || rightChain.indexOf(y) > -1) return false; // Quick checking of one object being a subset of another.\n    // todo: cache the structure of arguments[0] for performance\n\n    for (p in y) {\n      if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {\n        return false;\n      } else if (typeof y[p] !== typeof x[p]) {\n        return false;\n      }\n    }\n\n    for (p in x) {\n      if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {\n        return false;\n      } else if (typeof y[p] !== typeof x[p]) {\n        return false;\n      }\n\n      switch (typeof x[p]) {\n        case \"object\":\n        case \"function\":\n          leftChain.push(x);\n          rightChain.push(y);\n\n          if (!this.compare2Objects(leftChain, rightChain, x[p], y[p])) {\n            return false;\n          }\n\n          leftChain.pop();\n          rightChain.pop();\n          break;\n\n        default:\n          if (x[p] !== y[p]) {\n            return false;\n          }\n\n          break;\n      }\n    }\n\n    return true;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["OrmUtils","chunk","array","size","Array","from","Math","ceil","length","_","i","slice","splitClassesAndStrings","classesAndStrings","filter","cls","str","groupBy","propertyCallback","reduce","groupedArray","value","key","grouped","find","id","items","push","uniq","criteriaOrProperty","uniqueArray","item","found","itemValue","uniqueItem","indexOf","isPlainObject","undefined","constructor","Object","mergeArrayKey","target","memo","has","get","Promise","isArray","set","merge","delete","mergeObjectKey","assign","source","Map","keys","mergeDeep","sources","deepCompare","args","l","leftChain","rightChain","arguments","compare2Objects","deepValue","obj","path","segments","split","len","replaceEmptyObjectsWithBooleans","propertyPathsToTruthyObject","paths","props","recursiveChild","prop","entries","compareIds","firstId","secondId","toBoolean","zipObject","values","object","column","index","isArraysEqual","arr1","arr2","every","element","areMutuallyExclusive","lists","haveSharedObjects","some","list","otherLists","otherList","includes","x","y","p","Number","isNaN","equals","Date","RegExp","toString","isPrototypeOf","prototype","hasOwnProperty","pop"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\util\\OrmUtils.ts"],"sourcesContent":["import { ObjectLiteral } from \"../common/ObjectLiteral\"\n\nexport class OrmUtils {\n    // -------------------------------------------------------------------------\n    // Public methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Chunks array into pieces.\n     */\n    static chunk<T>(array: T[], size: number): T[][] {\n        return Array.from(Array(Math.ceil(array.length / size)), (_, i) => {\n            return array.slice(i * size, i * size + size)\n        })\n    }\n\n    static splitClassesAndStrings<T>(\n        classesAndStrings: (string | T)[],\n    ): [T[], string[]] {\n        return [\n            classesAndStrings.filter(\n                (cls): cls is T => typeof cls !== \"string\",\n            ),\n            classesAndStrings.filter(\n                (str): str is string => typeof str === \"string\",\n            ),\n        ]\n    }\n\n    static groupBy<T, R>(\n        array: T[],\n        propertyCallback: (item: T) => R,\n    ): { id: R; items: T[] }[] {\n        return array.reduce((groupedArray, value) => {\n            const key = propertyCallback(value)\n            let grouped = groupedArray.find((i) => i.id === key)\n            if (!grouped) {\n                grouped = { id: key, items: [] }\n                groupedArray.push(grouped)\n            }\n            grouped.items.push(value)\n            return groupedArray\n        }, [] as Array<{ id: R; items: T[] }>)\n    }\n\n    static uniq<T>(array: T[], criteria?: (item: T) => any): T[]\n    static uniq<T, K extends keyof T>(array: T[], property: K): T[]\n    static uniq<T, K extends keyof T>(\n        array: T[],\n        criteriaOrProperty?: ((item: T) => any) | K,\n    ): T[] {\n        return array.reduce((uniqueArray, item) => {\n            let found: boolean = false\n            if (typeof criteriaOrProperty === \"function\") {\n                const itemValue = criteriaOrProperty(item)\n                found = !!uniqueArray.find(\n                    (uniqueItem) =>\n                        criteriaOrProperty(uniqueItem) === itemValue,\n                )\n            } else if (typeof criteriaOrProperty === \"string\") {\n                found = !!uniqueArray.find(\n                    (uniqueItem) =>\n                        uniqueItem[criteriaOrProperty] ===\n                        item[criteriaOrProperty],\n                )\n            } else {\n                found = uniqueArray.indexOf(item) !== -1\n            }\n\n            if (!found) uniqueArray.push(item)\n\n            return uniqueArray\n        }, [] as T[])\n    }\n\n    // Checks if it's an object made by Object.create(null), {} or new Object()\n    private static isPlainObject(item: any) {\n        if (item === null || item === undefined) {\n            return false\n        }\n\n        return !item.constructor || item.constructor === Object\n    }\n\n    private static mergeArrayKey(\n        target: any,\n        key: number,\n        value: any,\n        memo: Map<any, any>,\n    ) {\n        // Have we seen this before?  Prevent infinite recursion.\n        if (memo.has(value)) {\n            target[key] = memo.get(value)\n            return\n        }\n\n        if (value instanceof Promise) {\n            // Skip promises entirely.\n            // This is a hold-over from the old code & is because we don't want to pull in\n            // the lazy fields.  Ideally we'd remove these promises via another function first\n            // but for now we have to do it here.\n            return\n        }\n\n        if (!this.isPlainObject(value) && !Array.isArray(value)) {\n            target[key] = value\n            return\n        }\n\n        if (!target[key]) {\n            target[key] = Array.isArray(value) ? [] : {}\n        }\n\n        memo.set(value, target[key])\n        this.merge(target[key], value, memo)\n        memo.delete(value)\n    }\n\n    private static mergeObjectKey(\n        target: any,\n        key: string,\n        value: any,\n        memo: Map<any, any>,\n    ) {\n        // Have we seen this before?  Prevent infinite recursion.\n        if (memo.has(value)) {\n            Object.assign(target, { [key]: memo.get(value) })\n            return\n        }\n\n        if (value instanceof Promise) {\n            // Skip promises entirely.\n            // This is a hold-over from the old code & is because we don't want to pull in\n            // the lazy fields.  Ideally we'd remove these promises via another function first\n            // but for now we have to do it here.\n            return\n        }\n\n        if (!this.isPlainObject(value) && !Array.isArray(value)) {\n            Object.assign(target, { [key]: value })\n            return\n        }\n\n        if (!target[key]) {\n            Object.assign(target, { [key]: Array.isArray(value) ? [] : {} })\n        }\n\n        memo.set(value, target[key])\n        this.merge(target[key], value, memo)\n        memo.delete(value)\n    }\n\n    private static merge(\n        target: any,\n        source: any,\n        memo: Map<any, any> = new Map(),\n    ): any {\n        if (this.isPlainObject(target) && this.isPlainObject(source)) {\n            for (const key of Object.keys(source)) {\n                if (key === \"__proto__\") continue\n                this.mergeObjectKey(target, key, source[key], memo)\n            }\n        }\n\n        if (Array.isArray(target) && Array.isArray(source)) {\n            for (let key = 0; key < source.length; key++) {\n                this.mergeArrayKey(target, key, source[key], memo)\n            }\n        }\n    }\n\n    /**\n     * Deep Object.assign.\n     */\n    static mergeDeep(target: any, ...sources: any[]): any {\n        if (!sources.length) {\n            return target\n        }\n\n        for (const source of sources) {\n            OrmUtils.merge(target, source)\n        }\n\n        return target\n    }\n\n    /**\n     * Deep compare objects.\n     *\n     * @see http://stackoverflow.com/a/1144249\n     */\n    static deepCompare(...args: any[]): boolean {\n        let i: any, l: any, leftChain: any, rightChain: any\n\n        if (arguments.length < 1) {\n            return true // Die silently? Don't know how to handle such case, please help...\n            // throw \"Need two or more arguments to compare\";\n        }\n\n        for (i = 1, l = arguments.length; i < l; i++) {\n            leftChain = [] // Todo: this can be cached\n            rightChain = []\n\n            if (\n                !this.compare2Objects(\n                    leftChain,\n                    rightChain,\n                    arguments[0],\n                    arguments[i],\n                )\n            ) {\n                return false\n            }\n        }\n\n        return true\n    }\n\n    /**\n     * Gets deeper value of object.\n     */\n    static deepValue(obj: ObjectLiteral, path: string) {\n        const segments = path.split(\".\")\n        for (let i = 0, len = segments.length; i < len; i++) {\n            obj = obj[segments[i]]\n        }\n        return obj\n    }\n\n    static replaceEmptyObjectsWithBooleans(obj: any) {\n        for (let key in obj) {\n            if (obj[key] && typeof obj[key] === \"object\") {\n                if (Object.keys(obj[key]).length === 0) {\n                    obj[key] = true\n                } else {\n                    this.replaceEmptyObjectsWithBooleans(obj[key])\n                }\n            }\n        }\n    }\n\n    static propertyPathsToTruthyObject(paths: string[]) {\n        let obj: any = {}\n        for (let path of paths) {\n            const props = path.split(\".\")\n            if (!props.length) continue\n\n            if (!obj[props[0]] || obj[props[0]] === true) {\n                obj[props[0]] = {}\n            }\n            let recursiveChild = obj[props[0]]\n            for (let [key, prop] of props.entries()) {\n                if (key === 0) continue\n\n                if (recursiveChild[prop]) {\n                    recursiveChild = recursiveChild[prop]\n                } else if (key === props.length - 1) {\n                    recursiveChild[prop] = {}\n                    recursiveChild = null\n                } else {\n                    recursiveChild[prop] = {}\n                    recursiveChild = recursiveChild[prop]\n                }\n            }\n        }\n        this.replaceEmptyObjectsWithBooleans(obj)\n        return obj\n    }\n\n    /**\n     * Check if two entity-id-maps are the same\n     */\n    static compareIds(\n        firstId: ObjectLiteral | undefined,\n        secondId: ObjectLiteral | undefined,\n    ): boolean {\n        if (\n            firstId === undefined ||\n            firstId === null ||\n            secondId === undefined ||\n            secondId === null\n        )\n            return false\n\n        // Optimized version for the common case\n        if (\n            ((typeof firstId.id === \"string\" &&\n                typeof secondId.id === \"string\") ||\n                (typeof firstId.id === \"number\" &&\n                    typeof secondId.id === \"number\")) &&\n            Object.keys(firstId).length === 1 &&\n            Object.keys(secondId).length === 1\n        ) {\n            return firstId.id === secondId.id\n        }\n\n        return OrmUtils.deepCompare(firstId, secondId)\n    }\n\n    /**\n     * Transforms given value into boolean value.\n     */\n    static toBoolean(value: any): boolean {\n        if (typeof value === \"boolean\") return value\n\n        if (typeof value === \"string\") return value === \"true\" || value === \"1\"\n\n        if (typeof value === \"number\") return value > 0\n\n        return false\n    }\n\n    /**\n     * Composes an object from the given array of keys and values.\n     */\n    static zipObject(keys: any[], values: any[]): ObjectLiteral {\n        return keys.reduce((object, column, index) => {\n            object[column] = values[index]\n            return object\n        }, {} as ObjectLiteral)\n    }\n\n    /**\n     * Compares two arrays.\n     */\n    static isArraysEqual(arr1: any[], arr2: any[]): boolean {\n        if (arr1.length !== arr2.length) return false\n        return arr1.every((element) => {\n            return arr2.indexOf(element) !== -1\n        })\n    }\n\n    static areMutuallyExclusive<T>(...lists: T[][]): boolean {\n        const haveSharedObjects = lists.some((list) => {\n            const otherLists = lists.filter((otherList) => otherList !== list)\n            return list.some((item) =>\n                otherLists.some((otherList) => otherList.includes(item)),\n            )\n        })\n        return !haveSharedObjects\n    }\n\n    // -------------------------------------------------------------------------\n    // Private methods\n    // -------------------------------------------------------------------------\n\n    private static compare2Objects(\n        leftChain: any,\n        rightChain: any,\n        x: any,\n        y: any,\n    ) {\n        let p\n\n        // remember that NaN === NaN returns false\n        // and isNaN(undefined) returns true\n        if (Number.isNaN(x) && Number.isNaN(y)) return true\n\n        // Compare primitives and functions.\n        // Check if both arguments link to the same object.\n        // Especially useful on the step where we compare prototypes\n        if (x === y) return true\n\n        // Unequal, but either is null or undefined (use case: jsonb comparison)\n        // PR #3776, todo: add tests\n        if (x === null || y === null || x === undefined || y === undefined)\n            return false\n\n        // Fix the buffer compare bug.\n        // See: https://github.com/typeorm/typeorm/issues/3654\n        if (\n            (typeof x.equals === \"function\" ||\n                typeof x.equals === \"function\") &&\n            x.equals(y)\n        )\n            return true\n\n        // Works in case when functions are created in constructor.\n        // Comparing dates is a common scenario. Another built-ins?\n        // We can even handle functions passed across iframes\n        if (\n            (typeof x === \"function\" && typeof y === \"function\") ||\n            (x instanceof Date && y instanceof Date) ||\n            (x instanceof RegExp && y instanceof RegExp) ||\n            (typeof x === \"string\" && typeof y === \"string\") ||\n            (typeof x === \"number\" && typeof y === \"number\")\n        )\n            return x.toString() === y.toString()\n\n        // At last checking prototypes as good as we can\n        if (!(typeof x === \"object\" && typeof y === \"object\")) return false\n\n        if (x.isPrototypeOf(y) || y.isPrototypeOf(x)) return false\n\n        if (x.constructor !== y.constructor) return false\n\n        if (x.prototype !== y.prototype) return false\n\n        // Check for infinitive linking loops\n        if (leftChain.indexOf(x) > -1 || rightChain.indexOf(y) > -1)\n            return false\n\n        // Quick checking of one object being a subset of another.\n        // todo: cache the structure of arguments[0] for performance\n        for (p in y) {\n            if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {\n                return false\n            } else if (typeof y[p] !== typeof x[p]) {\n                return false\n            }\n        }\n\n        for (p in x) {\n            if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {\n                return false\n            } else if (typeof y[p] !== typeof x[p]) {\n                return false\n            }\n\n            switch (typeof x[p]) {\n                case \"object\":\n                case \"function\":\n                    leftChain.push(x)\n                    rightChain.push(y)\n\n                    if (\n                        !this.compare2Objects(leftChain, rightChain, x[p], y[p])\n                    ) {\n                        return false\n                    }\n\n                    leftChain.pop()\n                    rightChain.pop()\n                    break\n\n                default:\n                    if (x[p] !== y[p]) {\n                        return false\n                    }\n                    break\n            }\n        }\n\n        return true\n    }\n}\n"]},"metadata":{},"sourceType":"module"}