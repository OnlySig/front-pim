{"ast":null,"code":"import { OrmUtils } from \"../util/OrmUtils\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\nimport { InstanceChecker } from \"../util/InstanceChecker\";\n/**\n * Subject is a subject of persistence.\n * It holds information about each entity that needs to be persisted:\n * - what entity should be persisted\n * - what is database representation of the persisted entity\n * - what entity metadata of the persisted entity\n * - what is allowed to with persisted entity (insert/update/remove)\n *\n * Having this collection of subjects we can perform database queries.\n */\n\nexport class Subject {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(options) {\n    this[\"@instanceof\"] = Symbol.for(\"Subject\");\n    /**\n     * Subject identifier.\n     * This identifier is not limited to table entity primary columns.\n     * This can be entity id or ids as well as some unique entity properties, like name or title.\n     * Insert / Update / Remove operation will be executed by a given identifier.\n     */\n\n    this.identifier = undefined;\n    /**\n     * Copy of entity but with relational ids fulfilled.\n     */\n\n    this.entityWithFulfilledIds = undefined;\n    /**\n     * Indicates if database entity was loaded.\n     * No matter if it was found or not, it indicates the fact of loading.\n     */\n\n    this.databaseEntityLoaded = false;\n    /**\n     * Changes needs to be applied in the database for the given subject.\n     */\n\n    this.changeMaps = [];\n    /**\n     * Indicates if this subject can be inserted into the database.\n     * This means that this subject either is newly persisted, either can be inserted by cascades.\n     */\n\n    this.canBeInserted = false;\n    /**\n     * Indicates if this subject can be updated in the database.\n     * This means that this subject either was persisted, either can be updated by cascades.\n     */\n\n    this.canBeUpdated = false;\n    /**\n     * Indicates if this subject MUST be removed from the database.\n     * This means that this subject either was removed, either was removed by cascades.\n     */\n\n    this.mustBeRemoved = false;\n    /**\n     * Indicates if this subject can be soft-removed from the database.\n     * This means that this subject either was soft-removed, either was soft-removed by cascades.\n     */\n\n    this.canBeSoftRemoved = false;\n    /**\n     * Indicates if this subject can be recovered from the database.\n     * This means that this subject either was recovered, either was recovered by cascades.\n     */\n\n    this.canBeRecovered = false;\n    /**\n     * Relations updated by the change maps.\n     */\n\n    this.updatedRelationMaps = [];\n    /**\n     * List of updated columns\n     */\n\n    this.diffColumns = [];\n    /**\n     * List of updated relations\n     */\n\n    this.diffRelations = [];\n    this.metadata = options.metadata;\n    this.entity = options.entity;\n    this.parentSubject = options.parentSubject;\n    if (options.canBeInserted !== undefined) this.canBeInserted = options.canBeInserted;\n    if (options.canBeUpdated !== undefined) this.canBeUpdated = options.canBeUpdated;\n    if (options.mustBeRemoved !== undefined) this.mustBeRemoved = options.mustBeRemoved;\n    if (options.canBeSoftRemoved !== undefined) this.canBeSoftRemoved = options.canBeSoftRemoved;\n    if (options.canBeRecovered !== undefined) this.canBeRecovered = options.canBeRecovered;\n    if (options.identifier !== undefined) this.identifier = options.identifier;\n    if (options.changeMaps !== undefined) this.changeMaps.push(...options.changeMaps);\n    this.recompute();\n  } // -------------------------------------------------------------------------\n  // Accessors\n  // -------------------------------------------------------------------------\n\n  /**\n   * Checks if this subject must be inserted into the database.\n   * Subject can be inserted into the database if it is allowed to be inserted (explicitly persisted or by cascades)\n   * and if it does not have database entity set.\n   */\n\n\n  get mustBeInserted() {\n    return this.canBeInserted && !this.databaseEntity;\n  }\n  /**\n   * Checks if this subject must be updated into the database.\n   * Subject can be updated in the database if it is allowed to be updated (explicitly persisted or by cascades)\n   * and if it does have differentiated columns or relations.\n   */\n\n\n  get mustBeUpdated() {\n    return this.canBeUpdated && this.identifier && (this.databaseEntityLoaded === false || this.databaseEntityLoaded && this.databaseEntity) && // ((this.entity && this.databaseEntity) || (!this.entity && !this.databaseEntity)) &&\n    this.changeMaps.length > 0;\n  }\n  /**\n   * Checks if this subject must be soft-removed into the database.\n   * Subject can be updated in the database if it is allowed to be soft-removed (explicitly persisted or by cascades)\n   * and if it does have differentiated columns or relations.\n   */\n\n\n  get mustBeSoftRemoved() {\n    return this.canBeSoftRemoved && this.identifier && (this.databaseEntityLoaded === false || this.databaseEntityLoaded && this.databaseEntity);\n  }\n  /**\n   * Checks if this subject must be recovered into the database.\n   * Subject can be updated in the database if it is allowed to be recovered (explicitly persisted or by cascades)\n   * and if it does have differentiated columns or relations.\n   */\n\n\n  get mustBeRecovered() {\n    return this.canBeRecovered && this.identifier && (this.databaseEntityLoaded === false || this.databaseEntityLoaded && this.databaseEntity);\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Creates a value set needs to be inserted / updated in the database.\n   * Value set is based on the entity and change maps of the subject.\n   * Important note: this method pops data from this subject's change maps.\n   */\n\n\n  createValueSetAndPopChangeMap() {\n    const changeMapsWithoutValues = [];\n    const changeSet = this.changeMaps.reduce((updateMap, changeMap) => {\n      let value = changeMap.value;\n\n      if (InstanceChecker.isSubject(value)) {\n        // referenced columns can refer on values both which were just inserted and which were present in the model\n        // if entity was just inserted valueSets must contain all values from the entity and values just inserted in the database\n        // so, here we check if we have a value set then we simply use it as value to get our reference column values\n        // otherwise simply use an entity which cannot be just inserted at the moment and have all necessary data\n        value = value.insertedValueSet ? value.insertedValueSet : value.entity;\n      } // value = changeMap.valueFactory ? changeMap.valueFactory(value) : changeMap.column.createValueMap(value);\n\n\n      let valueMap;\n\n      if (this.metadata.isJunction && changeMap.column) {\n        valueMap = changeMap.column.createValueMap(changeMap.column.referencedColumn.getEntityValue(value));\n      } else if (changeMap.column) {\n        valueMap = changeMap.column.createValueMap(value);\n      } else if (changeMap.relation) {\n        // value can be a related object, for example: post.question = { id: 1 }\n        // or value can be a null or direct relation id, e.g. post.question = 1\n        // if its a direction relation id then we just set it to the valueMap,\n        // however if its an object then we need to extract its relation id map and set it to the valueMap\n        if (ObjectUtils.isObject(value) && !Buffer.isBuffer(value)) {\n          // get relation id, e.g. referenced column name and its value,\n          // for example: { id: 1 } which then will be set to relation, e.g. post.category = { id: 1 }\n          const relationId = changeMap.relation.getRelationIdMap(value); // but relation id can be empty, for example in the case when you insert a new post with category\n          // and both post and category are newly inserted objects (by cascades) and in this case category will not have id\n          // this means we need to insert post without question id and update post's questionId once question be inserted\n          // that's why we create a new changeMap operation for future updation of the post entity\n\n          if (relationId === undefined) {\n            changeMapsWithoutValues.push(changeMap);\n            this.canBeUpdated = true;\n            return updateMap;\n          }\n\n          valueMap = changeMap.relation.createValueMap(relationId);\n          this.updatedRelationMaps.push({\n            relation: changeMap.relation,\n            value: relationId\n          });\n        } else {\n          // value can be \"null\" or direct relation id here\n          valueMap = changeMap.relation.createValueMap(value);\n          this.updatedRelationMaps.push({\n            relation: changeMap.relation,\n            value: value\n          });\n        }\n      }\n\n      OrmUtils.mergeDeep(updateMap, valueMap);\n      return updateMap;\n    }, {});\n    this.changeMaps = changeMapsWithoutValues;\n    return changeSet;\n  }\n  /**\n   * Recomputes entityWithFulfilledIds and identifier when entity changes.\n   */\n\n\n  recompute() {\n    if (this.entity) {\n      this.entityWithFulfilledIds = Object.assign({}, this.entity);\n\n      if (this.parentSubject) {\n        this.metadata.primaryColumns.forEach(primaryColumn => {\n          if (primaryColumn.relationMetadata && primaryColumn.relationMetadata.inverseEntityMetadata === this.parentSubject.metadata) {\n            const value = primaryColumn.referencedColumn.getEntityValue(this.parentSubject.entity);\n            primaryColumn.setEntityValue(this.entityWithFulfilledIds, value);\n          }\n        });\n      }\n\n      this.identifier = this.metadata.getEntityIdMap(this.entityWithFulfilledIds);\n    } else if (this.databaseEntity) {\n      this.identifier = this.metadata.getEntityIdMap(this.databaseEntity);\n    }\n  }\n\n}","map":{"version":3,"mappings":"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","names":["OrmUtils","ObjectUtils","InstanceChecker","Subject","constructor","options","Symbol","for","undefined","metadata","entity","parentSubject","canBeInserted","canBeUpdated","mustBeRemoved","canBeSoftRemoved","canBeRecovered","identifier","changeMaps","push","recompute","mustBeInserted","databaseEntity","mustBeUpdated","databaseEntityLoaded","length","mustBeSoftRemoved","mustBeRecovered","createValueSetAndPopChangeMap","changeMapsWithoutValues","changeSet","reduce","updateMap","changeMap","value","isSubject","insertedValueSet","valueMap","isJunction","column","createValueMap","referencedColumn","getEntityValue","relation","isObject","Buffer","isBuffer","relationId","getRelationIdMap","updatedRelationMaps","mergeDeep","entityWithFulfilledIds","Object","assign","primaryColumns","forEach","primaryColumn","relationMetadata","inverseEntityMetadata","setEntityValue","getEntityIdMap"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\persistence\\Subject.ts"],"sourcesContent":["import { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { EntityMetadata } from \"../metadata/EntityMetadata\"\nimport { SubjectChangeMap } from \"./SubjectChangeMap\"\nimport { OrmUtils } from \"../util/OrmUtils\"\nimport { RelationMetadata } from \"../metadata/RelationMetadata\"\nimport { ColumnMetadata } from \"../metadata/ColumnMetadata\"\nimport { ObjectUtils } from \"../util/ObjectUtils\"\nimport { InstanceChecker } from \"../util/InstanceChecker\"\n\n/**\n * Subject is a subject of persistence.\n * It holds information about each entity that needs to be persisted:\n * - what entity should be persisted\n * - what is database representation of the persisted entity\n * - what entity metadata of the persisted entity\n * - what is allowed to with persisted entity (insert/update/remove)\n *\n * Having this collection of subjects we can perform database queries.\n */\nexport class Subject {\n    readonly \"@instanceof\" = Symbol.for(\"Subject\")\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Entity metadata of the subject entity.\n     */\n    metadata: EntityMetadata\n\n    /**\n     * Subject identifier.\n     * This identifier is not limited to table entity primary columns.\n     * This can be entity id or ids as well as some unique entity properties, like name or title.\n     * Insert / Update / Remove operation will be executed by a given identifier.\n     */\n    identifier: ObjectLiteral | undefined = undefined\n\n    /**\n     * Copy of entity but with relational ids fulfilled.\n     */\n    entityWithFulfilledIds: ObjectLiteral | undefined = undefined\n\n    /**\n     * If subject was created by cascades this property will contain subject\n     * from where this subject was created.\n     */\n    parentSubject?: Subject\n\n    /**\n     * Gets entity sent to the persistence (e.g. changed entity).\n     * If entity is not set then this subject is created only for the entity loaded from the database,\n     * or this subject is used for the junction operation (junction operations are relying only on identifier).\n     */\n    entity?: ObjectLiteral\n\n    /**\n     * Database entity.\n     * THIS IS NOT RAW ENTITY DATA, its a real entity.\n     */\n    databaseEntity?: ObjectLiteral\n\n    /**\n     * Indicates if database entity was loaded.\n     * No matter if it was found or not, it indicates the fact of loading.\n     */\n    databaseEntityLoaded: boolean = false\n\n    /**\n     * Changes needs to be applied in the database for the given subject.\n     */\n    changeMaps: SubjectChangeMap[] = []\n\n    /**\n     * Generated values returned by a database (for example generated id or default values).\n     * Used in insert and update operations.\n     * Has entity-like structure (not just column database name and values).\n     */\n    generatedMap?: ObjectLiteral\n\n    /**\n     * Inserted values with updated values of special and default columns.\n     * Has entity-like structure (not just column database name and values).\n     */\n    insertedValueSet?: ObjectLiteral\n\n    /**\n     * Indicates if this subject can be inserted into the database.\n     * This means that this subject either is newly persisted, either can be inserted by cascades.\n     */\n    canBeInserted: boolean = false\n\n    /**\n     * Indicates if this subject can be updated in the database.\n     * This means that this subject either was persisted, either can be updated by cascades.\n     */\n    canBeUpdated: boolean = false\n\n    /**\n     * Indicates if this subject MUST be removed from the database.\n     * This means that this subject either was removed, either was removed by cascades.\n     */\n    mustBeRemoved: boolean = false\n\n    /**\n     * Indicates if this subject can be soft-removed from the database.\n     * This means that this subject either was soft-removed, either was soft-removed by cascades.\n     */\n    canBeSoftRemoved: boolean = false\n\n    /**\n     * Indicates if this subject can be recovered from the database.\n     * This means that this subject either was recovered, either was recovered by cascades.\n     */\n    canBeRecovered: boolean = false\n\n    /**\n     * Relations updated by the change maps.\n     */\n    updatedRelationMaps: {\n        relation: RelationMetadata\n        value: ObjectLiteral\n    }[] = []\n\n    /**\n     * List of updated columns\n     */\n    diffColumns: ColumnMetadata[] = []\n\n    /**\n     * List of updated relations\n     */\n    diffRelations: RelationMetadata[] = []\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(options: {\n        metadata: EntityMetadata\n        parentSubject?: Subject\n        entity?: ObjectLiteral\n        canBeInserted?: boolean\n        canBeUpdated?: boolean\n        mustBeRemoved?: boolean\n        canBeSoftRemoved?: boolean\n        canBeRecovered?: boolean\n        identifier?: ObjectLiteral\n        changeMaps?: SubjectChangeMap[]\n    }) {\n        this.metadata = options.metadata\n        this.entity = options.entity\n        this.parentSubject = options.parentSubject\n        if (options.canBeInserted !== undefined)\n            this.canBeInserted = options.canBeInserted\n        if (options.canBeUpdated !== undefined)\n            this.canBeUpdated = options.canBeUpdated\n        if (options.mustBeRemoved !== undefined)\n            this.mustBeRemoved = options.mustBeRemoved\n        if (options.canBeSoftRemoved !== undefined)\n            this.canBeSoftRemoved = options.canBeSoftRemoved\n        if (options.canBeRecovered !== undefined)\n            this.canBeRecovered = options.canBeRecovered\n        if (options.identifier !== undefined)\n            this.identifier = options.identifier\n        if (options.changeMaps !== undefined)\n            this.changeMaps.push(...options.changeMaps)\n\n        this.recompute()\n    }\n\n    // -------------------------------------------------------------------------\n    // Accessors\n    // -------------------------------------------------------------------------\n\n    /**\n     * Checks if this subject must be inserted into the database.\n     * Subject can be inserted into the database if it is allowed to be inserted (explicitly persisted or by cascades)\n     * and if it does not have database entity set.\n     */\n    get mustBeInserted() {\n        return this.canBeInserted && !this.databaseEntity\n    }\n\n    /**\n     * Checks if this subject must be updated into the database.\n     * Subject can be updated in the database if it is allowed to be updated (explicitly persisted or by cascades)\n     * and if it does have differentiated columns or relations.\n     */\n    get mustBeUpdated() {\n        return (\n            this.canBeUpdated &&\n            this.identifier &&\n            (this.databaseEntityLoaded === false ||\n                (this.databaseEntityLoaded && this.databaseEntity)) &&\n            // ((this.entity && this.databaseEntity) || (!this.entity && !this.databaseEntity)) &&\n            this.changeMaps.length > 0\n        )\n    }\n\n    /**\n     * Checks if this subject must be soft-removed into the database.\n     * Subject can be updated in the database if it is allowed to be soft-removed (explicitly persisted or by cascades)\n     * and if it does have differentiated columns or relations.\n     */\n    get mustBeSoftRemoved() {\n        return (\n            this.canBeSoftRemoved &&\n            this.identifier &&\n            (this.databaseEntityLoaded === false ||\n                (this.databaseEntityLoaded && this.databaseEntity))\n        )\n    }\n\n    /**\n     * Checks if this subject must be recovered into the database.\n     * Subject can be updated in the database if it is allowed to be recovered (explicitly persisted or by cascades)\n     * and if it does have differentiated columns or relations.\n     */\n    get mustBeRecovered() {\n        return (\n            this.canBeRecovered &&\n            this.identifier &&\n            (this.databaseEntityLoaded === false ||\n                (this.databaseEntityLoaded && this.databaseEntity))\n        )\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates a value set needs to be inserted / updated in the database.\n     * Value set is based on the entity and change maps of the subject.\n     * Important note: this method pops data from this subject's change maps.\n     */\n    createValueSetAndPopChangeMap(): ObjectLiteral {\n        const changeMapsWithoutValues: SubjectChangeMap[] = []\n        const changeSet = this.changeMaps.reduce((updateMap, changeMap) => {\n            let value = changeMap.value\n            if (InstanceChecker.isSubject(value)) {\n                // referenced columns can refer on values both which were just inserted and which were present in the model\n                // if entity was just inserted valueSets must contain all values from the entity and values just inserted in the database\n                // so, here we check if we have a value set then we simply use it as value to get our reference column values\n                // otherwise simply use an entity which cannot be just inserted at the moment and have all necessary data\n                value = value.insertedValueSet\n                    ? value.insertedValueSet\n                    : value.entity\n            }\n            // value = changeMap.valueFactory ? changeMap.valueFactory(value) : changeMap.column.createValueMap(value);\n\n            let valueMap: ObjectLiteral | undefined\n            if (this.metadata.isJunction && changeMap.column) {\n                valueMap = changeMap.column.createValueMap(\n                    changeMap.column.referencedColumn!.getEntityValue(value),\n                )\n            } else if (changeMap.column) {\n                valueMap = changeMap.column.createValueMap(value)\n            } else if (changeMap.relation) {\n                // value can be a related object, for example: post.question = { id: 1 }\n                // or value can be a null or direct relation id, e.g. post.question = 1\n                // if its a direction relation id then we just set it to the valueMap,\n                // however if its an object then we need to extract its relation id map and set it to the valueMap\n                if (ObjectUtils.isObject(value) && !Buffer.isBuffer(value)) {\n                    // get relation id, e.g. referenced column name and its value,\n                    // for example: { id: 1 } which then will be set to relation, e.g. post.category = { id: 1 }\n                    const relationId =\n                        changeMap.relation!.getRelationIdMap(value)\n\n                    // but relation id can be empty, for example in the case when you insert a new post with category\n                    // and both post and category are newly inserted objects (by cascades) and in this case category will not have id\n                    // this means we need to insert post without question id and update post's questionId once question be inserted\n                    // that's why we create a new changeMap operation for future updation of the post entity\n                    if (relationId === undefined) {\n                        changeMapsWithoutValues.push(changeMap)\n                        this.canBeUpdated = true\n                        return updateMap\n                    }\n                    valueMap = changeMap.relation!.createValueMap(relationId)\n                    this.updatedRelationMaps.push({\n                        relation: changeMap.relation,\n                        value: relationId,\n                    })\n                } else {\n                    // value can be \"null\" or direct relation id here\n                    valueMap = changeMap.relation!.createValueMap(value)\n                    this.updatedRelationMaps.push({\n                        relation: changeMap.relation,\n                        value: value,\n                    })\n                }\n            }\n\n            OrmUtils.mergeDeep(updateMap, valueMap)\n            return updateMap\n        }, {} as ObjectLiteral)\n        this.changeMaps = changeMapsWithoutValues\n        return changeSet\n    }\n\n    /**\n     * Recomputes entityWithFulfilledIds and identifier when entity changes.\n     */\n    recompute(): void {\n        if (this.entity) {\n            this.entityWithFulfilledIds = Object.assign({}, this.entity)\n            if (this.parentSubject) {\n                this.metadata.primaryColumns.forEach((primaryColumn) => {\n                    if (\n                        primaryColumn.relationMetadata &&\n                        primaryColumn.relationMetadata.inverseEntityMetadata ===\n                            this.parentSubject!.metadata\n                    ) {\n                        const value =\n                            primaryColumn.referencedColumn!.getEntityValue(\n                                this.parentSubject!.entity!,\n                            )\n                        primaryColumn.setEntityValue(\n                            this.entityWithFulfilledIds!,\n                            value,\n                        )\n                    }\n                })\n            }\n            this.identifier = this.metadata.getEntityIdMap(\n                this.entityWithFulfilledIds,\n            )\n        } else if (this.databaseEntity) {\n            this.identifier = this.metadata.getEntityIdMap(this.databaseEntity)\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}