{"ast":null,"code":"import { QueryRunnerAlreadyReleasedError } from \"../../error/QueryRunnerAlreadyReleasedError\";\nimport { QueryFailedError } from \"../../error/QueryFailedError\";\nimport { AbstractSqliteQueryRunner } from \"../sqlite-abstract/AbstractSqliteQueryRunner\";\nimport { TransactionNotStartedError } from \"../../error/TransactionNotStartedError\";\nimport { Broadcaster } from \"../../subscriber/Broadcaster\";\nimport { QueryResult } from \"../../query-runner/QueryResult\";\n/**\n * Runs queries on a single sqlite database connection.\n */\n\nexport class ExpoQueryRunner extends AbstractSqliteQueryRunner {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(driver) {\n    super();\n    this.driver = driver;\n    this.connection = driver.connection;\n    this.broadcaster = new Broadcaster(this);\n  }\n  /**\n   * Starts transaction. Within Expo, all database operations happen in a\n   * transaction context, so issuing a `BEGIN TRANSACTION` command is\n   * redundant and will result in the following error:\n   *\n   * `Error: Error code 1: cannot start a transaction within a transaction`\n   *\n   * Instead, we keep track of a `Transaction` object in `this.transaction`\n   * and continue using the same object until we wish to commit the\n   * transaction.\n   */\n\n\n  async startTransaction() {\n    this.isTransactionActive = true;\n\n    try {\n      await this.broadcaster.broadcast(\"BeforeTransactionStart\");\n    } catch (err) {\n      this.isTransactionActive = false;\n      throw err;\n    }\n\n    this.transactionDepth += 1;\n    await this.broadcaster.broadcast(\"AfterTransactionStart\");\n  }\n  /**\n   * Commits transaction.\n   * Error will be thrown if transaction was not started.\n   * Since Expo will automatically commit the transaction once all the\n   * callbacks of the transaction object have been completed, \"committing\" a\n   * transaction in this driver's context means that we delete the transaction\n   * object and set the stage for the next transaction.\n   */\n\n\n  async commitTransaction() {\n    if (!this.isTransactionActive && typeof this.transaction === \"undefined\") throw new TransactionNotStartedError();\n    await this.broadcaster.broadcast(\"BeforeTransactionCommit\");\n    this.transaction = undefined;\n    this.isTransactionActive = false;\n    this.transactionDepth -= 1;\n    await this.broadcaster.broadcast(\"AfterTransactionCommit\");\n  }\n  /**\n   * Rollbacks transaction.\n   * Error will be thrown if transaction was not started.\n   * This method's functionality is identical to `commitTransaction()` because\n   * the transaction lifecycle is handled within the Expo transaction object.\n   * Issuing separate statements for `COMMIT` or `ROLLBACK` aren't necessary.\n   */\n\n\n  async rollbackTransaction() {\n    if (!this.isTransactionActive && typeof this.transaction === \"undefined\") throw new TransactionNotStartedError();\n    await this.broadcaster.broadcast(\"BeforeTransactionRollback\");\n    this.transaction = undefined;\n    this.isTransactionActive = false;\n    this.transactionDepth -= 1;\n    await this.broadcaster.broadcast(\"AfterTransactionRollback\");\n  }\n  /**\n   * Called before migrations are run.\n   */\n\n\n  async beforeMigration() {\n    const databaseConnection = await this.connect();\n    return new Promise((ok, fail) => {\n      databaseConnection.exec([{\n        sql: \"PRAGMA foreign_keys = OFF\",\n        args: []\n      }], false, err => err ? fail(err) : ok());\n    });\n  }\n  /**\n   * Called after migrations are run.\n   */\n\n\n  async afterMigration() {\n    const databaseConnection = await this.connect();\n    return new Promise((ok, fail) => {\n      databaseConnection.exec([{\n        sql: \"PRAGMA foreign_keys = ON\",\n        args: []\n      }], false, err => err ? fail(err) : ok());\n    });\n  }\n  /**\n   * Executes a given SQL query.\n   */\n\n\n  async query(query, parameters) {\n    let useStructuredResult = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (this.isReleased) throw new QueryRunnerAlreadyReleasedError();\n    return new Promise(async (ok, fail) => {\n      const databaseConnection = await this.connect();\n      this.driver.connection.logger.logQuery(query, parameters, this);\n      const queryStartTime = +new Date(); // All Expo SQL queries are executed in a transaction context\n\n      databaseConnection.transaction(async transaction => {\n        if (typeof this.transaction === \"undefined\") {\n          await this.startTransaction();\n          this.transaction = transaction;\n        }\n\n        this.transaction.executeSql(query, parameters, (t, raw) => {\n          // log slow queries if maxQueryExecution time is set\n          const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;\n          const queryEndTime = +new Date();\n          const queryExecutionTime = queryEndTime - queryStartTime;\n\n          if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) {\n            this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);\n          }\n\n          const result = new QueryResult();\n\n          if (raw === null || raw === void 0 ? void 0 : raw.hasOwnProperty(\"rowsAffected\")) {\n            result.affected = raw.rowsAffected;\n          }\n\n          if (raw === null || raw === void 0 ? void 0 : raw.hasOwnProperty(\"rows\")) {\n            let resultSet = [];\n\n            for (let i = 0; i < raw.rows.length; i++) {\n              resultSet.push(raw.rows.item(i));\n            }\n\n            result.raw = resultSet;\n            result.records = resultSet;\n          } // return id of inserted row, if query was insert statement.\n\n\n          if (query.startsWith(\"INSERT INTO\")) {\n            result.raw = raw.insertId;\n          }\n\n          if (useStructuredResult) {\n            ok(result);\n          } else {\n            ok(result.raw);\n          }\n        }, (t, err) => {\n          this.driver.connection.logger.logQueryError(err, query, parameters, this);\n          fail(new QueryFailedError(query, parameters, err));\n        });\n      }, async err => {\n        await this.rollbackTransaction();\n        fail(err);\n      }, () => {\n        this.isTransactionActive = false;\n        this.transaction = undefined;\n      });\n    });\n  }\n\n}","map":{"version":3,"mappings":"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","names":["QueryRunnerAlreadyReleasedError","QueryFailedError","AbstractSqliteQueryRunner","TransactionNotStartedError","Broadcaster","QueryResult","ExpoQueryRunner","constructor","driver","connection","broadcaster","startTransaction","isTransactionActive","broadcast","err","transactionDepth","commitTransaction","transaction","undefined","rollbackTransaction","beforeMigration","databaseConnection","connect","Promise","ok","fail","exec","sql","args","afterMigration","query","parameters","useStructuredResult","isReleased","logger","logQuery","queryStartTime","Date","executeSql","t","raw","maxQueryExecutionTime","options","queryEndTime","queryExecutionTime","logQuerySlow","result","hasOwnProperty","affected","rowsAffected","resultSet","i","rows","length","push","item","records","startsWith","insertId","logQueryError"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\driver\\expo\\ExpoQueryRunner.ts"],"sourcesContent":["import { QueryRunnerAlreadyReleasedError } from \"../../error/QueryRunnerAlreadyReleasedError\"\nimport { QueryFailedError } from \"../../error/QueryFailedError\"\nimport { AbstractSqliteQueryRunner } from \"../sqlite-abstract/AbstractSqliteQueryRunner\"\nimport { TransactionNotStartedError } from \"../../error/TransactionNotStartedError\"\nimport { ExpoDriver } from \"./ExpoDriver\"\nimport { Broadcaster } from \"../../subscriber/Broadcaster\"\nimport { QueryResult } from \"../../query-runner/QueryResult\"\n\n// Needed to satisfy the Typescript compiler\ninterface IResultSet {\n    insertId: number | undefined\n    rowsAffected: number\n    rows: {\n        length: number\n        item: (idx: number) => any\n        _array: any[]\n    }\n}\ninterface ITransaction {\n    executeSql: (\n        sql: string,\n        args: any[] | undefined,\n        ok: (tsx: ITransaction, resultSet: IResultSet) => void,\n        fail: (tsx: ITransaction, err: any) => void,\n    ) => void\n}\n\n/**\n * Runs queries on a single sqlite database connection.\n */\nexport class ExpoQueryRunner extends AbstractSqliteQueryRunner {\n    /**\n     * Database driver used by connection.\n     */\n    driver: ExpoDriver\n\n    /**\n     * Database transaction object\n     */\n    private transaction?: ITransaction\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(driver: ExpoDriver) {\n        super()\n        this.driver = driver\n        this.connection = driver.connection\n        this.broadcaster = new Broadcaster(this)\n    }\n\n    /**\n     * Starts transaction. Within Expo, all database operations happen in a\n     * transaction context, so issuing a `BEGIN TRANSACTION` command is\n     * redundant and will result in the following error:\n     *\n     * `Error: Error code 1: cannot start a transaction within a transaction`\n     *\n     * Instead, we keep track of a `Transaction` object in `this.transaction`\n     * and continue using the same object until we wish to commit the\n     * transaction.\n     */\n    async startTransaction(): Promise<void> {\n        this.isTransactionActive = true\n        try {\n            await this.broadcaster.broadcast(\"BeforeTransactionStart\")\n        } catch (err) {\n            this.isTransactionActive = false\n            throw err\n        }\n\n        this.transactionDepth += 1\n\n        await this.broadcaster.broadcast(\"AfterTransactionStart\")\n    }\n\n    /**\n     * Commits transaction.\n     * Error will be thrown if transaction was not started.\n     * Since Expo will automatically commit the transaction once all the\n     * callbacks of the transaction object have been completed, \"committing\" a\n     * transaction in this driver's context means that we delete the transaction\n     * object and set the stage for the next transaction.\n     */\n    async commitTransaction(): Promise<void> {\n        if (\n            !this.isTransactionActive &&\n            typeof this.transaction === \"undefined\"\n        )\n            throw new TransactionNotStartedError()\n\n        await this.broadcaster.broadcast(\"BeforeTransactionCommit\")\n\n        this.transaction = undefined\n        this.isTransactionActive = false\n\n        this.transactionDepth -= 1\n\n        await this.broadcaster.broadcast(\"AfterTransactionCommit\")\n    }\n\n    /**\n     * Rollbacks transaction.\n     * Error will be thrown if transaction was not started.\n     * This method's functionality is identical to `commitTransaction()` because\n     * the transaction lifecycle is handled within the Expo transaction object.\n     * Issuing separate statements for `COMMIT` or `ROLLBACK` aren't necessary.\n     */\n    async rollbackTransaction(): Promise<void> {\n        if (\n            !this.isTransactionActive &&\n            typeof this.transaction === \"undefined\"\n        )\n            throw new TransactionNotStartedError()\n\n        await this.broadcaster.broadcast(\"BeforeTransactionRollback\")\n\n        this.transaction = undefined\n        this.isTransactionActive = false\n\n        this.transactionDepth -= 1\n\n        await this.broadcaster.broadcast(\"AfterTransactionRollback\")\n    }\n\n    /**\n     * Called before migrations are run.\n     */\n    async beforeMigration(): Promise<void> {\n        const databaseConnection = await this.connect()\n        return new Promise((ok, fail) => {\n            databaseConnection.exec(\n                [{ sql: \"PRAGMA foreign_keys = OFF\", args: [] }],\n                false,\n                (err: any) => (err ? fail(err) : ok()),\n            )\n        })\n    }\n\n    /**\n     * Called after migrations are run.\n     */\n    async afterMigration(): Promise<void> {\n        const databaseConnection = await this.connect()\n        return new Promise((ok, fail) => {\n            databaseConnection.exec(\n                [{ sql: \"PRAGMA foreign_keys = ON\", args: [] }],\n                false,\n                (err: any) => (err ? fail(err) : ok()),\n            )\n        })\n    }\n\n    /**\n     * Executes a given SQL query.\n     */\n    async query(\n        query: string,\n        parameters?: any[],\n        useStructuredResult = false,\n    ): Promise<any> {\n        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError()\n\n        return new Promise<any>(async (ok, fail) => {\n            const databaseConnection = await this.connect()\n            this.driver.connection.logger.logQuery(query, parameters, this)\n            const queryStartTime = +new Date()\n            // All Expo SQL queries are executed in a transaction context\n            databaseConnection.transaction(\n                async (transaction: ITransaction) => {\n                    if (typeof this.transaction === \"undefined\") {\n                        await this.startTransaction()\n                        this.transaction = transaction\n                    }\n                    this.transaction.executeSql(\n                        query,\n                        parameters,\n                        (t: ITransaction, raw: IResultSet) => {\n                            // log slow queries if maxQueryExecution time is set\n                            const maxQueryExecutionTime =\n                                this.driver.options.maxQueryExecutionTime\n                            const queryEndTime = +new Date()\n                            const queryExecutionTime =\n                                queryEndTime - queryStartTime\n                            if (\n                                maxQueryExecutionTime &&\n                                queryExecutionTime > maxQueryExecutionTime\n                            ) {\n                                this.driver.connection.logger.logQuerySlow(\n                                    queryExecutionTime,\n                                    query,\n                                    parameters,\n                                    this,\n                                )\n                            }\n\n                            const result = new QueryResult()\n\n                            if (raw?.hasOwnProperty(\"rowsAffected\")) {\n                                result.affected = raw.rowsAffected\n                            }\n\n                            if (raw?.hasOwnProperty(\"rows\")) {\n                                let resultSet = []\n                                for (let i = 0; i < raw.rows.length; i++) {\n                                    resultSet.push(raw.rows.item(i))\n                                }\n\n                                result.raw = resultSet\n                                result.records = resultSet\n                            }\n\n                            // return id of inserted row, if query was insert statement.\n                            if (query.startsWith(\"INSERT INTO\")) {\n                                result.raw = raw.insertId\n                            }\n\n                            if (useStructuredResult) {\n                                ok(result)\n                            } else {\n                                ok(result.raw)\n                            }\n                        },\n                        (t: ITransaction, err: any) => {\n                            this.driver.connection.logger.logQueryError(\n                                err,\n                                query,\n                                parameters,\n                                this,\n                            )\n                            fail(new QueryFailedError(query, parameters, err))\n                        },\n                    )\n                },\n                async (err: any) => {\n                    await this.rollbackTransaction()\n                    fail(err)\n                },\n                () => {\n                    this.isTransactionActive = false\n                    this.transaction = undefined\n                },\n            )\n        })\n    }\n}\n"]},"metadata":{},"sourceType":"module"}