{"ast":null,"code":"import { TransactionNotStartedError } from \"../../error/TransactionNotStartedError\";\nimport { TableColumn } from \"../../schema-builder/table/TableColumn\";\nimport { Table } from \"../../schema-builder/table/Table\";\nimport { TableIndex } from \"../../schema-builder/table/TableIndex\";\nimport { TableForeignKey } from \"../../schema-builder/table/TableForeignKey\";\nimport { View } from \"../../schema-builder/view/View\";\nimport { Query } from \"../Query\";\nimport { TableUnique } from \"../../schema-builder/table/TableUnique\";\nimport { BaseQueryRunner } from \"../../query-runner/BaseQueryRunner\";\nimport { OrmUtils } from \"../../util/OrmUtils\";\nimport { TableCheck } from \"../../schema-builder/table/TableCheck\";\nimport { TransactionAlreadyStartedError, TypeORMError } from \"../../error\";\nimport { MetadataTableType } from \"../types/MetadataTableType\";\nimport { InstanceChecker } from \"../../util/InstanceChecker\";\n/**\n * Runs queries on a single sqlite database connection.\n */\n\nexport class AbstractSqliteQueryRunner extends BaseQueryRunner {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor() {\n    super();\n    this.transactionPromise = null;\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Creates/uses database connection from the connection pool to perform further operations.\n   * Returns obtained database connection.\n   */\n\n\n  connect() {\n    return Promise.resolve(this.driver.databaseConnection);\n  }\n  /**\n   * Releases used database connection.\n   * We just clear loaded tables and sql in memory, because sqlite do not support multiple connections thus query runners.\n   */\n\n\n  release() {\n    this.loadedTables = [];\n    this.clearSqlMemory();\n    return Promise.resolve();\n  }\n  /**\n   * Starts transaction.\n   */\n\n\n  async startTransaction(isolationLevel) {\n    if (this.driver.transactionSupport === \"none\") throw new TypeORMError(`Transactions aren't supported by ${this.connection.driver.options.type}.`);\n    if (this.isTransactionActive && this.driver.transactionSupport === \"simple\") throw new TransactionAlreadyStartedError();\n    if (isolationLevel && isolationLevel !== \"READ UNCOMMITTED\" && isolationLevel !== \"SERIALIZABLE\") throw new TypeORMError(`SQLite only supports SERIALIZABLE and READ UNCOMMITTED isolation`);\n    this.isTransactionActive = true;\n\n    try {\n      await this.broadcaster.broadcast(\"BeforeTransactionStart\");\n    } catch (err) {\n      this.isTransactionActive = false;\n      throw err;\n    }\n\n    if (this.transactionDepth === 0) {\n      if (isolationLevel) {\n        if (isolationLevel === \"READ UNCOMMITTED\") {\n          await this.query(\"PRAGMA read_uncommitted = true\");\n        } else {\n          await this.query(\"PRAGMA read_uncommitted = false\");\n        }\n      }\n\n      await this.query(\"BEGIN TRANSACTION\");\n    } else {\n      await this.query(`SAVEPOINT typeorm_${this.transactionDepth}`);\n    }\n\n    this.transactionDepth += 1;\n    await this.broadcaster.broadcast(\"AfterTransactionStart\");\n  }\n  /**\n   * Commits transaction.\n   * Error will be thrown if transaction was not started.\n   */\n\n\n  async commitTransaction() {\n    if (!this.isTransactionActive) throw new TransactionNotStartedError();\n    await this.broadcaster.broadcast(\"BeforeTransactionCommit\");\n\n    if (this.transactionDepth > 1) {\n      await this.query(`RELEASE SAVEPOINT typeorm_${this.transactionDepth - 1}`);\n    } else {\n      await this.query(\"COMMIT\");\n      this.isTransactionActive = false;\n    }\n\n    this.transactionDepth -= 1;\n    await this.broadcaster.broadcast(\"AfterTransactionCommit\");\n  }\n  /**\n   * Rollbacks transaction.\n   * Error will be thrown if transaction was not started.\n   */\n\n\n  async rollbackTransaction() {\n    if (!this.isTransactionActive) throw new TransactionNotStartedError();\n    await this.broadcaster.broadcast(\"BeforeTransactionRollback\");\n\n    if (this.transactionDepth > 1) {\n      await this.query(`ROLLBACK TO SAVEPOINT typeorm_${this.transactionDepth - 1}`);\n    } else {\n      await this.query(\"ROLLBACK\");\n      this.isTransactionActive = false;\n    }\n\n    this.transactionDepth -= 1;\n    await this.broadcaster.broadcast(\"AfterTransactionRollback\");\n  }\n  /**\n   * Returns raw data stream.\n   */\n\n\n  stream(query, parameters, onEnd, onError) {\n    throw new TypeORMError(`Stream is not supported by sqlite driver.`);\n  }\n  /**\n   * Returns all available database names including system databases.\n   */\n\n\n  async getDatabases() {\n    return Promise.resolve([]);\n  }\n  /**\n   * Returns all available schema names including system schemas.\n   * If database parameter specified, returns schemas of that database.\n   */\n\n\n  async getSchemas(database) {\n    return Promise.resolve([]);\n  }\n  /**\n   * Checks if database with the given name exist.\n   */\n\n\n  async hasDatabase(database) {\n    return Promise.resolve(false);\n  }\n  /**\n   * Loads currently using database\n   */\n\n\n  async getCurrentDatabase() {\n    return Promise.resolve(undefined);\n  }\n  /**\n   * Checks if schema with the given name exist.\n   */\n\n\n  async hasSchema(schema) {\n    throw new TypeORMError(`This driver does not support table schemas`);\n  }\n  /**\n   * Loads currently using database schema\n   */\n\n\n  async getCurrentSchema() {\n    return Promise.resolve(undefined);\n  }\n  /**\n   * Checks if table with the given name exist in the database.\n   */\n\n\n  async hasTable(tableOrName) {\n    const tableName = InstanceChecker.isTable(tableOrName) ? tableOrName.name : tableOrName;\n    const sql = `SELECT * FROM \"sqlite_master\" WHERE \"type\" = 'table' AND \"name\" = '${tableName}'`;\n    const result = await this.query(sql);\n    return result.length ? true : false;\n  }\n  /**\n   * Checks if column with the given name exist in the given table.\n   */\n\n\n  async hasColumn(tableOrName, columnName) {\n    const tableName = InstanceChecker.isTable(tableOrName) ? tableOrName.name : tableOrName;\n    const sql = `PRAGMA table_xinfo(${this.escapePath(tableName)})`;\n    const columns = await this.query(sql);\n    return !!columns.find(column => column[\"name\"] === columnName);\n  }\n  /**\n   * Creates a new database.\n   */\n\n\n  async createDatabase(database, ifNotExist) {\n    return Promise.resolve();\n  }\n  /**\n   * Drops database.\n   */\n\n\n  async dropDatabase(database, ifExist) {\n    return Promise.resolve();\n  }\n  /**\n   * Creates a new table schema.\n   */\n\n\n  async createSchema(schemaPath, ifNotExist) {\n    return Promise.resolve();\n  }\n  /**\n   * Drops table schema.\n   */\n\n\n  async dropSchema(schemaPath, ifExist) {\n    return Promise.resolve();\n  }\n  /**\n   * Creates a new table.\n   */\n\n\n  async createTable(table) {\n    let ifNotExist = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let createForeignKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let createIndices = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    const upQueries = [];\n    const downQueries = [];\n\n    if (ifNotExist) {\n      const isTableExist = await this.hasTable(table);\n      if (isTableExist) return Promise.resolve();\n    }\n\n    upQueries.push(this.createTableSql(table, createForeignKeys));\n    downQueries.push(this.dropTableSql(table));\n\n    if (createIndices) {\n      table.indices.forEach(index => {\n        // new index may be passed without name. In this case we generate index name manually.\n        if (!index.name) index.name = this.connection.namingStrategy.indexName(table, index.columnNames, index.where);\n        upQueries.push(this.createIndexSql(table, index));\n        downQueries.push(this.dropIndexSql(index));\n      });\n    } // if table have column with generated type, we must add the expression to the metadata table\n\n\n    const generatedColumns = table.columns.filter(column => column.generatedType && column.asExpression);\n\n    for (const column of generatedColumns) {\n      const insertQuery = this.insertTypeormMetadataSql({\n        table: table.name,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name,\n        value: column.asExpression\n      });\n      const deleteQuery = this.deleteTypeormMetadataSql({\n        table: table.name,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name\n      });\n      upQueries.push(insertQuery);\n      downQueries.push(deleteQuery);\n    }\n\n    await this.executeQueries(upQueries, downQueries);\n  }\n  /**\n   * Drops the table.\n   */\n\n\n  async dropTable(tableOrName, ifExist) {\n    let dropForeignKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let dropIndices = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n    if (ifExist) {\n      const isTableExist = await this.hasTable(tableOrName);\n      if (!isTableExist) return Promise.resolve();\n    } // if dropTable called with dropForeignKeys = true, we must create foreign keys in down query.\n\n\n    const createForeignKeys = dropForeignKeys;\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const upQueries = [];\n    const downQueries = [];\n\n    if (dropIndices) {\n      table.indices.forEach(index => {\n        upQueries.push(this.dropIndexSql(index));\n        downQueries.push(this.createIndexSql(table, index));\n      });\n    }\n\n    upQueries.push(this.dropTableSql(table, ifExist));\n    downQueries.push(this.createTableSql(table, createForeignKeys)); // if table had columns with generated type, we must remove the expression from the metadata table\n\n    const generatedColumns = table.columns.filter(column => column.generatedType && column.asExpression);\n\n    for (const column of generatedColumns) {\n      const deleteQuery = this.deleteTypeormMetadataSql({\n        table: table.name,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name\n      });\n      const insertQuery = this.insertTypeormMetadataSql({\n        table: table.name,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name,\n        value: column.asExpression\n      });\n      upQueries.push(deleteQuery);\n      downQueries.push(insertQuery);\n    }\n\n    await this.executeQueries(upQueries, downQueries);\n  }\n  /**\n   * Creates a new view.\n   */\n\n\n  async createView(view) {\n    const upQueries = [];\n    const downQueries = [];\n    upQueries.push(this.createViewSql(view));\n    upQueries.push(this.insertViewDefinitionSql(view));\n    downQueries.push(this.dropViewSql(view));\n    downQueries.push(this.deleteViewDefinitionSql(view));\n    await this.executeQueries(upQueries, downQueries);\n  }\n  /**\n   * Drops the view.\n   */\n\n\n  async dropView(target) {\n    const viewName = InstanceChecker.isView(target) ? target.name : target;\n    const view = await this.getCachedView(viewName);\n    const upQueries = [];\n    const downQueries = [];\n    upQueries.push(this.deleteViewDefinitionSql(view));\n    upQueries.push(this.dropViewSql(view));\n    downQueries.push(this.insertViewDefinitionSql(view));\n    downQueries.push(this.createViewSql(view));\n    await this.executeQueries(upQueries, downQueries);\n  }\n  /**\n   * Renames the given table.\n   */\n\n\n  async renameTable(oldTableOrName, newTableName) {\n    const oldTable = InstanceChecker.isTable(oldTableOrName) ? oldTableOrName : await this.getCachedTable(oldTableOrName);\n    const newTable = oldTable.clone();\n    newTable.name = newTableName; // rename table\n\n    const up = new Query(`ALTER TABLE ${this.escapePath(oldTable.name)} RENAME TO ${this.escapePath(newTableName)}`);\n    const down = new Query(`ALTER TABLE ${this.escapePath(newTableName)} RENAME TO ${this.escapePath(oldTable.name)}`);\n    await this.executeQueries(up, down); // rename unique constraints\n\n    newTable.uniques.forEach(unique => {\n      const oldUniqueName = this.connection.namingStrategy.uniqueConstraintName(oldTable, unique.columnNames); // Skip renaming if Unique has user defined constraint name\n\n      if (unique.name !== oldUniqueName) return;\n      unique.name = this.connection.namingStrategy.uniqueConstraintName(newTable, unique.columnNames);\n    }); // rename foreign key constraints\n\n    newTable.foreignKeys.forEach(foreignKey => {\n      const oldForeignKeyName = this.connection.namingStrategy.foreignKeyName(oldTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames); // Skip renaming if foreign key has user defined constraint name\n\n      if (foreignKey.name !== oldForeignKeyName) return;\n      foreignKey.name = this.connection.namingStrategy.foreignKeyName(newTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);\n    }); // rename indices\n\n    newTable.indices.forEach(index => {\n      const oldIndexName = this.connection.namingStrategy.indexName(oldTable, index.columnNames, index.where); // Skip renaming if Index has user defined constraint name\n\n      if (index.name !== oldIndexName) return;\n      index.name = this.connection.namingStrategy.indexName(newTable, index.columnNames, index.where);\n    }); // rename old table;\n\n    oldTable.name = newTable.name; // recreate table with new constraint names\n\n    await this.recreateTable(newTable, oldTable);\n  }\n  /**\n   * Creates a new column from the column in the table.\n   */\n\n\n  async addColumn(tableOrName, column) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    return this.addColumns(table, [column]);\n  }\n  /**\n   * Creates a new columns from the column in the table.\n   */\n\n\n  async addColumns(tableOrName, columns) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const changedTable = table.clone();\n    columns.forEach(column => changedTable.addColumn(column));\n    await this.recreateTable(changedTable, table);\n  }\n  /**\n   * Renames column in the given table.\n   */\n\n\n  async renameColumn(tableOrName, oldTableColumnOrName, newTableColumnOrName) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const oldColumn = InstanceChecker.isTableColumn(oldTableColumnOrName) ? oldTableColumnOrName : table.columns.find(c => c.name === oldTableColumnOrName);\n    if (!oldColumn) throw new TypeORMError(`Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`);\n    let newColumn = undefined;\n\n    if (InstanceChecker.isTableColumn(newTableColumnOrName)) {\n      newColumn = newTableColumnOrName;\n    } else {\n      newColumn = oldColumn.clone();\n      newColumn.name = newTableColumnOrName;\n    }\n\n    return this.changeColumn(table, oldColumn, newColumn);\n  }\n  /**\n   * Changes a column in the table.\n   */\n\n\n  async changeColumn(tableOrName, oldTableColumnOrName, newColumn) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const oldColumn = InstanceChecker.isTableColumn(oldTableColumnOrName) ? oldTableColumnOrName : table.columns.find(c => c.name === oldTableColumnOrName);\n    if (!oldColumn) throw new TypeORMError(`Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`);\n    await this.changeColumns(table, [{\n      oldColumn,\n      newColumn\n    }]);\n  }\n  /**\n   * Changes a column in the table.\n   * Changed column looses all its keys in the db.\n   */\n\n\n  async changeColumns(tableOrName, changedColumns) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const changedTable = table.clone();\n    changedColumns.forEach(changedColumnSet => {\n      if (changedColumnSet.newColumn.name !== changedColumnSet.oldColumn.name) {\n        changedTable.findColumnUniques(changedColumnSet.oldColumn).forEach(unique => {\n          const uniqueName = this.connection.namingStrategy.uniqueConstraintName(table, unique.columnNames);\n          unique.columnNames.splice(unique.columnNames.indexOf(changedColumnSet.oldColumn.name), 1);\n          unique.columnNames.push(changedColumnSet.newColumn.name); // rename Unique only if it has default constraint name\n\n          if (unique.name === uniqueName) {\n            unique.name = this.connection.namingStrategy.uniqueConstraintName(changedTable, unique.columnNames);\n          }\n        });\n        changedTable.findColumnForeignKeys(changedColumnSet.oldColumn).forEach(foreignKey => {\n          const foreignKeyName = this.connection.namingStrategy.foreignKeyName(table, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);\n          foreignKey.columnNames.splice(foreignKey.columnNames.indexOf(changedColumnSet.oldColumn.name), 1);\n          foreignKey.columnNames.push(changedColumnSet.newColumn.name); // rename FK only if it has default constraint name\n\n          if (foreignKey.name === foreignKeyName) {\n            foreignKey.name = this.connection.namingStrategy.foreignKeyName(changedTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);\n          }\n        });\n        changedTable.findColumnIndices(changedColumnSet.oldColumn).forEach(index => {\n          const indexName = this.connection.namingStrategy.indexName(table, index.columnNames, index.where);\n          index.columnNames.splice(index.columnNames.indexOf(changedColumnSet.oldColumn.name), 1);\n          index.columnNames.push(changedColumnSet.newColumn.name); // rename Index only if it has default constraint name\n\n          if (index.name === indexName) {\n            index.name = this.connection.namingStrategy.indexName(changedTable, index.columnNames, index.where);\n          }\n        });\n      }\n\n      const originalColumn = changedTable.columns.find(column => column.name === changedColumnSet.oldColumn.name);\n      if (originalColumn) changedTable.columns[changedTable.columns.indexOf(originalColumn)] = changedColumnSet.newColumn;\n    });\n    await this.recreateTable(changedTable, table);\n  }\n  /**\n   * Drops column in the table.\n   */\n\n\n  async dropColumn(tableOrName, columnOrName) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const column = InstanceChecker.isTableColumn(columnOrName) ? columnOrName : table.findColumnByName(columnOrName);\n    if (!column) throw new TypeORMError(`Column \"${columnOrName}\" was not found in table \"${table.name}\"`);\n    await this.dropColumns(table, [column]);\n  }\n  /**\n   * Drops the columns in the table.\n   */\n\n\n  async dropColumns(tableOrName, columns) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName); // clone original table and remove column and its constraints from cloned table\n\n    const changedTable = table.clone();\n    columns.forEach(column => {\n      const columnInstance = InstanceChecker.isTableColumn(column) ? column : table.findColumnByName(column);\n      if (!columnInstance) throw new Error(`Column \"${column}\" was not found in table \"${table.name}\"`);\n      changedTable.removeColumn(columnInstance);\n      changedTable.findColumnUniques(columnInstance).forEach(unique => changedTable.removeUniqueConstraint(unique));\n      changedTable.findColumnIndices(columnInstance).forEach(index => changedTable.removeIndex(index));\n      changedTable.findColumnForeignKeys(columnInstance).forEach(fk => changedTable.removeForeignKey(fk));\n    });\n    await this.recreateTable(changedTable, table);\n  }\n  /**\n   * Creates a new primary key.\n   */\n\n\n  async createPrimaryKey(tableOrName, columnNames) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName); // clone original table and mark columns as primary\n\n    const changedTable = table.clone();\n    changedTable.columns.forEach(column => {\n      if (columnNames.find(columnName => columnName === column.name)) column.isPrimary = true;\n    });\n    await this.recreateTable(changedTable, table); // mark columns as primary in original table\n\n    table.columns.forEach(column => {\n      if (columnNames.find(columnName => columnName === column.name)) column.isPrimary = true;\n    });\n  }\n  /**\n   * Updates composite primary keys.\n   */\n\n\n  async updatePrimaryKeys(tableOrName, columns) {\n    await Promise.resolve();\n  }\n  /**\n   * Drops a primary key.\n   */\n\n\n  async dropPrimaryKey(tableOrName) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName); // clone original table and mark primary columns as non-primary\n\n    const changedTable = table.clone();\n    changedTable.primaryColumns.forEach(column => {\n      column.isPrimary = false;\n    });\n    await this.recreateTable(changedTable, table); // mark primary columns as non-primary in original table\n\n    table.primaryColumns.forEach(column => {\n      column.isPrimary = false;\n    });\n  }\n  /**\n   * Creates a new unique constraint.\n   */\n\n\n  async createUniqueConstraint(tableOrName, uniqueConstraint) {\n    await this.createUniqueConstraints(tableOrName, [uniqueConstraint]);\n  }\n  /**\n   * Creates a new unique constraints.\n   */\n\n\n  async createUniqueConstraints(tableOrName, uniqueConstraints) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName); // clone original table and add unique constraints in to cloned table\n\n    const changedTable = table.clone();\n    uniqueConstraints.forEach(uniqueConstraint => changedTable.addUniqueConstraint(uniqueConstraint));\n    await this.recreateTable(changedTable, table);\n  }\n  /**\n   * Drops an unique constraint.\n   */\n\n\n  async dropUniqueConstraint(tableOrName, uniqueOrName) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const uniqueConstraint = InstanceChecker.isTableUnique(uniqueOrName) ? uniqueOrName : table.uniques.find(u => u.name === uniqueOrName);\n    if (!uniqueConstraint) throw new TypeORMError(`Supplied unique constraint was not found in table ${table.name}`);\n    await this.dropUniqueConstraints(table, [uniqueConstraint]);\n  }\n  /**\n   * Creates an unique constraints.\n   */\n\n\n  async dropUniqueConstraints(tableOrName, uniqueConstraints) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName); // clone original table and remove unique constraints from cloned table\n\n    const changedTable = table.clone();\n    uniqueConstraints.forEach(uniqueConstraint => changedTable.removeUniqueConstraint(uniqueConstraint));\n    await this.recreateTable(changedTable, table);\n  }\n  /**\n   * Creates new check constraint.\n   */\n\n\n  async createCheckConstraint(tableOrName, checkConstraint) {\n    await this.createCheckConstraints(tableOrName, [checkConstraint]);\n  }\n  /**\n   * Creates new check constraints.\n   */\n\n\n  async createCheckConstraints(tableOrName, checkConstraints) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName); // clone original table and add check constraints in to cloned table\n\n    const changedTable = table.clone();\n    checkConstraints.forEach(checkConstraint => changedTable.addCheckConstraint(checkConstraint));\n    await this.recreateTable(changedTable, table);\n  }\n  /**\n   * Drops check constraint.\n   */\n\n\n  async dropCheckConstraint(tableOrName, checkOrName) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const checkConstraint = InstanceChecker.isTableCheck(checkOrName) ? checkOrName : table.checks.find(c => c.name === checkOrName);\n    if (!checkConstraint) throw new TypeORMError(`Supplied check constraint was not found in table ${table.name}`);\n    await this.dropCheckConstraints(table, [checkConstraint]);\n  }\n  /**\n   * Drops check constraints.\n   */\n\n\n  async dropCheckConstraints(tableOrName, checkConstraints) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName); // clone original table and remove check constraints from cloned table\n\n    const changedTable = table.clone();\n    checkConstraints.forEach(checkConstraint => changedTable.removeCheckConstraint(checkConstraint));\n    await this.recreateTable(changedTable, table);\n  }\n  /**\n   * Creates a new exclusion constraint.\n   */\n\n\n  async createExclusionConstraint(tableOrName, exclusionConstraint) {\n    throw new TypeORMError(`Sqlite does not support exclusion constraints.`);\n  }\n  /**\n   * Creates a new exclusion constraints.\n   */\n\n\n  async createExclusionConstraints(tableOrName, exclusionConstraints) {\n    throw new TypeORMError(`Sqlite does not support exclusion constraints.`);\n  }\n  /**\n   * Drops exclusion constraint.\n   */\n\n\n  async dropExclusionConstraint(tableOrName, exclusionOrName) {\n    throw new TypeORMError(`Sqlite does not support exclusion constraints.`);\n  }\n  /**\n   * Drops exclusion constraints.\n   */\n\n\n  async dropExclusionConstraints(tableOrName, exclusionConstraints) {\n    throw new TypeORMError(`Sqlite does not support exclusion constraints.`);\n  }\n  /**\n   * Creates a new foreign key.\n   */\n\n\n  async createForeignKey(tableOrName, foreignKey) {\n    await this.createForeignKeys(tableOrName, [foreignKey]);\n  }\n  /**\n   * Creates a new foreign keys.\n   */\n\n\n  async createForeignKeys(tableOrName, foreignKeys) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName); // clone original table and add foreign keys in to cloned table\n\n    const changedTable = table.clone();\n    foreignKeys.forEach(foreignKey => changedTable.addForeignKey(foreignKey));\n    await this.recreateTable(changedTable, table);\n  }\n  /**\n   * Drops a foreign key from the table.\n   */\n\n\n  async dropForeignKey(tableOrName, foreignKeyOrName) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const foreignKey = InstanceChecker.isTableForeignKey(foreignKeyOrName) ? foreignKeyOrName : table.foreignKeys.find(fk => fk.name === foreignKeyOrName);\n    if (!foreignKey) throw new TypeORMError(`Supplied foreign key was not found in table ${table.name}`);\n    await this.dropForeignKeys(tableOrName, [foreignKey]);\n  }\n  /**\n   * Drops a foreign keys from the table.\n   */\n\n\n  async dropForeignKeys(tableOrName, foreignKeys) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName); // clone original table and remove foreign keys from cloned table\n\n    const changedTable = table.clone();\n    foreignKeys.forEach(foreignKey => changedTable.removeForeignKey(foreignKey));\n    await this.recreateTable(changedTable, table);\n  }\n  /**\n   * Creates a new index.\n   */\n\n\n  async createIndex(tableOrName, index) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName); // new index may be passed without name. In this case we generate index name manually.\n\n    if (!index.name) index.name = this.generateIndexName(table, index);\n    const up = this.createIndexSql(table, index);\n    const down = this.dropIndexSql(index);\n    await this.executeQueries(up, down);\n    table.addIndex(index);\n  }\n  /**\n   * Creates a new indices\n   */\n\n\n  async createIndices(tableOrName, indices) {\n    const promises = indices.map(index => this.createIndex(tableOrName, index));\n    await Promise.all(promises);\n  }\n  /**\n   * Drops an index from the table.\n   */\n\n\n  async dropIndex(tableOrName, indexOrName) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const index = InstanceChecker.isTableIndex(indexOrName) ? indexOrName : table.indices.find(i => i.name === indexOrName);\n    if (!index) throw new TypeORMError(`Supplied index ${indexOrName} was not found in table ${table.name}`); // old index may be passed without name. In this case we generate index name manually.\n\n    if (!index.name) index.name = this.generateIndexName(table, index);\n    const up = this.dropIndexSql(index);\n    const down = this.createIndexSql(table, index);\n    await this.executeQueries(up, down);\n    table.removeIndex(index);\n  }\n  /**\n   * Drops an indices from the table.\n   */\n\n\n  async dropIndices(tableOrName, indices) {\n    const promises = indices.map(index => this.dropIndex(tableOrName, index));\n    await Promise.all(promises);\n  }\n  /**\n   * Clears all table contents.\n   * Note: this operation uses SQL's TRUNCATE query which cannot be reverted in transactions.\n   */\n\n\n  async clearTable(tableName) {\n    await this.query(`DELETE FROM ${this.escapePath(tableName)}`);\n  }\n  /**\n   * Removes all tables from the currently connected database.\n   */\n\n\n  async clearDatabase(database) {\n    let dbPath = undefined;\n\n    if (database && this.driver.getAttachedDatabaseHandleByRelativePath(database)) {\n      dbPath = this.driver.getAttachedDatabaseHandleByRelativePath(database);\n    }\n\n    await this.query(`PRAGMA foreign_keys = OFF`);\n    const isAnotherTransactionActive = this.isTransactionActive;\n    if (!isAnotherTransactionActive) await this.startTransaction();\n\n    try {\n      const selectViewDropsQuery = dbPath ? `SELECT 'DROP VIEW \"${dbPath}\".\"' || name || '\";' as query FROM \"${dbPath}\".\"sqlite_master\" WHERE \"type\" = 'view'` : `SELECT 'DROP VIEW \"' || name || '\";' as query FROM \"sqlite_master\" WHERE \"type\" = 'view'`;\n      const dropViewQueries = await this.query(selectViewDropsQuery);\n      await Promise.all(dropViewQueries.map(q => this.query(q[\"query\"])));\n      const selectTableDropsQuery = dbPath ? `SELECT 'DROP TABLE \"${dbPath}\".\"' || name || '\";' as query FROM \"${dbPath}\".\"sqlite_master\" WHERE \"type\" = 'table' AND \"name\" != 'sqlite_sequence'` : `SELECT 'DROP TABLE \"' || name || '\";' as query FROM \"sqlite_master\" WHERE \"type\" = 'table' AND \"name\" != 'sqlite_sequence'`;\n      const dropTableQueries = await this.query(selectTableDropsQuery);\n      await Promise.all(dropTableQueries.map(q => this.query(q[\"query\"])));\n      if (!isAnotherTransactionActive) await this.commitTransaction();\n    } catch (error) {\n      try {\n        // we throw original error even if rollback thrown an error\n        if (!isAnotherTransactionActive) await this.rollbackTransaction();\n      } catch (rollbackError) {}\n\n      throw error;\n    } finally {\n      await this.query(`PRAGMA foreign_keys = ON`);\n    }\n  } // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n\n  async loadViews(viewNames) {\n    const hasTable = await this.hasTable(this.getTypeormMetadataTableName());\n\n    if (!hasTable) {\n      return [];\n    }\n\n    if (!viewNames) {\n      viewNames = [];\n    }\n\n    const viewNamesString = viewNames.map(name => \"'\" + name + \"'\").join(\", \");\n    let query = `SELECT \"t\".* FROM \"${this.getTypeormMetadataTableName()}\" \"t\" INNER JOIN \"sqlite_master\" s ON \"s\".\"name\" = \"t\".\"name\" AND \"s\".\"type\" = 'view' WHERE \"t\".\"type\" = '${MetadataTableType.VIEW}'`;\n    if (viewNamesString.length > 0) query += ` AND \"t\".\"name\" IN (${viewNamesString})`;\n    const dbViews = await this.query(query);\n    return dbViews.map(dbView => {\n      const view = new View();\n      view.name = dbView[\"name\"];\n      view.expression = dbView[\"value\"];\n      return view;\n    });\n  }\n\n  async loadTableRecords(tablePath, tableOrIndex) {\n    let database = undefined;\n    const [schema, tableName] = this.splitTablePath(tablePath);\n\n    if (schema && this.driver.getAttachedDatabasePathRelativeByHandle(schema)) {\n      database = this.driver.getAttachedDatabasePathRelativeByHandle(schema);\n    }\n\n    const res = await this.query(`SELECT ${database ? `'${database}'` : null} as database, ${schema ? `'${schema}'` : null} as schema, * FROM ${schema ? `\"${schema}\".` : \"\"}${this.escapePath(`sqlite_master`)} WHERE \"type\" = '${tableOrIndex}' AND \"${tableOrIndex === \"table\" ? \"name\" : \"tbl_name\"}\" IN ('${tableName}')`);\n    return res;\n  }\n\n  async loadPragmaRecords(tablePath, pragma) {\n    const [, tableName] = this.splitTablePath(tablePath);\n    const res = await this.query(`PRAGMA ${pragma}(\"${tableName}\")`);\n    return res;\n  }\n  /**\n   * Loads all tables (with given names) from the database and creates a Table from them.\n   */\n\n\n  async loadTables(tableNames) {\n    // if no tables given then no need to proceed\n    if (tableNames && tableNames.length === 0) {\n      return [];\n    }\n\n    let dbTables = [];\n    let dbIndicesDef;\n\n    if (!tableNames) {\n      const tablesSql = `SELECT * FROM \"sqlite_master\" WHERE \"type\" = 'table'`;\n      dbTables.push(...(await this.query(tablesSql)));\n      const tableNamesString = dbTables.map(_ref => {\n        let {\n          name\n        } = _ref;\n        return `'${name}'`;\n      }).join(\", \");\n      dbIndicesDef = await this.query(`SELECT * FROM \"sqlite_master\" WHERE \"type\" = 'index' AND \"tbl_name\" IN (${tableNamesString})`);\n    } else {\n      dbTables = (await Promise.all(tableNames.map(tableName => this.loadTableRecords(tableName, \"table\")))).reduce((acc, res) => [...acc, ...res], []).filter(Boolean);\n      dbIndicesDef = (await Promise.all((tableNames !== null && tableNames !== void 0 ? tableNames : []).map(tableName => this.loadTableRecords(tableName, \"index\")))).reduce((acc, res) => [...acc, ...res], []).filter(Boolean);\n    } // if tables were not found in the db, no need to proceed\n\n\n    if (dbTables.length === 0) {\n      return [];\n    } // create table schemas for loaded tables\n\n\n    return Promise.all(dbTables.map(async dbTable => {\n      const tablePath = dbTable[\"database\"] && this.driver.getAttachedDatabaseHandleByRelativePath(dbTable[\"database\"]) ? `${this.driver.getAttachedDatabaseHandleByRelativePath(dbTable[\"database\"])}.${dbTable[\"name\"]}` : dbTable[\"name\"];\n      const sql = dbTable[\"sql\"];\n      const withoutRowid = sql.includes(\"WITHOUT ROWID\");\n      const table = new Table({\n        name: tablePath,\n        withoutRowid\n      }); // load columns and indices\n\n      const [dbColumns, dbIndices, dbForeignKeys] = await Promise.all([this.loadPragmaRecords(tablePath, `table_xinfo`), this.loadPragmaRecords(tablePath, `index_list`), this.loadPragmaRecords(tablePath, `foreign_key_list`)]); // find column name with auto increment\n\n      let autoIncrementColumnName = undefined;\n      const tableSql = dbTable[\"sql\"];\n      let autoIncrementIndex = tableSql.toUpperCase().indexOf(\"AUTOINCREMENT\");\n\n      if (autoIncrementIndex !== -1) {\n        autoIncrementColumnName = tableSql.substr(0, autoIncrementIndex);\n        const comma = autoIncrementColumnName.lastIndexOf(\",\");\n        const bracket = autoIncrementColumnName.lastIndexOf(\"(\");\n\n        if (comma !== -1) {\n          autoIncrementColumnName = autoIncrementColumnName.substr(comma);\n          autoIncrementColumnName = autoIncrementColumnName.substr(0, autoIncrementColumnName.lastIndexOf('\"'));\n          autoIncrementColumnName = autoIncrementColumnName.substr(autoIncrementColumnName.indexOf('\"') + 1);\n        } else if (bracket !== -1) {\n          autoIncrementColumnName = autoIncrementColumnName.substr(bracket);\n          autoIncrementColumnName = autoIncrementColumnName.substr(0, autoIncrementColumnName.lastIndexOf('\"'));\n          autoIncrementColumnName = autoIncrementColumnName.substr(autoIncrementColumnName.indexOf('\"') + 1);\n        }\n      } // create columns from the loaded columns\n\n\n      table.columns = await Promise.all(dbColumns.map(async dbColumn => {\n        const tableColumn = new TableColumn();\n        tableColumn.name = dbColumn[\"name\"];\n        tableColumn.type = dbColumn[\"type\"].toLowerCase();\n        tableColumn.default = dbColumn[\"dflt_value\"] !== null && dbColumn[\"dflt_value\"] !== undefined ? dbColumn[\"dflt_value\"] : undefined;\n        tableColumn.isNullable = dbColumn[\"notnull\"] === 0; // primary keys are numbered starting with 1, columns that aren't primary keys are marked with 0\n\n        tableColumn.isPrimary = dbColumn[\"pk\"] > 0;\n        tableColumn.comment = \"\"; // SQLite does not support column comments\n\n        tableColumn.isGenerated = autoIncrementColumnName === dbColumn[\"name\"];\n\n        if (tableColumn.isGenerated) {\n          tableColumn.generationStrategy = \"increment\";\n        }\n\n        if (dbColumn[\"hidden\"] === 2 || dbColumn[\"hidden\"] === 3) {\n          tableColumn.generatedType = dbColumn[\"hidden\"] === 2 ? \"VIRTUAL\" : \"STORED\";\n          const asExpressionQuery = await this.selectTypeormMetadataSql({\n            table: table.name,\n            type: MetadataTableType.GENERATED_COLUMN,\n            name: tableColumn.name\n          });\n          const results = await this.query(asExpressionQuery.query, asExpressionQuery.parameters);\n\n          if (results[0] && results[0].value) {\n            tableColumn.asExpression = results[0].value;\n          } else {\n            tableColumn.asExpression = \"\";\n          }\n        }\n\n        if (tableColumn.type === \"varchar\") {\n          // Check if this is an enum\n          const enumMatch = sql.match(new RegExp('\"(' + tableColumn.name + \")\\\" varchar CHECK\\\\s*\\\\(\\\\s*\\\"\\\\1\\\"\\\\s+IN\\\\s*\\\\(('[^']+'(?:\\\\s*,\\\\s*'[^']+')+)\\\\s*\\\\)\\\\s*\\\\)\"));\n\n          if (enumMatch) {\n            // This is an enum\n            tableColumn.enum = enumMatch[2].substr(1, enumMatch[2].length - 2).split(\"','\");\n          }\n        } // parse datatype and attempt to retrieve length, precision and scale\n\n\n        let pos = tableColumn.type.indexOf(\"(\");\n\n        if (pos !== -1) {\n          const fullType = tableColumn.type;\n          let dataType = fullType.substr(0, pos);\n\n          if (!!this.driver.withLengthColumnTypes.find(col => col === dataType)) {\n            let len = parseInt(fullType.substring(pos + 1, fullType.length - 1));\n\n            if (len) {\n              tableColumn.length = len.toString();\n              tableColumn.type = dataType; // remove the length part from the datatype\n            }\n          }\n\n          if (!!this.driver.withPrecisionColumnTypes.find(col => col === dataType)) {\n            const re = new RegExp(`^${dataType}\\\\((\\\\d+),?\\\\s?(\\\\d+)?\\\\)`);\n            const matches = fullType.match(re);\n\n            if (matches && matches[1]) {\n              tableColumn.precision = +matches[1];\n            }\n\n            if (!!this.driver.withScaleColumnTypes.find(col => col === dataType)) {\n              if (matches && matches[2]) {\n                tableColumn.scale = +matches[2];\n              }\n            }\n\n            tableColumn.type = dataType; // remove the precision/scale part from the datatype\n          }\n        }\n\n        return tableColumn;\n      })); // find foreign key constraints from CREATE TABLE sql\n\n      let fkResult;\n      const fkMappings = [];\n      const fkRegex = /CONSTRAINT \"([^\"]*)\" FOREIGN KEY ?\\((.*?)\\) REFERENCES \"([^\"]*)\"/g;\n\n      while ((fkResult = fkRegex.exec(sql)) !== null) {\n        fkMappings.push({\n          name: fkResult[1],\n          columns: fkResult[2].substr(1, fkResult[2].length - 2).split(`\", \"`),\n          referencedTableName: fkResult[3]\n        });\n      } // build foreign keys\n\n\n      const tableForeignKeyConstraints = OrmUtils.uniq(dbForeignKeys, dbForeignKey => dbForeignKey[\"id\"]);\n      table.foreignKeys = tableForeignKeyConstraints.map(foreignKey => {\n        const ownForeignKeys = dbForeignKeys.filter(dbForeignKey => dbForeignKey[\"id\"] === foreignKey[\"id\"] && dbForeignKey[\"table\"] === foreignKey[\"table\"]);\n        const columnNames = ownForeignKeys.map(dbForeignKey => dbForeignKey[\"from\"]);\n        const referencedColumnNames = ownForeignKeys.map(dbForeignKey => dbForeignKey[\"to\"]); // find related foreign key mapping\n\n        const fkMapping = fkMappings.find(it => it.referencedTableName === foreignKey[\"table\"] && it.columns.every(column => columnNames.indexOf(column) !== -1));\n        return new TableForeignKey({\n          name: fkMapping.name,\n          columnNames: columnNames,\n          referencedTableName: foreignKey[\"table\"],\n          referencedColumnNames: referencedColumnNames,\n          onDelete: foreignKey[\"on_delete\"],\n          onUpdate: foreignKey[\"on_update\"]\n        });\n      }); // find unique constraints from CREATE TABLE sql\n\n      let uniqueRegexResult;\n      const uniqueMappings = [];\n      const uniqueRegex = /CONSTRAINT \"([^\"]*)\" UNIQUE ?\\((.*?)\\)/g;\n\n      while ((uniqueRegexResult = uniqueRegex.exec(sql)) !== null) {\n        uniqueMappings.push({\n          name: uniqueRegexResult[1],\n          columns: uniqueRegexResult[2].substr(1, uniqueRegexResult[2].length - 2).split(`\", \"`)\n        });\n      } // build unique constraints\n\n\n      const tableUniquePromises = dbIndices.filter(dbIndex => dbIndex[\"origin\"] === \"u\").map(dbIndex => dbIndex[\"name\"]).filter((value, index, self) => self.indexOf(value) === index).map(async dbIndexName => {\n        const dbIndex = dbIndices.find(dbIndex => dbIndex[\"name\"] === dbIndexName);\n        const indexInfos = await this.query(`PRAGMA index_info(\"${dbIndex[\"name\"]}\")`);\n        const indexColumns = indexInfos.sort((indexInfo1, indexInfo2) => parseInt(indexInfo1[\"seqno\"]) - parseInt(indexInfo2[\"seqno\"])).map(indexInfo => indexInfo[\"name\"]);\n\n        if (indexColumns.length === 1) {\n          const column = table.columns.find(column => {\n            return !!indexColumns.find(indexColumn => indexColumn === column.name);\n          });\n          if (column) column.isUnique = true;\n        } // find existent mapping by a column names\n\n\n        const foundMapping = uniqueMappings.find(mapping => {\n          return mapping.columns.every(column => indexColumns.indexOf(column) !== -1);\n        });\n        return new TableUnique({\n          name: foundMapping ? foundMapping.name : this.connection.namingStrategy.uniqueConstraintName(table, indexColumns),\n          columnNames: indexColumns\n        });\n      });\n      table.uniques = await Promise.all(tableUniquePromises); // build checks\n\n      let result;\n      const regexp = /CONSTRAINT \"([^\"]*)\" CHECK ?(\\(.*?\\))([,]|[)]$)/g;\n\n      while ((result = regexp.exec(sql)) !== null) {\n        table.checks.push(new TableCheck({\n          name: result[1],\n          expression: result[2]\n        }));\n      } // build indices\n\n\n      const indicesPromises = dbIndices.filter(dbIndex => dbIndex[\"origin\"] === \"c\").map(dbIndex => dbIndex[\"name\"]).filter((value, index, self) => self.indexOf(value) === index) // unqiue\n      .map(async dbIndexName => {\n        const indexDef = dbIndicesDef.find(dbIndexDef => dbIndexDef[\"name\"] === dbIndexName);\n        const condition = /WHERE (.*)/.exec(indexDef[\"sql\"]);\n        const dbIndex = dbIndices.find(dbIndex => dbIndex[\"name\"] === dbIndexName);\n        const indexInfos = await this.query(`PRAGMA index_info(\"${dbIndex[\"name\"]}\")`);\n        const indexColumns = indexInfos.sort((indexInfo1, indexInfo2) => parseInt(indexInfo1[\"seqno\"]) - parseInt(indexInfo2[\"seqno\"])).map(indexInfo => indexInfo[\"name\"]);\n        const dbIndexPath = `${dbTable[\"database\"] ? `${dbTable[\"database\"]}.` : \"\"}${dbIndex[\"name\"]}`;\n        const isUnique = dbIndex[\"unique\"] === \"1\" || dbIndex[\"unique\"] === 1;\n        return new TableIndex({\n          table: table,\n          name: dbIndexPath,\n          columnNames: indexColumns,\n          isUnique: isUnique,\n          where: condition ? condition[1] : undefined\n        });\n      });\n      const indices = await Promise.all(indicesPromises);\n      table.indices = indices.filter(index => !!index);\n      return table;\n    }));\n  }\n  /**\n   * Builds create table sql.\n   */\n\n\n  createTableSql(table, createForeignKeys, temporaryTable) {\n    const primaryColumns = table.columns.filter(column => column.isPrimary);\n    const hasAutoIncrement = primaryColumns.find(column => column.isGenerated && column.generationStrategy === \"increment\");\n    const skipPrimary = primaryColumns.length > 1;\n    if (skipPrimary && hasAutoIncrement) throw new TypeORMError(`Sqlite does not support AUTOINCREMENT on composite primary key`);\n    const columnDefinitions = table.columns.map(column => this.buildCreateColumnSql(column, skipPrimary)).join(\", \");\n    const [database] = this.splitTablePath(table.name);\n    let sql = `CREATE TABLE ${this.escapePath(table.name)} (${columnDefinitions}`;\n    let [databaseNew, tableName] = this.splitTablePath(table.name);\n    const newTableName = temporaryTable ? `${databaseNew ? `${databaseNew}.` : \"\"}${tableName.replace(/^temporary_/, \"\")}` : table.name; // need for `addColumn()` method, because it recreates table.\n\n    table.columns.filter(column => column.isUnique).forEach(column => {\n      const isUniqueExist = table.uniques.some(unique => unique.columnNames.length === 1 && unique.columnNames[0] === column.name);\n      if (!isUniqueExist) table.uniques.push(new TableUnique({\n        name: this.connection.namingStrategy.uniqueConstraintName(table, [column.name]),\n        columnNames: [column.name]\n      }));\n    });\n\n    if (table.uniques.length > 0) {\n      const uniquesSql = table.uniques.map(unique => {\n        const uniqueName = unique.name ? unique.name : this.connection.namingStrategy.uniqueConstraintName(newTableName, unique.columnNames);\n        const columnNames = unique.columnNames.map(columnName => `\"${columnName}\"`).join(\", \");\n        return `CONSTRAINT \"${uniqueName}\" UNIQUE (${columnNames})`;\n      }).join(\", \");\n      sql += `, ${uniquesSql}`;\n    }\n\n    if (table.checks.length > 0) {\n      const checksSql = table.checks.map(check => {\n        const checkName = check.name ? check.name : this.connection.namingStrategy.checkConstraintName(newTableName, check.expression);\n        return `CONSTRAINT \"${checkName}\" CHECK (${check.expression})`;\n      }).join(\", \");\n      sql += `, ${checksSql}`;\n    }\n\n    if (table.foreignKeys.length > 0 && createForeignKeys) {\n      const foreignKeysSql = table.foreignKeys.filter(fk => {\n        const [referencedDatabase] = this.splitTablePath(fk.referencedTableName);\n\n        if (referencedDatabase !== database) {\n          return false;\n        }\n\n        return true;\n      }).map(fk => {\n        const [, referencedTable] = this.splitTablePath(fk.referencedTableName);\n        const columnNames = fk.columnNames.map(columnName => `\"${columnName}\"`).join(\", \");\n        if (!fk.name) fk.name = this.connection.namingStrategy.foreignKeyName(newTableName, fk.columnNames, this.getTablePath(fk), fk.referencedColumnNames);\n        const referencedColumnNames = fk.referencedColumnNames.map(columnName => `\"${columnName}\"`).join(\", \");\n        let constraint = `CONSTRAINT \"${fk.name}\" FOREIGN KEY (${columnNames}) REFERENCES \"${referencedTable}\" (${referencedColumnNames})`;\n        if (fk.onDelete) constraint += ` ON DELETE ${fk.onDelete}`;\n        if (fk.onUpdate) constraint += ` ON UPDATE ${fk.onUpdate}`;\n        if (fk.deferrable) constraint += ` DEFERRABLE ${fk.deferrable}`;\n        return constraint;\n      }).join(\", \");\n      sql += `, ${foreignKeysSql}`;\n    }\n\n    if (primaryColumns.length > 1) {\n      const columnNames = primaryColumns.map(column => `\"${column.name}\"`).join(\", \");\n      sql += `, PRIMARY KEY (${columnNames})`;\n    }\n\n    sql += `)`;\n\n    if (table.withoutRowid) {\n      sql += \" WITHOUT ROWID\";\n    }\n\n    return new Query(sql);\n  }\n  /**\n   * Builds drop table sql.\n   */\n\n\n  dropTableSql(tableOrName, ifExist) {\n    const tableName = InstanceChecker.isTable(tableOrName) ? tableOrName.name : tableOrName;\n    const query = ifExist ? `DROP TABLE IF EXISTS ${this.escapePath(tableName)}` : `DROP TABLE ${this.escapePath(tableName)}`;\n    return new Query(query);\n  }\n\n  createViewSql(view) {\n    if (typeof view.expression === \"string\") {\n      return new Query(`CREATE VIEW \"${view.name}\" AS ${view.expression}`);\n    } else {\n      return new Query(`CREATE VIEW \"${view.name}\" AS ${view.expression(this.connection).getQuery()}`);\n    }\n  }\n\n  insertViewDefinitionSql(view) {\n    const expression = typeof view.expression === \"string\" ? view.expression.trim() : view.expression(this.connection).getQuery();\n    return this.insertTypeormMetadataSql({\n      type: MetadataTableType.VIEW,\n      name: view.name,\n      value: expression\n    });\n  }\n  /**\n   * Builds drop view sql.\n   */\n\n\n  dropViewSql(viewOrPath) {\n    const viewName = InstanceChecker.isView(viewOrPath) ? viewOrPath.name : viewOrPath;\n    return new Query(`DROP VIEW \"${viewName}\"`);\n  }\n  /**\n   * Builds remove view sql.\n   */\n\n\n  deleteViewDefinitionSql(viewOrPath) {\n    const viewName = InstanceChecker.isView(viewOrPath) ? viewOrPath.name : viewOrPath;\n    return this.deleteTypeormMetadataSql({\n      type: MetadataTableType.VIEW,\n      name: viewName\n    });\n  }\n  /**\n   * Builds create index sql.\n   */\n\n\n  createIndexSql(table, index) {\n    const columns = index.columnNames.map(columnName => `\"${columnName}\"`).join(\", \");\n    const [database, tableName] = this.splitTablePath(table.name);\n    return new Query(`CREATE ${index.isUnique ? \"UNIQUE \" : \"\"}INDEX ${database ? `\"${database}\".` : \"\"}${this.escapePath(index.name)} ON \"${tableName}\" (${columns}) ${index.where ? \"WHERE \" + index.where : \"\"}`);\n  }\n  /**\n   * Builds drop index sql.\n   */\n\n\n  dropIndexSql(indexOrName) {\n    let indexName = InstanceChecker.isTableIndex(indexOrName) ? indexOrName.name : indexOrName;\n    return new Query(`DROP INDEX ${this.escapePath(indexName)}`);\n  }\n  /**\n   * Builds a query for create column.\n   */\n\n\n  buildCreateColumnSql(column, skipPrimary) {\n    let c = '\"' + column.name + '\"';\n\n    if (InstanceChecker.isColumnMetadata(column)) {\n      c += \" \" + this.driver.normalizeType(column);\n    } else {\n      c += \" \" + this.connection.driver.createFullType(column);\n    }\n\n    if (column.enum) c += ' CHECK( \"' + column.name + '\" IN (' + column.enum.map(val => \"'\" + val + \"'\").join(\",\") + \") )\";\n    if (column.isPrimary && !skipPrimary) c += \" PRIMARY KEY\";\n    if (column.isGenerated === true && column.generationStrategy === \"increment\") // don't use skipPrimary here since updates can update already exist primary without auto inc.\n      c += \" AUTOINCREMENT\";\n    if (column.collation) c += \" COLLATE \" + column.collation;\n    if (column.isNullable !== true) c += \" NOT NULL\";\n\n    if (column.asExpression) {\n      c += ` AS (${column.asExpression}) ${column.generatedType ? column.generatedType : \"VIRTUAL\"}`;\n    } else {\n      if (column.default !== undefined && column.default !== null) c += \" DEFAULT (\" + column.default + \")\";\n    }\n\n    return c;\n  }\n\n  async recreateTable(newTable, oldTable) {\n    let migrateData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    const upQueries = [];\n    const downQueries = []; // drop old table indices\n\n    oldTable.indices.forEach(index => {\n      upQueries.push(this.dropIndexSql(index));\n      downQueries.push(this.createIndexSql(oldTable, index));\n    }); // change table name into 'temporary_table'\n\n    let [databaseNew, tableNameNew] = this.splitTablePath(newTable.name);\n    let [, tableNameOld] = this.splitTablePath(oldTable.name);\n    newTable.name = tableNameNew = `${databaseNew ? `${databaseNew}.` : \"\"}temporary_${tableNameNew}`; // create new table\n\n    upQueries.push(this.createTableSql(newTable, true, true));\n    downQueries.push(this.dropTableSql(newTable)); // migrate all data from the old table into new table\n\n    if (migrateData) {\n      let newColumnNames = newTable.columns.filter(column => !column.generatedType).map(column => `\"${column.name}\"`);\n      let oldColumnNames = oldTable.columns.filter(column => !column.generatedType).map(column => `\"${column.name}\"`);\n\n      if (oldColumnNames.length < newColumnNames.length) {\n        newColumnNames = newTable.columns.filter(column => {\n          const oldColumn = oldTable.columns.find(c => c.name === column.name);\n          if (oldColumn && oldColumn.generatedType) return false;\n          return !column.generatedType && oldColumn;\n        }).map(column => `\"${column.name}\"`);\n      } else if (oldColumnNames.length > newColumnNames.length) {\n        oldColumnNames = oldTable.columns.filter(column => {\n          return !column.generatedType && newTable.columns.find(c => c.name === column.name);\n        }).map(column => `\"${column.name}\"`);\n      }\n\n      upQueries.push(new Query(`INSERT INTO ${this.escapePath(newTable.name)}(${newColumnNames.join(\", \")}) SELECT ${oldColumnNames.join(\", \")} FROM ${this.escapePath(oldTable.name)}`));\n      downQueries.push(new Query(`INSERT INTO ${this.escapePath(oldTable.name)}(${oldColumnNames.join(\", \")}) SELECT ${newColumnNames.join(\", \")} FROM ${this.escapePath(newTable.name)}`));\n    } // drop old table\n\n\n    upQueries.push(this.dropTableSql(oldTable));\n    downQueries.push(this.createTableSql(oldTable, true)); // rename old table\n\n    upQueries.push(new Query(`ALTER TABLE ${this.escapePath(newTable.name)} RENAME TO ${this.escapePath(tableNameOld)}`));\n    downQueries.push(new Query(`ALTER TABLE ${this.escapePath(oldTable.name)} RENAME TO ${this.escapePath(tableNameNew)}`));\n    newTable.name = oldTable.name; // recreate table indices\n\n    newTable.indices.forEach(index => {\n      // new index may be passed without name. In this case we generate index name manually.\n      if (!index.name) index.name = this.connection.namingStrategy.indexName(newTable, index.columnNames, index.where);\n      upQueries.push(this.createIndexSql(newTable, index));\n      downQueries.push(this.dropIndexSql(index));\n    }); // update generated columns in \"typeorm_metadata\" table\n    // Step 1: clear data for removed generated columns\n\n    oldTable.columns.filter(column => {\n      const newTableColumn = newTable.columns.find(c => c.name === column.name); // we should delete record from \"typeorm_metadata\" if generated column was removed\n      // or it was changed to non-generated\n\n      return column.generatedType && column.asExpression && (!newTableColumn || !newTableColumn.generatedType && !newTableColumn.asExpression);\n    }).forEach(column => {\n      const deleteQuery = this.deleteTypeormMetadataSql({\n        table: oldTable.name,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name\n      });\n      const insertQuery = this.insertTypeormMetadataSql({\n        table: oldTable.name,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name,\n        value: column.asExpression\n      });\n      upQueries.push(deleteQuery);\n      downQueries.push(insertQuery);\n    }); // Step 2: add data for new generated columns\n\n    newTable.columns.filter(column => column.generatedType && column.asExpression && !oldTable.columns.some(c => c.name === column.name)).forEach(column => {\n      const insertQuery = this.insertTypeormMetadataSql({\n        table: newTable.name,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name,\n        value: column.asExpression\n      });\n      const deleteQuery = this.deleteTypeormMetadataSql({\n        table: newTable.name,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name\n      });\n      upQueries.push(insertQuery);\n      downQueries.push(deleteQuery);\n    }); // Step 3: update changed expressions\n\n    newTable.columns.filter(column => column.generatedType && column.asExpression).forEach(column => {\n      const oldColumn = oldTable.columns.find(c => c.name === column.name && c.generatedType && column.generatedType && c.asExpression !== column.asExpression);\n      if (!oldColumn) return; // update expression\n\n      const deleteQuery = this.deleteTypeormMetadataSql({\n        table: oldTable.name,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: oldColumn.name\n      });\n      const insertQuery = this.insertTypeormMetadataSql({\n        table: newTable.name,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name,\n        value: column.asExpression\n      });\n      upQueries.push(deleteQuery);\n      upQueries.push(insertQuery); // revert update\n\n      const revertInsertQuery = this.insertTypeormMetadataSql({\n        table: newTable.name,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: oldColumn.name,\n        value: oldColumn.asExpression\n      });\n      const revertDeleteQuery = this.deleteTypeormMetadataSql({\n        table: oldTable.name,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name\n      });\n      downQueries.push(revertInsertQuery);\n      downQueries.push(revertDeleteQuery);\n    });\n    await this.executeQueries(upQueries, downQueries);\n    this.replaceCachedTable(oldTable, newTable);\n  }\n  /**\n   * tablePath e.g. \"myDB.myTable\", \"myTable\"\n   */\n\n\n  splitTablePath(tablePath) {\n    return tablePath.indexOf(\".\") !== -1 ? tablePath.split(\".\") : [undefined, tablePath];\n  }\n  /**\n   * Escapes given table or view path. Tolerates leading/trailing dots\n   */\n\n\n  escapePath(target, disableEscape) {\n    const tableName = InstanceChecker.isTable(target) || InstanceChecker.isView(target) ? target.name : target;\n    return tableName.replace(/^\\.+|\\.+$/g, \"\").split(\".\").map(i => disableEscape ? i : `\"${i}\"`).join(\".\");\n  }\n\n}","map":{"version":3,"mappings":"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","names":["TransactionNotStartedError","TableColumn","Table","TableIndex","TableForeignKey","View","Query","TableUnique","BaseQueryRunner","OrmUtils","TableCheck","TransactionAlreadyStartedError","TypeORMError","MetadataTableType","InstanceChecker","AbstractSqliteQueryRunner","constructor","connect","Promise","resolve","driver","databaseConnection","release","loadedTables","clearSqlMemory","startTransaction","isolationLevel","transactionSupport","connection","options","type","isTransactionActive","broadcaster","broadcast","err","transactionDepth","query","commitTransaction","rollbackTransaction","stream","parameters","onEnd","onError","getDatabases","getSchemas","database","hasDatabase","getCurrentDatabase","undefined","hasSchema","schema","getCurrentSchema","hasTable","tableOrName","tableName","isTable","name","sql","result","length","hasColumn","columnName","escapePath","columns","find","column","createDatabase","ifNotExist","dropDatabase","ifExist","createSchema","schemaPath","dropSchema","createTable","table","createForeignKeys","createIndices","upQueries","downQueries","isTableExist","push","createTableSql","dropTableSql","indices","forEach","index","namingStrategy","indexName","columnNames","where","createIndexSql","dropIndexSql","generatedColumns","filter","generatedType","asExpression","insertQuery","insertTypeormMetadataSql","GENERATED_COLUMN","value","deleteQuery","deleteTypeormMetadataSql","executeQueries","dropTable","dropForeignKeys","dropIndices","getCachedTable","createView","view","createViewSql","insertViewDefinitionSql","dropViewSql","deleteViewDefinitionSql","dropView","target","viewName","isView","getCachedView","renameTable","oldTableOrName","newTableName","oldTable","newTable","clone","up","down","uniques","unique","oldUniqueName","uniqueConstraintName","foreignKeys","foreignKey","oldForeignKeyName","foreignKeyName","getTablePath","referencedColumnNames","oldIndexName","recreateTable","addColumn","addColumns","changedTable","renameColumn","oldTableColumnOrName","newTableColumnOrName","oldColumn","isTableColumn","c","newColumn","changeColumn","changeColumns","changedColumns","changedColumnSet","findColumnUniques","uniqueName","splice","indexOf","findColumnForeignKeys","findColumnIndices","originalColumn","dropColumn","columnOrName","findColumnByName","dropColumns","columnInstance","Error","removeColumn","removeUniqueConstraint","removeIndex","fk","removeForeignKey","createPrimaryKey","isPrimary","updatePrimaryKeys","dropPrimaryKey","primaryColumns","createUniqueConstraint","uniqueConstraint","createUniqueConstraints","uniqueConstraints","addUniqueConstraint","dropUniqueConstraint","uniqueOrName","isTableUnique","u","dropUniqueConstraints","createCheckConstraint","checkConstraint","createCheckConstraints","checkConstraints","addCheckConstraint","dropCheckConstraint","checkOrName","isTableCheck","checks","dropCheckConstraints","removeCheckConstraint","createExclusionConstraint","exclusionConstraint","createExclusionConstraints","exclusionConstraints","dropExclusionConstraint","exclusionOrName","dropExclusionConstraints","createForeignKey","addForeignKey","dropForeignKey","foreignKeyOrName","isTableForeignKey","createIndex","generateIndexName","addIndex","promises","map","all","dropIndex","indexOrName","isTableIndex","i","clearTable","clearDatabase","dbPath","getAttachedDatabaseHandleByRelativePath","isAnotherTransactionActive","selectViewDropsQuery","dropViewQueries","q","selectTableDropsQuery","dropTableQueries","error","rollbackError","loadViews","viewNames","getTypeormMetadataTableName","viewNamesString","join","VIEW","dbViews","dbView","expression","loadTableRecords","tablePath","tableOrIndex","splitTablePath","getAttachedDatabasePathRelativeByHandle","res","loadPragmaRecords","pragma","loadTables","tableNames","dbTables","dbIndicesDef","tablesSql","tableNamesString","reduce","acc","Boolean","dbTable","withoutRowid","includes","dbColumns","dbIndices","dbForeignKeys","autoIncrementColumnName","tableSql","autoIncrementIndex","toUpperCase","substr","comma","lastIndexOf","bracket","dbColumn","tableColumn","toLowerCase","default","isNullable","comment","isGenerated","generationStrategy","asExpressionQuery","selectTypeormMetadataSql","results","enumMatch","match","RegExp","enum","split","pos","fullType","dataType","withLengthColumnTypes","col","len","parseInt","substring","toString","withPrecisionColumnTypes","re","matches","precision","withScaleColumnTypes","scale","fkResult","fkMappings","fkRegex","exec","referencedTableName","tableForeignKeyConstraints","uniq","dbForeignKey","ownForeignKeys","fkMapping","it","every","onDelete","onUpdate","uniqueRegexResult","uniqueMappings","uniqueRegex","tableUniquePromises","dbIndex","self","dbIndexName","indexInfos","indexColumns","sort","indexInfo1","indexInfo2","indexInfo","indexColumn","isUnique","foundMapping","mapping","regexp","indicesPromises","indexDef","dbIndexDef","condition","dbIndexPath","temporaryTable","hasAutoIncrement","skipPrimary","columnDefinitions","buildCreateColumnSql","databaseNew","replace","isUniqueExist","some","uniquesSql","checksSql","check","checkName","checkConstraintName","foreignKeysSql","referencedDatabase","referencedTable","constraint","deferrable","getQuery","trim","viewOrPath","isColumnMetadata","normalizeType","createFullType","val","collation","migrateData","tableNameNew","tableNameOld","newColumnNames","oldColumnNames","newTableColumn","revertInsertQuery","revertDeleteQuery","replaceCachedTable","disableEscape"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\driver\\sqlite-abstract\\AbstractSqliteQueryRunner.ts"],"sourcesContent":["import { QueryRunner } from \"../../query-runner/QueryRunner\"\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { TransactionNotStartedError } from \"../../error/TransactionNotStartedError\"\nimport { TableColumn } from \"../../schema-builder/table/TableColumn\"\nimport { Table } from \"../../schema-builder/table/Table\"\nimport { TableIndex } from \"../../schema-builder/table/TableIndex\"\nimport { TableForeignKey } from \"../../schema-builder/table/TableForeignKey\"\nimport { View } from \"../../schema-builder/view/View\"\nimport { Query } from \"../Query\"\nimport { AbstractSqliteDriver } from \"./AbstractSqliteDriver\"\nimport { ReadStream } from \"../../platform/PlatformTools\"\nimport { TableIndexOptions } from \"../../schema-builder/options/TableIndexOptions\"\nimport { TableUnique } from \"../../schema-builder/table/TableUnique\"\nimport { BaseQueryRunner } from \"../../query-runner/BaseQueryRunner\"\nimport { OrmUtils } from \"../../util/OrmUtils\"\nimport { TableCheck } from \"../../schema-builder/table/TableCheck\"\nimport { IsolationLevel } from \"../types/IsolationLevel\"\nimport { TableExclusion } from \"../../schema-builder/table/TableExclusion\"\nimport { TransactionAlreadyStartedError, TypeORMError } from \"../../error\"\nimport { MetadataTableType } from \"../types/MetadataTableType\"\nimport { InstanceChecker } from \"../../util/InstanceChecker\"\n\n/**\n * Runs queries on a single sqlite database connection.\n */\nexport abstract class AbstractSqliteQueryRunner\n    extends BaseQueryRunner\n    implements QueryRunner\n{\n    // -------------------------------------------------------------------------\n    // Public Implemented Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Database driver used by connection.\n     */\n    driver: AbstractSqliteDriver\n\n    protected transactionPromise: Promise<any> | null = null\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor() {\n        super()\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates/uses database connection from the connection pool to perform further operations.\n     * Returns obtained database connection.\n     */\n    connect(): Promise<any> {\n        return Promise.resolve(this.driver.databaseConnection)\n    }\n\n    /**\n     * Releases used database connection.\n     * We just clear loaded tables and sql in memory, because sqlite do not support multiple connections thus query runners.\n     */\n    release(): Promise<void> {\n        this.loadedTables = []\n        this.clearSqlMemory()\n        return Promise.resolve()\n    }\n\n    /**\n     * Starts transaction.\n     */\n    async startTransaction(isolationLevel?: IsolationLevel): Promise<void> {\n        if (this.driver.transactionSupport === \"none\")\n            throw new TypeORMError(\n                `Transactions aren't supported by ${this.connection.driver.options.type}.`,\n            )\n\n        if (\n            this.isTransactionActive &&\n            this.driver.transactionSupport === \"simple\"\n        )\n            throw new TransactionAlreadyStartedError()\n\n        if (\n            isolationLevel &&\n            isolationLevel !== \"READ UNCOMMITTED\" &&\n            isolationLevel !== \"SERIALIZABLE\"\n        )\n            throw new TypeORMError(\n                `SQLite only supports SERIALIZABLE and READ UNCOMMITTED isolation`,\n            )\n\n        this.isTransactionActive = true\n        try {\n            await this.broadcaster.broadcast(\"BeforeTransactionStart\")\n        } catch (err) {\n            this.isTransactionActive = false\n            throw err\n        }\n\n        if (this.transactionDepth === 0) {\n            if (isolationLevel) {\n                if (isolationLevel === \"READ UNCOMMITTED\") {\n                    await this.query(\"PRAGMA read_uncommitted = true\")\n                } else {\n                    await this.query(\"PRAGMA read_uncommitted = false\")\n                }\n            }\n            await this.query(\"BEGIN TRANSACTION\")\n        } else {\n            await this.query(`SAVEPOINT typeorm_${this.transactionDepth}`)\n        }\n        this.transactionDepth += 1\n\n        await this.broadcaster.broadcast(\"AfterTransactionStart\")\n    }\n\n    /**\n     * Commits transaction.\n     * Error will be thrown if transaction was not started.\n     */\n    async commitTransaction(): Promise<void> {\n        if (!this.isTransactionActive) throw new TransactionNotStartedError()\n\n        await this.broadcaster.broadcast(\"BeforeTransactionCommit\")\n\n        if (this.transactionDepth > 1) {\n            await this.query(\n                `RELEASE SAVEPOINT typeorm_${this.transactionDepth - 1}`,\n            )\n        } else {\n            await this.query(\"COMMIT\")\n            this.isTransactionActive = false\n        }\n        this.transactionDepth -= 1\n\n        await this.broadcaster.broadcast(\"AfterTransactionCommit\")\n    }\n\n    /**\n     * Rollbacks transaction.\n     * Error will be thrown if transaction was not started.\n     */\n    async rollbackTransaction(): Promise<void> {\n        if (!this.isTransactionActive) throw new TransactionNotStartedError()\n\n        await this.broadcaster.broadcast(\"BeforeTransactionRollback\")\n\n        if (this.transactionDepth > 1) {\n            await this.query(\n                `ROLLBACK TO SAVEPOINT typeorm_${this.transactionDepth - 1}`,\n            )\n        } else {\n            await this.query(\"ROLLBACK\")\n            this.isTransactionActive = false\n        }\n        this.transactionDepth -= 1\n\n        await this.broadcaster.broadcast(\"AfterTransactionRollback\")\n    }\n\n    /**\n     * Returns raw data stream.\n     */\n    stream(\n        query: string,\n        parameters?: any[],\n        onEnd?: Function,\n        onError?: Function,\n    ): Promise<ReadStream> {\n        throw new TypeORMError(`Stream is not supported by sqlite driver.`)\n    }\n\n    /**\n     * Returns all available database names including system databases.\n     */\n    async getDatabases(): Promise<string[]> {\n        return Promise.resolve([])\n    }\n\n    /**\n     * Returns all available schema names including system schemas.\n     * If database parameter specified, returns schemas of that database.\n     */\n    async getSchemas(database?: string): Promise<string[]> {\n        return Promise.resolve([])\n    }\n\n    /**\n     * Checks if database with the given name exist.\n     */\n    async hasDatabase(database: string): Promise<boolean> {\n        return Promise.resolve(false)\n    }\n\n    /**\n     * Loads currently using database\n     */\n    async getCurrentDatabase(): Promise<undefined> {\n        return Promise.resolve(undefined)\n    }\n\n    /**\n     * Checks if schema with the given name exist.\n     */\n    async hasSchema(schema: string): Promise<boolean> {\n        throw new TypeORMError(`This driver does not support table schemas`)\n    }\n\n    /**\n     * Loads currently using database schema\n     */\n    async getCurrentSchema(): Promise<undefined> {\n        return Promise.resolve(undefined)\n    }\n\n    /**\n     * Checks if table with the given name exist in the database.\n     */\n    async hasTable(tableOrName: Table | string): Promise<boolean> {\n        const tableName = InstanceChecker.isTable(tableOrName)\n            ? tableOrName.name\n            : tableOrName\n        const sql = `SELECT * FROM \"sqlite_master\" WHERE \"type\" = 'table' AND \"name\" = '${tableName}'`\n        const result = await this.query(sql)\n        return result.length ? true : false\n    }\n\n    /**\n     * Checks if column with the given name exist in the given table.\n     */\n    async hasColumn(\n        tableOrName: Table | string,\n        columnName: string,\n    ): Promise<boolean> {\n        const tableName = InstanceChecker.isTable(tableOrName)\n            ? tableOrName.name\n            : tableOrName\n        const sql = `PRAGMA table_xinfo(${this.escapePath(tableName)})`\n        const columns: ObjectLiteral[] = await this.query(sql)\n        return !!columns.find((column) => column[\"name\"] === columnName)\n    }\n\n    /**\n     * Creates a new database.\n     */\n    async createDatabase(\n        database: string,\n        ifNotExist?: boolean,\n    ): Promise<void> {\n        return Promise.resolve()\n    }\n\n    /**\n     * Drops database.\n     */\n    async dropDatabase(database: string, ifExist?: boolean): Promise<void> {\n        return Promise.resolve()\n    }\n\n    /**\n     * Creates a new table schema.\n     */\n    async createSchema(\n        schemaPath: string,\n        ifNotExist?: boolean,\n    ): Promise<void> {\n        return Promise.resolve()\n    }\n\n    /**\n     * Drops table schema.\n     */\n    async dropSchema(schemaPath: string, ifExist?: boolean): Promise<void> {\n        return Promise.resolve()\n    }\n\n    /**\n     * Creates a new table.\n     */\n    async createTable(\n        table: Table,\n        ifNotExist: boolean = false,\n        createForeignKeys: boolean = true,\n        createIndices: boolean = true,\n    ): Promise<void> {\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        if (ifNotExist) {\n            const isTableExist = await this.hasTable(table)\n            if (isTableExist) return Promise.resolve()\n        }\n\n        upQueries.push(this.createTableSql(table, createForeignKeys))\n        downQueries.push(this.dropTableSql(table))\n\n        if (createIndices) {\n            table.indices.forEach((index) => {\n                // new index may be passed without name. In this case we generate index name manually.\n                if (!index.name)\n                    index.name = this.connection.namingStrategy.indexName(\n                        table,\n                        index.columnNames,\n                        index.where,\n                    )\n                upQueries.push(this.createIndexSql(table, index))\n                downQueries.push(this.dropIndexSql(index))\n            })\n        }\n\n        // if table have column with generated type, we must add the expression to the metadata table\n        const generatedColumns = table.columns.filter(\n            (column) => column.generatedType && column.asExpression,\n        )\n\n        for (const column of generatedColumns) {\n            const insertQuery = this.insertTypeormMetadataSql({\n                table: table.name,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n                value: column.asExpression,\n            })\n\n            const deleteQuery = this.deleteTypeormMetadataSql({\n                table: table.name,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n            })\n\n            upQueries.push(insertQuery)\n            downQueries.push(deleteQuery)\n        }\n\n        await this.executeQueries(upQueries, downQueries)\n    }\n\n    /**\n     * Drops the table.\n     */\n    async dropTable(\n        tableOrName: Table | string,\n        ifExist?: boolean,\n        dropForeignKeys: boolean = true,\n        dropIndices: boolean = true,\n    ): Promise<void> {\n        if (ifExist) {\n            const isTableExist = await this.hasTable(tableOrName)\n            if (!isTableExist) return Promise.resolve()\n        }\n\n        // if dropTable called with dropForeignKeys = true, we must create foreign keys in down query.\n        const createForeignKeys: boolean = dropForeignKeys\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        if (dropIndices) {\n            table.indices.forEach((index) => {\n                upQueries.push(this.dropIndexSql(index))\n                downQueries.push(this.createIndexSql(table, index))\n            })\n        }\n\n        upQueries.push(this.dropTableSql(table, ifExist))\n        downQueries.push(this.createTableSql(table, createForeignKeys))\n\n        // if table had columns with generated type, we must remove the expression from the metadata table\n        const generatedColumns = table.columns.filter(\n            (column) => column.generatedType && column.asExpression,\n        )\n\n        for (const column of generatedColumns) {\n            const deleteQuery = this.deleteTypeormMetadataSql({\n                table: table.name,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n            })\n\n            const insertQuery = this.insertTypeormMetadataSql({\n                table: table.name,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n                value: column.asExpression,\n            })\n\n            upQueries.push(deleteQuery)\n            downQueries.push(insertQuery)\n        }\n\n        await this.executeQueries(upQueries, downQueries)\n    }\n\n    /**\n     * Creates a new view.\n     */\n    async createView(view: View): Promise<void> {\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n        upQueries.push(this.createViewSql(view))\n        upQueries.push(this.insertViewDefinitionSql(view))\n        downQueries.push(this.dropViewSql(view))\n        downQueries.push(this.deleteViewDefinitionSql(view))\n        await this.executeQueries(upQueries, downQueries)\n    }\n\n    /**\n     * Drops the view.\n     */\n    async dropView(target: View | string): Promise<void> {\n        const viewName = InstanceChecker.isView(target) ? target.name : target\n        const view = await this.getCachedView(viewName)\n\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n        upQueries.push(this.deleteViewDefinitionSql(view))\n        upQueries.push(this.dropViewSql(view))\n        downQueries.push(this.insertViewDefinitionSql(view))\n        downQueries.push(this.createViewSql(view))\n        await this.executeQueries(upQueries, downQueries)\n    }\n\n    /**\n     * Renames the given table.\n     */\n    async renameTable(\n        oldTableOrName: Table | string,\n        newTableName: string,\n    ): Promise<void> {\n        const oldTable = InstanceChecker.isTable(oldTableOrName)\n            ? oldTableOrName\n            : await this.getCachedTable(oldTableOrName)\n        const newTable = oldTable.clone()\n\n        newTable.name = newTableName\n\n        // rename table\n        const up = new Query(\n            `ALTER TABLE ${this.escapePath(\n                oldTable.name,\n            )} RENAME TO ${this.escapePath(newTableName)}`,\n        )\n        const down = new Query(\n            `ALTER TABLE ${this.escapePath(\n                newTableName,\n            )} RENAME TO ${this.escapePath(oldTable.name)}`,\n        )\n        await this.executeQueries(up, down)\n\n        // rename unique constraints\n        newTable.uniques.forEach((unique) => {\n            const oldUniqueName =\n                this.connection.namingStrategy.uniqueConstraintName(\n                    oldTable,\n                    unique.columnNames,\n                )\n\n            // Skip renaming if Unique has user defined constraint name\n            if (unique.name !== oldUniqueName) return\n\n            unique.name = this.connection.namingStrategy.uniqueConstraintName(\n                newTable,\n                unique.columnNames,\n            )\n        })\n\n        // rename foreign key constraints\n        newTable.foreignKeys.forEach((foreignKey) => {\n            const oldForeignKeyName =\n                this.connection.namingStrategy.foreignKeyName(\n                    oldTable,\n                    foreignKey.columnNames,\n                    this.getTablePath(foreignKey),\n                    foreignKey.referencedColumnNames,\n                )\n\n            // Skip renaming if foreign key has user defined constraint name\n            if (foreignKey.name !== oldForeignKeyName) return\n\n            foreignKey.name = this.connection.namingStrategy.foreignKeyName(\n                newTable,\n                foreignKey.columnNames,\n                this.getTablePath(foreignKey),\n                foreignKey.referencedColumnNames,\n            )\n        })\n\n        // rename indices\n        newTable.indices.forEach((index) => {\n            const oldIndexName = this.connection.namingStrategy.indexName(\n                oldTable,\n                index.columnNames,\n                index.where,\n            )\n\n            // Skip renaming if Index has user defined constraint name\n            if (index.name !== oldIndexName) return\n\n            index.name = this.connection.namingStrategy.indexName(\n                newTable,\n                index.columnNames,\n                index.where,\n            )\n        })\n\n        // rename old table;\n        oldTable.name = newTable.name\n\n        // recreate table with new constraint names\n        await this.recreateTable(newTable, oldTable)\n    }\n\n    /**\n     * Creates a new column from the column in the table.\n     */\n    async addColumn(\n        tableOrName: Table | string,\n        column: TableColumn,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        return this.addColumns(table!, [column])\n    }\n\n    /**\n     * Creates a new columns from the column in the table.\n     */\n    async addColumns(\n        tableOrName: Table | string,\n        columns: TableColumn[],\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const changedTable = table.clone()\n        columns.forEach((column) => changedTable.addColumn(column))\n        await this.recreateTable(changedTable, table)\n    }\n\n    /**\n     * Renames column in the given table.\n     */\n    async renameColumn(\n        tableOrName: Table | string,\n        oldTableColumnOrName: TableColumn | string,\n        newTableColumnOrName: TableColumn | string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const oldColumn = InstanceChecker.isTableColumn(oldTableColumnOrName)\n            ? oldTableColumnOrName\n            : table.columns.find((c) => c.name === oldTableColumnOrName)\n        if (!oldColumn)\n            throw new TypeORMError(\n                `Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`,\n            )\n\n        let newColumn: TableColumn | undefined = undefined\n        if (InstanceChecker.isTableColumn(newTableColumnOrName)) {\n            newColumn = newTableColumnOrName\n        } else {\n            newColumn = oldColumn.clone()\n            newColumn.name = newTableColumnOrName\n        }\n\n        return this.changeColumn(table, oldColumn, newColumn)\n    }\n\n    /**\n     * Changes a column in the table.\n     */\n    async changeColumn(\n        tableOrName: Table | string,\n        oldTableColumnOrName: TableColumn | string,\n        newColumn: TableColumn,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const oldColumn = InstanceChecker.isTableColumn(oldTableColumnOrName)\n            ? oldTableColumnOrName\n            : table.columns.find((c) => c.name === oldTableColumnOrName)\n        if (!oldColumn)\n            throw new TypeORMError(\n                `Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`,\n            )\n\n        await this.changeColumns(table, [{ oldColumn, newColumn }])\n    }\n\n    /**\n     * Changes a column in the table.\n     * Changed column looses all its keys in the db.\n     */\n    async changeColumns(\n        tableOrName: Table | string,\n        changedColumns: { oldColumn: TableColumn; newColumn: TableColumn }[],\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const changedTable = table.clone()\n        changedColumns.forEach((changedColumnSet) => {\n            if (\n                changedColumnSet.newColumn.name !==\n                changedColumnSet.oldColumn.name\n            ) {\n                changedTable\n                    .findColumnUniques(changedColumnSet.oldColumn)\n                    .forEach((unique) => {\n                        const uniqueName =\n                            this.connection.namingStrategy.uniqueConstraintName(\n                                table,\n                                unique.columnNames,\n                            )\n\n                        unique.columnNames.splice(\n                            unique.columnNames.indexOf(\n                                changedColumnSet.oldColumn.name,\n                            ),\n                            1,\n                        )\n                        unique.columnNames.push(changedColumnSet.newColumn.name)\n\n                        // rename Unique only if it has default constraint name\n                        if (unique.name === uniqueName) {\n                            unique.name =\n                                this.connection.namingStrategy.uniqueConstraintName(\n                                    changedTable,\n                                    unique.columnNames,\n                                )\n                        }\n                    })\n\n                changedTable\n                    .findColumnForeignKeys(changedColumnSet.oldColumn)\n                    .forEach((foreignKey) => {\n                        const foreignKeyName =\n                            this.connection.namingStrategy.foreignKeyName(\n                                table,\n                                foreignKey.columnNames,\n                                this.getTablePath(foreignKey),\n                                foreignKey.referencedColumnNames,\n                            )\n\n                        foreignKey.columnNames.splice(\n                            foreignKey.columnNames.indexOf(\n                                changedColumnSet.oldColumn.name,\n                            ),\n                            1,\n                        )\n                        foreignKey.columnNames.push(\n                            changedColumnSet.newColumn.name,\n                        )\n\n                        // rename FK only if it has default constraint name\n                        if (foreignKey.name === foreignKeyName) {\n                            foreignKey.name =\n                                this.connection.namingStrategy.foreignKeyName(\n                                    changedTable,\n                                    foreignKey.columnNames,\n                                    this.getTablePath(foreignKey),\n                                    foreignKey.referencedColumnNames,\n                                )\n                        }\n                    })\n\n                changedTable\n                    .findColumnIndices(changedColumnSet.oldColumn)\n                    .forEach((index) => {\n                        const indexName =\n                            this.connection.namingStrategy.indexName(\n                                table,\n                                index.columnNames,\n                                index.where,\n                            )\n\n                        index.columnNames.splice(\n                            index.columnNames.indexOf(\n                                changedColumnSet.oldColumn.name,\n                            ),\n                            1,\n                        )\n                        index.columnNames.push(changedColumnSet.newColumn.name)\n\n                        // rename Index only if it has default constraint name\n                        if (index.name === indexName) {\n                            index.name =\n                                this.connection.namingStrategy.indexName(\n                                    changedTable,\n                                    index.columnNames,\n                                    index.where,\n                                )\n                        }\n                    })\n            }\n            const originalColumn = changedTable.columns.find(\n                (column) => column.name === changedColumnSet.oldColumn.name,\n            )\n            if (originalColumn)\n                changedTable.columns[\n                    changedTable.columns.indexOf(originalColumn)\n                ] = changedColumnSet.newColumn\n        })\n\n        await this.recreateTable(changedTable, table)\n    }\n\n    /**\n     * Drops column in the table.\n     */\n    async dropColumn(\n        tableOrName: Table | string,\n        columnOrName: TableColumn | string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const column = InstanceChecker.isTableColumn(columnOrName)\n            ? columnOrName\n            : table.findColumnByName(columnOrName)\n        if (!column)\n            throw new TypeORMError(\n                `Column \"${columnOrName}\" was not found in table \"${table.name}\"`,\n            )\n\n        await this.dropColumns(table, [column])\n    }\n\n    /**\n     * Drops the columns in the table.\n     */\n    async dropColumns(\n        tableOrName: Table | string,\n        columns: TableColumn[] | string[],\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n\n        // clone original table and remove column and its constraints from cloned table\n        const changedTable = table.clone()\n        columns.forEach((column: TableColumn | string) => {\n            const columnInstance = InstanceChecker.isTableColumn(column)\n                ? column\n                : table.findColumnByName(column)\n            if (!columnInstance)\n                throw new Error(\n                    `Column \"${column}\" was not found in table \"${table.name}\"`,\n                )\n\n            changedTable.removeColumn(columnInstance)\n            changedTable\n                .findColumnUniques(columnInstance)\n                .forEach((unique) =>\n                    changedTable.removeUniqueConstraint(unique),\n                )\n            changedTable\n                .findColumnIndices(columnInstance)\n                .forEach((index) => changedTable.removeIndex(index))\n            changedTable\n                .findColumnForeignKeys(columnInstance)\n                .forEach((fk) => changedTable.removeForeignKey(fk))\n        })\n\n        await this.recreateTable(changedTable, table)\n    }\n\n    /**\n     * Creates a new primary key.\n     */\n    async createPrimaryKey(\n        tableOrName: Table | string,\n        columnNames: string[],\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        // clone original table and mark columns as primary\n        const changedTable = table.clone()\n        changedTable.columns.forEach((column) => {\n            if (columnNames.find((columnName) => columnName === column.name))\n                column.isPrimary = true\n        })\n\n        await this.recreateTable(changedTable, table)\n        // mark columns as primary in original table\n        table.columns.forEach((column) => {\n            if (columnNames.find((columnName) => columnName === column.name))\n                column.isPrimary = true\n        })\n    }\n\n    /**\n     * Updates composite primary keys.\n     */\n    async updatePrimaryKeys(\n        tableOrName: Table | string,\n        columns: TableColumn[],\n    ): Promise<void> {\n        await Promise.resolve()\n    }\n\n    /**\n     * Drops a primary key.\n     */\n    async dropPrimaryKey(tableOrName: Table | string): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        // clone original table and mark primary columns as non-primary\n        const changedTable = table.clone()\n        changedTable.primaryColumns.forEach((column) => {\n            column.isPrimary = false\n        })\n\n        await this.recreateTable(changedTable, table)\n        // mark primary columns as non-primary in original table\n        table.primaryColumns.forEach((column) => {\n            column.isPrimary = false\n        })\n    }\n\n    /**\n     * Creates a new unique constraint.\n     */\n    async createUniqueConstraint(\n        tableOrName: Table | string,\n        uniqueConstraint: TableUnique,\n    ): Promise<void> {\n        await this.createUniqueConstraints(tableOrName, [uniqueConstraint])\n    }\n\n    /**\n     * Creates a new unique constraints.\n     */\n    async createUniqueConstraints(\n        tableOrName: Table | string,\n        uniqueConstraints: TableUnique[],\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n\n        // clone original table and add unique constraints in to cloned table\n        const changedTable = table.clone()\n        uniqueConstraints.forEach((uniqueConstraint) =>\n            changedTable.addUniqueConstraint(uniqueConstraint),\n        )\n        await this.recreateTable(changedTable, table)\n    }\n\n    /**\n     * Drops an unique constraint.\n     */\n    async dropUniqueConstraint(\n        tableOrName: Table | string,\n        uniqueOrName: TableUnique | string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const uniqueConstraint = InstanceChecker.isTableUnique(uniqueOrName)\n            ? uniqueOrName\n            : table.uniques.find((u) => u.name === uniqueOrName)\n        if (!uniqueConstraint)\n            throw new TypeORMError(\n                `Supplied unique constraint was not found in table ${table.name}`,\n            )\n\n        await this.dropUniqueConstraints(table, [uniqueConstraint])\n    }\n\n    /**\n     * Creates an unique constraints.\n     */\n    async dropUniqueConstraints(\n        tableOrName: Table | string,\n        uniqueConstraints: TableUnique[],\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n\n        // clone original table and remove unique constraints from cloned table\n        const changedTable = table.clone()\n        uniqueConstraints.forEach((uniqueConstraint) =>\n            changedTable.removeUniqueConstraint(uniqueConstraint),\n        )\n\n        await this.recreateTable(changedTable, table)\n    }\n\n    /**\n     * Creates new check constraint.\n     */\n    async createCheckConstraint(\n        tableOrName: Table | string,\n        checkConstraint: TableCheck,\n    ): Promise<void> {\n        await this.createCheckConstraints(tableOrName, [checkConstraint])\n    }\n\n    /**\n     * Creates new check constraints.\n     */\n    async createCheckConstraints(\n        tableOrName: Table | string,\n        checkConstraints: TableCheck[],\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n\n        // clone original table and add check constraints in to cloned table\n        const changedTable = table.clone()\n        checkConstraints.forEach((checkConstraint) =>\n            changedTable.addCheckConstraint(checkConstraint),\n        )\n        await this.recreateTable(changedTable, table)\n    }\n\n    /**\n     * Drops check constraint.\n     */\n    async dropCheckConstraint(\n        tableOrName: Table | string,\n        checkOrName: TableCheck | string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const checkConstraint = InstanceChecker.isTableCheck(checkOrName)\n            ? checkOrName\n            : table.checks.find((c) => c.name === checkOrName)\n        if (!checkConstraint)\n            throw new TypeORMError(\n                `Supplied check constraint was not found in table ${table.name}`,\n            )\n\n        await this.dropCheckConstraints(table, [checkConstraint])\n    }\n\n    /**\n     * Drops check constraints.\n     */\n    async dropCheckConstraints(\n        tableOrName: Table | string,\n        checkConstraints: TableCheck[],\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n\n        // clone original table and remove check constraints from cloned table\n        const changedTable = table.clone()\n        checkConstraints.forEach((checkConstraint) =>\n            changedTable.removeCheckConstraint(checkConstraint),\n        )\n\n        await this.recreateTable(changedTable, table)\n    }\n\n    /**\n     * Creates a new exclusion constraint.\n     */\n    async createExclusionConstraint(\n        tableOrName: Table | string,\n        exclusionConstraint: TableExclusion,\n    ): Promise<void> {\n        throw new TypeORMError(`Sqlite does not support exclusion constraints.`)\n    }\n\n    /**\n     * Creates a new exclusion constraints.\n     */\n    async createExclusionConstraints(\n        tableOrName: Table | string,\n        exclusionConstraints: TableExclusion[],\n    ): Promise<void> {\n        throw new TypeORMError(`Sqlite does not support exclusion constraints.`)\n    }\n\n    /**\n     * Drops exclusion constraint.\n     */\n    async dropExclusionConstraint(\n        tableOrName: Table | string,\n        exclusionOrName: TableExclusion | string,\n    ): Promise<void> {\n        throw new TypeORMError(`Sqlite does not support exclusion constraints.`)\n    }\n\n    /**\n     * Drops exclusion constraints.\n     */\n    async dropExclusionConstraints(\n        tableOrName: Table | string,\n        exclusionConstraints: TableExclusion[],\n    ): Promise<void> {\n        throw new TypeORMError(`Sqlite does not support exclusion constraints.`)\n    }\n\n    /**\n     * Creates a new foreign key.\n     */\n    async createForeignKey(\n        tableOrName: Table | string,\n        foreignKey: TableForeignKey,\n    ): Promise<void> {\n        await this.createForeignKeys(tableOrName, [foreignKey])\n    }\n\n    /**\n     * Creates a new foreign keys.\n     */\n    async createForeignKeys(\n        tableOrName: Table | string,\n        foreignKeys: TableForeignKey[],\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        // clone original table and add foreign keys in to cloned table\n        const changedTable = table.clone()\n        foreignKeys.forEach((foreignKey) =>\n            changedTable.addForeignKey(foreignKey),\n        )\n\n        await this.recreateTable(changedTable, table)\n    }\n\n    /**\n     * Drops a foreign key from the table.\n     */\n    async dropForeignKey(\n        tableOrName: Table | string,\n        foreignKeyOrName: TableForeignKey | string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const foreignKey = InstanceChecker.isTableForeignKey(foreignKeyOrName)\n            ? foreignKeyOrName\n            : table.foreignKeys.find((fk) => fk.name === foreignKeyOrName)\n        if (!foreignKey)\n            throw new TypeORMError(\n                `Supplied foreign key was not found in table ${table.name}`,\n            )\n\n        await this.dropForeignKeys(tableOrName, [foreignKey])\n    }\n\n    /**\n     * Drops a foreign keys from the table.\n     */\n    async dropForeignKeys(\n        tableOrName: Table | string,\n        foreignKeys: TableForeignKey[],\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n\n        // clone original table and remove foreign keys from cloned table\n        const changedTable = table.clone()\n        foreignKeys.forEach((foreignKey) =>\n            changedTable.removeForeignKey(foreignKey),\n        )\n\n        await this.recreateTable(changedTable, table)\n    }\n\n    /**\n     * Creates a new index.\n     */\n    async createIndex(\n        tableOrName: Table | string,\n        index: TableIndex,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n\n        // new index may be passed without name. In this case we generate index name manually.\n        if (!index.name) index.name = this.generateIndexName(table, index)\n\n        const up = this.createIndexSql(table, index)\n        const down = this.dropIndexSql(index)\n        await this.executeQueries(up, down)\n        table.addIndex(index)\n    }\n\n    /**\n     * Creates a new indices\n     */\n    async createIndices(\n        tableOrName: Table | string,\n        indices: TableIndex[],\n    ): Promise<void> {\n        const promises = indices.map((index) =>\n            this.createIndex(tableOrName, index),\n        )\n        await Promise.all(promises)\n    }\n\n    /**\n     * Drops an index from the table.\n     */\n    async dropIndex(\n        tableOrName: Table | string,\n        indexOrName: TableIndex | string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const index = InstanceChecker.isTableIndex(indexOrName)\n            ? indexOrName\n            : table.indices.find((i) => i.name === indexOrName)\n        if (!index)\n            throw new TypeORMError(\n                `Supplied index ${indexOrName} was not found in table ${table.name}`,\n            )\n\n        // old index may be passed without name. In this case we generate index name manually.\n        if (!index.name) index.name = this.generateIndexName(table, index)\n\n        const up = this.dropIndexSql(index)\n        const down = this.createIndexSql(table, index)\n        await this.executeQueries(up, down)\n        table.removeIndex(index)\n    }\n\n    /**\n     * Drops an indices from the table.\n     */\n    async dropIndices(\n        tableOrName: Table | string,\n        indices: TableIndex[],\n    ): Promise<void> {\n        const promises = indices.map((index) =>\n            this.dropIndex(tableOrName, index),\n        )\n        await Promise.all(promises)\n    }\n\n    /**\n     * Clears all table contents.\n     * Note: this operation uses SQL's TRUNCATE query which cannot be reverted in transactions.\n     */\n    async clearTable(tableName: string): Promise<void> {\n        await this.query(`DELETE FROM ${this.escapePath(tableName)}`)\n    }\n\n    /**\n     * Removes all tables from the currently connected database.\n     */\n    async clearDatabase(database?: string): Promise<void> {\n        let dbPath: string | undefined = undefined\n        if (\n            database &&\n            this.driver.getAttachedDatabaseHandleByRelativePath(database)\n        ) {\n            dbPath =\n                this.driver.getAttachedDatabaseHandleByRelativePath(database)\n        }\n\n        await this.query(`PRAGMA foreign_keys = OFF`)\n\n        const isAnotherTransactionActive = this.isTransactionActive\n        if (!isAnotherTransactionActive) await this.startTransaction()\n        try {\n            const selectViewDropsQuery = dbPath\n                ? `SELECT 'DROP VIEW \"${dbPath}\".\"' || name || '\";' as query FROM \"${dbPath}\".\"sqlite_master\" WHERE \"type\" = 'view'`\n                : `SELECT 'DROP VIEW \"' || name || '\";' as query FROM \"sqlite_master\" WHERE \"type\" = 'view'`\n            const dropViewQueries: ObjectLiteral[] = await this.query(\n                selectViewDropsQuery,\n            )\n            await Promise.all(\n                dropViewQueries.map((q) => this.query(q[\"query\"])),\n            )\n\n            const selectTableDropsQuery = dbPath\n                ? `SELECT 'DROP TABLE \"${dbPath}\".\"' || name || '\";' as query FROM \"${dbPath}\".\"sqlite_master\" WHERE \"type\" = 'table' AND \"name\" != 'sqlite_sequence'`\n                : `SELECT 'DROP TABLE \"' || name || '\";' as query FROM \"sqlite_master\" WHERE \"type\" = 'table' AND \"name\" != 'sqlite_sequence'`\n            const dropTableQueries: ObjectLiteral[] = await this.query(\n                selectTableDropsQuery,\n            )\n            await Promise.all(\n                dropTableQueries.map((q) => this.query(q[\"query\"])),\n            )\n\n            if (!isAnotherTransactionActive) await this.commitTransaction()\n        } catch (error) {\n            try {\n                // we throw original error even if rollback thrown an error\n                if (!isAnotherTransactionActive)\n                    await this.rollbackTransaction()\n            } catch (rollbackError) {}\n            throw error\n        } finally {\n            await this.query(`PRAGMA foreign_keys = ON`)\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    protected async loadViews(viewNames?: string[]): Promise<View[]> {\n        const hasTable = await this.hasTable(this.getTypeormMetadataTableName())\n        if (!hasTable) {\n            return []\n        }\n\n        if (!viewNames) {\n            viewNames = []\n        }\n\n        const viewNamesString = viewNames\n            .map((name) => \"'\" + name + \"'\")\n            .join(\", \")\n        let query = `SELECT \"t\".* FROM \"${this.getTypeormMetadataTableName()}\" \"t\" INNER JOIN \"sqlite_master\" s ON \"s\".\"name\" = \"t\".\"name\" AND \"s\".\"type\" = 'view' WHERE \"t\".\"type\" = '${\n            MetadataTableType.VIEW\n        }'`\n        if (viewNamesString.length > 0)\n            query += ` AND \"t\".\"name\" IN (${viewNamesString})`\n        const dbViews = await this.query(query)\n        return dbViews.map((dbView: any) => {\n            const view = new View()\n            view.name = dbView[\"name\"]\n            view.expression = dbView[\"value\"]\n            return view\n        })\n    }\n\n    protected async loadTableRecords(\n        tablePath: string,\n        tableOrIndex: \"table\" | \"index\",\n    ) {\n        let database: string | undefined = undefined\n        const [schema, tableName] = this.splitTablePath(tablePath)\n        if (\n            schema &&\n            this.driver.getAttachedDatabasePathRelativeByHandle(schema)\n        ) {\n            database =\n                this.driver.getAttachedDatabasePathRelativeByHandle(schema)\n        }\n        const res = await this.query(\n            `SELECT ${database ? `'${database}'` : null} as database, ${\n                schema ? `'${schema}'` : null\n            } as schema, * FROM ${\n                schema ? `\"${schema}\".` : \"\"\n            }${this.escapePath(\n                `sqlite_master`,\n            )} WHERE \"type\" = '${tableOrIndex}' AND \"${\n                tableOrIndex === \"table\" ? \"name\" : \"tbl_name\"\n            }\" IN ('${tableName}')`,\n        )\n        return res\n    }\n    protected async loadPragmaRecords(tablePath: string, pragma: string) {\n        const [, tableName] = this.splitTablePath(tablePath)\n        const res = await this.query(`PRAGMA ${pragma}(\"${tableName}\")`)\n        return res\n    }\n\n    /**\n     * Loads all tables (with given names) from the database and creates a Table from them.\n     */\n    protected async loadTables(tableNames?: string[]): Promise<Table[]> {\n        // if no tables given then no need to proceed\n        if (tableNames && tableNames.length === 0) {\n            return []\n        }\n\n        let dbTables: { database?: string; name: string; sql: string }[] = []\n        let dbIndicesDef: ObjectLiteral[]\n\n        if (!tableNames) {\n            const tablesSql = `SELECT * FROM \"sqlite_master\" WHERE \"type\" = 'table'`\n            dbTables.push(...(await this.query(tablesSql)))\n\n            const tableNamesString = dbTables\n                .map(({ name }) => `'${name}'`)\n                .join(\", \")\n            dbIndicesDef = await this.query(\n                `SELECT * FROM \"sqlite_master\" WHERE \"type\" = 'index' AND \"tbl_name\" IN (${tableNamesString})`,\n            )\n        } else {\n            dbTables = (\n                await Promise.all(\n                    tableNames.map((tableName) =>\n                        this.loadTableRecords(tableName, \"table\"),\n                    ),\n                )\n            )\n                .reduce((acc, res) => [...acc, ...res], [])\n                .filter(Boolean)\n            dbIndicesDef = (\n                await Promise.all(\n                    (tableNames ?? []).map((tableName) =>\n                        this.loadTableRecords(tableName, \"index\"),\n                    ),\n                )\n            )\n                .reduce((acc, res) => [...acc, ...res], [])\n                .filter(Boolean)\n        }\n\n        // if tables were not found in the db, no need to proceed\n        if (dbTables.length === 0) {\n            return []\n        }\n\n        // create table schemas for loaded tables\n        return Promise.all(\n            dbTables.map(async (dbTable) => {\n                const tablePath =\n                    dbTable[\"database\"] &&\n                    this.driver.getAttachedDatabaseHandleByRelativePath(\n                        dbTable[\"database\"],\n                    )\n                        ? `${this.driver.getAttachedDatabaseHandleByRelativePath(\n                              dbTable[\"database\"],\n                          )}.${dbTable[\"name\"]}`\n                        : dbTable[\"name\"]\n\n                const sql = dbTable[\"sql\"]\n\n                const withoutRowid = sql.includes(\"WITHOUT ROWID\")\n                const table = new Table({ name: tablePath, withoutRowid })\n\n                // load columns and indices\n                const [dbColumns, dbIndices, dbForeignKeys]: ObjectLiteral[][] =\n                    await Promise.all([\n                        this.loadPragmaRecords(tablePath, `table_xinfo`),\n                        this.loadPragmaRecords(tablePath, `index_list`),\n                        this.loadPragmaRecords(tablePath, `foreign_key_list`),\n                    ])\n\n                // find column name with auto increment\n                let autoIncrementColumnName: string | undefined = undefined\n                const tableSql: string = dbTable[\"sql\"]\n                let autoIncrementIndex = tableSql\n                    .toUpperCase()\n                    .indexOf(\"AUTOINCREMENT\")\n                if (autoIncrementIndex !== -1) {\n                    autoIncrementColumnName = tableSql.substr(\n                        0,\n                        autoIncrementIndex,\n                    )\n                    const comma = autoIncrementColumnName.lastIndexOf(\",\")\n                    const bracket = autoIncrementColumnName.lastIndexOf(\"(\")\n                    if (comma !== -1) {\n                        autoIncrementColumnName =\n                            autoIncrementColumnName.substr(comma)\n                        autoIncrementColumnName =\n                            autoIncrementColumnName.substr(\n                                0,\n                                autoIncrementColumnName.lastIndexOf('\"'),\n                            )\n                        autoIncrementColumnName =\n                            autoIncrementColumnName.substr(\n                                autoIncrementColumnName.indexOf('\"') + 1,\n                            )\n                    } else if (bracket !== -1) {\n                        autoIncrementColumnName =\n                            autoIncrementColumnName.substr(bracket)\n                        autoIncrementColumnName =\n                            autoIncrementColumnName.substr(\n                                0,\n                                autoIncrementColumnName.lastIndexOf('\"'),\n                            )\n                        autoIncrementColumnName =\n                            autoIncrementColumnName.substr(\n                                autoIncrementColumnName.indexOf('\"') + 1,\n                            )\n                    }\n                }\n\n                // create columns from the loaded columns\n                table.columns = await Promise.all(\n                    dbColumns.map(async (dbColumn) => {\n                        const tableColumn = new TableColumn()\n                        tableColumn.name = dbColumn[\"name\"]\n                        tableColumn.type = dbColumn[\"type\"].toLowerCase()\n                        tableColumn.default =\n                            dbColumn[\"dflt_value\"] !== null &&\n                            dbColumn[\"dflt_value\"] !== undefined\n                                ? dbColumn[\"dflt_value\"]\n                                : undefined\n                        tableColumn.isNullable = dbColumn[\"notnull\"] === 0\n                        // primary keys are numbered starting with 1, columns that aren't primary keys are marked with 0\n                        tableColumn.isPrimary = dbColumn[\"pk\"] > 0\n                        tableColumn.comment = \"\" // SQLite does not support column comments\n                        tableColumn.isGenerated =\n                            autoIncrementColumnName === dbColumn[\"name\"]\n                        if (tableColumn.isGenerated) {\n                            tableColumn.generationStrategy = \"increment\"\n                        }\n\n                        if (\n                            dbColumn[\"hidden\"] === 2 ||\n                            dbColumn[\"hidden\"] === 3\n                        ) {\n                            tableColumn.generatedType =\n                                dbColumn[\"hidden\"] === 2 ? \"VIRTUAL\" : \"STORED\"\n\n                            const asExpressionQuery =\n                                await this.selectTypeormMetadataSql({\n                                    table: table.name,\n                                    type: MetadataTableType.GENERATED_COLUMN,\n                                    name: tableColumn.name,\n                                })\n\n                            const results = await this.query(\n                                asExpressionQuery.query,\n                                asExpressionQuery.parameters,\n                            )\n                            if (results[0] && results[0].value) {\n                                tableColumn.asExpression = results[0].value\n                            } else {\n                                tableColumn.asExpression = \"\"\n                            }\n                        }\n\n                        if (tableColumn.type === \"varchar\") {\n                            // Check if this is an enum\n                            const enumMatch = sql.match(\n                                new RegExp(\n                                    '\"(' +\n                                        tableColumn.name +\n                                        \")\\\" varchar CHECK\\\\s*\\\\(\\\\s*\\\"\\\\1\\\"\\\\s+IN\\\\s*\\\\(('[^']+'(?:\\\\s*,\\\\s*'[^']+')+)\\\\s*\\\\)\\\\s*\\\\)\",\n                                ),\n                            )\n                            if (enumMatch) {\n                                // This is an enum\n                                tableColumn.enum = enumMatch[2]\n                                    .substr(1, enumMatch[2].length - 2)\n                                    .split(\"','\")\n                            }\n                        }\n\n                        // parse datatype and attempt to retrieve length, precision and scale\n                        let pos = tableColumn.type.indexOf(\"(\")\n                        if (pos !== -1) {\n                            const fullType = tableColumn.type\n                            let dataType = fullType.substr(0, pos)\n                            if (\n                                !!this.driver.withLengthColumnTypes.find(\n                                    (col) => col === dataType,\n                                )\n                            ) {\n                                let len = parseInt(\n                                    fullType.substring(\n                                        pos + 1,\n                                        fullType.length - 1,\n                                    ),\n                                )\n                                if (len) {\n                                    tableColumn.length = len.toString()\n                                    tableColumn.type = dataType // remove the length part from the datatype\n                                }\n                            }\n                            if (\n                                !!this.driver.withPrecisionColumnTypes.find(\n                                    (col) => col === dataType,\n                                )\n                            ) {\n                                const re = new RegExp(\n                                    `^${dataType}\\\\((\\\\d+),?\\\\s?(\\\\d+)?\\\\)`,\n                                )\n                                const matches = fullType.match(re)\n                                if (matches && matches[1]) {\n                                    tableColumn.precision = +matches[1]\n                                }\n                                if (\n                                    !!this.driver.withScaleColumnTypes.find(\n                                        (col) => col === dataType,\n                                    )\n                                ) {\n                                    if (matches && matches[2]) {\n                                        tableColumn.scale = +matches[2]\n                                    }\n                                }\n                                tableColumn.type = dataType // remove the precision/scale part from the datatype\n                            }\n                        }\n\n                        return tableColumn\n                    }),\n                )\n\n                // find foreign key constraints from CREATE TABLE sql\n                let fkResult\n                const fkMappings: {\n                    name: string\n                    columns: string[]\n                    referencedTableName: string\n                }[] = []\n                const fkRegex =\n                    /CONSTRAINT \"([^\"]*)\" FOREIGN KEY ?\\((.*?)\\) REFERENCES \"([^\"]*)\"/g\n                while ((fkResult = fkRegex.exec(sql)) !== null) {\n                    fkMappings.push({\n                        name: fkResult[1],\n                        columns: fkResult[2]\n                            .substr(1, fkResult[2].length - 2)\n                            .split(`\", \"`),\n                        referencedTableName: fkResult[3],\n                    })\n                }\n\n                // build foreign keys\n                const tableForeignKeyConstraints = OrmUtils.uniq(\n                    dbForeignKeys,\n                    (dbForeignKey) => dbForeignKey[\"id\"],\n                )\n\n                table.foreignKeys = tableForeignKeyConstraints.map(\n                    (foreignKey) => {\n                        const ownForeignKeys = dbForeignKeys.filter(\n                            (dbForeignKey) =>\n                                dbForeignKey[\"id\"] === foreignKey[\"id\"] &&\n                                dbForeignKey[\"table\"] === foreignKey[\"table\"],\n                        )\n                        const columnNames = ownForeignKeys.map(\n                            (dbForeignKey) => dbForeignKey[\"from\"],\n                        )\n                        const referencedColumnNames = ownForeignKeys.map(\n                            (dbForeignKey) => dbForeignKey[\"to\"],\n                        )\n\n                        // find related foreign key mapping\n                        const fkMapping = fkMappings.find(\n                            (it) =>\n                                it.referencedTableName ===\n                                    foreignKey[\"table\"] &&\n                                it.columns.every(\n                                    (column) =>\n                                        columnNames.indexOf(column) !== -1,\n                                ),\n                        )\n\n                        return new TableForeignKey({\n                            name: fkMapping!.name,\n                            columnNames: columnNames,\n                            referencedTableName: foreignKey[\"table\"],\n                            referencedColumnNames: referencedColumnNames,\n                            onDelete: foreignKey[\"on_delete\"],\n                            onUpdate: foreignKey[\"on_update\"],\n                        })\n                    },\n                )\n\n                // find unique constraints from CREATE TABLE sql\n                let uniqueRegexResult\n                const uniqueMappings: { name: string; columns: string[] }[] = []\n                const uniqueRegex = /CONSTRAINT \"([^\"]*)\" UNIQUE ?\\((.*?)\\)/g\n                while ((uniqueRegexResult = uniqueRegex.exec(sql)) !== null) {\n                    uniqueMappings.push({\n                        name: uniqueRegexResult[1],\n                        columns: uniqueRegexResult[2]\n                            .substr(1, uniqueRegexResult[2].length - 2)\n                            .split(`\", \"`),\n                    })\n                }\n\n                // build unique constraints\n                const tableUniquePromises = dbIndices\n                    .filter((dbIndex) => dbIndex[\"origin\"] === \"u\")\n                    .map((dbIndex) => dbIndex[\"name\"])\n                    .filter(\n                        (value, index, self) => self.indexOf(value) === index,\n                    )\n                    .map(async (dbIndexName) => {\n                        const dbIndex = dbIndices.find(\n                            (dbIndex) => dbIndex[\"name\"] === dbIndexName,\n                        )\n                        const indexInfos: ObjectLiteral[] = await this.query(\n                            `PRAGMA index_info(\"${dbIndex![\"name\"]}\")`,\n                        )\n                        const indexColumns = indexInfos\n                            .sort(\n                                (indexInfo1, indexInfo2) =>\n                                    parseInt(indexInfo1[\"seqno\"]) -\n                                    parseInt(indexInfo2[\"seqno\"]),\n                            )\n                            .map((indexInfo) => indexInfo[\"name\"])\n                        if (indexColumns.length === 1) {\n                            const column = table.columns.find((column) => {\n                                return !!indexColumns.find(\n                                    (indexColumn) =>\n                                        indexColumn === column.name,\n                                )\n                            })\n                            if (column) column.isUnique = true\n                        }\n\n                        // find existent mapping by a column names\n                        const foundMapping = uniqueMappings.find((mapping) => {\n                            return mapping!.columns.every(\n                                (column) => indexColumns.indexOf(column) !== -1,\n                            )\n                        })\n\n                        return new TableUnique({\n                            name: foundMapping\n                                ? foundMapping.name\n                                : this.connection.namingStrategy.uniqueConstraintName(\n                                      table,\n                                      indexColumns,\n                                  ),\n                            columnNames: indexColumns,\n                        })\n                    })\n                table.uniques = (await Promise.all(\n                    tableUniquePromises,\n                )) as TableUnique[]\n\n                // build checks\n                let result\n                const regexp =\n                    /CONSTRAINT \"([^\"]*)\" CHECK ?(\\(.*?\\))([,]|[)]$)/g\n                while ((result = regexp.exec(sql)) !== null) {\n                    table.checks.push(\n                        new TableCheck({\n                            name: result[1],\n                            expression: result[2],\n                        }),\n                    )\n                }\n\n                // build indices\n                const indicesPromises = dbIndices\n                    .filter((dbIndex) => dbIndex[\"origin\"] === \"c\")\n                    .map((dbIndex) => dbIndex[\"name\"])\n                    .filter(\n                        (value, index, self) => self.indexOf(value) === index,\n                    ) // unqiue\n                    .map(async (dbIndexName) => {\n                        const indexDef = dbIndicesDef.find(\n                            (dbIndexDef) => dbIndexDef[\"name\"] === dbIndexName,\n                        )\n                        const condition = /WHERE (.*)/.exec(indexDef![\"sql\"])\n                        const dbIndex = dbIndices.find(\n                            (dbIndex) => dbIndex[\"name\"] === dbIndexName,\n                        )\n                        const indexInfos: ObjectLiteral[] = await this.query(\n                            `PRAGMA index_info(\"${dbIndex![\"name\"]}\")`,\n                        )\n                        const indexColumns = indexInfos\n                            .sort(\n                                (indexInfo1, indexInfo2) =>\n                                    parseInt(indexInfo1[\"seqno\"]) -\n                                    parseInt(indexInfo2[\"seqno\"]),\n                            )\n                            .map((indexInfo) => indexInfo[\"name\"])\n                        const dbIndexPath = `${\n                            dbTable[\"database\"] ? `${dbTable[\"database\"]}.` : \"\"\n                        }${dbIndex![\"name\"]}`\n\n                        const isUnique =\n                            dbIndex![\"unique\"] === \"1\" ||\n                            dbIndex![\"unique\"] === 1\n                        return new TableIndex(<TableIndexOptions>{\n                            table: table,\n                            name: dbIndexPath,\n                            columnNames: indexColumns,\n                            isUnique: isUnique,\n                            where: condition ? condition[1] : undefined,\n                        })\n                    })\n                const indices = await Promise.all(indicesPromises)\n                table.indices = indices.filter(\n                    (index) => !!index,\n                ) as TableIndex[]\n\n                return table\n            }),\n        )\n    }\n\n    /**\n     * Builds create table sql.\n     */\n    protected createTableSql(\n        table: Table,\n        createForeignKeys?: boolean,\n        temporaryTable?: boolean,\n    ): Query {\n        const primaryColumns = table.columns.filter(\n            (column) => column.isPrimary,\n        )\n        const hasAutoIncrement = primaryColumns.find(\n            (column) =>\n                column.isGenerated && column.generationStrategy === \"increment\",\n        )\n        const skipPrimary = primaryColumns.length > 1\n        if (skipPrimary && hasAutoIncrement)\n            throw new TypeORMError(\n                `Sqlite does not support AUTOINCREMENT on composite primary key`,\n            )\n\n        const columnDefinitions = table.columns\n            .map((column) => this.buildCreateColumnSql(column, skipPrimary))\n            .join(\", \")\n        const [database] = this.splitTablePath(table.name)\n        let sql = `CREATE TABLE ${this.escapePath(\n            table.name,\n        )} (${columnDefinitions}`\n\n        let [databaseNew, tableName] = this.splitTablePath(table.name)\n        const newTableName = temporaryTable\n            ? `${databaseNew ? `${databaseNew}.` : \"\"}${tableName.replace(\n                  /^temporary_/,\n                  \"\",\n              )}`\n            : table.name\n\n        // need for `addColumn()` method, because it recreates table.\n        table.columns\n            .filter((column) => column.isUnique)\n            .forEach((column) => {\n                const isUniqueExist = table.uniques.some(\n                    (unique) =>\n                        unique.columnNames.length === 1 &&\n                        unique.columnNames[0] === column.name,\n                )\n                if (!isUniqueExist)\n                    table.uniques.push(\n                        new TableUnique({\n                            name: this.connection.namingStrategy.uniqueConstraintName(\n                                table,\n                                [column.name],\n                            ),\n                            columnNames: [column.name],\n                        }),\n                    )\n            })\n\n        if (table.uniques.length > 0) {\n            const uniquesSql = table.uniques\n                .map((unique) => {\n                    const uniqueName = unique.name\n                        ? unique.name\n                        : this.connection.namingStrategy.uniqueConstraintName(\n                              newTableName,\n                              unique.columnNames,\n                          )\n                    const columnNames = unique.columnNames\n                        .map((columnName) => `\"${columnName}\"`)\n                        .join(\", \")\n                    return `CONSTRAINT \"${uniqueName}\" UNIQUE (${columnNames})`\n                })\n                .join(\", \")\n\n            sql += `, ${uniquesSql}`\n        }\n\n        if (table.checks.length > 0) {\n            const checksSql = table.checks\n                .map((check) => {\n                    const checkName = check.name\n                        ? check.name\n                        : this.connection.namingStrategy.checkConstraintName(\n                              newTableName,\n                              check.expression!,\n                          )\n                    return `CONSTRAINT \"${checkName}\" CHECK (${check.expression})`\n                })\n                .join(\", \")\n\n            sql += `, ${checksSql}`\n        }\n\n        if (table.foreignKeys.length > 0 && createForeignKeys) {\n            const foreignKeysSql = table.foreignKeys\n                .filter((fk) => {\n                    const [referencedDatabase] = this.splitTablePath(\n                        fk.referencedTableName,\n                    )\n                    if (referencedDatabase !== database) {\n                        return false\n                    }\n                    return true\n                })\n                .map((fk) => {\n                    const [, referencedTable] = this.splitTablePath(\n                        fk.referencedTableName,\n                    )\n                    const columnNames = fk.columnNames\n                        .map((columnName) => `\"${columnName}\"`)\n                        .join(\", \")\n                    if (!fk.name)\n                        fk.name = this.connection.namingStrategy.foreignKeyName(\n                            newTableName,\n                            fk.columnNames,\n                            this.getTablePath(fk),\n                            fk.referencedColumnNames,\n                        )\n                    const referencedColumnNames = fk.referencedColumnNames\n                        .map((columnName) => `\"${columnName}\"`)\n                        .join(\", \")\n\n                    let constraint = `CONSTRAINT \"${fk.name}\" FOREIGN KEY (${columnNames}) REFERENCES \"${referencedTable}\" (${referencedColumnNames})`\n                    if (fk.onDelete) constraint += ` ON DELETE ${fk.onDelete}`\n                    if (fk.onUpdate) constraint += ` ON UPDATE ${fk.onUpdate}`\n                    if (fk.deferrable)\n                        constraint += ` DEFERRABLE ${fk.deferrable}`\n\n                    return constraint\n                })\n                .join(\", \")\n\n            sql += `, ${foreignKeysSql}`\n        }\n\n        if (primaryColumns.length > 1) {\n            const columnNames = primaryColumns\n                .map((column) => `\"${column.name}\"`)\n                .join(\", \")\n            sql += `, PRIMARY KEY (${columnNames})`\n        }\n\n        sql += `)`\n\n        if (table.withoutRowid) {\n            sql += \" WITHOUT ROWID\"\n        }\n\n        return new Query(sql)\n    }\n\n    /**\n     * Builds drop table sql.\n     */\n    protected dropTableSql(\n        tableOrName: Table | string,\n        ifExist?: boolean,\n    ): Query {\n        const tableName = InstanceChecker.isTable(tableOrName)\n            ? tableOrName.name\n            : tableOrName\n        const query = ifExist\n            ? `DROP TABLE IF EXISTS ${this.escapePath(tableName)}`\n            : `DROP TABLE ${this.escapePath(tableName)}`\n        return new Query(query)\n    }\n\n    protected createViewSql(view: View): Query {\n        if (typeof view.expression === \"string\") {\n            return new Query(`CREATE VIEW \"${view.name}\" AS ${view.expression}`)\n        } else {\n            return new Query(\n                `CREATE VIEW \"${view.name}\" AS ${view\n                    .expression(this.connection)\n                    .getQuery()}`,\n            )\n        }\n    }\n\n    protected insertViewDefinitionSql(view: View): Query {\n        const expression =\n            typeof view.expression === \"string\"\n                ? view.expression.trim()\n                : view.expression(this.connection).getQuery()\n        return this.insertTypeormMetadataSql({\n            type: MetadataTableType.VIEW,\n            name: view.name,\n            value: expression,\n        })\n    }\n\n    /**\n     * Builds drop view sql.\n     */\n    protected dropViewSql(viewOrPath: View | string): Query {\n        const viewName = InstanceChecker.isView(viewOrPath)\n            ? viewOrPath.name\n            : viewOrPath\n        return new Query(`DROP VIEW \"${viewName}\"`)\n    }\n\n    /**\n     * Builds remove view sql.\n     */\n    protected deleteViewDefinitionSql(viewOrPath: View | string): Query {\n        const viewName = InstanceChecker.isView(viewOrPath)\n            ? viewOrPath.name\n            : viewOrPath\n        return this.deleteTypeormMetadataSql({\n            type: MetadataTableType.VIEW,\n            name: viewName,\n        })\n    }\n\n    /**\n     * Builds create index sql.\n     */\n    protected createIndexSql(table: Table, index: TableIndex): Query {\n        const columns = index.columnNames\n            .map((columnName) => `\"${columnName}\"`)\n            .join(\", \")\n        const [database, tableName] = this.splitTablePath(table.name)\n        return new Query(\n            `CREATE ${index.isUnique ? \"UNIQUE \" : \"\"}INDEX ${\n                database ? `\"${database}\".` : \"\"\n            }${this.escapePath(index.name!)} ON \"${tableName}\" (${columns}) ${\n                index.where ? \"WHERE \" + index.where : \"\"\n            }`,\n        )\n    }\n\n    /**\n     * Builds drop index sql.\n     */\n    protected dropIndexSql(indexOrName: TableIndex | string): Query {\n        let indexName = InstanceChecker.isTableIndex(indexOrName)\n            ? indexOrName.name\n            : indexOrName\n        return new Query(`DROP INDEX ${this.escapePath(indexName!)}`)\n    }\n\n    /**\n     * Builds a query for create column.\n     */\n    protected buildCreateColumnSql(\n        column: TableColumn,\n        skipPrimary?: boolean,\n    ): string {\n        let c = '\"' + column.name + '\"'\n        if (InstanceChecker.isColumnMetadata(column)) {\n            c += \" \" + this.driver.normalizeType(column)\n        } else {\n            c += \" \" + this.connection.driver.createFullType(column)\n        }\n\n        if (column.enum)\n            c +=\n                ' CHECK( \"' +\n                column.name +\n                '\" IN (' +\n                column.enum.map((val) => \"'\" + val + \"'\").join(\",\") +\n                \") )\"\n        if (column.isPrimary && !skipPrimary) c += \" PRIMARY KEY\"\n        if (\n            column.isGenerated === true &&\n            column.generationStrategy === \"increment\"\n        )\n            // don't use skipPrimary here since updates can update already exist primary without auto inc.\n            c += \" AUTOINCREMENT\"\n        if (column.collation) c += \" COLLATE \" + column.collation\n        if (column.isNullable !== true) c += \" NOT NULL\"\n\n        if (column.asExpression) {\n            c += ` AS (${column.asExpression}) ${\n                column.generatedType ? column.generatedType : \"VIRTUAL\"\n            }`\n        } else {\n            if (column.default !== undefined && column.default !== null)\n                c += \" DEFAULT (\" + column.default + \")\"\n        }\n\n        return c\n    }\n\n    protected async recreateTable(\n        newTable: Table,\n        oldTable: Table,\n        migrateData = true,\n    ): Promise<void> {\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        // drop old table indices\n        oldTable.indices.forEach((index) => {\n            upQueries.push(this.dropIndexSql(index))\n            downQueries.push(this.createIndexSql(oldTable, index))\n        })\n\n        // change table name into 'temporary_table'\n        let [databaseNew, tableNameNew] = this.splitTablePath(newTable.name)\n        let [, tableNameOld] = this.splitTablePath(oldTable.name)\n        newTable.name = tableNameNew = `${\n            databaseNew ? `${databaseNew}.` : \"\"\n        }temporary_${tableNameNew}`\n\n        // create new table\n        upQueries.push(this.createTableSql(newTable, true, true))\n        downQueries.push(this.dropTableSql(newTable))\n\n        // migrate all data from the old table into new table\n        if (migrateData) {\n            let newColumnNames = newTable.columns\n                .filter((column) => !column.generatedType)\n                .map((column) => `\"${column.name}\"`)\n\n            let oldColumnNames = oldTable.columns\n                .filter((column) => !column.generatedType)\n                .map((column) => `\"${column.name}\"`)\n\n            if (oldColumnNames.length < newColumnNames.length) {\n                newColumnNames = newTable.columns\n                    .filter((column) => {\n                        const oldColumn = oldTable.columns.find(\n                            (c) => c.name === column.name,\n                        )\n                        if (oldColumn && oldColumn.generatedType) return false\n                        return !column.generatedType && oldColumn\n                    })\n                    .map((column) => `\"${column.name}\"`)\n            } else if (oldColumnNames.length > newColumnNames.length) {\n                oldColumnNames = oldTable.columns\n                    .filter((column) => {\n                        return (\n                            !column.generatedType &&\n                            newTable.columns.find((c) => c.name === column.name)\n                        )\n                    })\n                    .map((column) => `\"${column.name}\"`)\n            }\n\n            upQueries.push(\n                new Query(\n                    `INSERT INTO ${this.escapePath(\n                        newTable.name,\n                    )}(${newColumnNames.join(\n                        \", \",\n                    )}) SELECT ${oldColumnNames.join(\n                        \", \",\n                    )} FROM ${this.escapePath(oldTable.name)}`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `INSERT INTO ${this.escapePath(\n                        oldTable.name,\n                    )}(${oldColumnNames.join(\n                        \", \",\n                    )}) SELECT ${newColumnNames.join(\n                        \", \",\n                    )} FROM ${this.escapePath(newTable.name)}`,\n                ),\n            )\n        }\n\n        // drop old table\n        upQueries.push(this.dropTableSql(oldTable))\n        downQueries.push(this.createTableSql(oldTable, true))\n\n        // rename old table\n        upQueries.push(\n            new Query(\n                `ALTER TABLE ${this.escapePath(\n                    newTable.name,\n                )} RENAME TO ${this.escapePath(tableNameOld)}`,\n            ),\n        )\n        downQueries.push(\n            new Query(\n                `ALTER TABLE ${this.escapePath(\n                    oldTable.name,\n                )} RENAME TO ${this.escapePath(tableNameNew)}`,\n            ),\n        )\n\n        newTable.name = oldTable.name\n\n        // recreate table indices\n        newTable.indices.forEach((index) => {\n            // new index may be passed without name. In this case we generate index name manually.\n            if (!index.name)\n                index.name = this.connection.namingStrategy.indexName(\n                    newTable,\n                    index.columnNames,\n                    index.where,\n                )\n            upQueries.push(this.createIndexSql(newTable, index))\n            downQueries.push(this.dropIndexSql(index))\n        })\n\n        // update generated columns in \"typeorm_metadata\" table\n        // Step 1: clear data for removed generated columns\n        oldTable.columns\n            .filter((column) => {\n                const newTableColumn = newTable.columns.find(\n                    (c) => c.name === column.name,\n                )\n                // we should delete record from \"typeorm_metadata\" if generated column was removed\n                // or it was changed to non-generated\n                return (\n                    column.generatedType &&\n                    column.asExpression &&\n                    (!newTableColumn ||\n                        (!newTableColumn.generatedType &&\n                            !newTableColumn.asExpression))\n                )\n            })\n            .forEach((column) => {\n                const deleteQuery = this.deleteTypeormMetadataSql({\n                    table: oldTable.name,\n                    type: MetadataTableType.GENERATED_COLUMN,\n                    name: column.name,\n                })\n\n                const insertQuery = this.insertTypeormMetadataSql({\n                    table: oldTable.name,\n                    type: MetadataTableType.GENERATED_COLUMN,\n                    name: column.name,\n                    value: column.asExpression,\n                })\n\n                upQueries.push(deleteQuery)\n                downQueries.push(insertQuery)\n            })\n\n        // Step 2: add data for new generated columns\n        newTable.columns\n            .filter(\n                (column) =>\n                    column.generatedType &&\n                    column.asExpression &&\n                    !oldTable.columns.some((c) => c.name === column.name),\n            )\n            .forEach((column) => {\n                const insertQuery = this.insertTypeormMetadataSql({\n                    table: newTable.name,\n                    type: MetadataTableType.GENERATED_COLUMN,\n                    name: column.name,\n                    value: column.asExpression,\n                })\n\n                const deleteQuery = this.deleteTypeormMetadataSql({\n                    table: newTable.name,\n                    type: MetadataTableType.GENERATED_COLUMN,\n                    name: column.name,\n                })\n\n                upQueries.push(insertQuery)\n                downQueries.push(deleteQuery)\n            })\n\n        // Step 3: update changed expressions\n        newTable.columns\n            .filter((column) => column.generatedType && column.asExpression)\n            .forEach((column) => {\n                const oldColumn = oldTable.columns.find(\n                    (c) =>\n                        c.name === column.name &&\n                        c.generatedType &&\n                        column.generatedType &&\n                        c.asExpression !== column.asExpression,\n                )\n\n                if (!oldColumn) return\n\n                // update expression\n                const deleteQuery = this.deleteTypeormMetadataSql({\n                    table: oldTable.name,\n                    type: MetadataTableType.GENERATED_COLUMN,\n                    name: oldColumn.name,\n                })\n\n                const insertQuery = this.insertTypeormMetadataSql({\n                    table: newTable.name,\n                    type: MetadataTableType.GENERATED_COLUMN,\n                    name: column.name,\n                    value: column.asExpression,\n                })\n\n                upQueries.push(deleteQuery)\n                upQueries.push(insertQuery)\n\n                // revert update\n                const revertInsertQuery = this.insertTypeormMetadataSql({\n                    table: newTable.name,\n                    type: MetadataTableType.GENERATED_COLUMN,\n                    name: oldColumn.name,\n                    value: oldColumn.asExpression,\n                })\n\n                const revertDeleteQuery = this.deleteTypeormMetadataSql({\n                    table: oldTable.name,\n                    type: MetadataTableType.GENERATED_COLUMN,\n                    name: column.name,\n                })\n\n                downQueries.push(revertInsertQuery)\n                downQueries.push(revertDeleteQuery)\n            })\n\n        await this.executeQueries(upQueries, downQueries)\n        this.replaceCachedTable(oldTable, newTable)\n    }\n\n    /**\n     * tablePath e.g. \"myDB.myTable\", \"myTable\"\n     */\n    protected splitTablePath(tablePath: string): [string | undefined, string] {\n        return (\n            tablePath.indexOf(\".\") !== -1\n                ? tablePath.split(\".\")\n                : [undefined, tablePath]\n        ) as [string | undefined, string]\n    }\n\n    /**\n     * Escapes given table or view path. Tolerates leading/trailing dots\n     */\n    protected escapePath(\n        target: Table | View | string,\n        disableEscape?: boolean,\n    ): string {\n        const tableName =\n            InstanceChecker.isTable(target) || InstanceChecker.isView(target)\n                ? target.name\n                : target\n        return tableName\n            .replace(/^\\.+|\\.+$/g, \"\")\n            .split(\".\")\n            .map((i) => (disableEscape ? i : `\"${i}\"`))\n            .join(\".\")\n    }\n}\n"]},"metadata":{},"sourceType":"module"}