{"ast":null,"code":"import { EntityMetadata } from \"../metadata/EntityMetadata\";\nimport { ColumnMetadata } from \"../metadata/ColumnMetadata\";\nimport { IndexMetadata } from \"../metadata/IndexMetadata\";\nimport { RelationMetadata } from \"../metadata/RelationMetadata\";\nimport { EmbeddedMetadata } from \"../metadata/EmbeddedMetadata\";\nimport { RelationIdMetadata } from \"../metadata/RelationIdMetadata\";\nimport { RelationCountMetadata } from \"../metadata/RelationCountMetadata\";\nimport { EventListenerTypes } from \"../metadata/types/EventListenerTypes\";\nimport { MetadataUtils } from \"./MetadataUtils\";\nimport { JunctionEntityMetadataBuilder } from \"./JunctionEntityMetadataBuilder\";\nimport { ClosureJunctionEntityMetadataBuilder } from \"./ClosureJunctionEntityMetadataBuilder\";\nimport { RelationJoinColumnBuilder } from \"./RelationJoinColumnBuilder\";\nimport { EntityListenerMetadata } from \"../metadata/EntityListenerMetadata\";\nimport { UniqueMetadata } from \"../metadata/UniqueMetadata\";\nimport { CheckMetadata } from \"../metadata/CheckMetadata\";\nimport { ExclusionMetadata } from \"../metadata/ExclusionMetadata\";\nimport { TypeORMError } from \"../error\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\n/**\n * Builds EntityMetadata objects and all its sub-metadatas.\n */\n\nexport class EntityMetadataBuilder {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection, metadataArgsStorage) {\n    this.connection = connection;\n    this.metadataArgsStorage = metadataArgsStorage;\n    this.junctionEntityMetadataBuilder = new JunctionEntityMetadataBuilder(connection);\n    this.closureJunctionEntityMetadataBuilder = new ClosureJunctionEntityMetadataBuilder(connection);\n    this.relationJoinColumnBuilder = new RelationJoinColumnBuilder(connection);\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Builds a complete entity metadatas for the given entity classes.\n   */\n\n\n  build(entityClasses) {\n    // if entity classes to filter entities by are given then do filtering, otherwise use all\n    const allTables = entityClasses ? this.metadataArgsStorage.filterTables(entityClasses) : this.metadataArgsStorage.tables; // filter out table metadata args for those we really create entity metadatas and tables in the db\n\n    const realTables = allTables.filter(table => table.type === \"regular\" || table.type === \"closure\" || table.type === \"entity-child\" || table.type === \"view\"); // create entity metadatas for a user defined entities (marked with @Entity decorator or loaded from entity schemas)\n\n    const entityMetadatas = realTables.map(tableArgs => this.createEntityMetadata(tableArgs)); // compute parent entity metadatas for table inheritance\n\n    entityMetadatas.forEach(entityMetadata => this.computeParentEntityMetadata(entityMetadatas, entityMetadata)); // after all metadatas created we set child entity metadatas for table inheritance\n\n    entityMetadatas.forEach(metadata => {\n      metadata.childEntityMetadatas = entityMetadatas.filter(childMetadata => {\n        return typeof metadata.target === \"function\" && typeof childMetadata.target === \"function\" && MetadataUtils.isInherited(childMetadata.target, metadata.target);\n      });\n    }); // build entity metadata (step0), first for non-single-table-inherited entity metadatas (dependant)\n\n    entityMetadatas.filter(entityMetadata => entityMetadata.tableType !== \"entity-child\").forEach(entityMetadata => entityMetadata.build()); // build entity metadata (step0), now for single-table-inherited entity metadatas (dependant)\n\n    entityMetadatas.filter(entityMetadata => entityMetadata.tableType === \"entity-child\").forEach(entityMetadata => entityMetadata.build()); // compute entity metadata columns, relations, etc. first for the regular, non-single-table-inherited entity metadatas\n\n    entityMetadatas.filter(entityMetadata => entityMetadata.tableType !== \"entity-child\").forEach(entityMetadata => this.computeEntityMetadataStep1(entityMetadatas, entityMetadata)); // then do it for single table inheritance children (since they are depend on their parents to be built)\n\n    entityMetadatas.filter(entityMetadata => entityMetadata.tableType === \"entity-child\").forEach(entityMetadata => this.computeEntityMetadataStep1(entityMetadatas, entityMetadata)); // calculate entity metadata computed properties and all its sub-metadatas\n\n    entityMetadatas.forEach(entityMetadata => this.computeEntityMetadataStep2(entityMetadata)); // calculate entity metadata's inverse properties\n\n    entityMetadatas.forEach(entityMetadata => this.computeInverseProperties(entityMetadata, entityMetadatas)); // go through all entity metadatas and create foreign keys / junction entity metadatas for their relations\n\n    entityMetadatas.filter(entityMetadata => entityMetadata.tableType !== \"entity-child\").forEach(entityMetadata => {\n      // create entity's relations join columns (for many-to-one and one-to-one owner)\n      entityMetadata.relations.filter(relation => relation.isOneToOne || relation.isManyToOne).forEach(relation => {\n        const joinColumns = this.metadataArgsStorage.filterJoinColumns(relation.target, relation.propertyName);\n        const {\n          foreignKey,\n          columns,\n          uniqueConstraint\n        } = this.relationJoinColumnBuilder.build(joinColumns, relation); // create a foreign key based on its metadata args\n\n        if (foreignKey) {\n          relation.registerForeignKeys(foreignKey); // push it to the relation and thus register there a join column\n\n          entityMetadata.foreignKeys.push(foreignKey);\n        }\n\n        if (columns) {\n          relation.registerJoinColumns(columns);\n        }\n\n        if (uniqueConstraint) {\n          if (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === \"aurora-mysql\" || this.connection.driver.options.type === \"mssql\" || this.connection.driver.options.type === \"sap\" || this.connection.driver.options.type === \"spanner\") {\n            const index = new IndexMetadata({\n              entityMetadata: uniqueConstraint.entityMetadata,\n              columns: uniqueConstraint.columns,\n              args: {\n                target: uniqueConstraint.target,\n                name: uniqueConstraint.name,\n                unique: true,\n                synchronize: true\n              }\n            });\n\n            if (this.connection.driver.options.type === \"mssql\") {\n              index.where = index.columns.map(column => {\n                return `${this.connection.driver.escape(column.databaseName)} IS NOT NULL`;\n              }).join(\" AND \");\n            }\n\n            if (this.connection.driver.options.type === \"spanner\") {\n              index.isNullFiltered = true;\n            }\n\n            if (relation.embeddedMetadata) {\n              relation.embeddedMetadata.indices.push(index);\n            } else {\n              relation.entityMetadata.ownIndices.push(index);\n            }\n\n            this.computeEntityMetadataStep2(entityMetadata);\n          } else {\n            if (relation.embeddedMetadata) {\n              relation.embeddedMetadata.uniques.push(uniqueConstraint);\n            } else {\n              relation.entityMetadata.ownUniques.push(uniqueConstraint);\n            }\n\n            this.computeEntityMetadataStep2(entityMetadata);\n          }\n        }\n\n        if (foreignKey && this.connection.driver.options.type === \"cockroachdb\") {\n          const index = new IndexMetadata({\n            entityMetadata: relation.entityMetadata,\n            columns: foreignKey.columns,\n            args: {\n              target: relation.entityMetadata.target,\n              synchronize: true\n            }\n          });\n\n          if (relation.embeddedMetadata) {\n            relation.embeddedMetadata.indices.push(index);\n          } else {\n            relation.entityMetadata.ownIndices.push(index);\n          }\n\n          this.computeEntityMetadataStep2(entityMetadata);\n        }\n      }); // create junction entity metadatas for entity many-to-many relations\n\n      entityMetadata.relations.filter(relation => relation.isManyToMany).forEach(relation => {\n        const joinTable = this.metadataArgsStorage.findJoinTable(relation.target, relation.propertyName);\n        if (!joinTable) return; // no join table set - no need to do anything (it means this is many-to-many inverse side)\n        // here we create a junction entity metadata for a new junction table of many-to-many relation\n\n        const junctionEntityMetadata = this.junctionEntityMetadataBuilder.build(relation, joinTable);\n        relation.registerForeignKeys(...junctionEntityMetadata.foreignKeys);\n        relation.registerJoinColumns(junctionEntityMetadata.ownIndices[0].columns, junctionEntityMetadata.ownIndices[1].columns);\n        relation.registerJunctionEntityMetadata(junctionEntityMetadata); // compute new entity metadata properties and push it to entity metadatas pool\n\n        this.computeEntityMetadataStep2(junctionEntityMetadata);\n        this.computeInverseProperties(junctionEntityMetadata, entityMetadatas);\n        entityMetadatas.push(junctionEntityMetadata);\n      });\n    }); // update entity metadata depend properties\n\n    entityMetadatas.forEach(entityMetadata => {\n      entityMetadata.relationsWithJoinColumns = entityMetadata.relations.filter(relation => relation.isWithJoinColumn);\n      entityMetadata.hasNonNullableRelations = entityMetadata.relationsWithJoinColumns.some(relation => !relation.isNullable || relation.isPrimary);\n    }); // generate closure junction tables for all closure tables\n\n    entityMetadatas.filter(metadata => metadata.treeType === \"closure-table\").forEach(entityMetadata => {\n      const closureJunctionEntityMetadata = this.closureJunctionEntityMetadataBuilder.build(entityMetadata);\n      entityMetadata.closureJunctionTable = closureJunctionEntityMetadata;\n      this.computeEntityMetadataStep2(closureJunctionEntityMetadata);\n      this.computeInverseProperties(closureJunctionEntityMetadata, entityMetadatas);\n      entityMetadatas.push(closureJunctionEntityMetadata);\n    }); // generate keys for tables with single-table inheritance\n\n    entityMetadatas.filter(metadata => metadata.inheritancePattern === \"STI\" && metadata.discriminatorColumn).forEach(entityMetadata => this.createKeysForTableInheritance(entityMetadata)); // build all indices (need to do it after relations and their join columns are built)\n\n    entityMetadatas.forEach(entityMetadata => {\n      entityMetadata.indices.forEach(index => index.build(this.connection.namingStrategy));\n    }); // build all unique constraints (need to do it after relations and their join columns are built)\n\n    entityMetadatas.forEach(entityMetadata => {\n      entityMetadata.uniques.forEach(unique => unique.build(this.connection.namingStrategy));\n    }); // build all check constraints\n\n    entityMetadatas.forEach(entityMetadata => {\n      entityMetadata.checks.forEach(check => check.build(this.connection.namingStrategy));\n    }); // build all exclusion constraints\n\n    entityMetadatas.forEach(entityMetadata => {\n      entityMetadata.exclusions.forEach(exclusion => exclusion.build(this.connection.namingStrategy));\n    }); // add lazy initializer for entity relations\n\n    entityMetadatas.filter(metadata => typeof metadata.target === \"function\").forEach(entityMetadata => {\n      entityMetadata.relations.filter(relation => relation.isLazy).forEach(relation => {\n        this.connection.relationLoader.enableLazyLoad(relation, entityMetadata.target.prototype);\n      });\n    });\n    entityMetadatas.forEach(entityMetadata => {\n      entityMetadata.columns.forEach(column => {\n        // const target = column.embeddedMetadata ? column.embeddedMetadata.type : column.target;\n        const generated = this.metadataArgsStorage.findGenerated(column.target, column.propertyName);\n\n        if (generated) {\n          column.isGenerated = true;\n          column.generationStrategy = generated.strategy;\n\n          if (generated.strategy === \"uuid\") {\n            column.type = \"uuid\";\n          } else if (generated.strategy === \"rowid\") {\n            column.type = \"int\";\n          } else {\n            column.type = column.type || Number;\n          }\n\n          column.build(this.connection);\n          this.computeEntityMetadataStep2(entityMetadata);\n        }\n      });\n    });\n    return entityMetadatas;\n  } // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Creates entity metadata from the given table args.\n   * Creates column, relation, etc. metadatas for everything this entity metadata owns.\n   */\n\n\n  createEntityMetadata(tableArgs) {\n    // we take all \"inheritance tree\" from a target entity to collect all stored metadata args\n    // (by decorators or inside entity schemas). For example for target Post < ContentModel < Unit\n    // it will be an array of [Post, ContentModel, Unit] and we can then get all metadata args of those classes\n    const inheritanceTree = typeof tableArgs.target === \"function\" ? MetadataUtils.getInheritanceTree(tableArgs.target) : [tableArgs.target]; // todo: implement later here inheritance for string-targets\n\n    const tableInheritance = this.metadataArgsStorage.findInheritanceType(tableArgs.target);\n    const tableTree = this.metadataArgsStorage.findTree(tableArgs.target); // if single table inheritance used, we need to copy all children columns in to parent table\n\n    let singleTableChildrenTargets;\n\n    if (tableInheritance && tableInheritance.pattern === \"STI\" || tableArgs.type === \"entity-child\") {\n      singleTableChildrenTargets = this.metadataArgsStorage.filterSingleTableChildren(tableArgs.target).map(args => args.target).filter(target => typeof target === \"function\");\n      inheritanceTree.push(...singleTableChildrenTargets);\n    }\n\n    return new EntityMetadata({\n      connection: this.connection,\n      args: tableArgs,\n      inheritanceTree: inheritanceTree,\n      tableTree: tableTree,\n      inheritancePattern: tableInheritance ? tableInheritance.pattern : undefined\n    });\n  }\n\n  computeParentEntityMetadata(allEntityMetadatas, entityMetadata) {\n    // after all metadatas created we set parent entity metadata for table inheritance\n    if (entityMetadata.tableType === \"entity-child\") {\n      entityMetadata.parentEntityMetadata = allEntityMetadatas.find(allEntityMetadata => {\n        return allEntityMetadata.inheritanceTree.indexOf(entityMetadata.target) !== -1 && allEntityMetadata.inheritancePattern === \"STI\";\n      });\n    }\n  }\n\n  computeEntityMetadataStep1(allEntityMetadatas, entityMetadata) {\n    const entityInheritance = this.metadataArgsStorage.findInheritanceType(entityMetadata.target);\n    const discriminatorValue = this.metadataArgsStorage.findDiscriminatorValue(entityMetadata.target);\n\n    if (typeof discriminatorValue !== \"undefined\") {\n      entityMetadata.discriminatorValue = discriminatorValue.value;\n    } else {\n      entityMetadata.discriminatorValue = entityMetadata.target.name;\n    } // if single table inheritance is used, we need to mark all embedded columns as nullable\n\n\n    entityMetadata.embeddeds = this.createEmbeddedsRecursively(entityMetadata, this.metadataArgsStorage.filterEmbeddeds(entityMetadata.inheritanceTree)).map(embedded => {\n      if (entityMetadata.inheritancePattern === \"STI\") {\n        embedded.columns = embedded.columns.map(column => {\n          column.isNullable = true;\n          return column;\n        });\n      }\n\n      return embedded;\n    });\n    entityMetadata.ownColumns = this.metadataArgsStorage.filterColumns(entityMetadata.inheritanceTree).map(args => {\n      // for single table children we reuse columns created for their parents\n      if (entityMetadata.tableType === \"entity-child\") return entityMetadata.parentEntityMetadata.ownColumns.find(column => column.propertyName === args.propertyName);\n      const column = new ColumnMetadata({\n        connection: this.connection,\n        entityMetadata,\n        args\n      }); // if single table inheritance used, we need to mark all inherit table columns as nullable\n\n      const columnInSingleTableInheritedChild = allEntityMetadatas.find(otherEntityMetadata => otherEntityMetadata.tableType === \"entity-child\" && otherEntityMetadata.target === args.target);\n      if (columnInSingleTableInheritedChild) column.isNullable = true;\n      return column;\n    }); // for table inheritance we need to add a discriminator column\n    //\n\n    if (entityInheritance && entityInheritance.column) {\n      const discriminatorColumnName = entityInheritance.column && entityInheritance.column.name ? entityInheritance.column.name : \"type\";\n      let discriminatorColumn = entityMetadata.ownColumns.find(column => column.propertyName === discriminatorColumnName);\n\n      if (!discriminatorColumn) {\n        discriminatorColumn = new ColumnMetadata({\n          connection: this.connection,\n          entityMetadata: entityMetadata,\n          args: {\n            target: entityMetadata.target,\n            mode: \"virtual\",\n            propertyName: discriminatorColumnName,\n            options: entityInheritance.column || {\n              name: discriminatorColumnName,\n              type: \"varchar\",\n              nullable: false\n            }\n          }\n        });\n        discriminatorColumn.isVirtual = true;\n        discriminatorColumn.isDiscriminator = true;\n        entityMetadata.ownColumns.push(discriminatorColumn);\n      } else {\n        discriminatorColumn.isDiscriminator = true;\n      }\n    } // add discriminator column to the child entity metadatas\n    // discriminator column will not be there automatically since we are creating it in the code above\n\n\n    if (entityMetadata.tableType === \"entity-child\") {\n      const discriminatorColumn = entityMetadata.parentEntityMetadata.ownColumns.find(column => column.isDiscriminator);\n\n      if (discriminatorColumn && !entityMetadata.ownColumns.find(column => column === discriminatorColumn)) {\n        entityMetadata.ownColumns.push(discriminatorColumn);\n      }\n    }\n\n    const {\n      namingStrategy\n    } = this.connection; // check if tree is used then we need to add extra columns for specific tree types\n\n    if (entityMetadata.treeType === \"materialized-path\") {\n      entityMetadata.ownColumns.push(new ColumnMetadata({\n        connection: this.connection,\n        entityMetadata: entityMetadata,\n        materializedPath: true,\n        args: {\n          target: entityMetadata.target,\n          mode: \"virtual\",\n          propertyName: \"mpath\",\n          options:\n          /*tree.column || */\n          {\n            name: namingStrategy.materializedPathColumnName,\n            type: String,\n            nullable: true,\n            default: \"\"\n          }\n        }\n      }));\n    } else if (entityMetadata.treeType === \"nested-set\") {\n      const {\n        left,\n        right\n      } = namingStrategy.nestedSetColumnNames;\n      entityMetadata.ownColumns.push(new ColumnMetadata({\n        connection: this.connection,\n        entityMetadata: entityMetadata,\n        nestedSetLeft: true,\n        args: {\n          target: entityMetadata.target,\n          mode: \"virtual\",\n          propertyName: left,\n          options:\n          /*tree.column || */\n          {\n            name: left,\n            type: Number,\n            nullable: false,\n            default: 1\n          }\n        }\n      }));\n      entityMetadata.ownColumns.push(new ColumnMetadata({\n        connection: this.connection,\n        entityMetadata: entityMetadata,\n        nestedSetRight: true,\n        args: {\n          target: entityMetadata.target,\n          mode: \"virtual\",\n          propertyName: right,\n          options:\n          /*tree.column || */\n          {\n            name: right,\n            type: Number,\n            nullable: false,\n            default: 2\n          }\n        }\n      }));\n    }\n\n    entityMetadata.ownRelations = this.metadataArgsStorage.filterRelations(entityMetadata.inheritanceTree).map(args => {\n      // for single table children we reuse relations created for their parents\n      if (entityMetadata.tableType === \"entity-child\") {\n        const parentRelation = entityMetadata.parentEntityMetadata.ownRelations.find(relation => relation.propertyName === args.propertyName);\n        const type = typeof args.type === \"function\" ? args.type() : args.type;\n\n        if (parentRelation.type !== type) {\n          const clone = Object.create(parentRelation);\n          clone.type = type;\n          return clone;\n        }\n\n        return parentRelation;\n      }\n\n      return new RelationMetadata({\n        entityMetadata,\n        args\n      });\n    });\n    entityMetadata.relationIds = this.metadataArgsStorage.filterRelationIds(entityMetadata.inheritanceTree).map(args => {\n      // for single table children we reuse relation ids created for their parents\n      if (entityMetadata.tableType === \"entity-child\") return entityMetadata.parentEntityMetadata.relationIds.find(relationId => relationId.propertyName === args.propertyName);\n      return new RelationIdMetadata({\n        entityMetadata,\n        args\n      });\n    });\n    entityMetadata.relationCounts = this.metadataArgsStorage.filterRelationCounts(entityMetadata.inheritanceTree).map(args => {\n      // for single table children we reuse relation counts created for their parents\n      if (entityMetadata.tableType === \"entity-child\") return entityMetadata.parentEntityMetadata.relationCounts.find(relationCount => relationCount.propertyName === args.propertyName);\n      return new RelationCountMetadata({\n        entityMetadata,\n        args\n      });\n    });\n    entityMetadata.ownListeners = this.metadataArgsStorage.filterListeners(entityMetadata.inheritanceTree).map(args => {\n      return new EntityListenerMetadata({\n        entityMetadata: entityMetadata,\n        args: args\n      });\n    });\n    entityMetadata.checks = this.metadataArgsStorage.filterChecks(entityMetadata.inheritanceTree).map(args => {\n      return new CheckMetadata({\n        entityMetadata,\n        args\n      });\n    }); // Only PostgreSQL supports exclusion constraints.\n\n    if (this.connection.driver.options.type === \"postgres\") {\n      entityMetadata.exclusions = this.metadataArgsStorage.filterExclusions(entityMetadata.inheritanceTree).map(args => {\n        return new ExclusionMetadata({\n          entityMetadata,\n          args\n        });\n      });\n    }\n\n    if (this.connection.driver.options.type === \"cockroachdb\") {\n      entityMetadata.ownIndices = this.metadataArgsStorage.filterIndices(entityMetadata.inheritanceTree).filter(args => !args.unique).map(args => {\n        return new IndexMetadata({\n          entityMetadata,\n          args\n        });\n      });\n      const uniques = this.metadataArgsStorage.filterIndices(entityMetadata.inheritanceTree).filter(args => args.unique).map(args => {\n        return new UniqueMetadata({\n          entityMetadata: entityMetadata,\n          args: {\n            target: args.target,\n            name: args.name,\n            columns: args.columns\n          }\n        });\n      });\n      entityMetadata.ownUniques.push(...uniques);\n    } else {\n      entityMetadata.ownIndices = this.metadataArgsStorage.filterIndices(entityMetadata.inheritanceTree).map(args => {\n        return new IndexMetadata({\n          entityMetadata,\n          args\n        });\n      });\n    } // This drivers stores unique constraints as unique indices.\n\n\n    if (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === \"aurora-mysql\" || this.connection.driver.options.type === \"sap\" || this.connection.driver.options.type === \"spanner\") {\n      const indices = this.metadataArgsStorage.filterUniques(entityMetadata.inheritanceTree).map(args => {\n        return new IndexMetadata({\n          entityMetadata: entityMetadata,\n          args: {\n            target: args.target,\n            name: args.name,\n            columns: args.columns,\n            unique: true,\n            synchronize: true\n          }\n        });\n      });\n      entityMetadata.ownIndices.push(...indices);\n    } else {\n      const uniques = this.metadataArgsStorage.filterUniques(entityMetadata.inheritanceTree).map(args => {\n        return new UniqueMetadata({\n          entityMetadata,\n          args\n        });\n      });\n      entityMetadata.ownUniques.push(...uniques);\n    }\n  }\n  /**\n   * Creates from the given embedded metadata args real embedded metadatas with its columns and relations,\n   * and does the same for all its sub-embeddeds (goes recursively).\n   */\n\n\n  createEmbeddedsRecursively(entityMetadata, embeddedArgs) {\n    return embeddedArgs.map(embeddedArgs => {\n      const embeddedMetadata = new EmbeddedMetadata({\n        entityMetadata: entityMetadata,\n        args: embeddedArgs\n      });\n      const targets = typeof embeddedMetadata.type === \"function\" ? MetadataUtils.getInheritanceTree(embeddedMetadata.type) : [embeddedMetadata.type]; // todo: implement later here inheritance for string-targets\n\n      embeddedMetadata.columns = this.metadataArgsStorage.filterColumns(targets).map(args => {\n        return new ColumnMetadata({\n          connection: this.connection,\n          entityMetadata,\n          embeddedMetadata,\n          args\n        });\n      });\n      embeddedMetadata.relations = this.metadataArgsStorage.filterRelations(targets).map(args => {\n        return new RelationMetadata({\n          entityMetadata,\n          embeddedMetadata,\n          args\n        });\n      });\n      embeddedMetadata.listeners = this.metadataArgsStorage.filterListeners(targets).map(args => {\n        return new EntityListenerMetadata({\n          entityMetadata,\n          embeddedMetadata,\n          args\n        });\n      });\n      embeddedMetadata.indices = this.metadataArgsStorage.filterIndices(targets).map(args => {\n        return new IndexMetadata({\n          entityMetadata,\n          embeddedMetadata,\n          args\n        });\n      });\n      embeddedMetadata.uniques = this.metadataArgsStorage.filterUniques(targets).map(args => {\n        return new UniqueMetadata({\n          entityMetadata,\n          embeddedMetadata,\n          args\n        });\n      });\n      embeddedMetadata.relationIds = this.metadataArgsStorage.filterRelationIds(targets).map(args => {\n        return new RelationIdMetadata({\n          entityMetadata,\n          args\n        });\n      });\n      embeddedMetadata.relationCounts = this.metadataArgsStorage.filterRelationCounts(targets).map(args => {\n        return new RelationCountMetadata({\n          entityMetadata,\n          args\n        });\n      });\n      embeddedMetadata.embeddeds = this.createEmbeddedsRecursively(entityMetadata, this.metadataArgsStorage.filterEmbeddeds(targets));\n      embeddedMetadata.embeddeds.forEach(subEmbedded => subEmbedded.parentEmbeddedMetadata = embeddedMetadata);\n      entityMetadata.allEmbeddeds.push(embeddedMetadata);\n      return embeddedMetadata;\n    });\n  }\n  /**\n   * Computes all entity metadata's computed properties, and all its sub-metadatas (relations, columns, embeds, etc).\n   */\n\n\n  computeEntityMetadataStep2(entityMetadata) {\n    entityMetadata.embeddeds.forEach(embedded => embedded.build(this.connection));\n    entityMetadata.embeddeds.forEach(embedded => {\n      embedded.columnsFromTree.forEach(column => column.build(this.connection));\n      embedded.relationsFromTree.forEach(relation => relation.build());\n    });\n    entityMetadata.ownColumns.forEach(column => column.build(this.connection));\n    entityMetadata.ownRelations.forEach(relation => relation.build());\n    entityMetadata.relations = entityMetadata.embeddeds.reduce((relations, embedded) => relations.concat(embedded.relationsFromTree), entityMetadata.ownRelations);\n    entityMetadata.eagerRelations = entityMetadata.relations.filter(relation => relation.isEager);\n    entityMetadata.lazyRelations = entityMetadata.relations.filter(relation => relation.isLazy);\n    entityMetadata.oneToOneRelations = entityMetadata.relations.filter(relation => relation.isOneToOne);\n    entityMetadata.oneToManyRelations = entityMetadata.relations.filter(relation => relation.isOneToMany);\n    entityMetadata.manyToOneRelations = entityMetadata.relations.filter(relation => relation.isManyToOne);\n    entityMetadata.manyToManyRelations = entityMetadata.relations.filter(relation => relation.isManyToMany);\n    entityMetadata.ownerOneToOneRelations = entityMetadata.relations.filter(relation => relation.isOneToOneOwner);\n    entityMetadata.ownerManyToManyRelations = entityMetadata.relations.filter(relation => relation.isManyToManyOwner);\n    entityMetadata.treeParentRelation = entityMetadata.relations.find(relation => relation.isTreeParent);\n    entityMetadata.treeChildrenRelation = entityMetadata.relations.find(relation => relation.isTreeChildren);\n    entityMetadata.columns = entityMetadata.embeddeds.reduce((columns, embedded) => columns.concat(embedded.columnsFromTree), entityMetadata.ownColumns);\n    entityMetadata.listeners = entityMetadata.embeddeds.reduce((listeners, embedded) => listeners.concat(embedded.listenersFromTree), entityMetadata.ownListeners);\n    entityMetadata.afterLoadListeners = entityMetadata.listeners.filter(listener => listener.type === EventListenerTypes.AFTER_LOAD);\n    entityMetadata.afterInsertListeners = entityMetadata.listeners.filter(listener => listener.type === EventListenerTypes.AFTER_INSERT);\n    entityMetadata.afterUpdateListeners = entityMetadata.listeners.filter(listener => listener.type === EventListenerTypes.AFTER_UPDATE);\n    entityMetadata.afterRemoveListeners = entityMetadata.listeners.filter(listener => listener.type === EventListenerTypes.AFTER_REMOVE);\n    entityMetadata.afterSoftRemoveListeners = entityMetadata.listeners.filter(listener => listener.type === EventListenerTypes.AFTER_SOFT_REMOVE);\n    entityMetadata.afterRecoverListeners = entityMetadata.listeners.filter(listener => listener.type === EventListenerTypes.AFTER_RECOVER);\n    entityMetadata.beforeInsertListeners = entityMetadata.listeners.filter(listener => listener.type === EventListenerTypes.BEFORE_INSERT);\n    entityMetadata.beforeUpdateListeners = entityMetadata.listeners.filter(listener => listener.type === EventListenerTypes.BEFORE_UPDATE);\n    entityMetadata.beforeRemoveListeners = entityMetadata.listeners.filter(listener => listener.type === EventListenerTypes.BEFORE_REMOVE);\n    entityMetadata.beforeSoftRemoveListeners = entityMetadata.listeners.filter(listener => listener.type === EventListenerTypes.BEFORE_SOFT_REMOVE);\n    entityMetadata.beforeRecoverListeners = entityMetadata.listeners.filter(listener => listener.type === EventListenerTypes.BEFORE_RECOVER);\n    entityMetadata.indices = entityMetadata.embeddeds.reduce((indices, embedded) => indices.concat(embedded.indicesFromTree), entityMetadata.ownIndices);\n    entityMetadata.uniques = entityMetadata.embeddeds.reduce((uniques, embedded) => uniques.concat(embedded.uniquesFromTree), entityMetadata.ownUniques);\n    entityMetadata.primaryColumns = entityMetadata.columns.filter(column => column.isPrimary);\n    entityMetadata.nonVirtualColumns = entityMetadata.columns.filter(column => !column.isVirtual);\n    entityMetadata.ancestorColumns = entityMetadata.columns.filter(column => column.closureType === \"ancestor\");\n    entityMetadata.descendantColumns = entityMetadata.columns.filter(column => column.closureType === \"descendant\");\n    entityMetadata.hasMultiplePrimaryKeys = entityMetadata.primaryColumns.length > 1;\n    entityMetadata.generatedColumns = entityMetadata.columns.filter(column => column.isGenerated || column.isObjectId);\n    entityMetadata.hasUUIDGeneratedColumns = entityMetadata.columns.filter(column => column.isGenerated || column.generationStrategy === \"uuid\").length > 0;\n    entityMetadata.createDateColumn = entityMetadata.columns.find(column => column.isCreateDate);\n    entityMetadata.updateDateColumn = entityMetadata.columns.find(column => column.isUpdateDate);\n    entityMetadata.deleteDateColumn = entityMetadata.columns.find(column => column.isDeleteDate);\n    entityMetadata.versionColumn = entityMetadata.columns.find(column => column.isVersion);\n    entityMetadata.discriminatorColumn = entityMetadata.columns.find(column => column.isDiscriminator);\n    entityMetadata.treeLevelColumn = entityMetadata.columns.find(column => column.isTreeLevel);\n    entityMetadata.nestedSetLeftColumn = entityMetadata.columns.find(column => column.isNestedSetLeft);\n    entityMetadata.nestedSetRightColumn = entityMetadata.columns.find(column => column.isNestedSetRight);\n    entityMetadata.materializedPathColumn = entityMetadata.columns.find(column => column.isMaterializedPath);\n    entityMetadata.objectIdColumn = entityMetadata.columns.find(column => column.isObjectId);\n    entityMetadata.foreignKeys.forEach(foreignKey => foreignKey.build(this.connection.namingStrategy));\n    entityMetadata.propertiesMap = entityMetadata.createPropertiesMap();\n    entityMetadata.relationIds.forEach(relationId => relationId.build());\n    entityMetadata.relationCounts.forEach(relationCount => relationCount.build());\n    entityMetadata.embeddeds.forEach(embedded => {\n      embedded.relationIdsFromTree.forEach(relationId => relationId.build());\n      embedded.relationCountsFromTree.forEach(relationCount => relationCount.build());\n    });\n  }\n  /**\n   * Computes entity metadata's relations inverse side properties.\n   */\n\n\n  computeInverseProperties(entityMetadata, entityMetadatas) {\n    entityMetadata.relations.forEach(relation => {\n      // compute inverse side (related) entity metadatas for all relation metadatas\n      const inverseEntityMetadata = entityMetadatas.find(m => m.target === relation.type || typeof relation.type === \"string\" && (m.targetName === relation.type || m.givenTableName === relation.type));\n      if (!inverseEntityMetadata) throw new TypeORMError(\"Entity metadata for \" + entityMetadata.name + \"#\" + relation.propertyPath + \" was not found. Check if you specified a correct entity object and if it's connected in the connection options.\");\n      relation.inverseEntityMetadata = inverseEntityMetadata;\n      relation.inverseSidePropertyPath = relation.buildInverseSidePropertyPath(); // and compute inverse relation and mark if it has such\n\n      relation.inverseRelation = inverseEntityMetadata.relations.find(foundRelation => foundRelation.propertyPath === relation.inverseSidePropertyPath);\n    });\n  }\n  /**\n   * Creates indices for the table of single table inheritance.\n   */\n\n\n  createKeysForTableInheritance(entityMetadata) {\n    entityMetadata.indices.push(new IndexMetadata({\n      entityMetadata: entityMetadata,\n      columns: [entityMetadata.discriminatorColumn],\n      args: {\n        target: entityMetadata.target,\n        unique: false\n      }\n    }));\n  }\n\n}","map":{"version":3,"mappings":"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","names":["EntityMetadata","ColumnMetadata","IndexMetadata","RelationMetadata","EmbeddedMetadata","RelationIdMetadata","RelationCountMetadata","EventListenerTypes","MetadataUtils","JunctionEntityMetadataBuilder","ClosureJunctionEntityMetadataBuilder","RelationJoinColumnBuilder","EntityListenerMetadata","UniqueMetadata","CheckMetadata","ExclusionMetadata","TypeORMError","DriverUtils","EntityMetadataBuilder","constructor","connection","metadataArgsStorage","junctionEntityMetadataBuilder","closureJunctionEntityMetadataBuilder","relationJoinColumnBuilder","build","entityClasses","allTables","filterTables","tables","realTables","filter","table","type","entityMetadatas","map","tableArgs","createEntityMetadata","forEach","entityMetadata","computeParentEntityMetadata","metadata","childEntityMetadatas","childMetadata","target","isInherited","tableType","computeEntityMetadataStep1","computeEntityMetadataStep2","computeInverseProperties","relations","relation","isOneToOne","isManyToOne","joinColumns","filterJoinColumns","propertyName","foreignKey","columns","uniqueConstraint","registerForeignKeys","foreignKeys","push","registerJoinColumns","isMySQLFamily","driver","options","index","args","name","unique","synchronize","where","column","escape","databaseName","join","isNullFiltered","embeddedMetadata","indices","ownIndices","uniques","ownUniques","isManyToMany","joinTable","findJoinTable","junctionEntityMetadata","registerJunctionEntityMetadata","relationsWithJoinColumns","isWithJoinColumn","hasNonNullableRelations","some","isNullable","isPrimary","treeType","closureJunctionEntityMetadata","closureJunctionTable","inheritancePattern","discriminatorColumn","createKeysForTableInheritance","namingStrategy","checks","check","exclusions","exclusion","isLazy","relationLoader","enableLazyLoad","prototype","generated","findGenerated","isGenerated","generationStrategy","strategy","Number","inheritanceTree","getInheritanceTree","tableInheritance","findInheritanceType","tableTree","findTree","singleTableChildrenTargets","pattern","filterSingleTableChildren","undefined","allEntityMetadatas","parentEntityMetadata","find","allEntityMetadata","indexOf","entityInheritance","discriminatorValue","findDiscriminatorValue","value","embeddeds","createEmbeddedsRecursively","filterEmbeddeds","embedded","ownColumns","filterColumns","columnInSingleTableInheritedChild","otherEntityMetadata","discriminatorColumnName","mode","nullable","isVirtual","isDiscriminator","materializedPath","materializedPathColumnName","String","default","left","right","nestedSetColumnNames","nestedSetLeft","nestedSetRight","ownRelations","filterRelations","parentRelation","clone","Object","create","relationIds","filterRelationIds","relationId","relationCounts","filterRelationCounts","relationCount","ownListeners","filterListeners","filterChecks","filterExclusions","filterIndices","filterUniques","embeddedArgs","targets","listeners","subEmbedded","parentEmbeddedMetadata","allEmbeddeds","columnsFromTree","relationsFromTree","reduce","concat","eagerRelations","isEager","lazyRelations","oneToOneRelations","oneToManyRelations","isOneToMany","manyToOneRelations","manyToManyRelations","ownerOneToOneRelations","isOneToOneOwner","ownerManyToManyRelations","isManyToManyOwner","treeParentRelation","isTreeParent","treeChildrenRelation","isTreeChildren","listenersFromTree","afterLoadListeners","listener","AFTER_LOAD","afterInsertListeners","AFTER_INSERT","afterUpdateListeners","AFTER_UPDATE","afterRemoveListeners","AFTER_REMOVE","afterSoftRemoveListeners","AFTER_SOFT_REMOVE","afterRecoverListeners","AFTER_RECOVER","beforeInsertListeners","BEFORE_INSERT","beforeUpdateListeners","BEFORE_UPDATE","beforeRemoveListeners","BEFORE_REMOVE","beforeSoftRemoveListeners","BEFORE_SOFT_REMOVE","beforeRecoverListeners","BEFORE_RECOVER","indicesFromTree","uniquesFromTree","primaryColumns","nonVirtualColumns","ancestorColumns","closureType","descendantColumns","hasMultiplePrimaryKeys","length","generatedColumns","isObjectId","hasUUIDGeneratedColumns","createDateColumn","isCreateDate","updateDateColumn","isUpdateDate","deleteDateColumn","isDeleteDate","versionColumn","isVersion","treeLevelColumn","isTreeLevel","nestedSetLeftColumn","isNestedSetLeft","nestedSetRightColumn","isNestedSetRight","materializedPathColumn","isMaterializedPath","objectIdColumn","propertiesMap","createPropertiesMap","relationIdsFromTree","relationCountsFromTree","inverseEntityMetadata","m","targetName","givenTableName","propertyPath","inverseSidePropertyPath","buildInverseSidePropertyPath","inverseRelation","foundRelation"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\metadata-builder\\EntityMetadataBuilder.ts"],"sourcesContent":["import { EntityMetadata } from \"../metadata/EntityMetadata\"\nimport { ColumnMetadata } from \"../metadata/ColumnMetadata\"\nimport { IndexMetadata } from \"../metadata/IndexMetadata\"\nimport { RelationMetadata } from \"../metadata/RelationMetadata\"\nimport { EmbeddedMetadata } from \"../metadata/EmbeddedMetadata\"\nimport { MetadataArgsStorage } from \"../metadata-args/MetadataArgsStorage\"\nimport { EmbeddedMetadataArgs } from \"../metadata-args/EmbeddedMetadataArgs\"\nimport { RelationIdMetadata } from \"../metadata/RelationIdMetadata\"\nimport { RelationCountMetadata } from \"../metadata/RelationCountMetadata\"\nimport { EventListenerTypes } from \"../metadata/types/EventListenerTypes\"\nimport { MetadataUtils } from \"./MetadataUtils\"\nimport { TableMetadataArgs } from \"../metadata-args/TableMetadataArgs\"\nimport { JunctionEntityMetadataBuilder } from \"./JunctionEntityMetadataBuilder\"\nimport { ClosureJunctionEntityMetadataBuilder } from \"./ClosureJunctionEntityMetadataBuilder\"\nimport { RelationJoinColumnBuilder } from \"./RelationJoinColumnBuilder\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { EntityListenerMetadata } from \"../metadata/EntityListenerMetadata\"\nimport { UniqueMetadata } from \"../metadata/UniqueMetadata\"\nimport { CheckMetadata } from \"../metadata/CheckMetadata\"\nimport { ExclusionMetadata } from \"../metadata/ExclusionMetadata\"\nimport { TypeORMError } from \"../error\"\nimport { DriverUtils } from \"../driver/DriverUtils\"\n\n/**\n * Builds EntityMetadata objects and all its sub-metadatas.\n */\nexport class EntityMetadataBuilder {\n    // -------------------------------------------------------------------------\n    // Protected Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Used to build entity metadatas of the junction entities.\n     */\n    protected junctionEntityMetadataBuilder: JunctionEntityMetadataBuilder\n\n    /**\n     * Used to build entity metadatas of the closure junction entities.\n     */\n    protected closureJunctionEntityMetadataBuilder: ClosureJunctionEntityMetadataBuilder\n\n    /**\n     * Used to build join columns of the relations.\n     */\n    protected relationJoinColumnBuilder: RelationJoinColumnBuilder\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        private connection: DataSource,\n        private metadataArgsStorage: MetadataArgsStorage,\n    ) {\n        this.junctionEntityMetadataBuilder = new JunctionEntityMetadataBuilder(\n            connection,\n        )\n        this.closureJunctionEntityMetadataBuilder =\n            new ClosureJunctionEntityMetadataBuilder(connection)\n        this.relationJoinColumnBuilder = new RelationJoinColumnBuilder(\n            connection,\n        )\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Builds a complete entity metadatas for the given entity classes.\n     */\n    build(entityClasses?: Function[]): EntityMetadata[] {\n        // if entity classes to filter entities by are given then do filtering, otherwise use all\n        const allTables = entityClasses\n            ? this.metadataArgsStorage.filterTables(entityClasses)\n            : this.metadataArgsStorage.tables\n\n        // filter out table metadata args for those we really create entity metadatas and tables in the db\n        const realTables = allTables.filter(\n            (table) =>\n                table.type === \"regular\" ||\n                table.type === \"closure\" ||\n                table.type === \"entity-child\" ||\n                table.type === \"view\",\n        )\n\n        // create entity metadatas for a user defined entities (marked with @Entity decorator or loaded from entity schemas)\n        const entityMetadatas = realTables.map((tableArgs) =>\n            this.createEntityMetadata(tableArgs),\n        )\n\n        // compute parent entity metadatas for table inheritance\n        entityMetadatas.forEach((entityMetadata) =>\n            this.computeParentEntityMetadata(entityMetadatas, entityMetadata),\n        )\n\n        // after all metadatas created we set child entity metadatas for table inheritance\n        entityMetadatas.forEach((metadata) => {\n            metadata.childEntityMetadatas = entityMetadatas.filter(\n                (childMetadata) => {\n                    return (\n                        typeof metadata.target === \"function\" &&\n                        typeof childMetadata.target === \"function\" &&\n                        MetadataUtils.isInherited(\n                            childMetadata.target,\n                            metadata.target,\n                        )\n                    )\n                },\n            )\n        })\n\n        // build entity metadata (step0), first for non-single-table-inherited entity metadatas (dependant)\n        entityMetadatas\n            .filter(\n                (entityMetadata) => entityMetadata.tableType !== \"entity-child\",\n            )\n            .forEach((entityMetadata) => entityMetadata.build())\n\n        // build entity metadata (step0), now for single-table-inherited entity metadatas (dependant)\n        entityMetadatas\n            .filter(\n                (entityMetadata) => entityMetadata.tableType === \"entity-child\",\n            )\n            .forEach((entityMetadata) => entityMetadata.build())\n\n        // compute entity metadata columns, relations, etc. first for the regular, non-single-table-inherited entity metadatas\n        entityMetadatas\n            .filter(\n                (entityMetadata) => entityMetadata.tableType !== \"entity-child\",\n            )\n            .forEach((entityMetadata) =>\n                this.computeEntityMetadataStep1(\n                    entityMetadatas,\n                    entityMetadata,\n                ),\n            )\n\n        // then do it for single table inheritance children (since they are depend on their parents to be built)\n        entityMetadatas\n            .filter(\n                (entityMetadata) => entityMetadata.tableType === \"entity-child\",\n            )\n            .forEach((entityMetadata) =>\n                this.computeEntityMetadataStep1(\n                    entityMetadatas,\n                    entityMetadata,\n                ),\n            )\n\n        // calculate entity metadata computed properties and all its sub-metadatas\n        entityMetadatas.forEach((entityMetadata) =>\n            this.computeEntityMetadataStep2(entityMetadata),\n        )\n\n        // calculate entity metadata's inverse properties\n        entityMetadatas.forEach((entityMetadata) =>\n            this.computeInverseProperties(entityMetadata, entityMetadatas),\n        )\n\n        // go through all entity metadatas and create foreign keys / junction entity metadatas for their relations\n        entityMetadatas\n            .filter(\n                (entityMetadata) => entityMetadata.tableType !== \"entity-child\",\n            )\n            .forEach((entityMetadata) => {\n                // create entity's relations join columns (for many-to-one and one-to-one owner)\n                entityMetadata.relations\n                    .filter(\n                        (relation) =>\n                            relation.isOneToOne || relation.isManyToOne,\n                    )\n                    .forEach((relation) => {\n                        const joinColumns =\n                            this.metadataArgsStorage.filterJoinColumns(\n                                relation.target,\n                                relation.propertyName,\n                            )\n                        const { foreignKey, columns, uniqueConstraint } =\n                            this.relationJoinColumnBuilder.build(\n                                joinColumns,\n                                relation,\n                            ) // create a foreign key based on its metadata args\n                        if (foreignKey) {\n                            relation.registerForeignKeys(foreignKey) // push it to the relation and thus register there a join column\n                            entityMetadata.foreignKeys.push(foreignKey)\n                        }\n                        if (columns) {\n                            relation.registerJoinColumns(columns)\n                        }\n                        if (uniqueConstraint) {\n                            if (\n                                DriverUtils.isMySQLFamily(\n                                    this.connection.driver,\n                                ) ||\n                                this.connection.driver.options.type ===\n                                    \"aurora-mysql\" ||\n                                this.connection.driver.options.type ===\n                                    \"mssql\" ||\n                                this.connection.driver.options.type === \"sap\" ||\n                                this.connection.driver.options.type ===\n                                    \"spanner\"\n                            ) {\n                                const index = new IndexMetadata({\n                                    entityMetadata:\n                                        uniqueConstraint.entityMetadata,\n                                    columns: uniqueConstraint.columns,\n                                    args: {\n                                        target: uniqueConstraint.target!,\n                                        name: uniqueConstraint.name,\n                                        unique: true,\n                                        synchronize: true,\n                                    },\n                                })\n\n                                if (\n                                    this.connection.driver.options.type ===\n                                    \"mssql\"\n                                ) {\n                                    index.where = index.columns\n                                        .map((column) => {\n                                            return `${this.connection.driver.escape(\n                                                column.databaseName,\n                                            )} IS NOT NULL`\n                                        })\n                                        .join(\" AND \")\n                                }\n\n                                if (\n                                    this.connection.driver.options.type ===\n                                    \"spanner\"\n                                ) {\n                                    index.isNullFiltered = true\n                                }\n\n                                if (relation.embeddedMetadata) {\n                                    relation.embeddedMetadata.indices.push(\n                                        index,\n                                    )\n                                } else {\n                                    relation.entityMetadata.ownIndices.push(\n                                        index,\n                                    )\n                                }\n                                this.computeEntityMetadataStep2(entityMetadata)\n                            } else {\n                                if (relation.embeddedMetadata) {\n                                    relation.embeddedMetadata.uniques.push(\n                                        uniqueConstraint,\n                                    )\n                                } else {\n                                    relation.entityMetadata.ownUniques.push(\n                                        uniqueConstraint,\n                                    )\n                                }\n                                this.computeEntityMetadataStep2(entityMetadata)\n                            }\n                        }\n\n                        if (\n                            foreignKey &&\n                            this.connection.driver.options.type ===\n                                \"cockroachdb\"\n                        ) {\n                            const index = new IndexMetadata({\n                                entityMetadata: relation.entityMetadata,\n                                columns: foreignKey.columns,\n                                args: {\n                                    target: relation.entityMetadata.target!,\n                                    synchronize: true,\n                                },\n                            })\n                            if (relation.embeddedMetadata) {\n                                relation.embeddedMetadata.indices.push(index)\n                            } else {\n                                relation.entityMetadata.ownIndices.push(index)\n                            }\n                            this.computeEntityMetadataStep2(entityMetadata)\n                        }\n                    })\n\n                // create junction entity metadatas for entity many-to-many relations\n                entityMetadata.relations\n                    .filter((relation) => relation.isManyToMany)\n                    .forEach((relation) => {\n                        const joinTable =\n                            this.metadataArgsStorage.findJoinTable(\n                                relation.target,\n                                relation.propertyName,\n                            )!\n                        if (!joinTable) return // no join table set - no need to do anything (it means this is many-to-many inverse side)\n\n                        // here we create a junction entity metadata for a new junction table of many-to-many relation\n                        const junctionEntityMetadata =\n                            this.junctionEntityMetadataBuilder.build(\n                                relation,\n                                joinTable,\n                            )\n                        relation.registerForeignKeys(\n                            ...junctionEntityMetadata.foreignKeys,\n                        )\n                        relation.registerJoinColumns(\n                            junctionEntityMetadata.ownIndices[0].columns,\n                            junctionEntityMetadata.ownIndices[1].columns,\n                        )\n                        relation.registerJunctionEntityMetadata(\n                            junctionEntityMetadata,\n                        )\n\n                        // compute new entity metadata properties and push it to entity metadatas pool\n                        this.computeEntityMetadataStep2(junctionEntityMetadata)\n                        this.computeInverseProperties(\n                            junctionEntityMetadata,\n                            entityMetadatas,\n                        )\n                        entityMetadatas.push(junctionEntityMetadata)\n                    })\n            })\n\n        // update entity metadata depend properties\n        entityMetadatas.forEach((entityMetadata) => {\n            entityMetadata.relationsWithJoinColumns =\n                entityMetadata.relations.filter(\n                    (relation) => relation.isWithJoinColumn,\n                )\n            entityMetadata.hasNonNullableRelations =\n                entityMetadata.relationsWithJoinColumns.some(\n                    (relation) => !relation.isNullable || relation.isPrimary,\n                )\n        })\n\n        // generate closure junction tables for all closure tables\n        entityMetadatas\n            .filter((metadata) => metadata.treeType === \"closure-table\")\n            .forEach((entityMetadata) => {\n                const closureJunctionEntityMetadata =\n                    this.closureJunctionEntityMetadataBuilder.build(\n                        entityMetadata,\n                    )\n                entityMetadata.closureJunctionTable =\n                    closureJunctionEntityMetadata\n                this.computeEntityMetadataStep2(closureJunctionEntityMetadata)\n                this.computeInverseProperties(\n                    closureJunctionEntityMetadata,\n                    entityMetadatas,\n                )\n                entityMetadatas.push(closureJunctionEntityMetadata)\n            })\n\n        // generate keys for tables with single-table inheritance\n        entityMetadatas\n            .filter(\n                (metadata) =>\n                    metadata.inheritancePattern === \"STI\" &&\n                    metadata.discriminatorColumn,\n            )\n            .forEach((entityMetadata) =>\n                this.createKeysForTableInheritance(entityMetadata),\n            )\n\n        // build all indices (need to do it after relations and their join columns are built)\n        entityMetadatas.forEach((entityMetadata) => {\n            entityMetadata.indices.forEach((index) =>\n                index.build(this.connection.namingStrategy),\n            )\n        })\n\n        // build all unique constraints (need to do it after relations and their join columns are built)\n        entityMetadatas.forEach((entityMetadata) => {\n            entityMetadata.uniques.forEach((unique) =>\n                unique.build(this.connection.namingStrategy),\n            )\n        })\n\n        // build all check constraints\n        entityMetadatas.forEach((entityMetadata) => {\n            entityMetadata.checks.forEach((check) =>\n                check.build(this.connection.namingStrategy),\n            )\n        })\n\n        // build all exclusion constraints\n        entityMetadatas.forEach((entityMetadata) => {\n            entityMetadata.exclusions.forEach((exclusion) =>\n                exclusion.build(this.connection.namingStrategy),\n            )\n        })\n\n        // add lazy initializer for entity relations\n        entityMetadatas\n            .filter((metadata) => typeof metadata.target === \"function\")\n            .forEach((entityMetadata) => {\n                entityMetadata.relations\n                    .filter((relation) => relation.isLazy)\n                    .forEach((relation) => {\n                        this.connection.relationLoader.enableLazyLoad(\n                            relation,\n                            (entityMetadata.target as Function).prototype,\n                        )\n                    })\n            })\n\n        entityMetadatas.forEach((entityMetadata) => {\n            entityMetadata.columns.forEach((column) => {\n                // const target = column.embeddedMetadata ? column.embeddedMetadata.type : column.target;\n                const generated = this.metadataArgsStorage.findGenerated(\n                    column.target,\n                    column.propertyName,\n                )\n                if (generated) {\n                    column.isGenerated = true\n                    column.generationStrategy = generated.strategy\n                    if (generated.strategy === \"uuid\") {\n                        column.type = \"uuid\"\n                    } else if (generated.strategy === \"rowid\") {\n                        column.type = \"int\"\n                    } else {\n                        column.type = column.type || Number\n                    }\n                    column.build(this.connection)\n                    this.computeEntityMetadataStep2(entityMetadata)\n                }\n            })\n        })\n\n        return entityMetadatas\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates entity metadata from the given table args.\n     * Creates column, relation, etc. metadatas for everything this entity metadata owns.\n     */\n    protected createEntityMetadata(\n        tableArgs: TableMetadataArgs,\n    ): EntityMetadata {\n        // we take all \"inheritance tree\" from a target entity to collect all stored metadata args\n        // (by decorators or inside entity schemas). For example for target Post < ContentModel < Unit\n        // it will be an array of [Post, ContentModel, Unit] and we can then get all metadata args of those classes\n        const inheritanceTree: any[] =\n            typeof tableArgs.target === \"function\"\n                ? MetadataUtils.getInheritanceTree(tableArgs.target)\n                : [tableArgs.target] // todo: implement later here inheritance for string-targets\n\n        const tableInheritance = this.metadataArgsStorage.findInheritanceType(\n            tableArgs.target,\n        )\n        const tableTree = this.metadataArgsStorage.findTree(tableArgs.target)\n\n        // if single table inheritance used, we need to copy all children columns in to parent table\n        let singleTableChildrenTargets: any[]\n        if (\n            (tableInheritance && tableInheritance.pattern === \"STI\") ||\n            tableArgs.type === \"entity-child\"\n        ) {\n            singleTableChildrenTargets = this.metadataArgsStorage\n                .filterSingleTableChildren(tableArgs.target)\n                .map((args) => args.target)\n                .filter((target) => typeof target === \"function\")\n\n            inheritanceTree.push(...singleTableChildrenTargets)\n        }\n\n        return new EntityMetadata({\n            connection: this.connection,\n            args: tableArgs,\n            inheritanceTree: inheritanceTree,\n            tableTree: tableTree,\n            inheritancePattern: tableInheritance\n                ? tableInheritance.pattern\n                : undefined,\n        })\n    }\n\n    protected computeParentEntityMetadata(\n        allEntityMetadatas: EntityMetadata[],\n        entityMetadata: EntityMetadata,\n    ) {\n        // after all metadatas created we set parent entity metadata for table inheritance\n        if (entityMetadata.tableType === \"entity-child\") {\n            entityMetadata.parentEntityMetadata = allEntityMetadatas.find(\n                (allEntityMetadata) => {\n                    return (\n                        allEntityMetadata.inheritanceTree.indexOf(\n                            entityMetadata.target as Function,\n                        ) !== -1 &&\n                        allEntityMetadata.inheritancePattern === \"STI\"\n                    )\n                },\n            )!\n        }\n    }\n\n    protected computeEntityMetadataStep1(\n        allEntityMetadatas: EntityMetadata[],\n        entityMetadata: EntityMetadata,\n    ) {\n        const entityInheritance = this.metadataArgsStorage.findInheritanceType(\n            entityMetadata.target,\n        )\n\n        const discriminatorValue =\n            this.metadataArgsStorage.findDiscriminatorValue(\n                entityMetadata.target,\n            )\n\n        if (typeof discriminatorValue !== \"undefined\") {\n            entityMetadata.discriminatorValue = discriminatorValue.value\n        } else {\n            entityMetadata.discriminatorValue = (\n                entityMetadata.target as any\n            ).name\n        }\n\n        // if single table inheritance is used, we need to mark all embedded columns as nullable\n        entityMetadata.embeddeds = this.createEmbeddedsRecursively(\n            entityMetadata,\n            this.metadataArgsStorage.filterEmbeddeds(\n                entityMetadata.inheritanceTree,\n            ),\n        ).map((embedded: EmbeddedMetadata): EmbeddedMetadata => {\n            if (entityMetadata.inheritancePattern === \"STI\") {\n                embedded.columns = embedded.columns.map(\n                    (column: ColumnMetadata): ColumnMetadata => {\n                        column.isNullable = true\n                        return column\n                    },\n                )\n            }\n            return embedded\n        })\n\n        entityMetadata.ownColumns = this.metadataArgsStorage\n            .filterColumns(entityMetadata.inheritanceTree)\n            .map((args) => {\n                // for single table children we reuse columns created for their parents\n                if (entityMetadata.tableType === \"entity-child\")\n                    return entityMetadata.parentEntityMetadata.ownColumns.find(\n                        (column) => column.propertyName === args.propertyName,\n                    )!\n\n                const column = new ColumnMetadata({\n                    connection: this.connection,\n                    entityMetadata,\n                    args,\n                })\n\n                // if single table inheritance used, we need to mark all inherit table columns as nullable\n                const columnInSingleTableInheritedChild =\n                    allEntityMetadatas.find(\n                        (otherEntityMetadata) =>\n                            otherEntityMetadata.tableType === \"entity-child\" &&\n                            otherEntityMetadata.target === args.target,\n                    )\n                if (columnInSingleTableInheritedChild) column.isNullable = true\n                return column\n            })\n\n        // for table inheritance we need to add a discriminator column\n        //\n        if (entityInheritance && entityInheritance.column) {\n            const discriminatorColumnName =\n                entityInheritance.column && entityInheritance.column.name\n                    ? entityInheritance.column.name\n                    : \"type\"\n            let discriminatorColumn = entityMetadata.ownColumns.find(\n                (column) => column.propertyName === discriminatorColumnName,\n            )\n            if (!discriminatorColumn) {\n                discriminatorColumn = new ColumnMetadata({\n                    connection: this.connection,\n                    entityMetadata: entityMetadata,\n                    args: {\n                        target: entityMetadata.target,\n                        mode: \"virtual\",\n                        propertyName: discriminatorColumnName,\n                        options: entityInheritance.column || {\n                            name: discriminatorColumnName,\n                            type: \"varchar\",\n                            nullable: false,\n                        },\n                    },\n                })\n                discriminatorColumn.isVirtual = true\n                discriminatorColumn.isDiscriminator = true\n                entityMetadata.ownColumns.push(discriminatorColumn)\n            } else {\n                discriminatorColumn.isDiscriminator = true\n            }\n        }\n\n        // add discriminator column to the child entity metadatas\n        // discriminator column will not be there automatically since we are creating it in the code above\n        if (entityMetadata.tableType === \"entity-child\") {\n            const discriminatorColumn =\n                entityMetadata.parentEntityMetadata.ownColumns.find(\n                    (column) => column.isDiscriminator,\n                )\n            if (\n                discriminatorColumn &&\n                !entityMetadata.ownColumns.find(\n                    (column) => column === discriminatorColumn,\n                )\n            ) {\n                entityMetadata.ownColumns.push(discriminatorColumn)\n            }\n        }\n\n        const { namingStrategy } = this.connection\n\n        // check if tree is used then we need to add extra columns for specific tree types\n        if (entityMetadata.treeType === \"materialized-path\") {\n            entityMetadata.ownColumns.push(\n                new ColumnMetadata({\n                    connection: this.connection,\n                    entityMetadata: entityMetadata,\n                    materializedPath: true,\n                    args: {\n                        target: entityMetadata.target,\n                        mode: \"virtual\",\n                        propertyName: \"mpath\",\n                        options: /*tree.column || */ {\n                            name: namingStrategy.materializedPathColumnName,\n                            type: String,\n                            nullable: true,\n                            default: \"\",\n                        },\n                    },\n                }),\n            )\n        } else if (entityMetadata.treeType === \"nested-set\") {\n            const { left, right } = namingStrategy.nestedSetColumnNames\n            entityMetadata.ownColumns.push(\n                new ColumnMetadata({\n                    connection: this.connection,\n                    entityMetadata: entityMetadata,\n                    nestedSetLeft: true,\n                    args: {\n                        target: entityMetadata.target,\n                        mode: \"virtual\",\n                        propertyName: left,\n                        options: /*tree.column || */ {\n                            name: left,\n                            type: Number,\n                            nullable: false,\n                            default: 1,\n                        },\n                    },\n                }),\n            )\n            entityMetadata.ownColumns.push(\n                new ColumnMetadata({\n                    connection: this.connection,\n                    entityMetadata: entityMetadata,\n                    nestedSetRight: true,\n                    args: {\n                        target: entityMetadata.target,\n                        mode: \"virtual\",\n                        propertyName: right,\n                        options: /*tree.column || */ {\n                            name: right,\n                            type: Number,\n                            nullable: false,\n                            default: 2,\n                        },\n                    },\n                }),\n            )\n        }\n\n        entityMetadata.ownRelations = this.metadataArgsStorage\n            .filterRelations(entityMetadata.inheritanceTree)\n            .map((args) => {\n                // for single table children we reuse relations created for their parents\n                if (entityMetadata.tableType === \"entity-child\") {\n                    const parentRelation =\n                        entityMetadata.parentEntityMetadata.ownRelations.find(\n                            (relation) =>\n                                relation.propertyName === args.propertyName,\n                        )!\n                    const type =\n                        typeof args.type === \"function\"\n                            ? (args.type as () => any)()\n                            : args.type\n                    if (parentRelation.type !== type) {\n                        const clone = Object.create(parentRelation)\n                        clone.type = type\n                        return clone\n                    }\n\n                    return parentRelation\n                }\n\n                return new RelationMetadata({ entityMetadata, args })\n            })\n        entityMetadata.relationIds = this.metadataArgsStorage\n            .filterRelationIds(entityMetadata.inheritanceTree)\n            .map((args) => {\n                // for single table children we reuse relation ids created for their parents\n                if (entityMetadata.tableType === \"entity-child\")\n                    return entityMetadata.parentEntityMetadata.relationIds.find(\n                        (relationId) =>\n                            relationId.propertyName === args.propertyName,\n                    )!\n\n                return new RelationIdMetadata({ entityMetadata, args })\n            })\n        entityMetadata.relationCounts = this.metadataArgsStorage\n            .filterRelationCounts(entityMetadata.inheritanceTree)\n            .map((args) => {\n                // for single table children we reuse relation counts created for their parents\n                if (entityMetadata.tableType === \"entity-child\")\n                    return entityMetadata.parentEntityMetadata.relationCounts.find(\n                        (relationCount) =>\n                            relationCount.propertyName === args.propertyName,\n                    )!\n\n                return new RelationCountMetadata({ entityMetadata, args })\n            })\n        entityMetadata.ownListeners = this.metadataArgsStorage\n            .filterListeners(entityMetadata.inheritanceTree)\n            .map((args) => {\n                return new EntityListenerMetadata({\n                    entityMetadata: entityMetadata,\n                    args: args,\n                })\n            })\n        entityMetadata.checks = this.metadataArgsStorage\n            .filterChecks(entityMetadata.inheritanceTree)\n            .map((args) => {\n                return new CheckMetadata({ entityMetadata, args })\n            })\n\n        // Only PostgreSQL supports exclusion constraints.\n        if (this.connection.driver.options.type === \"postgres\") {\n            entityMetadata.exclusions = this.metadataArgsStorage\n                .filterExclusions(entityMetadata.inheritanceTree)\n                .map((args) => {\n                    return new ExclusionMetadata({ entityMetadata, args })\n                })\n        }\n\n        if (this.connection.driver.options.type === \"cockroachdb\") {\n            entityMetadata.ownIndices = this.metadataArgsStorage\n                .filterIndices(entityMetadata.inheritanceTree)\n                .filter((args) => !args.unique)\n                .map((args) => {\n                    return new IndexMetadata({ entityMetadata, args })\n                })\n\n            const uniques = this.metadataArgsStorage\n                .filterIndices(entityMetadata.inheritanceTree)\n                .filter((args) => args.unique)\n                .map((args) => {\n                    return new UniqueMetadata({\n                        entityMetadata: entityMetadata,\n                        args: {\n                            target: args.target,\n                            name: args.name,\n                            columns: args.columns,\n                        },\n                    })\n                })\n            entityMetadata.ownUniques.push(...uniques)\n        } else {\n            entityMetadata.ownIndices = this.metadataArgsStorage\n                .filterIndices(entityMetadata.inheritanceTree)\n                .map((args) => {\n                    return new IndexMetadata({ entityMetadata, args })\n                })\n        }\n\n        // This drivers stores unique constraints as unique indices.\n        if (\n            DriverUtils.isMySQLFamily(this.connection.driver) ||\n            this.connection.driver.options.type === \"aurora-mysql\" ||\n            this.connection.driver.options.type === \"sap\" ||\n            this.connection.driver.options.type === \"spanner\"\n        ) {\n            const indices = this.metadataArgsStorage\n                .filterUniques(entityMetadata.inheritanceTree)\n                .map((args) => {\n                    return new IndexMetadata({\n                        entityMetadata: entityMetadata,\n                        args: {\n                            target: args.target,\n                            name: args.name,\n                            columns: args.columns,\n                            unique: true,\n                            synchronize: true,\n                        },\n                    })\n                })\n            entityMetadata.ownIndices.push(...indices)\n        } else {\n            const uniques = this.metadataArgsStorage\n                .filterUniques(entityMetadata.inheritanceTree)\n                .map((args) => {\n                    return new UniqueMetadata({ entityMetadata, args })\n                })\n            entityMetadata.ownUniques.push(...uniques)\n        }\n    }\n\n    /**\n     * Creates from the given embedded metadata args real embedded metadatas with its columns and relations,\n     * and does the same for all its sub-embeddeds (goes recursively).\n     */\n    protected createEmbeddedsRecursively(\n        entityMetadata: EntityMetadata,\n        embeddedArgs: EmbeddedMetadataArgs[],\n    ): EmbeddedMetadata[] {\n        return embeddedArgs.map((embeddedArgs) => {\n            const embeddedMetadata = new EmbeddedMetadata({\n                entityMetadata: entityMetadata,\n                args: embeddedArgs,\n            })\n            const targets: any[] =\n                typeof embeddedMetadata.type === \"function\"\n                    ? MetadataUtils.getInheritanceTree(embeddedMetadata.type)\n                    : [embeddedMetadata.type] // todo: implement later here inheritance for string-targets\n\n            embeddedMetadata.columns = this.metadataArgsStorage\n                .filterColumns(targets)\n                .map((args) => {\n                    return new ColumnMetadata({\n                        connection: this.connection,\n                        entityMetadata,\n                        embeddedMetadata,\n                        args,\n                    })\n                })\n            embeddedMetadata.relations = this.metadataArgsStorage\n                .filterRelations(targets)\n                .map((args) => {\n                    return new RelationMetadata({\n                        entityMetadata,\n                        embeddedMetadata,\n                        args,\n                    })\n                })\n            embeddedMetadata.listeners = this.metadataArgsStorage\n                .filterListeners(targets)\n                .map((args) => {\n                    return new EntityListenerMetadata({\n                        entityMetadata,\n                        embeddedMetadata,\n                        args,\n                    })\n                })\n            embeddedMetadata.indices = this.metadataArgsStorage\n                .filterIndices(targets)\n                .map((args) => {\n                    return new IndexMetadata({\n                        entityMetadata,\n                        embeddedMetadata,\n                        args,\n                    })\n                })\n            embeddedMetadata.uniques = this.metadataArgsStorage\n                .filterUniques(targets)\n                .map((args) => {\n                    return new UniqueMetadata({\n                        entityMetadata,\n                        embeddedMetadata,\n                        args,\n                    })\n                })\n            embeddedMetadata.relationIds = this.metadataArgsStorage\n                .filterRelationIds(targets)\n                .map((args) => {\n                    return new RelationIdMetadata({ entityMetadata, args })\n                })\n            embeddedMetadata.relationCounts = this.metadataArgsStorage\n                .filterRelationCounts(targets)\n                .map((args) => {\n                    return new RelationCountMetadata({ entityMetadata, args })\n                })\n            embeddedMetadata.embeddeds = this.createEmbeddedsRecursively(\n                entityMetadata,\n                this.metadataArgsStorage.filterEmbeddeds(targets),\n            )\n            embeddedMetadata.embeddeds.forEach(\n                (subEmbedded) =>\n                    (subEmbedded.parentEmbeddedMetadata = embeddedMetadata),\n            )\n            entityMetadata.allEmbeddeds.push(embeddedMetadata)\n            return embeddedMetadata\n        })\n    }\n\n    /**\n     * Computes all entity metadata's computed properties, and all its sub-metadatas (relations, columns, embeds, etc).\n     */\n    protected computeEntityMetadataStep2(entityMetadata: EntityMetadata) {\n        entityMetadata.embeddeds.forEach((embedded) =>\n            embedded.build(this.connection),\n        )\n        entityMetadata.embeddeds.forEach((embedded) => {\n            embedded.columnsFromTree.forEach((column) =>\n                column.build(this.connection),\n            )\n            embedded.relationsFromTree.forEach((relation) => relation.build())\n        })\n        entityMetadata.ownColumns.forEach((column) =>\n            column.build(this.connection),\n        )\n        entityMetadata.ownRelations.forEach((relation) => relation.build())\n        entityMetadata.relations = entityMetadata.embeddeds.reduce(\n            (relations, embedded) =>\n                relations.concat(embedded.relationsFromTree),\n            entityMetadata.ownRelations,\n        )\n        entityMetadata.eagerRelations = entityMetadata.relations.filter(\n            (relation) => relation.isEager,\n        )\n        entityMetadata.lazyRelations = entityMetadata.relations.filter(\n            (relation) => relation.isLazy,\n        )\n        entityMetadata.oneToOneRelations = entityMetadata.relations.filter(\n            (relation) => relation.isOneToOne,\n        )\n        entityMetadata.oneToManyRelations = entityMetadata.relations.filter(\n            (relation) => relation.isOneToMany,\n        )\n        entityMetadata.manyToOneRelations = entityMetadata.relations.filter(\n            (relation) => relation.isManyToOne,\n        )\n        entityMetadata.manyToManyRelations = entityMetadata.relations.filter(\n            (relation) => relation.isManyToMany,\n        )\n        entityMetadata.ownerOneToOneRelations = entityMetadata.relations.filter(\n            (relation) => relation.isOneToOneOwner,\n        )\n        entityMetadata.ownerManyToManyRelations =\n            entityMetadata.relations.filter(\n                (relation) => relation.isManyToManyOwner,\n            )\n        entityMetadata.treeParentRelation = entityMetadata.relations.find(\n            (relation) => relation.isTreeParent,\n        )\n        entityMetadata.treeChildrenRelation = entityMetadata.relations.find(\n            (relation) => relation.isTreeChildren,\n        )\n        entityMetadata.columns = entityMetadata.embeddeds.reduce(\n            (columns, embedded) => columns.concat(embedded.columnsFromTree),\n            entityMetadata.ownColumns,\n        )\n        entityMetadata.listeners = entityMetadata.embeddeds.reduce(\n            (listeners, embedded) =>\n                listeners.concat(embedded.listenersFromTree),\n            entityMetadata.ownListeners,\n        )\n        entityMetadata.afterLoadListeners = entityMetadata.listeners.filter(\n            (listener) => listener.type === EventListenerTypes.AFTER_LOAD,\n        )\n        entityMetadata.afterInsertListeners = entityMetadata.listeners.filter(\n            (listener) => listener.type === EventListenerTypes.AFTER_INSERT,\n        )\n        entityMetadata.afterUpdateListeners = entityMetadata.listeners.filter(\n            (listener) => listener.type === EventListenerTypes.AFTER_UPDATE,\n        )\n        entityMetadata.afterRemoveListeners = entityMetadata.listeners.filter(\n            (listener) => listener.type === EventListenerTypes.AFTER_REMOVE,\n        )\n        entityMetadata.afterSoftRemoveListeners =\n            entityMetadata.listeners.filter(\n                (listener) =>\n                    listener.type === EventListenerTypes.AFTER_SOFT_REMOVE,\n            )\n        entityMetadata.afterRecoverListeners = entityMetadata.listeners.filter(\n            (listener) => listener.type === EventListenerTypes.AFTER_RECOVER,\n        )\n        entityMetadata.beforeInsertListeners = entityMetadata.listeners.filter(\n            (listener) => listener.type === EventListenerTypes.BEFORE_INSERT,\n        )\n        entityMetadata.beforeUpdateListeners = entityMetadata.listeners.filter(\n            (listener) => listener.type === EventListenerTypes.BEFORE_UPDATE,\n        )\n        entityMetadata.beforeRemoveListeners = entityMetadata.listeners.filter(\n            (listener) => listener.type === EventListenerTypes.BEFORE_REMOVE,\n        )\n        entityMetadata.beforeSoftRemoveListeners =\n            entityMetadata.listeners.filter(\n                (listener) =>\n                    listener.type === EventListenerTypes.BEFORE_SOFT_REMOVE,\n            )\n        entityMetadata.beforeRecoverListeners = entityMetadata.listeners.filter(\n            (listener) => listener.type === EventListenerTypes.BEFORE_RECOVER,\n        )\n        entityMetadata.indices = entityMetadata.embeddeds.reduce(\n            (indices, embedded) => indices.concat(embedded.indicesFromTree),\n            entityMetadata.ownIndices,\n        )\n        entityMetadata.uniques = entityMetadata.embeddeds.reduce(\n            (uniques, embedded) => uniques.concat(embedded.uniquesFromTree),\n            entityMetadata.ownUniques,\n        )\n        entityMetadata.primaryColumns = entityMetadata.columns.filter(\n            (column) => column.isPrimary,\n        )\n        entityMetadata.nonVirtualColumns = entityMetadata.columns.filter(\n            (column) => !column.isVirtual,\n        )\n        entityMetadata.ancestorColumns = entityMetadata.columns.filter(\n            (column) => column.closureType === \"ancestor\",\n        )\n        entityMetadata.descendantColumns = entityMetadata.columns.filter(\n            (column) => column.closureType === \"descendant\",\n        )\n        entityMetadata.hasMultiplePrimaryKeys =\n            entityMetadata.primaryColumns.length > 1\n        entityMetadata.generatedColumns = entityMetadata.columns.filter(\n            (column) => column.isGenerated || column.isObjectId,\n        )\n        entityMetadata.hasUUIDGeneratedColumns =\n            entityMetadata.columns.filter(\n                (column) =>\n                    column.isGenerated || column.generationStrategy === \"uuid\",\n            ).length > 0\n        entityMetadata.createDateColumn = entityMetadata.columns.find(\n            (column) => column.isCreateDate,\n        )\n        entityMetadata.updateDateColumn = entityMetadata.columns.find(\n            (column) => column.isUpdateDate,\n        )\n        entityMetadata.deleteDateColumn = entityMetadata.columns.find(\n            (column) => column.isDeleteDate,\n        )\n        entityMetadata.versionColumn = entityMetadata.columns.find(\n            (column) => column.isVersion,\n        )\n        entityMetadata.discriminatorColumn = entityMetadata.columns.find(\n            (column) => column.isDiscriminator,\n        )\n        entityMetadata.treeLevelColumn = entityMetadata.columns.find(\n            (column) => column.isTreeLevel,\n        )\n        entityMetadata.nestedSetLeftColumn = entityMetadata.columns.find(\n            (column) => column.isNestedSetLeft,\n        )\n        entityMetadata.nestedSetRightColumn = entityMetadata.columns.find(\n            (column) => column.isNestedSetRight,\n        )\n        entityMetadata.materializedPathColumn = entityMetadata.columns.find(\n            (column) => column.isMaterializedPath,\n        )\n        entityMetadata.objectIdColumn = entityMetadata.columns.find(\n            (column) => column.isObjectId,\n        )\n        entityMetadata.foreignKeys.forEach((foreignKey) =>\n            foreignKey.build(this.connection.namingStrategy),\n        )\n        entityMetadata.propertiesMap = entityMetadata.createPropertiesMap()\n        entityMetadata.relationIds.forEach((relationId) => relationId.build())\n        entityMetadata.relationCounts.forEach((relationCount) =>\n            relationCount.build(),\n        )\n        entityMetadata.embeddeds.forEach((embedded) => {\n            embedded.relationIdsFromTree.forEach((relationId) =>\n                relationId.build(),\n            )\n            embedded.relationCountsFromTree.forEach((relationCount) =>\n                relationCount.build(),\n            )\n        })\n    }\n\n    /**\n     * Computes entity metadata's relations inverse side properties.\n     */\n    protected computeInverseProperties(\n        entityMetadata: EntityMetadata,\n        entityMetadatas: EntityMetadata[],\n    ) {\n        entityMetadata.relations.forEach((relation) => {\n            // compute inverse side (related) entity metadatas for all relation metadatas\n            const inverseEntityMetadata = entityMetadatas.find(\n                (m) =>\n                    m.target === relation.type ||\n                    (typeof relation.type === \"string\" &&\n                        (m.targetName === relation.type ||\n                            m.givenTableName === relation.type)),\n            )\n            if (!inverseEntityMetadata)\n                throw new TypeORMError(\n                    \"Entity metadata for \" +\n                        entityMetadata.name +\n                        \"#\" +\n                        relation.propertyPath +\n                        \" was not found. Check if you specified a correct entity object and if it's connected in the connection options.\",\n                )\n\n            relation.inverseEntityMetadata = inverseEntityMetadata\n            relation.inverseSidePropertyPath =\n                relation.buildInverseSidePropertyPath()\n\n            // and compute inverse relation and mark if it has such\n            relation.inverseRelation = inverseEntityMetadata.relations.find(\n                (foundRelation) =>\n                    foundRelation.propertyPath ===\n                    relation.inverseSidePropertyPath,\n            )\n        })\n    }\n\n    /**\n     * Creates indices for the table of single table inheritance.\n     */\n    protected createKeysForTableInheritance(entityMetadata: EntityMetadata) {\n        entityMetadata.indices.push(\n            new IndexMetadata({\n                entityMetadata: entityMetadata,\n                columns: [entityMetadata.discriminatorColumn!],\n                args: {\n                    target: entityMetadata.target,\n                    unique: false,\n                },\n            }),\n        )\n    }\n}\n"]},"metadata":{},"sourceType":"module"}