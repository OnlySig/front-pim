{"ast":null,"code":"/**\n * Repository is supposed to work with your entity objects. Find entities, insert, update, delete, etc.\n */\nexport class Repository {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(target, manager, queryRunner) {\n    this.target = target;\n    this.manager = manager;\n    this.queryRunner = queryRunner;\n  } // -------------------------------------------------------------------------\n  // Accessors\n  // -------------------------------------------------------------------------\n\n  /**\n   * Entity metadata of the entity current repository manages.\n   */\n\n\n  get metadata() {\n    return this.manager.connection.getMetadata(this.target);\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Creates a new query builder that can be used to build a SQL query.\n   */\n\n\n  createQueryBuilder(alias, queryRunner) {\n    return this.manager.createQueryBuilder(this.metadata.target, alias || this.metadata.targetName, queryRunner || this.queryRunner);\n  }\n  /**\n   * Checks if entity has an id.\n   * If entity composite compose ids, it will check them all.\n   */\n\n\n  hasId(entity) {\n    return this.manager.hasId(this.metadata.target, entity);\n  }\n  /**\n   * Gets entity mixed id.\n   */\n\n\n  getId(entity) {\n    return this.manager.getId(this.metadata.target, entity);\n  }\n  /**\n   * Creates a new entity instance or instances.\n   * Can copy properties from the given object into new entities.\n   */\n\n\n  create(plainEntityLikeOrPlainEntityLikes) {\n    return this.manager.create(this.metadata.target, plainEntityLikeOrPlainEntityLikes);\n  }\n  /**\n   * Merges multiple entities (or entity-like objects) into a given entity.\n   */\n\n\n  merge(mergeIntoEntity) {\n    for (var _len = arguments.length, entityLikes = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      entityLikes[_key - 1] = arguments[_key];\n    }\n\n    return this.manager.merge(this.metadata.target, mergeIntoEntity, ...entityLikes);\n  }\n  /**\n   * Creates a new entity from the given plain javascript object. If entity already exist in the database, then\n   * it loads it (and everything related to it), replaces all values with the new ones from the given object\n   * and returns this new entity. This new entity is actually a loaded from the db entity with all properties\n   * replaced from the new object.\n   *\n   * Note that given entity-like object must have an entity id / primary key to find entity by.\n   * Returns undefined if entity with given id was not found.\n   */\n\n\n  preload(entityLike) {\n    return this.manager.preload(this.metadata.target, entityLike);\n  }\n  /**\n   * Saves one or many given entities.\n   */\n\n\n  save(entityOrEntities, options) {\n    return this.manager.save(this.metadata.target, entityOrEntities, options);\n  }\n  /**\n   * Removes one or many given entities.\n   */\n\n\n  remove(entityOrEntities, options) {\n    return this.manager.remove(this.metadata.target, entityOrEntities, options);\n  }\n  /**\n   * Records the delete date of one or many given entities.\n   */\n\n\n  softRemove(entityOrEntities, options) {\n    return this.manager.softRemove(this.metadata.target, entityOrEntities, options);\n  }\n  /**\n   * Recovers one or many given entities.\n   */\n\n\n  recover(entityOrEntities, options) {\n    return this.manager.recover(this.metadata.target, entityOrEntities, options);\n  }\n  /**\n   * Inserts a given entity into the database.\n   * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n   * Executes fast and efficient INSERT query.\n   * Does not check if entity exist in the database, so query will fail if duplicate entity is being inserted.\n   */\n\n\n  insert(entity) {\n    return this.manager.insert(this.metadata.target, entity);\n  }\n  /**\n   * Updates entity partially. Entity can be found by a given conditions.\n   * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n   * Executes fast and efficient UPDATE query.\n   * Does not check if entity exist in the database.\n   */\n\n\n  update(criteria, partialEntity) {\n    return this.manager.update(this.metadata.target, criteria, partialEntity);\n  }\n  /**\n   * Inserts a given entity into the database, unless a unique constraint conflicts then updates the entity\n   * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n   * Executes fast and efficient INSERT ... ON CONFLICT DO UPDATE/ON DUPLICATE KEY UPDATE query.\n   */\n\n\n  upsert(entityOrEntities, conflictPathsOrOptions) {\n    return this.manager.upsert(this.metadata.target, entityOrEntities, conflictPathsOrOptions);\n  }\n  /**\n   * Deletes entities by a given criteria.\n   * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n   * Executes fast and efficient DELETE query.\n   * Does not check if entity exist in the database.\n   */\n\n\n  delete(criteria) {\n    return this.manager.delete(this.metadata.target, criteria);\n  }\n  /**\n   * Records the delete date of entities by a given criteria.\n   * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n   * Executes fast and efficient SOFT-DELETE query.\n   * Does not check if entity exist in the database.\n   */\n\n\n  softDelete(criteria) {\n    return this.manager.softDelete(this.metadata.target, criteria);\n  }\n  /**\n   * Restores entities by a given criteria.\n   * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n   * Executes fast and efficient SOFT-DELETE query.\n   * Does not check if entity exist in the database.\n   */\n\n\n  restore(criteria) {\n    return this.manager.restore(this.metadata.target, criteria);\n  }\n  /**\n   * Counts entities that match given options.\n   * Useful for pagination.\n   */\n\n\n  count(options) {\n    return this.manager.count(this.metadata.target, options);\n  }\n  /**\n   * Counts entities that match given conditions.\n   * Useful for pagination.\n   */\n\n\n  countBy(where) {\n    return this.manager.countBy(this.metadata.target, where);\n  }\n  /**\n   * Finds entities that match given find options.\n   */\n\n\n  async find(options) {\n    return this.manager.find(this.metadata.target, options);\n  }\n  /**\n   * Finds entities that match given find options.\n   */\n\n\n  async findBy(where) {\n    return this.manager.findBy(this.metadata.target, where);\n  }\n  /**\n   * Finds entities that match given find options.\n   * Also counts all entities that match given conditions,\n   * but ignores pagination settings (from and take options).\n   */\n\n\n  findAndCount(options) {\n    return this.manager.findAndCount(this.metadata.target, options);\n  }\n  /**\n   * Finds entities that match given WHERE conditions.\n   * Also counts all entities that match given conditions,\n   * but ignores pagination settings (from and take options).\n   */\n\n\n  findAndCountBy(where) {\n    return this.manager.findAndCountBy(this.metadata.target, where);\n  }\n  /**\n   * Finds entities with ids.\n   * Optionally find options or conditions can be applied.\n   *\n   * @deprecated use `findBy` method instead in conjunction with `In` operator, for example:\n   *\n   * .findBy({\n   *     id: In([1, 2, 3])\n   * })\n   */\n\n\n  async findByIds(ids) {\n    return this.manager.findByIds(this.metadata.target, ids);\n  }\n  /**\n   * Finds first entity by a given find options.\n   * If entity was not found in the database - returns null.\n   */\n\n\n  async findOne(options) {\n    return this.manager.findOne(this.metadata.target, options);\n  }\n  /**\n   * Finds first entity that matches given where condition.\n   * If entity was not found in the database - returns null.\n   */\n\n\n  async findOneBy(where) {\n    return this.manager.findOneBy(this.metadata.target, where);\n  }\n  /**\n   * Finds first entity that matches given id.\n   * If entity was not found in the database - returns null.\n   *\n   * @deprecated use `findOneBy` method instead in conjunction with `In` operator, for example:\n   *\n   * .findOneBy({\n   *     id: 1 // where \"id\" is your primary column name\n   * })\n   */\n\n\n  async findOneById(id) {\n    return this.manager.findOneById(this.metadata.target, id);\n  }\n  /**\n   * Finds first entity by a given find options.\n   * If entity was not found in the database - rejects with error.\n   */\n\n\n  async findOneOrFail(options) {\n    return this.manager.findOneOrFail(this.metadata.target, options);\n  }\n  /**\n   * Finds first entity that matches given where condition.\n   * If entity was not found in the database - rejects with error.\n   */\n\n\n  async findOneByOrFail(where) {\n    return this.manager.findOneByOrFail(this.metadata.target, where);\n  }\n  /**\n   * Executes a raw SQL query and returns a raw database results.\n   * Raw query execution is supported only by relational databases (MongoDB is not supported).\n   */\n\n\n  query(query, parameters) {\n    return this.manager.query(query, parameters);\n  }\n  /**\n   * Clears all the data from the given table/collection (truncates/drops it).\n   *\n   * Note: this method uses TRUNCATE and may not work as you expect in transactions on some platforms.\n   * @see https://stackoverflow.com/a/5972738/925151\n   */\n\n\n  clear() {\n    return this.manager.clear(this.metadata.target);\n  }\n  /**\n   * Increments some column by provided value of the entities matched given conditions.\n   */\n\n\n  increment(conditions, propertyPath, value) {\n    return this.manager.increment(this.metadata.target, conditions, propertyPath, value);\n  }\n  /**\n   * Decrements some column by provided value of the entities matched given conditions.\n   */\n\n\n  decrement(conditions, propertyPath, value) {\n    return this.manager.decrement(this.metadata.target, conditions, propertyPath, value);\n  }\n  /**\n   * Extends repository with provided functions.\n   */\n\n\n  extend(custom) {\n    // return {\n    //     ...this,\n    //     ...custom\n    // };\n    const thisRepo = this.constructor;\n    const {\n      target,\n      manager,\n      queryRunner\n    } = this;\n    const cls = new class extends thisRepo {}(target, manager, queryRunner);\n    Object.assign(cls, custom);\n    return cls;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["Repository","constructor","target","manager","queryRunner","metadata","connection","getMetadata","createQueryBuilder","alias","targetName","hasId","entity","getId","create","plainEntityLikeOrPlainEntityLikes","merge","mergeIntoEntity","entityLikes","preload","entityLike","save","entityOrEntities","options","remove","softRemove","recover","insert","update","criteria","partialEntity","upsert","conflictPathsOrOptions","delete","softDelete","restore","count","countBy","where","find","findBy","findAndCount","findAndCountBy","findByIds","ids","findOne","findOneBy","findOneById","id","findOneOrFail","findOneByOrFail","query","parameters","clear","increment","conditions","propertyPath","value","decrement","extend","custom","thisRepo","cls","Object","assign"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\repository\\Repository.ts"],"sourcesContent":["import { FindManyOptions } from \"../find-options/FindManyOptions\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { FindOneOptions } from \"../find-options/FindOneOptions\"\nimport { DeepPartial } from \"../common/DeepPartial\"\nimport { SaveOptions } from \"./SaveOptions\"\nimport { RemoveOptions } from \"./RemoveOptions\"\nimport { EntityManager } from \"../entity-manager/EntityManager\"\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\nimport { SelectQueryBuilder } from \"../query-builder/SelectQueryBuilder\"\nimport { DeleteResult } from \"../query-builder/result/DeleteResult\"\nimport { UpdateResult } from \"../query-builder/result/UpdateResult\"\nimport { InsertResult } from \"../query-builder/result/InsertResult\"\nimport { QueryDeepPartialEntity } from \"../query-builder/QueryPartialEntity\"\nimport { ObjectID } from \"../driver/mongodb/typings\"\nimport { FindOptionsWhere } from \"../find-options/FindOptionsWhere\"\nimport { UpsertOptions } from \"./UpsertOptions\"\nimport { EntityTarget } from \"../common/EntityTarget\"\n\n/**\n * Repository is supposed to work with your entity objects. Find entities, insert, update, delete, etc.\n */\nexport class Repository<Entity extends ObjectLiteral> {\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Entity target that is managed by this repository.\n     * If this repository manages entity from schema,\n     * then it returns a name of that schema instead.\n     */\n    readonly target: EntityTarget<Entity>\n\n    /**\n     * Entity Manager used by this repository.\n     */\n    readonly manager: EntityManager\n\n    /**\n     * Query runner provider used for this repository.\n     */\n    readonly queryRunner?: QueryRunner\n\n    // -------------------------------------------------------------------------\n    // Accessors\n    // -------------------------------------------------------------------------\n\n    /**\n     * Entity metadata of the entity current repository manages.\n     */\n    get metadata() {\n        return this.manager.connection.getMetadata(this.target)\n    }\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        target: EntityTarget<Entity>,\n        manager: EntityManager,\n        queryRunner?: QueryRunner,\n    ) {\n        this.target = target\n        this.manager = manager\n        this.queryRunner = queryRunner\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates a new query builder that can be used to build a SQL query.\n     */\n    createQueryBuilder(\n        alias?: string,\n        queryRunner?: QueryRunner,\n    ): SelectQueryBuilder<Entity> {\n        return this.manager.createQueryBuilder<Entity>(\n            this.metadata.target as any,\n            alias || this.metadata.targetName,\n            queryRunner || this.queryRunner,\n        )\n    }\n\n    /**\n     * Checks if entity has an id.\n     * If entity composite compose ids, it will check them all.\n     */\n    hasId(entity: Entity): boolean {\n        return this.manager.hasId(this.metadata.target, entity)\n    }\n\n    /**\n     * Gets entity mixed id.\n     */\n    getId(entity: Entity): any {\n        return this.manager.getId(this.metadata.target, entity)\n    }\n\n    /**\n     * Creates a new entity instance.\n     */\n    create(): Entity\n\n    /**\n     * Creates new entities and copies all entity properties from given objects into their new entities.\n     * Note that it copies only properties that are present in entity schema.\n     */\n    create(entityLikeArray: DeepPartial<Entity>[]): Entity[]\n\n    /**\n     * Creates a new entity instance and copies all entity properties from this object into a new entity.\n     * Note that it copies only properties that are present in entity schema.\n     */\n    create(entityLike: DeepPartial<Entity>): Entity\n\n    /**\n     * Creates a new entity instance or instances.\n     * Can copy properties from the given object into new entities.\n     */\n    create(\n        plainEntityLikeOrPlainEntityLikes?:\n            | DeepPartial<Entity>\n            | DeepPartial<Entity>[],\n    ): Entity | Entity[] {\n        return this.manager.create<any>(\n            this.metadata.target as any,\n            plainEntityLikeOrPlainEntityLikes as any,\n        )\n    }\n\n    /**\n     * Merges multiple entities (or entity-like objects) into a given entity.\n     */\n    merge(\n        mergeIntoEntity: Entity,\n        ...entityLikes: DeepPartial<Entity>[]\n    ): Entity {\n        return this.manager.merge(\n            this.metadata.target as any,\n            mergeIntoEntity,\n            ...entityLikes,\n        )\n    }\n\n    /**\n     * Creates a new entity from the given plain javascript object. If entity already exist in the database, then\n     * it loads it (and everything related to it), replaces all values with the new ones from the given object\n     * and returns this new entity. This new entity is actually a loaded from the db entity with all properties\n     * replaced from the new object.\n     *\n     * Note that given entity-like object must have an entity id / primary key to find entity by.\n     * Returns undefined if entity with given id was not found.\n     */\n    preload(entityLike: DeepPartial<Entity>): Promise<Entity | undefined> {\n        return this.manager.preload(this.metadata.target as any, entityLike)\n    }\n\n    /**\n     * Saves all given entities in the database.\n     * If entities do not exist in the database then inserts, otherwise updates.\n     */\n    save<T extends DeepPartial<Entity>>(\n        entities: T[],\n        options: SaveOptions & { reload: false },\n    ): Promise<T[]>\n\n    /**\n     * Saves all given entities in the database.\n     * If entities do not exist in the database then inserts, otherwise updates.\n     */\n    save<T extends DeepPartial<Entity>>(\n        entities: T[],\n        options?: SaveOptions,\n    ): Promise<(T & Entity)[]>\n\n    /**\n     * Saves a given entity in the database.\n     * If entity does not exist in the database then inserts, otherwise updates.\n     */\n    save<T extends DeepPartial<Entity>>(\n        entity: T,\n        options: SaveOptions & { reload: false },\n    ): Promise<T>\n\n    /**\n     * Saves a given entity in the database.\n     * If entity does not exist in the database then inserts, otherwise updates.\n     */\n    save<T extends DeepPartial<Entity>>(\n        entity: T,\n        options?: SaveOptions,\n    ): Promise<T & Entity>\n\n    /**\n     * Saves one or many given entities.\n     */\n    save<T extends DeepPartial<Entity>>(\n        entityOrEntities: T | T[],\n        options?: SaveOptions,\n    ): Promise<T | T[]> {\n        return this.manager.save<Entity, T>(\n            this.metadata.target as any,\n            entityOrEntities as any,\n            options,\n        )\n    }\n\n    /**\n     * Removes a given entities from the database.\n     */\n    remove(entities: Entity[], options?: RemoveOptions): Promise<Entity[]>\n\n    /**\n     * Removes a given entity from the database.\n     */\n    remove(entity: Entity, options?: RemoveOptions): Promise<Entity>\n\n    /**\n     * Removes one or many given entities.\n     */\n    remove(\n        entityOrEntities: Entity | Entity[],\n        options?: RemoveOptions,\n    ): Promise<Entity | Entity[]> {\n        return this.manager.remove(\n            this.metadata.target as any,\n            entityOrEntities as any,\n            options,\n        )\n    }\n\n    /**\n     * Records the delete date of all given entities.\n     */\n    softRemove<T extends DeepPartial<Entity>>(\n        entities: T[],\n        options: SaveOptions & { reload: false },\n    ): Promise<T[]>\n\n    /**\n     * Records the delete date of all given entities.\n     */\n    softRemove<T extends DeepPartial<Entity>>(\n        entities: T[],\n        options?: SaveOptions,\n    ): Promise<(T & Entity)[]>\n\n    /**\n     * Records the delete date of a given entity.\n     */\n    softRemove<T extends DeepPartial<Entity>>(\n        entity: T,\n        options: SaveOptions & { reload: false },\n    ): Promise<T>\n\n    /**\n     * Records the delete date of a given entity.\n     */\n    softRemove<T extends DeepPartial<Entity>>(\n        entity: T,\n        options?: SaveOptions,\n    ): Promise<T & Entity>\n\n    /**\n     * Records the delete date of one or many given entities.\n     */\n    softRemove<T extends DeepPartial<Entity>>(\n        entityOrEntities: T | T[],\n        options?: SaveOptions,\n    ): Promise<T | T[]> {\n        return this.manager.softRemove<Entity, T>(\n            this.metadata.target as any,\n            entityOrEntities as any,\n            options,\n        )\n    }\n\n    /**\n     * Recovers all given entities in the database.\n     */\n    recover<T extends DeepPartial<Entity>>(\n        entities: T[],\n        options: SaveOptions & { reload: false },\n    ): Promise<T[]>\n\n    /**\n     * Recovers all given entities in the database.\n     */\n    recover<T extends DeepPartial<Entity>>(\n        entities: T[],\n        options?: SaveOptions,\n    ): Promise<(T & Entity)[]>\n\n    /**\n     * Recovers a given entity in the database.\n     */\n    recover<T extends DeepPartial<Entity>>(\n        entity: T,\n        options: SaveOptions & { reload: false },\n    ): Promise<T>\n\n    /**\n     * Recovers a given entity in the database.\n     */\n    recover<T extends DeepPartial<Entity>>(\n        entity: T,\n        options?: SaveOptions,\n    ): Promise<T & Entity>\n\n    /**\n     * Recovers one or many given entities.\n     */\n    recover<T extends DeepPartial<Entity>>(\n        entityOrEntities: T | T[],\n        options?: SaveOptions,\n    ): Promise<T | T[]> {\n        return this.manager.recover<Entity, T>(\n            this.metadata.target as any,\n            entityOrEntities as any,\n            options,\n        )\n    }\n\n    /**\n     * Inserts a given entity into the database.\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient INSERT query.\n     * Does not check if entity exist in the database, so query will fail if duplicate entity is being inserted.\n     */\n    insert(\n        entity:\n            | QueryDeepPartialEntity<Entity>\n            | QueryDeepPartialEntity<Entity>[],\n    ): Promise<InsertResult> {\n        return this.manager.insert(this.metadata.target as any, entity)\n    }\n\n    /**\n     * Updates entity partially. Entity can be found by a given conditions.\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient UPDATE query.\n     * Does not check if entity exist in the database.\n     */\n    update(\n        criteria:\n            | string\n            | string[]\n            | number\n            | number[]\n            | Date\n            | Date[]\n            | ObjectID\n            | ObjectID[]\n            | FindOptionsWhere<Entity>,\n        partialEntity: QueryDeepPartialEntity<Entity>,\n    ): Promise<UpdateResult> {\n        return this.manager.update(\n            this.metadata.target as any,\n            criteria as any,\n            partialEntity,\n        )\n    }\n\n    /**\n     * Inserts a given entity into the database, unless a unique constraint conflicts then updates the entity\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient INSERT ... ON CONFLICT DO UPDATE/ON DUPLICATE KEY UPDATE query.\n     */\n    upsert(\n        entityOrEntities:\n            | QueryDeepPartialEntity<Entity>\n            | QueryDeepPartialEntity<Entity>[],\n        conflictPathsOrOptions: string[] | UpsertOptions<Entity>,\n    ): Promise<InsertResult> {\n        return this.manager.upsert(\n            this.metadata.target as any,\n            entityOrEntities,\n            conflictPathsOrOptions,\n        )\n    }\n\n    /**\n     * Deletes entities by a given criteria.\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient DELETE query.\n     * Does not check if entity exist in the database.\n     */\n    delete(\n        criteria:\n            | string\n            | string[]\n            | number\n            | number[]\n            | Date\n            | Date[]\n            | ObjectID\n            | ObjectID[]\n            | FindOptionsWhere<Entity>,\n    ): Promise<DeleteResult> {\n        return this.manager.delete(this.metadata.target as any, criteria as any)\n    }\n\n    /**\n     * Records the delete date of entities by a given criteria.\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient SOFT-DELETE query.\n     * Does not check if entity exist in the database.\n     */\n    softDelete(\n        criteria:\n            | string\n            | string[]\n            | number\n            | number[]\n            | Date\n            | Date[]\n            | ObjectID\n            | ObjectID[]\n            | FindOptionsWhere<Entity>,\n    ): Promise<UpdateResult> {\n        return this.manager.softDelete(\n            this.metadata.target as any,\n            criteria as any,\n        )\n    }\n\n    /**\n     * Restores entities by a given criteria.\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient SOFT-DELETE query.\n     * Does not check if entity exist in the database.\n     */\n    restore(\n        criteria:\n            | string\n            | string[]\n            | number\n            | number[]\n            | Date\n            | Date[]\n            | ObjectID\n            | ObjectID[]\n            | FindOptionsWhere<Entity>,\n    ): Promise<UpdateResult> {\n        return this.manager.restore(\n            this.metadata.target as any,\n            criteria as any,\n        )\n    }\n\n    /**\n     * Counts entities that match given options.\n     * Useful for pagination.\n     */\n    count(options?: FindManyOptions<Entity>): Promise<number> {\n        return this.manager.count(this.metadata.target, options)\n    }\n\n    /**\n     * Counts entities that match given conditions.\n     * Useful for pagination.\n     */\n    countBy(\n        where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    ): Promise<number> {\n        return this.manager.countBy(this.metadata.target, where)\n    }\n\n    /**\n     * Finds entities that match given find options.\n     */\n    async find(options?: FindManyOptions<Entity>): Promise<Entity[]> {\n        return this.manager.find(this.metadata.target, options)\n    }\n\n    /**\n     * Finds entities that match given find options.\n     */\n    async findBy(\n        where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    ): Promise<Entity[]> {\n        return this.manager.findBy(this.metadata.target, where)\n    }\n\n    /**\n     * Finds entities that match given find options.\n     * Also counts all entities that match given conditions,\n     * but ignores pagination settings (from and take options).\n     */\n    findAndCount(\n        options?: FindManyOptions<Entity>,\n    ): Promise<[Entity[], number]> {\n        return this.manager.findAndCount(this.metadata.target, options)\n    }\n\n    /**\n     * Finds entities that match given WHERE conditions.\n     * Also counts all entities that match given conditions,\n     * but ignores pagination settings (from and take options).\n     */\n    findAndCountBy(\n        where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    ): Promise<[Entity[], number]> {\n        return this.manager.findAndCountBy(this.metadata.target, where)\n    }\n\n    /**\n     * Finds entities with ids.\n     * Optionally find options or conditions can be applied.\n     *\n     * @deprecated use `findBy` method instead in conjunction with `In` operator, for example:\n     *\n     * .findBy({\n     *     id: In([1, 2, 3])\n     * })\n     */\n    async findByIds(ids: any[]): Promise<Entity[]> {\n        return this.manager.findByIds(this.metadata.target, ids)\n    }\n\n    /**\n     * Finds first entity by a given find options.\n     * If entity was not found in the database - returns null.\n     */\n    async findOne(options: FindOneOptions<Entity>): Promise<Entity | null> {\n        return this.manager.findOne(this.metadata.target, options)\n    }\n\n    /**\n     * Finds first entity that matches given where condition.\n     * If entity was not found in the database - returns null.\n     */\n    async findOneBy(\n        where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    ): Promise<Entity | null> {\n        return this.manager.findOneBy(this.metadata.target, where)\n    }\n\n    /**\n     * Finds first entity that matches given id.\n     * If entity was not found in the database - returns null.\n     *\n     * @deprecated use `findOneBy` method instead in conjunction with `In` operator, for example:\n     *\n     * .findOneBy({\n     *     id: 1 // where \"id\" is your primary column name\n     * })\n     */\n    async findOneById(\n        id: number | string | Date | ObjectID,\n    ): Promise<Entity | null> {\n        return this.manager.findOneById(this.metadata.target, id)\n    }\n\n    /**\n     * Finds first entity by a given find options.\n     * If entity was not found in the database - rejects with error.\n     */\n    async findOneOrFail(options: FindOneOptions<Entity>): Promise<Entity> {\n        return this.manager.findOneOrFail(this.metadata.target, options)\n    }\n\n    /**\n     * Finds first entity that matches given where condition.\n     * If entity was not found in the database - rejects with error.\n     */\n    async findOneByOrFail(\n        where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    ): Promise<Entity> {\n        return this.manager.findOneByOrFail(this.metadata.target, where)\n    }\n\n    /**\n     * Executes a raw SQL query and returns a raw database results.\n     * Raw query execution is supported only by relational databases (MongoDB is not supported).\n     */\n    query(query: string, parameters?: any[]): Promise<any> {\n        return this.manager.query(query, parameters)\n    }\n\n    /**\n     * Clears all the data from the given table/collection (truncates/drops it).\n     *\n     * Note: this method uses TRUNCATE and may not work as you expect in transactions on some platforms.\n     * @see https://stackoverflow.com/a/5972738/925151\n     */\n    clear(): Promise<void> {\n        return this.manager.clear(this.metadata.target)\n    }\n\n    /**\n     * Increments some column by provided value of the entities matched given conditions.\n     */\n    increment(\n        conditions: FindOptionsWhere<Entity>,\n        propertyPath: string,\n        value: number | string,\n    ): Promise<UpdateResult> {\n        return this.manager.increment(\n            this.metadata.target,\n            conditions,\n            propertyPath,\n            value,\n        )\n    }\n\n    /**\n     * Decrements some column by provided value of the entities matched given conditions.\n     */\n    decrement(\n        conditions: FindOptionsWhere<Entity>,\n        propertyPath: string,\n        value: number | string,\n    ): Promise<UpdateResult> {\n        return this.manager.decrement(\n            this.metadata.target,\n            conditions,\n            propertyPath,\n            value,\n        )\n    }\n\n    /**\n     * Extends repository with provided functions.\n     */\n    extend<CustomRepository>(\n        custom: CustomRepository &\n            ThisType<Repository<Entity> & CustomRepository>,\n    ): Repository<Entity> & CustomRepository {\n        // return {\n        //     ...this,\n        //     ...custom\n        // };\n        const thisRepo = this.constructor as new (...args: any[]) => typeof this\n        const { target, manager, queryRunner } = this\n        const cls = new (class extends thisRepo {})(\n            target,\n            manager,\n            queryRunner,\n        )\n        Object.assign(cls, custom)\n        return cls as any\n    }\n}\n"]},"metadata":{},"sourceType":"module"}