{"ast":null,"code":"import { DriverPackageNotInstalledError } from \"../../error/DriverPackageNotInstalledError\";\nimport { SpannerQueryRunner } from \"./SpannerQueryRunner\";\nimport { DateUtils } from \"../../util/DateUtils\";\nimport { PlatformTools } from \"../../platform/PlatformTools\";\nimport { RdbmsSchemaBuilder } from \"../../schema-builder/RdbmsSchemaBuilder\";\nimport { EntityMetadata } from \"../../metadata/EntityMetadata\";\nimport { OrmUtils } from \"../../util/OrmUtils\";\nimport { ApplyValueTransformers } from \"../../util/ApplyValueTransformers\";\nimport { Table } from \"../../schema-builder/table/Table\";\nimport { View } from \"../../schema-builder/view/View\";\nimport { TableForeignKey } from \"../../schema-builder/table/TableForeignKey\";\n/**\n * Organizes communication with Spanner DBMS.\n */\n\nexport class SpannerDriver {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection) {\n    /**\n     * Indicates if replication is enabled.\n     */\n    this.isReplicated = false;\n    /**\n     * Indicates if tree tables are supported by this driver.\n     */\n\n    this.treeSupport = true;\n    /**\n     * Represent transaction support by this driver\n     */\n\n    this.transactionSupport = \"none\";\n    /**\n     * Gets list of supported column data types by a driver.\n     *\n     * @see https://cloud.google.com/spanner/docs/reference/standard-sql/data-types\n     */\n\n    this.supportedDataTypes = [\"bool\", \"int64\", \"float64\", \"numeric\", \"string\", \"json\", \"bytes\", \"date\", \"timestamp\", \"array\"];\n    /**\n     * Returns type of upsert supported by driver if any\n     */\n\n    this.supportedUpsertType = undefined;\n    /**\n     * Gets list of spatial column data types.\n     */\n\n    this.spatialTypes = [];\n    /**\n     * Gets list of column data types that support length by a driver.\n     */\n\n    this.withLengthColumnTypes = [\"string\", \"bytes\"];\n    /**\n     * Gets list of column data types that support length by a driver.\n     */\n\n    this.withWidthColumnTypes = [];\n    /**\n     * Gets list of column data types that support precision by a driver.\n     */\n\n    this.withPrecisionColumnTypes = [];\n    /**\n     * Gets list of column data types that supports scale by a driver.\n     */\n\n    this.withScaleColumnTypes = [];\n    /**\n     * ORM has special columns and we need to know what database column types should be for those columns.\n     * Column types are driver dependant.\n     */\n\n    this.mappedDataTypes = {\n      createDate: \"timestamp\",\n      createDateDefault: \"\",\n      updateDate: \"timestamp\",\n      updateDateDefault: \"\",\n      deleteDate: \"timestamp\",\n      deleteDateNullable: true,\n      version: \"int64\",\n      treeLevel: \"int64\",\n      migrationId: \"int64\",\n      migrationName: \"string\",\n      migrationTimestamp: \"int64\",\n      cacheId: \"string\",\n      cacheIdentifier: \"string\",\n      cacheTime: \"int64\",\n      cacheDuration: \"int64\",\n      cacheQuery: \"string\",\n      cacheResult: \"string\",\n      metadataType: \"string\",\n      metadataDatabase: \"string\",\n      metadataSchema: \"string\",\n      metadataTable: \"string\",\n      metadataName: \"string\",\n      metadataValue: \"string\"\n    };\n    /**\n     * Default values of length, precision and scale depends on column data type.\n     * Used in the cases when length/precision/scale is not specified by user.\n     */\n\n    this.dataTypeDefaults = {};\n    /**\n     * Max length allowed by MySQL for aliases.\n     * @see https://dev.mysql.com/doc/refman/5.5/en/identifiers.html\n     */\n\n    this.maxAliasLength = 63;\n    this.cteCapabilities = {\n      enabled: true\n    };\n    /**\n     * Supported returning types\n     */\n\n    this._isReturningSqlSupported = {\n      delete: false,\n      insert: false,\n      update: false\n    };\n    this.connection = connection;\n    this.options = connection.options;\n    this.isReplicated = this.options.replication ? true : false; // load mysql package\n\n    this.loadDependencies();\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Performs connection to the database.\n   */\n\n\n  async connect() {\n    this.instance = this.spanner.instance(this.options.instanceId);\n    this.instanceDatabase = this.instance.database(this.options.databaseId);\n  }\n  /**\n   * Makes any action after connection (e.g. create extensions in Postgres driver).\n   */\n\n\n  afterConnect() {\n    return Promise.resolve();\n  }\n  /**\n   * Closes connection with the database.\n   */\n\n\n  async disconnect() {\n    this.instanceDatabase.close();\n  }\n  /**\n   * Creates a schema builder used to build and sync a schema.\n   */\n\n\n  createSchemaBuilder() {\n    return new RdbmsSchemaBuilder(this.connection);\n  }\n  /**\n   * Creates a query runner used to execute database queries.\n   */\n\n\n  createQueryRunner(mode) {\n    return new SpannerQueryRunner(this, mode);\n  }\n  /**\n   * Replaces parameters in the given sql with special escaping character\n   * and an array of parameter names to be passed to a query.\n   */\n\n\n  escapeQueryWithParameters(sql, parameters, nativeParameters) {\n    const escapedParameters = Object.keys(nativeParameters).map(key => nativeParameters[key]);\n    if (!parameters || !Object.keys(parameters).length) return [sql, escapedParameters];\n    sql = sql.replace(/:(\\.\\.\\.)?([A-Za-z0-9_.]+)/g, (full, isArray, key) => {\n      if (!parameters.hasOwnProperty(key)) {\n        return full;\n      }\n\n      let value = parameters[key];\n\n      if (value === null) {\n        return full;\n      }\n\n      if (isArray) {\n        return value.map(v => {\n          escapedParameters.push(v);\n          return this.createParameter(key, escapedParameters.length - 1);\n        }).join(\", \");\n      }\n\n      if (value instanceof Function) {\n        return value();\n      }\n\n      escapedParameters.push(value);\n      return this.createParameter(key, escapedParameters.length - 1);\n    }); // todo: make replace only in value statements, otherwise problems\n\n    sql = sql.replace(/([ ]+)?=([ ]+)?:(\\.\\.\\.)?([A-Za-z0-9_.]+)/g, (full, emptySpaceBefore, emptySpaceAfter, isArray, key) => {\n      if (!parameters.hasOwnProperty(key)) {\n        return full;\n      }\n\n      let value = parameters[key];\n\n      if (value === null) {\n        return \" IS NULL\";\n      }\n\n      return full;\n    });\n    return [sql, escapedParameters];\n  }\n  /**\n   * Escapes a column name.\n   */\n\n\n  escape(columnName) {\n    return `\\`${columnName}\\``;\n  }\n  /**\n   * Build full table name with database name, schema name and table name.\n   * E.g. myDB.mySchema.myTable\n   */\n\n\n  buildTableName(tableName, schema, database) {\n    let tablePath = [tableName];\n\n    if (database) {\n      tablePath.unshift(database);\n    }\n\n    return tablePath.join(\".\");\n  }\n  /**\n   * Parse a target table name or other types and return a normalized table definition.\n   */\n\n\n  parseTableName(target) {\n    const driverDatabase = this.database;\n    const driverSchema = undefined;\n\n    if (target instanceof Table || target instanceof View) {\n      const parsed = this.parseTableName(target.name);\n      return {\n        database: target.database || parsed.database || driverDatabase,\n        schema: target.schema || parsed.schema || driverSchema,\n        tableName: parsed.tableName\n      };\n    }\n\n    if (target instanceof TableForeignKey) {\n      const parsed = this.parseTableName(target.referencedTableName);\n      return {\n        database: target.referencedDatabase || parsed.database || driverDatabase,\n        schema: target.referencedSchema || parsed.schema || driverSchema,\n        tableName: parsed.tableName\n      };\n    }\n\n    if (target instanceof EntityMetadata) {\n      // EntityMetadata tableName is never a path\n      return {\n        database: target.database || driverDatabase,\n        schema: target.schema || driverSchema,\n        tableName: target.tableName\n      };\n    }\n\n    const parts = target.split(\".\");\n    return {\n      database: (parts.length > 1 ? parts[0] : undefined) || driverDatabase,\n      schema: driverSchema,\n      tableName: parts.length > 1 ? parts[1] : parts[0]\n    };\n  }\n  /**\n   * Prepares given value to a value to be persisted, based on its column type and metadata.\n   */\n\n\n  preparePersistentValue(value, columnMetadata) {\n    if (columnMetadata.transformer) value = ApplyValueTransformers.transformTo(columnMetadata.transformer, value);\n    if (value === null || value === undefined) return value;\n\n    if (columnMetadata.type === \"numeric\") {\n      const lib = this.options.driver || PlatformTools.load(\"spanner\");\n      return lib.Spanner.numeric(value);\n    } else if (columnMetadata.type === \"date\") {\n      return DateUtils.mixedDateToDateString(value);\n    } else if (columnMetadata.type === \"json\") {\n      return value;\n    } else if (columnMetadata.type === \"timestamp\" || columnMetadata.type === Date) {\n      return DateUtils.mixedDateToDate(value);\n    }\n\n    return value;\n  }\n  /**\n   * Prepares given value to a value to be persisted, based on its column type or metadata.\n   */\n\n\n  prepareHydratedValue(value, columnMetadata) {\n    if (value === null || value === undefined) return columnMetadata.transformer ? ApplyValueTransformers.transformFrom(columnMetadata.transformer, value) : value;\n\n    if (columnMetadata.type === Boolean || columnMetadata.type === \"bool\") {\n      value = value ? true : false;\n    } else if (columnMetadata.type === \"timestamp\" || columnMetadata.type === Date) {\n      value = new Date(value);\n    } else if (columnMetadata.type === \"numeric\") {\n      value = value.value;\n    } else if (columnMetadata.type === \"date\") {\n      value = DateUtils.mixedDateToDateString(value);\n    } else if (columnMetadata.type === \"json\") {\n      value = typeof value === \"string\" ? JSON.parse(value) : value;\n    }\n\n    if (columnMetadata.transformer) value = ApplyValueTransformers.transformFrom(columnMetadata.transformer, value);\n    return value;\n  }\n  /**\n   * Creates a database type from a given column metadata.\n   */\n\n\n  normalizeType(column) {\n    if (column.type === Number) {\n      return \"int64\";\n    } else if (column.type === String || column.type === \"uuid\") {\n      return \"string\";\n    } else if (column.type === Date) {\n      return \"timestamp\";\n    } else if (column.type === Buffer) {\n      return \"bytes\";\n    } else if (column.type === Boolean) {\n      return \"bool\";\n    } else {\n      return column.type || \"\";\n    }\n  }\n  /**\n   * Normalizes \"default\" value of the column.\n   *\n   * Spanner does not support default values.\n   */\n\n\n  normalizeDefault(columnMetadata) {\n    return columnMetadata.default === \"\" ? `\"${columnMetadata.default}\"` : `${columnMetadata.default}`;\n  }\n  /**\n   * Normalizes \"isUnique\" value of the column.\n   */\n\n\n  normalizeIsUnique(column) {\n    return column.entityMetadata.indices.some(idx => idx.isUnique && idx.columns.length === 1 && idx.columns[0] === column);\n  }\n  /**\n   * Returns default column lengths, which is required on column creation.\n   */\n\n\n  getColumnLength(column) {\n    if (column.length) return column.length.toString();\n    if (column.generationStrategy === \"uuid\") return \"36\";\n\n    switch (column.type) {\n      case String:\n      case \"string\":\n      case \"bytes\":\n        return \"max\";\n\n      default:\n        return \"\";\n    }\n  }\n  /**\n   * Creates column type definition including length, precision and scale\n   */\n\n\n  createFullType(column) {\n    let type = column.type; // used 'getColumnLength()' method, because Spanner requires column length for `string` and `bytes` data types\n\n    if (this.getColumnLength(column)) {\n      type += `(${this.getColumnLength(column)})`;\n    } else if (column.width) {\n      type += `(${column.width})`;\n    } else if (column.precision !== null && column.precision !== undefined && column.scale !== null && column.scale !== undefined) {\n      type += `(${column.precision},${column.scale})`;\n    } else if (column.precision !== null && column.precision !== undefined) {\n      type += `(${column.precision})`;\n    }\n\n    if (column.isArray) type = `array<${type}>`;\n    return type;\n  }\n  /**\n   * Obtains a new database connection to a master server.\n   * Used for replication.\n   * If replication is not setup then returns default connection's database connection.\n   */\n\n\n  obtainMasterConnection() {\n    return this.instanceDatabase;\n  }\n  /**\n   * Obtains a new database connection to a slave server.\n   * Used for replication.\n   * If replication is not setup then returns master (default) connection's database connection.\n   */\n\n\n  obtainSlaveConnection() {\n    return this.instanceDatabase;\n  }\n  /**\n   * Creates generated map of values generated or returned by database after INSERT query.\n   */\n\n\n  createGeneratedMap(metadata, insertResult, entityIndex) {\n    if (!insertResult) {\n      return undefined;\n    }\n\n    if (insertResult.insertId === undefined) {\n      return Object.keys(insertResult).reduce((map, key) => {\n        const column = metadata.findColumnWithDatabaseName(key);\n\n        if (column) {\n          OrmUtils.mergeDeep(map, column.createValueMap(insertResult[key])); // OrmUtils.mergeDeep(map, column.createValueMap(this.prepareHydratedValue(insertResult[key], column))); // TODO: probably should be like there, but fails on enums, fix later\n        }\n\n        return map;\n      }, {});\n    }\n\n    const generatedMap = metadata.generatedColumns.reduce((map, generatedColumn) => {\n      let value;\n\n      if (generatedColumn.generationStrategy === \"increment\" && insertResult.insertId) {\n        // NOTE: When multiple rows is inserted by a single INSERT statement,\n        // `insertId` is the value generated for the first inserted row only.\n        value = insertResult.insertId + entityIndex; // } else if (generatedColumn.generationStrategy === \"uuid\") {\n        //     console.log(\"getting db value:\", generatedColumn.databaseName);\n        //     value = generatedColumn.getEntityValue(uuidMap);\n      }\n\n      return OrmUtils.mergeDeep(map, generatedColumn.createValueMap(value));\n    }, {});\n    return Object.keys(generatedMap).length > 0 ? generatedMap : undefined;\n  }\n  /**\n   * Differentiate columns of this table and columns from the given column metadatas columns\n   * and returns only changed.\n   */\n\n\n  findChangedColumns(tableColumns, columnMetadatas) {\n    return columnMetadatas.filter(columnMetadata => {\n      const tableColumn = tableColumns.find(c => c.name === columnMetadata.databaseName);\n      if (!tableColumn) return false; // we don't need new columns, we only need exist and changed\n\n      const isColumnChanged = tableColumn.name !== columnMetadata.databaseName || tableColumn.type !== this.normalizeType(columnMetadata) || tableColumn.length !== this.getColumnLength(columnMetadata) || tableColumn.asExpression !== columnMetadata.asExpression || tableColumn.generatedType !== columnMetadata.generatedType || tableColumn.isPrimary !== columnMetadata.isPrimary || !this.compareNullableValues(columnMetadata, tableColumn) || tableColumn.isUnique !== this.normalizeIsUnique(columnMetadata); // DEBUG SECTION\n      // if (isColumnChanged) {\n      //     console.log(\"table:\", columnMetadata.entityMetadata.tableName)\n      //     console.log(\n      //         \"name:\",\n      //         tableColumn.name,\n      //         columnMetadata.databaseName,\n      //     )\n      //     console.log(\n      //         \"type:\",\n      //         tableColumn.type,\n      //         this.normalizeType(columnMetadata),\n      //     )\n      //     console.log(\n      //         \"length:\",\n      //         tableColumn.length,\n      //         this.getColumnLength(columnMetadata),\n      //     )\n      //     console.log(\n      //         \"asExpression:\",\n      //         tableColumn.asExpression,\n      //         columnMetadata.asExpression,\n      //     )\n      //     console.log(\n      //         \"generatedType:\",\n      //         tableColumn.generatedType,\n      //         columnMetadata.generatedType,\n      //     )\n      //     console.log(\n      //         \"isPrimary:\",\n      //         tableColumn.isPrimary,\n      //         columnMetadata.isPrimary,\n      //     )\n      //     console.log(\n      //         \"isNullable:\",\n      //         tableColumn.isNullable,\n      //         columnMetadata.isNullable,\n      //     )\n      //     console.log(\n      //         \"isUnique:\",\n      //         tableColumn.isUnique,\n      //         this.normalizeIsUnique(columnMetadata),\n      //     )\n      //     console.log(\"==========================================\")\n      // }\n\n      return isColumnChanged;\n    });\n  }\n  /**\n   * Returns true if driver supports RETURNING / OUTPUT statement.\n   */\n\n\n  isReturningSqlSupported(returningType) {\n    return this._isReturningSqlSupported[returningType];\n  }\n  /**\n   * Returns true if driver supports uuid values generation on its own.\n   */\n\n\n  isUUIDGenerationSupported() {\n    return false;\n  }\n  /**\n   * Returns true if driver supports fulltext indices.\n   */\n\n\n  isFullTextColumnTypeSupported() {\n    return false;\n  }\n  /**\n   * Creates an escaped parameter.\n   */\n\n\n  createParameter(parameterName, index) {\n    return \"@param\" + index;\n  } // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Loads all driver dependencies.\n   */\n\n\n  loadDependencies() {\n    try {\n      const lib = this.options.driver || PlatformTools.load(\"spanner\");\n      this.spanner = new lib.Spanner({\n        projectId: this.options.projectId\n      });\n    } catch (e) {\n      console.error(e);\n      throw new DriverPackageNotInstalledError(\"Spanner\", \"@google-cloud/spanner\");\n    }\n  }\n\n  compareNullableValues(columnMetadata, tableColumn) {\n    // Spanner does not support NULL/NOT NULL expressions for generated columns\n    if (columnMetadata.generatedType) {\n      return true;\n    }\n\n    return columnMetadata.isNullable === tableColumn.isNullable;\n  }\n  /**\n   * Checks if \"DEFAULT\" values in the column metadata and in the database are equal.\n   */\n\n\n  compareDefaultValues(columnMetadataValue, databaseValue) {\n    if (typeof columnMetadataValue === \"string\" && typeof databaseValue === \"string\") {\n      // we need to cut out \"'\" because in mysql we can understand returned value is a string or a function\n      // as result compare cannot understand if default is really changed or not\n      columnMetadataValue = columnMetadataValue.replace(/^'+|'+$/g, \"\");\n      databaseValue = databaseValue.replace(/^'+|'+$/g, \"\");\n    }\n\n    return columnMetadataValue === databaseValue;\n  }\n  /**\n   * If parameter is a datetime function, e.g. \"CURRENT_TIMESTAMP\", normalizes it.\n   * Otherwise returns original input.\n   */\n\n\n  normalizeDatetimeFunction(value) {\n    if (!value) return value; // check if input is datetime function\n\n    const isDatetimeFunction = value.toUpperCase().indexOf(\"CURRENT_TIMESTAMP\") !== -1 || value.toUpperCase().indexOf(\"NOW\") !== -1;\n\n    if (isDatetimeFunction) {\n      // extract precision, e.g. \"(3)\"\n      const precision = value.match(/\\(\\d+\\)/);\n      return precision ? `CURRENT_TIMESTAMP${precision[0]}` : \"CURRENT_TIMESTAMP\";\n    } else {\n      return value;\n    }\n  }\n  /**\n   * Escapes a given comment.\n   */\n\n\n  escapeComment(comment) {\n    if (!comment) return comment;\n    comment = comment.replace(/\\u0000/g, \"\"); // Null bytes aren't allowed in comments\n\n    return comment;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["DriverPackageNotInstalledError","SpannerQueryRunner","DateUtils","PlatformTools","RdbmsSchemaBuilder","EntityMetadata","OrmUtils","ApplyValueTransformers","Table","View","TableForeignKey","SpannerDriver","constructor","connection","undefined","createDate","createDateDefault","updateDate","updateDateDefault","deleteDate","deleteDateNullable","version","treeLevel","migrationId","migrationName","migrationTimestamp","cacheId","cacheIdentifier","cacheTime","cacheDuration","cacheQuery","cacheResult","metadataType","metadataDatabase","metadataSchema","metadataTable","metadataName","metadataValue","enabled","delete","insert","update","options","isReplicated","replication","loadDependencies","connect","instance","spanner","instanceId","instanceDatabase","database","databaseId","afterConnect","Promise","resolve","disconnect","close","createSchemaBuilder","createQueryRunner","mode","escapeQueryWithParameters","sql","parameters","nativeParameters","escapedParameters","Object","keys","map","key","length","replace","full","isArray","hasOwnProperty","value","v","push","createParameter","join","Function","emptySpaceBefore","emptySpaceAfter","escape","columnName","buildTableName","tableName","schema","tablePath","unshift","parseTableName","target","driverDatabase","driverSchema","parsed","name","referencedTableName","referencedDatabase","referencedSchema","parts","split","preparePersistentValue","columnMetadata","transformer","transformTo","type","lib","driver","load","Spanner","numeric","mixedDateToDateString","Date","mixedDateToDate","prepareHydratedValue","transformFrom","Boolean","JSON","parse","normalizeType","column","Number","String","Buffer","normalizeDefault","default","normalizeIsUnique","entityMetadata","indices","some","idx","isUnique","columns","getColumnLength","toString","generationStrategy","createFullType","width","precision","scale","obtainMasterConnection","obtainSlaveConnection","createGeneratedMap","metadata","insertResult","entityIndex","insertId","reduce","findColumnWithDatabaseName","mergeDeep","createValueMap","generatedMap","generatedColumns","generatedColumn","findChangedColumns","tableColumns","columnMetadatas","filter","tableColumn","find","c","databaseName","isColumnChanged","asExpression","generatedType","isPrimary","compareNullableValues","isReturningSqlSupported","returningType","_isReturningSqlSupported","isUUIDGenerationSupported","isFullTextColumnTypeSupported","parameterName","index","projectId","e","console","error","isNullable","compareDefaultValues","columnMetadataValue","databaseValue","normalizeDatetimeFunction","isDatetimeFunction","toUpperCase","indexOf","match","escapeComment","comment"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\driver\\spanner\\SpannerDriver.ts"],"sourcesContent":["import { Driver, ReturningType } from \"../Driver\"\nimport { DriverPackageNotInstalledError } from \"../../error/DriverPackageNotInstalledError\"\nimport { SpannerQueryRunner } from \"./SpannerQueryRunner\"\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { ColumnMetadata } from \"../../metadata/ColumnMetadata\"\nimport { DateUtils } from \"../../util/DateUtils\"\nimport { PlatformTools } from \"../../platform/PlatformTools\"\nimport { Connection } from \"../../connection/Connection\"\nimport { RdbmsSchemaBuilder } from \"../../schema-builder/RdbmsSchemaBuilder\"\nimport { SpannerConnectionOptions } from \"./SpannerConnectionOptions\"\nimport { MappedColumnTypes } from \"../types/MappedColumnTypes\"\nimport { ColumnType } from \"../types/ColumnTypes\"\nimport { DataTypeDefaults } from \"../types/DataTypeDefaults\"\nimport { TableColumn } from \"../../schema-builder/table/TableColumn\"\nimport { EntityMetadata } from \"../../metadata/EntityMetadata\"\nimport { OrmUtils } from \"../../util/OrmUtils\"\nimport { ApplyValueTransformers } from \"../../util/ApplyValueTransformers\"\nimport { ReplicationMode } from \"../types/ReplicationMode\"\nimport { Table } from \"../../schema-builder/table/Table\"\nimport { View } from \"../../schema-builder/view/View\"\nimport { TableForeignKey } from \"../../schema-builder/table/TableForeignKey\"\nimport { CteCapabilities } from \"../types/CteCapabilities\"\n\n/**\n * Organizes communication with Spanner DBMS.\n */\nexport class SpannerDriver implements Driver {\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Connection used by driver.\n     */\n    connection: Connection\n\n    /**\n     * Cloud Spanner underlying library.\n     */\n    spanner: any\n\n    /**\n     * Cloud Spanner instance.\n     */\n    instance: any\n\n    /**\n     * Cloud Spanner database.\n     */\n    instanceDatabase: any\n\n    /**\n     * Database name.\n     */\n    database?: string\n\n    // -------------------------------------------------------------------------\n    // Public Implemented Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Connection options.\n     */\n    options: SpannerConnectionOptions\n\n    /**\n     * Indicates if replication is enabled.\n     */\n    isReplicated: boolean = false\n\n    /**\n     * Indicates if tree tables are supported by this driver.\n     */\n    treeSupport = true\n\n    /**\n     * Represent transaction support by this driver\n     */\n    transactionSupport = \"none\" as const\n\n    /**\n     * Gets list of supported column data types by a driver.\n     *\n     * @see https://cloud.google.com/spanner/docs/reference/standard-sql/data-types\n     */\n    supportedDataTypes: ColumnType[] = [\n        \"bool\",\n        \"int64\",\n        \"float64\",\n        \"numeric\",\n        \"string\",\n        \"json\",\n        \"bytes\",\n        \"date\",\n        \"timestamp\",\n        \"array\",\n    ]\n\n    /**\n     * Returns type of upsert supported by driver if any\n     */\n    readonly supportedUpsertType = undefined\n\n    /**\n     * Gets list of spatial column data types.\n     */\n    spatialTypes: ColumnType[] = []\n\n    /**\n     * Gets list of column data types that support length by a driver.\n     */\n    withLengthColumnTypes: ColumnType[] = [\"string\", \"bytes\"]\n\n    /**\n     * Gets list of column data types that support length by a driver.\n     */\n    withWidthColumnTypes: ColumnType[] = []\n\n    /**\n     * Gets list of column data types that support precision by a driver.\n     */\n    withPrecisionColumnTypes: ColumnType[] = []\n\n    /**\n     * Gets list of column data types that supports scale by a driver.\n     */\n    withScaleColumnTypes: ColumnType[] = []\n\n    /**\n     * ORM has special columns and we need to know what database column types should be for those columns.\n     * Column types are driver dependant.\n     */\n    mappedDataTypes: MappedColumnTypes = {\n        createDate: \"timestamp\",\n        createDateDefault: \"\",\n        updateDate: \"timestamp\",\n        updateDateDefault: \"\",\n        deleteDate: \"timestamp\",\n        deleteDateNullable: true,\n        version: \"int64\",\n        treeLevel: \"int64\",\n        migrationId: \"int64\",\n        migrationName: \"string\",\n        migrationTimestamp: \"int64\",\n        cacheId: \"string\",\n        cacheIdentifier: \"string\",\n        cacheTime: \"int64\",\n        cacheDuration: \"int64\",\n        cacheQuery: \"string\",\n        cacheResult: \"string\",\n        metadataType: \"string\",\n        metadataDatabase: \"string\",\n        metadataSchema: \"string\",\n        metadataTable: \"string\",\n        metadataName: \"string\",\n        metadataValue: \"string\",\n    }\n\n    /**\n     * Default values of length, precision and scale depends on column data type.\n     * Used in the cases when length/precision/scale is not specified by user.\n     */\n    dataTypeDefaults: DataTypeDefaults = {}\n\n    /**\n     * Max length allowed by MySQL for aliases.\n     * @see https://dev.mysql.com/doc/refman/5.5/en/identifiers.html\n     */\n    maxAliasLength = 63\n\n    cteCapabilities: CteCapabilities = {\n        enabled: true,\n    }\n\n    /**\n     * Supported returning types\n     */\n    private readonly _isReturningSqlSupported: Record<ReturningType, boolean> =\n        {\n            delete: false,\n            insert: false,\n            update: false,\n        }\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(connection: Connection) {\n        this.connection = connection\n        this.options = connection.options as SpannerConnectionOptions\n        this.isReplicated = this.options.replication ? true : false\n\n        // load mysql package\n        this.loadDependencies()\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Performs connection to the database.\n     */\n    async connect(): Promise<void> {\n        this.instance = this.spanner.instance(this.options.instanceId)\n        this.instanceDatabase = this.instance.database(this.options.databaseId)\n    }\n\n    /**\n     * Makes any action after connection (e.g. create extensions in Postgres driver).\n     */\n    afterConnect(): Promise<void> {\n        return Promise.resolve()\n    }\n\n    /**\n     * Closes connection with the database.\n     */\n    async disconnect(): Promise<void> {\n        this.instanceDatabase.close()\n    }\n\n    /**\n     * Creates a schema builder used to build and sync a schema.\n     */\n    createSchemaBuilder() {\n        return new RdbmsSchemaBuilder(this.connection)\n    }\n\n    /**\n     * Creates a query runner used to execute database queries.\n     */\n    createQueryRunner(mode: ReplicationMode) {\n        return new SpannerQueryRunner(this, mode)\n    }\n\n    /**\n     * Replaces parameters in the given sql with special escaping character\n     * and an array of parameter names to be passed to a query.\n     */\n    escapeQueryWithParameters(\n        sql: string,\n        parameters: ObjectLiteral,\n        nativeParameters: ObjectLiteral,\n    ): [string, any[]] {\n        const escapedParameters: any[] = Object.keys(nativeParameters).map(\n            (key) => nativeParameters[key],\n        )\n        if (!parameters || !Object.keys(parameters).length)\n            return [sql, escapedParameters]\n\n        sql = sql.replace(\n            /:(\\.\\.\\.)?([A-Za-z0-9_.]+)/g,\n            (full, isArray: string, key: string): string => {\n                if (!parameters.hasOwnProperty(key)) {\n                    return full\n                }\n\n                let value: any = parameters[key]\n\n                if (value === null) {\n                    return full\n                }\n\n                if (isArray) {\n                    return value\n                        .map((v: any) => {\n                            escapedParameters.push(v)\n                            return this.createParameter(\n                                key,\n                                escapedParameters.length - 1,\n                            )\n                        })\n                        .join(\", \")\n                }\n\n                if (value instanceof Function) {\n                    return value()\n                }\n                escapedParameters.push(value)\n                return this.createParameter(key, escapedParameters.length - 1)\n            },\n        ) // todo: make replace only in value statements, otherwise problems\n\n        sql = sql.replace(\n            /([ ]+)?=([ ]+)?:(\\.\\.\\.)?([A-Za-z0-9_.]+)/g,\n            (\n                full,\n                emptySpaceBefore: string,\n                emptySpaceAfter: string,\n                isArray: string,\n                key: string,\n            ): string => {\n                if (!parameters.hasOwnProperty(key)) {\n                    return full\n                }\n\n                let value: any = parameters[key]\n                if (value === null) {\n                    return \" IS NULL\"\n                }\n\n                return full\n            },\n        )\n        return [sql, escapedParameters]\n    }\n\n    /**\n     * Escapes a column name.\n     */\n    escape(columnName: string): string {\n        return `\\`${columnName}\\``\n    }\n\n    /**\n     * Build full table name with database name, schema name and table name.\n     * E.g. myDB.mySchema.myTable\n     */\n    buildTableName(\n        tableName: string,\n        schema?: string,\n        database?: string,\n    ): string {\n        let tablePath = [tableName]\n\n        if (database) {\n            tablePath.unshift(database)\n        }\n\n        return tablePath.join(\".\")\n    }\n\n    /**\n     * Parse a target table name or other types and return a normalized table definition.\n     */\n    parseTableName(\n        target: EntityMetadata | Table | View | TableForeignKey | string,\n    ): { database?: string; schema?: string; tableName: string } {\n        const driverDatabase = this.database\n        const driverSchema = undefined\n\n        if (target instanceof Table || target instanceof View) {\n            const parsed = this.parseTableName(target.name)\n\n            return {\n                database: target.database || parsed.database || driverDatabase,\n                schema: target.schema || parsed.schema || driverSchema,\n                tableName: parsed.tableName,\n            }\n        }\n\n        if (target instanceof TableForeignKey) {\n            const parsed = this.parseTableName(target.referencedTableName)\n\n            return {\n                database:\n                    target.referencedDatabase ||\n                    parsed.database ||\n                    driverDatabase,\n                schema:\n                    target.referencedSchema || parsed.schema || driverSchema,\n                tableName: parsed.tableName,\n            }\n        }\n\n        if (target instanceof EntityMetadata) {\n            // EntityMetadata tableName is never a path\n\n            return {\n                database: target.database || driverDatabase,\n                schema: target.schema || driverSchema,\n                tableName: target.tableName,\n            }\n        }\n\n        const parts = target.split(\".\")\n\n        return {\n            database:\n                (parts.length > 1 ? parts[0] : undefined) || driverDatabase,\n            schema: driverSchema,\n            tableName: parts.length > 1 ? parts[1] : parts[0],\n        }\n    }\n\n    /**\n     * Prepares given value to a value to be persisted, based on its column type and metadata.\n     */\n    preparePersistentValue(value: any, columnMetadata: ColumnMetadata): any {\n        if (columnMetadata.transformer)\n            value = ApplyValueTransformers.transformTo(\n                columnMetadata.transformer,\n                value,\n            )\n\n        if (value === null || value === undefined) return value\n\n        if (columnMetadata.type === \"numeric\") {\n            const lib = this.options.driver || PlatformTools.load(\"spanner\")\n            return lib.Spanner.numeric(value)\n        } else if (columnMetadata.type === \"date\") {\n            return DateUtils.mixedDateToDateString(value)\n        } else if (columnMetadata.type === \"json\") {\n            return value\n        } else if (\n            columnMetadata.type === \"timestamp\" ||\n            columnMetadata.type === Date\n        ) {\n            return DateUtils.mixedDateToDate(value)\n        }\n\n        return value\n    }\n\n    /**\n     * Prepares given value to a value to be persisted, based on its column type or metadata.\n     */\n    prepareHydratedValue(value: any, columnMetadata: ColumnMetadata): any {\n        if (value === null || value === undefined)\n            return columnMetadata.transformer\n                ? ApplyValueTransformers.transformFrom(\n                      columnMetadata.transformer,\n                      value,\n                  )\n                : value\n\n        if (columnMetadata.type === Boolean || columnMetadata.type === \"bool\") {\n            value = value ? true : false\n        } else if (\n            columnMetadata.type === \"timestamp\" ||\n            columnMetadata.type === Date\n        ) {\n            value = new Date(value)\n        } else if (columnMetadata.type === \"numeric\") {\n            value = value.value\n        } else if (columnMetadata.type === \"date\") {\n            value = DateUtils.mixedDateToDateString(value)\n        } else if (columnMetadata.type === \"json\") {\n            value = typeof value === \"string\" ? JSON.parse(value) : value\n        }\n\n        if (columnMetadata.transformer)\n            value = ApplyValueTransformers.transformFrom(\n                columnMetadata.transformer,\n                value,\n            )\n\n        return value\n    }\n\n    /**\n     * Creates a database type from a given column metadata.\n     */\n    normalizeType(column: {\n        type: ColumnType\n        length?: number | string\n        precision?: number | null\n        scale?: number\n    }): string {\n        if (column.type === Number) {\n            return \"int64\"\n        } else if (column.type === String || column.type === \"uuid\") {\n            return \"string\"\n        } else if (column.type === Date) {\n            return \"timestamp\"\n        } else if ((column.type as any) === Buffer) {\n            return \"bytes\"\n        } else if (column.type === Boolean) {\n            return \"bool\"\n        } else {\n            return (column.type as string) || \"\"\n        }\n    }\n\n    /**\n     * Normalizes \"default\" value of the column.\n     *\n     * Spanner does not support default values.\n     */\n    normalizeDefault(columnMetadata: ColumnMetadata): string | undefined {\n        return columnMetadata.default === \"\"\n            ? `\"${columnMetadata.default}\"`\n            : `${columnMetadata.default}`\n    }\n\n    /**\n     * Normalizes \"isUnique\" value of the column.\n     */\n    normalizeIsUnique(column: ColumnMetadata): boolean {\n        return column.entityMetadata.indices.some(\n            (idx) =>\n                idx.isUnique &&\n                idx.columns.length === 1 &&\n                idx.columns[0] === column,\n        )\n    }\n\n    /**\n     * Returns default column lengths, which is required on column creation.\n     */\n    getColumnLength(column: ColumnMetadata | TableColumn): string {\n        if (column.length) return column.length.toString()\n        if (column.generationStrategy === \"uuid\") return \"36\"\n\n        switch (column.type) {\n            case String:\n            case \"string\":\n            case \"bytes\":\n                return \"max\"\n            default:\n                return \"\"\n        }\n    }\n\n    /**\n     * Creates column type definition including length, precision and scale\n     */\n    createFullType(column: TableColumn): string {\n        let type = column.type\n\n        // used 'getColumnLength()' method, because Spanner requires column length for `string` and `bytes` data types\n        if (this.getColumnLength(column)) {\n            type += `(${this.getColumnLength(column)})`\n        } else if (column.width) {\n            type += `(${column.width})`\n        } else if (\n            column.precision !== null &&\n            column.precision !== undefined &&\n            column.scale !== null &&\n            column.scale !== undefined\n        ) {\n            type += `(${column.precision},${column.scale})`\n        } else if (\n            column.precision !== null &&\n            column.precision !== undefined\n        ) {\n            type += `(${column.precision})`\n        }\n\n        if (column.isArray) type = `array<${type}>`\n\n        return type\n    }\n\n    /**\n     * Obtains a new database connection to a master server.\n     * Used for replication.\n     * If replication is not setup then returns default connection's database connection.\n     */\n    obtainMasterConnection(): Promise<any> {\n        return this.instanceDatabase\n    }\n\n    /**\n     * Obtains a new database connection to a slave server.\n     * Used for replication.\n     * If replication is not setup then returns master (default) connection's database connection.\n     */\n    obtainSlaveConnection(): Promise<any> {\n        return this.instanceDatabase\n    }\n\n    /**\n     * Creates generated map of values generated or returned by database after INSERT query.\n     */\n    createGeneratedMap(\n        metadata: EntityMetadata,\n        insertResult: any,\n        entityIndex: number,\n    ) {\n        if (!insertResult) {\n            return undefined\n        }\n\n        if (insertResult.insertId === undefined) {\n            return Object.keys(insertResult).reduce((map, key) => {\n                const column = metadata.findColumnWithDatabaseName(key)\n                if (column) {\n                    OrmUtils.mergeDeep(\n                        map,\n                        column.createValueMap(insertResult[key]),\n                    )\n                    // OrmUtils.mergeDeep(map, column.createValueMap(this.prepareHydratedValue(insertResult[key], column))); // TODO: probably should be like there, but fails on enums, fix later\n                }\n                return map\n            }, {} as ObjectLiteral)\n        }\n\n        const generatedMap = metadata.generatedColumns.reduce(\n            (map, generatedColumn) => {\n                let value: any\n                if (\n                    generatedColumn.generationStrategy === \"increment\" &&\n                    insertResult.insertId\n                ) {\n                    // NOTE: When multiple rows is inserted by a single INSERT statement,\n                    // `insertId` is the value generated for the first inserted row only.\n                    value = insertResult.insertId + entityIndex\n                    // } else if (generatedColumn.generationStrategy === \"uuid\") {\n                    //     console.log(\"getting db value:\", generatedColumn.databaseName);\n                    //     value = generatedColumn.getEntityValue(uuidMap);\n                }\n\n                return OrmUtils.mergeDeep(\n                    map,\n                    generatedColumn.createValueMap(value),\n                )\n            },\n            {} as ObjectLiteral,\n        )\n\n        return Object.keys(generatedMap).length > 0 ? generatedMap : undefined\n    }\n\n    /**\n     * Differentiate columns of this table and columns from the given column metadatas columns\n     * and returns only changed.\n     */\n    findChangedColumns(\n        tableColumns: TableColumn[],\n        columnMetadatas: ColumnMetadata[],\n    ): ColumnMetadata[] {\n        return columnMetadatas.filter((columnMetadata) => {\n            const tableColumn = tableColumns.find(\n                (c) => c.name === columnMetadata.databaseName,\n            )\n            if (!tableColumn) return false // we don't need new columns, we only need exist and changed\n\n            const isColumnChanged =\n                tableColumn.name !== columnMetadata.databaseName ||\n                tableColumn.type !== this.normalizeType(columnMetadata) ||\n                tableColumn.length !== this.getColumnLength(columnMetadata) ||\n                tableColumn.asExpression !== columnMetadata.asExpression ||\n                tableColumn.generatedType !== columnMetadata.generatedType ||\n                tableColumn.isPrimary !== columnMetadata.isPrimary ||\n                !this.compareNullableValues(columnMetadata, tableColumn) ||\n                tableColumn.isUnique !== this.normalizeIsUnique(columnMetadata)\n\n            // DEBUG SECTION\n            // if (isColumnChanged) {\n            //     console.log(\"table:\", columnMetadata.entityMetadata.tableName)\n            //     console.log(\n            //         \"name:\",\n            //         tableColumn.name,\n            //         columnMetadata.databaseName,\n            //     )\n            //     console.log(\n            //         \"type:\",\n            //         tableColumn.type,\n            //         this.normalizeType(columnMetadata),\n            //     )\n            //     console.log(\n            //         \"length:\",\n            //         tableColumn.length,\n            //         this.getColumnLength(columnMetadata),\n            //     )\n            //     console.log(\n            //         \"asExpression:\",\n            //         tableColumn.asExpression,\n            //         columnMetadata.asExpression,\n            //     )\n            //     console.log(\n            //         \"generatedType:\",\n            //         tableColumn.generatedType,\n            //         columnMetadata.generatedType,\n            //     )\n            //     console.log(\n            //         \"isPrimary:\",\n            //         tableColumn.isPrimary,\n            //         columnMetadata.isPrimary,\n            //     )\n            //     console.log(\n            //         \"isNullable:\",\n            //         tableColumn.isNullable,\n            //         columnMetadata.isNullable,\n            //     )\n            //     console.log(\n            //         \"isUnique:\",\n            //         tableColumn.isUnique,\n            //         this.normalizeIsUnique(columnMetadata),\n            //     )\n            //     console.log(\"==========================================\")\n            // }\n\n            return isColumnChanged\n        })\n    }\n\n    /**\n     * Returns true if driver supports RETURNING / OUTPUT statement.\n     */\n    isReturningSqlSupported(returningType: ReturningType): boolean {\n        return this._isReturningSqlSupported[returningType]\n    }\n\n    /**\n     * Returns true if driver supports uuid values generation on its own.\n     */\n    isUUIDGenerationSupported(): boolean {\n        return false\n    }\n\n    /**\n     * Returns true if driver supports fulltext indices.\n     */\n    isFullTextColumnTypeSupported(): boolean {\n        return false\n    }\n\n    /**\n     * Creates an escaped parameter.\n     */\n    createParameter(parameterName: string, index: number): string {\n        return \"@param\" + index\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Loads all driver dependencies.\n     */\n    protected loadDependencies(): void {\n        try {\n            const lib = this.options.driver || PlatformTools.load(\"spanner\")\n            this.spanner = new lib.Spanner({\n                projectId: this.options.projectId,\n            })\n        } catch (e) {\n            console.error(e)\n            throw new DriverPackageNotInstalledError(\n                \"Spanner\",\n                \"@google-cloud/spanner\",\n            )\n        }\n    }\n\n    compareNullableValues(\n        columnMetadata: ColumnMetadata,\n        tableColumn: TableColumn,\n    ): boolean {\n        // Spanner does not support NULL/NOT NULL expressions for generated columns\n        if (columnMetadata.generatedType) {\n            return true\n        }\n\n        return columnMetadata.isNullable === tableColumn.isNullable\n    }\n\n    /**\n     * Checks if \"DEFAULT\" values in the column metadata and in the database are equal.\n     */\n    protected compareDefaultValues(\n        columnMetadataValue: string | undefined,\n        databaseValue: string | undefined,\n    ): boolean {\n        if (\n            typeof columnMetadataValue === \"string\" &&\n            typeof databaseValue === \"string\"\n        ) {\n            // we need to cut out \"'\" because in mysql we can understand returned value is a string or a function\n            // as result compare cannot understand if default is really changed or not\n            columnMetadataValue = columnMetadataValue.replace(/^'+|'+$/g, \"\")\n            databaseValue = databaseValue.replace(/^'+|'+$/g, \"\")\n        }\n\n        return columnMetadataValue === databaseValue\n    }\n\n    /**\n     * If parameter is a datetime function, e.g. \"CURRENT_TIMESTAMP\", normalizes it.\n     * Otherwise returns original input.\n     */\n    protected normalizeDatetimeFunction(value?: string) {\n        if (!value) return value\n\n        // check if input is datetime function\n        const isDatetimeFunction =\n            value.toUpperCase().indexOf(\"CURRENT_TIMESTAMP\") !== -1 ||\n            value.toUpperCase().indexOf(\"NOW\") !== -1\n\n        if (isDatetimeFunction) {\n            // extract precision, e.g. \"(3)\"\n            const precision = value.match(/\\(\\d+\\)/)\n            return precision\n                ? `CURRENT_TIMESTAMP${precision[0]}`\n                : \"CURRENT_TIMESTAMP\"\n        } else {\n            return value\n        }\n    }\n\n    /**\n     * Escapes a given comment.\n     */\n    protected escapeComment(comment?: string) {\n        if (!comment) return comment\n\n        comment = comment.replace(/\\u0000/g, \"\") // Null bytes aren't allowed in comments\n\n        return comment\n    }\n}\n"]},"metadata":{},"sourceType":"module"}