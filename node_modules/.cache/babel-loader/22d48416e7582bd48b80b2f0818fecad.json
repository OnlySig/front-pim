{"ast":null,"code":"import { importClassesFromDirectories } from \"../util/DirectoryExportedClassesLoader\";\nimport { OrmUtils } from \"../util/OrmUtils\";\nimport { getFromContainer } from \"../container\";\nimport { getMetadataArgsStorage } from \"../globals\";\nimport { EntityMetadataBuilder } from \"../metadata-builder/EntityMetadataBuilder\";\nimport { EntitySchemaTransformer } from \"../entity-schema/EntitySchemaTransformer\";\nimport { InstanceChecker } from \"../util/InstanceChecker\";\n/**\n * Builds migration instances, subscriber instances and entity metadatas for the given classes.\n */\n\nexport class ConnectionMetadataBuilder {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection) {\n    this.connection = connection;\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Builds migration instances for the given classes or directories.\n   */\n\n\n  async buildMigrations(migrations) {\n    const [migrationClasses, migrationDirectories] = OrmUtils.splitClassesAndStrings(migrations);\n    const allMigrationClasses = [...migrationClasses, ...(await importClassesFromDirectories(this.connection.logger, migrationDirectories))];\n    return allMigrationClasses.map(migrationClass => getFromContainer(migrationClass));\n  }\n  /**\n   * Builds subscriber instances for the given classes or directories.\n   */\n\n\n  async buildSubscribers(subscribers) {\n    const [subscriberClasses, subscriberDirectories] = OrmUtils.splitClassesAndStrings(subscribers || []);\n    const allSubscriberClasses = [...subscriberClasses, ...(await importClassesFromDirectories(this.connection.logger, subscriberDirectories))];\n    return getMetadataArgsStorage().filterSubscribers(allSubscriberClasses).map(metadata => getFromContainer(metadata.target));\n  }\n  /**\n   * Builds entity metadatas for the given classes or directories.\n   */\n\n\n  async buildEntityMetadatas(entities) {\n    // todo: instead we need to merge multiple metadata args storages\n    const [entityClassesOrSchemas, entityDirectories] = OrmUtils.splitClassesAndStrings(entities || []);\n    const entityClasses = entityClassesOrSchemas.filter(entityClass => !InstanceChecker.isEntitySchema(entityClass));\n    const entitySchemas = entityClassesOrSchemas.filter(entityClass => InstanceChecker.isEntitySchema(entityClass));\n    const allEntityClasses = [...entityClasses, ...(await importClassesFromDirectories(this.connection.logger, entityDirectories))];\n    allEntityClasses.forEach(entityClass => {\n      // if we have entity schemas loaded from directories\n      if (InstanceChecker.isEntitySchema(entityClass)) {\n        entitySchemas.push(entityClass);\n      }\n    });\n    const decoratorEntityMetadatas = new EntityMetadataBuilder(this.connection, getMetadataArgsStorage()).build(allEntityClasses);\n    const metadataArgsStorageFromSchema = new EntitySchemaTransformer().transform(entitySchemas);\n    const schemaEntityMetadatas = new EntityMetadataBuilder(this.connection, metadataArgsStorageFromSchema).build();\n    return [...decoratorEntityMetadatas, ...schemaEntityMetadatas];\n  }\n\n}","map":{"version":3,"mappings":"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","names":["importClassesFromDirectories","OrmUtils","getFromContainer","getMetadataArgsStorage","EntityMetadataBuilder","EntitySchemaTransformer","InstanceChecker","ConnectionMetadataBuilder","constructor","connection","buildMigrations","migrations","migrationClasses","migrationDirectories","splitClassesAndStrings","allMigrationClasses","logger","map","migrationClass","buildSubscribers","subscribers","subscriberClasses","subscriberDirectories","allSubscriberClasses","filterSubscribers","metadata","target","buildEntityMetadatas","entities","entityClassesOrSchemas","entityDirectories","entityClasses","filter","entityClass","isEntitySchema","entitySchemas","allEntityClasses","forEach","push","decoratorEntityMetadatas","build","metadataArgsStorageFromSchema","transform","schemaEntityMetadatas"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\connection\\ConnectionMetadataBuilder.ts"],"sourcesContent":["import { importClassesFromDirectories } from \"../util/DirectoryExportedClassesLoader\"\nimport { OrmUtils } from \"../util/OrmUtils\"\nimport { getFromContainer } from \"../container\"\nimport { MigrationInterface } from \"../migration/MigrationInterface\"\nimport { getMetadataArgsStorage } from \"../globals\"\nimport { EntityMetadataBuilder } from \"../metadata-builder/EntityMetadataBuilder\"\nimport { EntitySchemaTransformer } from \"../entity-schema/EntitySchemaTransformer\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { EntitySchema } from \"../entity-schema/EntitySchema\"\nimport { EntityMetadata } from \"../metadata/EntityMetadata\"\nimport { EntitySubscriberInterface } from \"../subscriber/EntitySubscriberInterface\"\nimport { InstanceChecker } from \"../util/InstanceChecker\"\n\n/**\n * Builds migration instances, subscriber instances and entity metadatas for the given classes.\n */\nexport class ConnectionMetadataBuilder {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(protected connection: DataSource) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Builds migration instances for the given classes or directories.\n     */\n    async buildMigrations(\n        migrations: (Function | string)[],\n    ): Promise<MigrationInterface[]> {\n        const [migrationClasses, migrationDirectories] =\n            OrmUtils.splitClassesAndStrings(migrations)\n        const allMigrationClasses = [\n            ...migrationClasses,\n            ...(await importClassesFromDirectories(\n                this.connection.logger,\n                migrationDirectories,\n            )),\n        ]\n        return allMigrationClasses.map((migrationClass) =>\n            getFromContainer<MigrationInterface>(migrationClass),\n        )\n    }\n\n    /**\n     * Builds subscriber instances for the given classes or directories.\n     */\n    async buildSubscribers(\n        subscribers: (Function | string)[],\n    ): Promise<EntitySubscriberInterface<any>[]> {\n        const [subscriberClasses, subscriberDirectories] =\n            OrmUtils.splitClassesAndStrings(subscribers || [])\n        const allSubscriberClasses = [\n            ...subscriberClasses,\n            ...(await importClassesFromDirectories(\n                this.connection.logger,\n                subscriberDirectories,\n            )),\n        ]\n        return getMetadataArgsStorage()\n            .filterSubscribers(allSubscriberClasses)\n            .map((metadata) =>\n                getFromContainer<EntitySubscriberInterface<any>>(\n                    metadata.target,\n                ),\n            )\n    }\n\n    /**\n     * Builds entity metadatas for the given classes or directories.\n     */\n    async buildEntityMetadatas(\n        entities: (Function | EntitySchema<any> | string)[],\n    ): Promise<EntityMetadata[]> {\n        // todo: instead we need to merge multiple metadata args storages\n\n        const [entityClassesOrSchemas, entityDirectories] =\n            OrmUtils.splitClassesAndStrings(entities || [])\n        const entityClasses: Function[] = entityClassesOrSchemas.filter(\n            (entityClass) => !InstanceChecker.isEntitySchema(entityClass),\n        ) as any\n        const entitySchemas: EntitySchema<any>[] =\n            entityClassesOrSchemas.filter((entityClass) =>\n                InstanceChecker.isEntitySchema(entityClass),\n            ) as any\n\n        const allEntityClasses = [\n            ...entityClasses,\n            ...(await importClassesFromDirectories(\n                this.connection.logger,\n                entityDirectories,\n            )),\n        ]\n        allEntityClasses.forEach((entityClass) => {\n            // if we have entity schemas loaded from directories\n            if (InstanceChecker.isEntitySchema(entityClass)) {\n                entitySchemas.push(entityClass)\n            }\n        })\n        const decoratorEntityMetadatas = new EntityMetadataBuilder(\n            this.connection,\n            getMetadataArgsStorage(),\n        ).build(allEntityClasses)\n\n        const metadataArgsStorageFromSchema =\n            new EntitySchemaTransformer().transform(entitySchemas)\n        const schemaEntityMetadatas = new EntityMetadataBuilder(\n            this.connection,\n            metadataArgsStorageFromSchema,\n        ).build()\n\n        return [...decoratorEntityMetadatas, ...schemaEntityMetadatas]\n    }\n}\n"]},"metadata":{},"sourceType":"module"}