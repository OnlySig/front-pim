{"ast":null,"code":"export class RelationCountLoader {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection, queryRunner, relationCountAttributes) {\n    this.connection = connection;\n    this.queryRunner = queryRunner;\n    this.relationCountAttributes = relationCountAttributes;\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n\n  async load(rawEntities) {\n    const onlyUnique = (value, index, self) => {\n      return self.indexOf(value) === index;\n    };\n\n    const promises = this.relationCountAttributes.map(async relationCountAttr => {\n      if (relationCountAttr.relation.isOneToMany) {\n        // example: Post and Category\n        // loadRelationCountAndMap(\"post.categoryCount\", \"post.categories\")\n        // we expect it to load array of post ids\n        // todo(dima): fix issues wit multiple primary keys and remove joinColumns[0]\n        const relation = relationCountAttr.relation; // \"category.posts\"\n\n        const inverseRelation = relation.inverseRelation; // \"post.category\"\n\n        const referenceColumnName = inverseRelation.joinColumns[0].referencedColumn.propertyName; // post id\n\n        const inverseSideTable = relation.inverseEntityMetadata.target; // Post\n\n        const inverseSideTableName = relation.inverseEntityMetadata.tableName; // post\n\n        const inverseSideTableAlias = relationCountAttr.alias || inverseSideTableName; // if condition (custom query builder factory) is set then relationIdAttr.alias defined\n\n        const inverseSidePropertyName = inverseRelation.propertyName; // \"category\" from \"post.category\"\n\n        let referenceColumnValues = rawEntities.map(rawEntity => rawEntity[relationCountAttr.parentAlias + \"_\" + referenceColumnName]).filter(value => !!value);\n        referenceColumnValues = referenceColumnValues.filter(onlyUnique); // ensure we won't perform redundant queries for joined data which was not found in selection\n        // example: if post.category was not found in db then no need to execute query for category.imageIds\n\n        if (referenceColumnValues.length === 0) return {\n          relationCountAttribute: relationCountAttr,\n          results: []\n        }; // generate query:\n        // SELECT category.post as parentId, COUNT(*) AS cnt FROM category category WHERE category.post IN (1, 2) GROUP BY category.post\n\n        const qb = this.connection.createQueryBuilder(this.queryRunner);\n        qb.select(inverseSideTableAlias + \".\" + inverseSidePropertyName, \"parentId\").addSelect(\"COUNT(*)\", \"cnt\").from(inverseSideTable, inverseSideTableAlias).where(inverseSideTableAlias + \".\" + inverseSidePropertyName + \" IN (:...ids)\").addGroupBy(inverseSideTableAlias + \".\" + inverseSidePropertyName).setParameter(\"ids\", referenceColumnValues); // apply condition (custom query builder factory)\n\n        if (relationCountAttr.queryBuilderFactory) relationCountAttr.queryBuilderFactory(qb);\n        return {\n          relationCountAttribute: relationCountAttr,\n          results: await qb.getRawMany()\n        };\n      } else {\n        // example: Post and Category\n        // owner side: loadRelationIdAndMap(\"post.categoryIds\", \"post.categories\")\n        // inverse side: loadRelationIdAndMap(\"category.postIds\", \"category.posts\")\n        // we expect it to load array of post ids\n        let joinTableColumnName;\n        let inverseJoinColumnName;\n        let firstJunctionColumn;\n        let secondJunctionColumn;\n\n        if (relationCountAttr.relation.isOwning) {\n          // todo fix joinColumns[0] and inverseJoinColumns[0].\n          joinTableColumnName = relationCountAttr.relation.joinColumns[0].referencedColumn.databaseName;\n          inverseJoinColumnName = relationCountAttr.relation.inverseJoinColumns[0].referencedColumn.databaseName;\n          firstJunctionColumn = relationCountAttr.relation.junctionEntityMetadata.columns[0];\n          secondJunctionColumn = relationCountAttr.relation.junctionEntityMetadata.columns[1];\n        } else {\n          joinTableColumnName = relationCountAttr.relation.inverseRelation.inverseJoinColumns[0].referencedColumn.databaseName;\n          inverseJoinColumnName = relationCountAttr.relation.inverseRelation.joinColumns[0].referencedColumn.databaseName;\n          firstJunctionColumn = relationCountAttr.relation.junctionEntityMetadata.columns[1];\n          secondJunctionColumn = relationCountAttr.relation.junctionEntityMetadata.columns[0];\n        }\n\n        let referenceColumnValues = rawEntities.map(rawEntity => rawEntity[relationCountAttr.parentAlias + \"_\" + joinTableColumnName]).filter(value => !!value);\n        referenceColumnValues = referenceColumnValues.filter(onlyUnique); // ensure we won't perform redundant queries for joined data which was not found in selection\n        // example: if post.category was not found in db then no need to execute query for category.imageIds\n\n        if (referenceColumnValues.length === 0) return {\n          relationCountAttribute: relationCountAttr,\n          results: []\n        };\n        const junctionAlias = relationCountAttr.junctionAlias;\n        const inverseSideTableName = relationCountAttr.joinInverseSideMetadata.tableName;\n        const inverseSideTableAlias = relationCountAttr.alias || inverseSideTableName;\n        const junctionTableName = relationCountAttr.relation.junctionEntityMetadata.tableName;\n        const condition = junctionAlias + \".\" + firstJunctionColumn.propertyName + \" IN (\" + referenceColumnValues.map(vals => isNaN(vals) ? \"'\" + vals + \"'\" : vals) + \")\" + \" AND \" + junctionAlias + \".\" + secondJunctionColumn.propertyName + \" = \" + inverseSideTableAlias + \".\" + inverseJoinColumnName;\n        const qb = this.connection.createQueryBuilder(this.queryRunner);\n        qb.select(junctionAlias + \".\" + firstJunctionColumn.propertyName, \"parentId\").addSelect(\"COUNT(\" + qb.escape(inverseSideTableAlias) + \".\" + qb.escape(inverseJoinColumnName) + \")\", \"cnt\").from(inverseSideTableName, inverseSideTableAlias).innerJoin(junctionTableName, junctionAlias, condition).addGroupBy(junctionAlias + \".\" + firstJunctionColumn.propertyName); // apply condition (custom query builder factory)\n\n        if (relationCountAttr.queryBuilderFactory) relationCountAttr.queryBuilderFactory(qb);\n        return {\n          relationCountAttribute: relationCountAttr,\n          results: await qb.getRawMany()\n        };\n      }\n    });\n    return Promise.all(promises);\n  }\n\n}","map":{"version":3,"mappings":"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","names":["RelationCountLoader","constructor","connection","queryRunner","relationCountAttributes","load","rawEntities","onlyUnique","value","index","self","indexOf","promises","map","relationCountAttr","relation","isOneToMany","inverseRelation","referenceColumnName","joinColumns","referencedColumn","propertyName","inverseSideTable","inverseEntityMetadata","target","inverseSideTableName","tableName","inverseSideTableAlias","alias","inverseSidePropertyName","referenceColumnValues","rawEntity","parentAlias","filter","length","relationCountAttribute","results","qb","createQueryBuilder","select","addSelect","from","where","addGroupBy","setParameter","queryBuilderFactory","getRawMany","joinTableColumnName","inverseJoinColumnName","firstJunctionColumn","secondJunctionColumn","isOwning","databaseName","inverseJoinColumns","junctionEntityMetadata","columns","junctionAlias","joinInverseSideMetadata","junctionTableName","condition","vals","isNaN","escape","innerJoin","Promise","all"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\query-builder\\relation-count\\RelationCountLoader.ts"],"sourcesContent":["import { ColumnMetadata } from \"../../metadata/ColumnMetadata\"\nimport { DataSource } from \"../../data-source/DataSource\"\nimport { RelationCountAttribute } from \"./RelationCountAttribute\"\nimport { RelationCountLoadResult } from \"./RelationCountLoadResult\"\nimport { QueryRunner } from \"../../query-runner/QueryRunner\"\n\nexport class RelationCountLoader {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        protected connection: DataSource,\n        protected queryRunner: QueryRunner | undefined,\n        protected relationCountAttributes: RelationCountAttribute[],\n    ) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    async load(rawEntities: any[]): Promise<RelationCountLoadResult[]> {\n        const onlyUnique = (value: any, index: number, self: any) => {\n            return self.indexOf(value) === index\n        }\n\n        const promises = this.relationCountAttributes.map(\n            async (relationCountAttr) => {\n                if (relationCountAttr.relation.isOneToMany) {\n                    // example: Post and Category\n                    // loadRelationCountAndMap(\"post.categoryCount\", \"post.categories\")\n                    // we expect it to load array of post ids\n\n                    // todo(dima): fix issues wit multiple primary keys and remove joinColumns[0]\n                    const relation = relationCountAttr.relation // \"category.posts\"\n                    const inverseRelation = relation.inverseRelation! // \"post.category\"\n                    const referenceColumnName =\n                        inverseRelation.joinColumns[0].referencedColumn!\n                            .propertyName // post id\n                    const inverseSideTable =\n                        relation.inverseEntityMetadata.target // Post\n                    const inverseSideTableName =\n                        relation.inverseEntityMetadata.tableName // post\n                    const inverseSideTableAlias =\n                        relationCountAttr.alias || inverseSideTableName // if condition (custom query builder factory) is set then relationIdAttr.alias defined\n                    const inverseSidePropertyName = inverseRelation.propertyName // \"category\" from \"post.category\"\n\n                    let referenceColumnValues = rawEntities\n                        .map(\n                            (rawEntity) =>\n                                rawEntity[\n                                    relationCountAttr.parentAlias +\n                                        \"_\" +\n                                        referenceColumnName\n                                ],\n                        )\n                        .filter((value) => !!value)\n                    referenceColumnValues =\n                        referenceColumnValues.filter(onlyUnique)\n\n                    // ensure we won't perform redundant queries for joined data which was not found in selection\n                    // example: if post.category was not found in db then no need to execute query for category.imageIds\n                    if (referenceColumnValues.length === 0)\n                        return {\n                            relationCountAttribute: relationCountAttr,\n                            results: [],\n                        }\n\n                    // generate query:\n                    // SELECT category.post as parentId, COUNT(*) AS cnt FROM category category WHERE category.post IN (1, 2) GROUP BY category.post\n                    const qb = this.connection.createQueryBuilder(\n                        this.queryRunner,\n                    )\n                    qb.select(\n                        inverseSideTableAlias + \".\" + inverseSidePropertyName,\n                        \"parentId\",\n                    )\n                        .addSelect(\"COUNT(*)\", \"cnt\")\n                        .from(inverseSideTable, inverseSideTableAlias)\n                        .where(\n                            inverseSideTableAlias +\n                                \".\" +\n                                inverseSidePropertyName +\n                                \" IN (:...ids)\",\n                        )\n                        .addGroupBy(\n                            inverseSideTableAlias +\n                                \".\" +\n                                inverseSidePropertyName,\n                        )\n                        .setParameter(\"ids\", referenceColumnValues)\n\n                    // apply condition (custom query builder factory)\n                    if (relationCountAttr.queryBuilderFactory)\n                        relationCountAttr.queryBuilderFactory(qb)\n\n                    return {\n                        relationCountAttribute: relationCountAttr,\n                        results: await qb.getRawMany(),\n                    }\n                } else {\n                    // example: Post and Category\n                    // owner side: loadRelationIdAndMap(\"post.categoryIds\", \"post.categories\")\n                    // inverse side: loadRelationIdAndMap(\"category.postIds\", \"category.posts\")\n                    // we expect it to load array of post ids\n\n                    let joinTableColumnName: string\n                    let inverseJoinColumnName: string\n                    let firstJunctionColumn: ColumnMetadata\n                    let secondJunctionColumn: ColumnMetadata\n\n                    if (relationCountAttr.relation.isOwning) {\n                        // todo fix joinColumns[0] and inverseJoinColumns[0].\n                        joinTableColumnName =\n                            relationCountAttr.relation.joinColumns[0]\n                                .referencedColumn!.databaseName\n                        inverseJoinColumnName =\n                            relationCountAttr.relation.inverseJoinColumns[0]\n                                .referencedColumn!.databaseName\n                        firstJunctionColumn =\n                            relationCountAttr.relation.junctionEntityMetadata!\n                                .columns[0]\n                        secondJunctionColumn =\n                            relationCountAttr.relation.junctionEntityMetadata!\n                                .columns[1]\n                    } else {\n                        joinTableColumnName =\n                            relationCountAttr.relation.inverseRelation!\n                                .inverseJoinColumns[0].referencedColumn!\n                                .databaseName\n                        inverseJoinColumnName =\n                            relationCountAttr.relation.inverseRelation!\n                                .joinColumns[0].referencedColumn!.databaseName\n                        firstJunctionColumn =\n                            relationCountAttr.relation.junctionEntityMetadata!\n                                .columns[1]\n                        secondJunctionColumn =\n                            relationCountAttr.relation.junctionEntityMetadata!\n                                .columns[0]\n                    }\n\n                    let referenceColumnValues = rawEntities\n                        .map(\n                            (rawEntity) =>\n                                rawEntity[\n                                    relationCountAttr.parentAlias +\n                                        \"_\" +\n                                        joinTableColumnName\n                                ],\n                        )\n                        .filter((value) => !!value)\n                    referenceColumnValues =\n                        referenceColumnValues.filter(onlyUnique)\n\n                    // ensure we won't perform redundant queries for joined data which was not found in selection\n                    // example: if post.category was not found in db then no need to execute query for category.imageIds\n                    if (referenceColumnValues.length === 0)\n                        return {\n                            relationCountAttribute: relationCountAttr,\n                            results: [],\n                        }\n\n                    const junctionAlias = relationCountAttr.junctionAlias\n                    const inverseSideTableName =\n                        relationCountAttr.joinInverseSideMetadata.tableName\n                    const inverseSideTableAlias =\n                        relationCountAttr.alias || inverseSideTableName\n                    const junctionTableName =\n                        relationCountAttr.relation.junctionEntityMetadata!\n                            .tableName\n\n                    const condition =\n                        junctionAlias +\n                        \".\" +\n                        firstJunctionColumn.propertyName +\n                        \" IN (\" +\n                        referenceColumnValues.map((vals) =>\n                            isNaN(vals) ? \"'\" + vals + \"'\" : vals,\n                        ) +\n                        \")\" +\n                        \" AND \" +\n                        junctionAlias +\n                        \".\" +\n                        secondJunctionColumn.propertyName +\n                        \" = \" +\n                        inverseSideTableAlias +\n                        \".\" +\n                        inverseJoinColumnName\n\n                    const qb = this.connection.createQueryBuilder(\n                        this.queryRunner,\n                    )\n                    qb.select(\n                        junctionAlias + \".\" + firstJunctionColumn.propertyName,\n                        \"parentId\",\n                    )\n                        .addSelect(\n                            \"COUNT(\" +\n                                qb.escape(inverseSideTableAlias) +\n                                \".\" +\n                                qb.escape(inverseJoinColumnName) +\n                                \")\",\n                            \"cnt\",\n                        )\n                        .from(inverseSideTableName, inverseSideTableAlias)\n                        .innerJoin(junctionTableName, junctionAlias, condition)\n                        .addGroupBy(\n                            junctionAlias +\n                                \".\" +\n                                firstJunctionColumn.propertyName,\n                        )\n\n                    // apply condition (custom query builder factory)\n                    if (relationCountAttr.queryBuilderFactory)\n                        relationCountAttr.queryBuilderFactory(qb)\n\n                    return {\n                        relationCountAttribute: relationCountAttr,\n                        results: await qb.getRawMany(),\n                    }\n                }\n            },\n        )\n\n        return Promise.all(promises)\n    }\n}\n"]},"metadata":{},"sourceType":"module"}