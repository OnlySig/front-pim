{"ast":null,"code":"import { OrmUtils } from \"../util/OrmUtils\";\nimport { ApplyValueTransformers } from \"../util/ApplyValueTransformers\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\nimport { InstanceChecker } from \"../util/InstanceChecker\";\n/**\n * This metadata contains all information about entity's column.\n */\n\nexport class ColumnMetadata {\n  // ---------------------------------------------------------------------\n  // Constructor\n  // ---------------------------------------------------------------------\n  constructor(options) {\n    this[\"@instanceof\"] = Symbol.for(\"ColumnMetadata\");\n    /**\n     * Type's length in the database.\n     */\n\n    this.length = \"\";\n    /**\n     * Indicates if this column is a primary key.\n     */\n\n    this.isPrimary = false;\n    /**\n     * Indicates if this column is generated (auto increment or generated other way).\n     */\n\n    this.isGenerated = false;\n    /**\n     * Indicates if column can contain nulls or not.\n     */\n\n    this.isNullable = false;\n    /**\n     * Indicates if column is selected by query builder or not.\n     */\n\n    this.isSelect = true;\n    /**\n     * Indicates if column is inserted by default or not.\n     */\n\n    this.isInsert = true;\n    /**\n     * Indicates if column allows updates or not.\n     */\n\n    this.isUpdate = true;\n    /**\n     * Puts ZEROFILL attribute on to numeric column. Works only for MySQL.\n     * If you specify ZEROFILL for a numeric column, MySQL automatically adds the UNSIGNED attribute to the column\n     */\n\n    this.zerofill = false;\n    /**\n     * Puts UNSIGNED attribute on to numeric column. Works only for MySQL.\n     */\n\n    this.unsigned = false;\n    /**\n     * Indicates if this column is an array.\n     */\n\n    this.isArray = false;\n    /**\n     * Indicates if column is virtual. Virtual columns are not mapped to the entity.\n     */\n\n    this.isVirtual = false;\n    /**\n     * Indicates if column is discriminator. Discriminator columns are not mapped to the entity.\n     */\n\n    this.isDiscriminator = false;\n    /**\n     * Indicates if column is tree-level column. Tree-level columns are used in closure entities.\n     */\n\n    this.isTreeLevel = false;\n    /**\n     * Indicates if this column contains an entity creation date.\n     */\n\n    this.isCreateDate = false;\n    /**\n     * Indicates if this column contains an entity update date.\n     */\n\n    this.isUpdateDate = false;\n    /**\n     * Indicates if this column contains an entity delete date.\n     */\n\n    this.isDeleteDate = false;\n    /**\n     * Indicates if this column contains an entity version.\n     */\n\n    this.isVersion = false;\n    /**\n     * Indicates if this column contains an object id.\n     */\n\n    this.isObjectId = false;\n    /**\n     * Indicates if this column is nested set's left column.\n     * Used only in tree entities with nested-set type.\n     */\n\n    this.isNestedSetLeft = false;\n    /**\n     * Indicates if this column is nested set's right column.\n     * Used only in tree entities with nested-set type.\n     */\n\n    this.isNestedSetRight = false;\n    /**\n     * Indicates if this column is materialized path's path column.\n     * Used only in tree entities with materialized path type.\n     */\n\n    this.isMaterializedPath = false;\n    this.entityMetadata = options.entityMetadata;\n    this.embeddedMetadata = options.embeddedMetadata;\n    this.referencedColumn = options.referencedColumn;\n    if (options.args.target) this.target = options.args.target;\n    if (options.args.propertyName) this.propertyName = options.args.propertyName;\n    if (options.args.options.name) this.givenDatabaseName = options.args.options.name;\n    if (options.args.options.type) this.type = options.args.options.type;\n    if (options.args.options.length) this.length = options.args.options.length ? options.args.options.length.toString() : \"\";\n    if (options.args.options.width) this.width = options.args.options.width;\n    if (options.args.options.charset) this.charset = options.args.options.charset;\n    if (options.args.options.collation) this.collation = options.args.options.collation;\n    if (options.args.options.primary) this.isPrimary = options.args.options.primary;\n    if (options.args.options.default === null) // to make sure default: null is the same as nullable: true\n      this.isNullable = true;\n    if (options.args.options.nullable !== undefined) this.isNullable = options.args.options.nullable;\n    if (options.args.options.select !== undefined) this.isSelect = options.args.options.select;\n    if (options.args.options.insert !== undefined) this.isInsert = options.args.options.insert;\n    if (options.args.options.update !== undefined) this.isUpdate = options.args.options.update;\n    if (options.args.options.readonly !== undefined) this.isUpdate = !options.args.options.readonly;\n    if (options.args.options.comment) this.comment = options.args.options.comment;\n    if (options.args.options.default !== undefined) this.default = options.args.options.default;\n    if (options.args.options.onUpdate) this.onUpdate = options.args.options.onUpdate;\n    if (options.args.options.generatedIdentity) this.generatedIdentity = options.args.options.generatedIdentity;\n    if (options.args.options.scale !== null && options.args.options.scale !== undefined) this.scale = options.args.options.scale;\n\n    if (options.args.options.zerofill) {\n      this.zerofill = options.args.options.zerofill;\n      this.unsigned = true; // if you specify ZEROFILL for a numeric column, MySQL automatically adds the UNSIGNED attribute to the column\n    }\n\n    if (options.args.options.unsigned) this.unsigned = options.args.options.unsigned;\n    if (options.args.options.precision !== null) this.precision = options.args.options.precision;\n\n    if (options.args.options.enum) {\n      if (ObjectUtils.isObject(options.args.options.enum) && !Array.isArray(options.args.options.enum)) {\n        this.enum = Object.keys(options.args.options.enum) // remove numeric keys - typescript numeric enum types generate them\n        // From the documentation: “declaration merging” means that the compiler merges two separate declarations\n        // declared with the same name into a single definition. This concept is often used to merge enum with namespace\n        // where in namespace we define e.g. utility methods for creating enum. This is well known in other languages\n        // like Java (enum methods). Here in case if enum have function, we need to remove it from metadata, otherwise\n        // generated SQL statements contains string representation of that function which leads into syntax error\n        // at database side.\n        .filter(key => isNaN(+key) && typeof options.args.options.enum[key] !== \"function\").map(key => options.args.options.enum[key]);\n      } else {\n        this.enum = options.args.options.enum;\n      }\n    }\n\n    if (options.args.options.enumName) {\n      this.enumName = options.args.options.enumName;\n    }\n\n    if (options.args.options.primaryKeyConstraintName) {\n      this.primaryKeyConstraintName = options.args.options.primaryKeyConstraintName;\n    }\n\n    if (options.args.options.foreignKeyConstraintName) {\n      this.foreignKeyConstraintName = options.args.options.foreignKeyConstraintName;\n    }\n\n    if (options.args.options.asExpression) {\n      this.asExpression = options.args.options.asExpression;\n      this.generatedType = options.args.options.generatedType ? options.args.options.generatedType : \"VIRTUAL\";\n    }\n\n    if (options.args.options.hstoreType) this.hstoreType = options.args.options.hstoreType;\n    if (options.args.options.array) this.isArray = options.args.options.array;\n\n    if (options.args.mode) {\n      this.isVirtual = options.args.mode === \"virtual\";\n      this.isTreeLevel = options.args.mode === \"treeLevel\";\n      this.isCreateDate = options.args.mode === \"createDate\";\n      this.isUpdateDate = options.args.mode === \"updateDate\";\n      this.isDeleteDate = options.args.mode === \"deleteDate\";\n      this.isVersion = options.args.mode === \"version\";\n      this.isObjectId = options.args.mode === \"objectId\";\n    }\n\n    if (options.args.options.transformer) this.transformer = options.args.options.transformer;\n    if (options.args.options.spatialFeatureType) this.spatialFeatureType = options.args.options.spatialFeatureType;\n    if (options.args.options.srid !== undefined) this.srid = options.args.options.srid;\n    if (this.isTreeLevel) this.type = options.connection.driver.mappedDataTypes.treeLevel;\n\n    if (this.isCreateDate) {\n      if (!this.type) this.type = options.connection.driver.mappedDataTypes.createDate;\n      if (!this.default) this.default = () => options.connection.driver.mappedDataTypes.createDateDefault; // skip precision if it was explicitly set to \"null\" in column options. Otherwise use default precision if it exist.\n\n      if (this.precision === undefined && options.args.options.precision === undefined && options.connection.driver.mappedDataTypes.createDatePrecision) this.precision = options.connection.driver.mappedDataTypes.createDatePrecision;\n    }\n\n    if (this.isUpdateDate) {\n      if (!this.type) this.type = options.connection.driver.mappedDataTypes.updateDate;\n      if (!this.default) this.default = () => options.connection.driver.mappedDataTypes.updateDateDefault;\n      if (!this.onUpdate) this.onUpdate = options.connection.driver.mappedDataTypes.updateDateDefault; // skip precision if it was explicitly set to \"null\" in column options. Otherwise use default precision if it exist.\n\n      if (this.precision === undefined && options.args.options.precision === undefined && options.connection.driver.mappedDataTypes.updateDatePrecision) this.precision = options.connection.driver.mappedDataTypes.updateDatePrecision;\n    }\n\n    if (this.isDeleteDate) {\n      if (!this.type) this.type = options.connection.driver.mappedDataTypes.deleteDate;\n      if (!this.isNullable) this.isNullable = options.connection.driver.mappedDataTypes.deleteDateNullable; // skip precision if it was explicitly set to \"null\" in column options. Otherwise use default precision if it exist.\n\n      if (this.precision === undefined && options.args.options.precision === undefined && options.connection.driver.mappedDataTypes.deleteDatePrecision) this.precision = options.connection.driver.mappedDataTypes.deleteDatePrecision;\n    }\n\n    if (this.isVersion) this.type = options.connection.driver.mappedDataTypes.version;\n    if (options.closureType) this.closureType = options.closureType;\n    if (options.nestedSetLeft) this.isNestedSetLeft = options.nestedSetLeft;\n    if (options.nestedSetRight) this.isNestedSetRight = options.nestedSetRight;\n    if (options.materializedPath) this.isMaterializedPath = options.materializedPath;\n  } // ---------------------------------------------------------------------\n  // Public Methods\n  // ---------------------------------------------------------------------\n\n  /**\n   * Creates entity id map from the given entity ids array.\n   */\n\n\n  createValueMap(value) {\n    let useDatabaseName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    // extract column value from embeds of entity if column is in embedded\n    if (this.embeddedMetadata) {\n      // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n      // we need to get value of \"id\" column from the post real entity object and return it in a\n      // { data: { information: { counters: { id: ... } } } } format\n      // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n      const propertyNames = [...this.embeddedMetadata.parentPropertyNames]; // now need to access post[data][information][counters] to get column value from the counters\n      // and on each step we need to create complex literal object, e.g. first { data },\n      // then { data: { information } }, then { data: { information: { counters } } },\n      // then { data: { information: { counters: [this.propertyName]: entity[data][information][counters][this.propertyName] } } }\n      // this recursive function helps doing that\n\n      const extractEmbeddedColumnValue = (propertyNames, map) => {\n        const propertyName = propertyNames.shift();\n\n        if (propertyName) {\n          map[propertyName] = {};\n          extractEmbeddedColumnValue(propertyNames, map[propertyName]);\n          return map;\n        } // this is bugfix for #720 when increment number is bigint we need to make sure its a string\n\n\n        if ((this.generationStrategy === \"increment\" || this.generationStrategy === \"rowid\") && this.type === \"bigint\" && value !== null) value = String(value);\n        map[useDatabaseName ? this.databaseName : this.propertyName] = value;\n        return map;\n      };\n\n      return extractEmbeddedColumnValue(propertyNames, {});\n    } else {\n      // no embeds - no problems. Simply return column property name and its value of the entity\n      // this is bugfix for #720 when increment number is bigint we need to make sure its a string\n      if ((this.generationStrategy === \"increment\" || this.generationStrategy === \"rowid\") && this.type === \"bigint\" && value !== null) value = String(value);\n      return {\n        [useDatabaseName ? this.databaseName : this.propertyName]: value\n      };\n    }\n  }\n  /**\n   * Extracts column value and returns its column name with this value in a literal object.\n   * If column is in embedded (or recursive embedded) it returns complex literal object.\n   *\n   * Examples what this method can return depend if this column is in embeds.\n   * { id: 1 } or { title: \"hello\" }, { counters: { code: 1 } }, { data: { information: { counters: { code: 1 } } } }\n   */\n\n\n  getEntityValueMap(entity, options) {\n    var _a;\n\n    const returnNulls = false; // options && options.skipNulls === false ? false : true; // todo: remove if current will not bring problems, uncomment if it will.\n    // extract column value from embeds of entity if column is in embedded\n\n    if (this.embeddedMetadata) {\n      // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n      // we need to get value of \"id\" column from the post real entity object and return it in a\n      // { data: { information: { counters: { id: ... } } } } format\n      // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n      const propertyNames = [...this.embeddedMetadata.parentPropertyNames];\n      const isEmbeddedArray = this.embeddedMetadata.isArray; // now need to access post[data][information][counters] to get column value from the counters\n      // and on each step we need to create complex literal object, e.g. first { data },\n      // then { data: { information } }, then { data: { information: { counters } } },\n      // then { data: { information: { counters: [this.propertyName]: entity[data][information][counters][this.propertyName] } } }\n      // this recursive function helps doing that\n\n      const extractEmbeddedColumnValue = (propertyNames, value) => {\n        if (value === undefined) {\n          return {};\n        }\n\n        const propertyName = propertyNames.shift();\n\n        if (propertyName) {\n          const submap = extractEmbeddedColumnValue(propertyNames, value[propertyName]);\n\n          if (Object.keys(submap).length > 0) {\n            return {\n              [propertyName]: submap\n            };\n          }\n\n          return {};\n        }\n\n        if (isEmbeddedArray && Array.isArray(value)) {\n          return value.map(v => ({\n            [this.propertyName]: v[this.propertyName]\n          }));\n        }\n\n        if (value[this.propertyName] !== undefined && (returnNulls === false || value[this.propertyName] !== null)) {\n          return {\n            [this.propertyName]: value[this.propertyName]\n          };\n        }\n\n        return {};\n      };\n\n      const map = extractEmbeddedColumnValue(propertyNames, entity);\n      return Object.keys(map).length > 0 ? map : undefined;\n    } else {\n      // no embeds - no problems. Simply return column property name and its value of the entity\n\n      /**\n       * Object.getOwnPropertyDescriptor checks if the relation is lazy, in which case value is a Promise\n       * DO NOT use `entity[\n          this.relationMetadata.propertyName] instanceof Promise`, which will invoke property getter and make unwanted DB request\n       * refer: https://github.com/typeorm/typeorm/pull/8676#issuecomment-1049906331\n       */\n      if (this.relationMetadata && !((_a = Object.getOwnPropertyDescriptor(entity, this.relationMetadata.propertyName)) === null || _a === void 0 ? void 0 : _a.get) && entity[this.relationMetadata.propertyName] && ObjectUtils.isObject(entity[this.relationMetadata.propertyName])) {\n        const map = this.relationMetadata.joinColumns.reduce((map, joinColumn) => {\n          const value = joinColumn.referencedColumn.getEntityValueMap(entity[this.relationMetadata.propertyName]);\n          if (value === undefined) return map;\n          return OrmUtils.mergeDeep(map, value);\n        }, {});\n        if (Object.keys(map).length > 0) return {\n          [this.propertyName]: map\n        };\n        return undefined;\n      } else {\n        if (entity[this.propertyName] !== undefined && (returnNulls === false || entity[this.propertyName] !== null)) return {\n          [this.propertyName]: entity[this.propertyName]\n        };\n        return undefined;\n      }\n    }\n  }\n  /**\n   * Extracts column value from the given entity.\n   * If column is in embedded (or recursive embedded) it extracts its value from there.\n   */\n\n\n  getEntityValue(entity) {\n    let transform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (entity === undefined || entity === null) return undefined; // extract column value from embeddeds of entity if column is in embedded\n\n    let value = undefined;\n\n    if (this.embeddedMetadata) {\n      // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n      // we need to get value of \"id\" column from the post real entity object\n      // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n      const propertyNames = [...this.embeddedMetadata.parentPropertyNames];\n      const isEmbeddedArray = this.embeddedMetadata.isArray; // next we need to access post[data][information][counters][this.propertyName] to get column value from the counters\n      // this recursive function takes array of generated property names and gets the post[data][information][counters] embed\n\n      const extractEmbeddedColumnValue = (propertyNames, value) => {\n        const propertyName = propertyNames.shift();\n        return propertyName && value ? extractEmbeddedColumnValue(propertyNames, value[propertyName]) : value;\n      }; // once we get nested embed object we get its column, e.g. post[data][information][counters][this.propertyName]\n\n\n      const embeddedObject = extractEmbeddedColumnValue(propertyNames, entity);\n\n      if (embeddedObject) {\n        if (this.relationMetadata && this.referencedColumn) {\n          const relatedEntity = this.relationMetadata.getEntityValue(embeddedObject);\n\n          if (relatedEntity && ObjectUtils.isObject(relatedEntity) && !InstanceChecker.isFindOperator(relatedEntity) && !Buffer.isBuffer(relatedEntity)) {\n            value = this.referencedColumn.getEntityValue(relatedEntity);\n          } else if (embeddedObject[this.propertyName] && ObjectUtils.isObject(embeddedObject[this.propertyName]) && !InstanceChecker.isFindOperator(embeddedObject[this.propertyName]) && !Buffer.isBuffer(embeddedObject[this.propertyName]) && !(embeddedObject[this.propertyName] instanceof Date)) {\n            value = this.referencedColumn.getEntityValue(embeddedObject[this.propertyName]);\n          } else {\n            value = embeddedObject[this.propertyName];\n          }\n        } else if (this.referencedColumn) {\n          value = this.referencedColumn.getEntityValue(embeddedObject[this.propertyName]);\n        } else if (isEmbeddedArray && Array.isArray(embeddedObject)) {\n          value = embeddedObject.map(o => o[this.propertyName]);\n        } else {\n          value = embeddedObject[this.propertyName];\n        }\n      }\n    } else {\n      // no embeds - no problems. Simply return column name by property name of the entity\n      if (this.relationMetadata && this.referencedColumn) {\n        const relatedEntity = this.relationMetadata.getEntityValue(entity);\n\n        if (relatedEntity && ObjectUtils.isObject(relatedEntity) && !InstanceChecker.isFindOperator(relatedEntity) && !(typeof relatedEntity === \"function\") && !Buffer.isBuffer(relatedEntity)) {\n          value = this.referencedColumn.getEntityValue(relatedEntity);\n        } else if (entity[this.propertyName] && ObjectUtils.isObject(entity[this.propertyName]) && !InstanceChecker.isFindOperator(entity[this.propertyName]) && !(typeof entity[this.propertyName] === \"function\") && !Buffer.isBuffer(entity[this.propertyName]) && !(entity[this.propertyName] instanceof Date)) {\n          value = this.referencedColumn.getEntityValue(entity[this.propertyName]);\n        } else {\n          value = entity[this.propertyName];\n        }\n      } else if (this.referencedColumn) {\n        value = this.referencedColumn.getEntityValue(entity[this.propertyName]);\n      } else {\n        value = entity[this.propertyName];\n      }\n    }\n\n    if (transform && this.transformer) value = ApplyValueTransformers.transformTo(this.transformer, value);\n    return value;\n  }\n  /**\n   * Sets given entity's column value.\n   * Using of this method helps to set entity relation's value of the lazy and non-lazy relations.\n   */\n\n\n  setEntityValue(entity, value) {\n    if (this.embeddedMetadata) {\n      // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n      const extractEmbeddedColumnValue = (embeddedMetadatas, map) => {\n        // if (!object[embeddedMetadata.propertyName])\n        //     object[embeddedMetadata.propertyName] = embeddedMetadata.create();\n        const embeddedMetadata = embeddedMetadatas.shift();\n\n        if (embeddedMetadata) {\n          if (!map[embeddedMetadata.propertyName]) map[embeddedMetadata.propertyName] = embeddedMetadata.create();\n          extractEmbeddedColumnValue(embeddedMetadatas, map[embeddedMetadata.propertyName]);\n          return map;\n        }\n\n        map[this.propertyName] = value;\n        return map;\n      };\n\n      return extractEmbeddedColumnValue([...this.embeddedMetadata.embeddedMetadataTree], entity);\n    } else {\n      // we write a deep object in this entity only if the column is virtual\n      // because if its not virtual it means the user defined a real column for this relation\n      // also we don't do it if column is inside a junction table\n      if (!this.entityMetadata.isJunction && this.isVirtual && this.referencedColumn && this.referencedColumn.propertyName !== this.propertyName) {\n        if (!(this.propertyName in entity)) {\n          entity[this.propertyName] = {};\n        }\n\n        entity[this.propertyName][this.referencedColumn.propertyName] = value;\n      } else {\n        entity[this.propertyName] = value;\n      }\n    }\n  }\n  /**\n   * Compares given entity's column value with a given value.\n   */\n\n\n  compareEntityValue(entity, valueToCompareWith) {\n    const columnValue = this.getEntityValue(entity);\n\n    if (ObjectUtils.isObject(columnValue)) {\n      return columnValue.equals(valueToCompareWith);\n    }\n\n    return columnValue === valueToCompareWith;\n  } // ---------------------------------------------------------------------\n  // Builder Methods\n  // ---------------------------------------------------------------------\n\n\n  build(connection) {\n    this.propertyPath = this.buildPropertyPath();\n    this.propertyAliasName = this.propertyPath.replace(\".\", \"_\");\n    this.databaseName = this.buildDatabaseName(connection);\n    this.databasePath = this.buildDatabasePath();\n    this.databaseNameWithoutPrefixes = connection.namingStrategy.columnName(this.propertyName, this.givenDatabaseName, []);\n    return this;\n  }\n\n  buildPropertyPath() {\n    let path = \"\";\n    if (this.embeddedMetadata && this.embeddedMetadata.parentPropertyNames.length) path = this.embeddedMetadata.parentPropertyNames.join(\".\") + \".\";\n    path += this.propertyName; // we add reference column to property path only if this column is virtual\n    // because if its not virtual it means user defined a real column for this relation\n    // also we don't do it if column is inside a junction table\n\n    if (!this.entityMetadata.isJunction && this.isVirtual && this.referencedColumn && this.referencedColumn.propertyName !== this.propertyName) path += \".\" + this.referencedColumn.propertyName;\n    return path;\n  }\n\n  buildDatabasePath() {\n    let path = \"\";\n    if (this.embeddedMetadata && this.embeddedMetadata.parentPropertyNames.length) path = this.embeddedMetadata.parentPropertyNames.join(\".\") + \".\";\n    path += this.databaseName; // we add reference column to property path only if this column is virtual\n    // because if its not virtual it means user defined a real column for this relation\n    // also we don't do it if column is inside a junction table\n\n    if (!this.entityMetadata.isJunction && this.isVirtual && this.referencedColumn && this.referencedColumn.databaseName !== this.databaseName) path += \".\" + this.referencedColumn.databaseName;\n    return path;\n  }\n\n  buildDatabaseName(connection) {\n    let propertyNames = this.embeddedMetadata ? this.embeddedMetadata.parentPrefixes : [];\n    if (connection.driver.options.type === \"mongodb\") // we don't need to include embedded name for the mongodb column names\n      propertyNames = [];\n    return connection.namingStrategy.columnName(this.propertyName, this.givenDatabaseName, propertyNames);\n  }\n\n}","map":{"version":3,"mappings":"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","names":["OrmUtils","ApplyValueTransformers","ObjectUtils","InstanceChecker","ColumnMetadata","constructor","options","Symbol","for","entityMetadata","embeddedMetadata","referencedColumn","args","target","propertyName","name","givenDatabaseName","type","length","toString","width","charset","collation","primary","isPrimary","default","isNullable","nullable","undefined","select","isSelect","insert","isInsert","update","isUpdate","readonly","comment","onUpdate","generatedIdentity","scale","zerofill","unsigned","precision","enum","isObject","Array","isArray","Object","keys","filter","key","isNaN","map","enumName","primaryKeyConstraintName","foreignKeyConstraintName","asExpression","generatedType","hstoreType","array","mode","isVirtual","isTreeLevel","isCreateDate","isUpdateDate","isDeleteDate","isVersion","isObjectId","transformer","spatialFeatureType","srid","connection","driver","mappedDataTypes","treeLevel","createDate","createDateDefault","createDatePrecision","updateDate","updateDateDefault","updateDatePrecision","deleteDate","deleteDateNullable","deleteDatePrecision","version","closureType","nestedSetLeft","isNestedSetLeft","nestedSetRight","isNestedSetRight","materializedPath","isMaterializedPath","createValueMap","value","useDatabaseName","propertyNames","parentPropertyNames","extractEmbeddedColumnValue","shift","generationStrategy","String","databaseName","getEntityValueMap","entity","returnNulls","isEmbeddedArray","submap","v","relationMetadata","getOwnPropertyDescriptor","_a","get","joinColumns","reduce","joinColumn","mergeDeep","getEntityValue","transform","embeddedObject","relatedEntity","isFindOperator","Buffer","isBuffer","Date","o","transformTo","setEntityValue","embeddedMetadatas","create","embeddedMetadataTree","isJunction","compareEntityValue","valueToCompareWith","columnValue","equals","build","propertyPath","buildPropertyPath","propertyAliasName","replace","buildDatabaseName","databasePath","buildDatabasePath","databaseNameWithoutPrefixes","namingStrategy","columnName","path","join","parentPrefixes"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\metadata\\ColumnMetadata.ts"],"sourcesContent":["import { ColumnType } from \"../driver/types/ColumnTypes\"\nimport { EntityMetadata } from \"./EntityMetadata\"\nimport { EmbeddedMetadata } from \"./EmbeddedMetadata\"\nimport { RelationMetadata } from \"./RelationMetadata\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { ColumnMetadataArgs } from \"../metadata-args/ColumnMetadataArgs\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { OrmUtils } from \"../util/OrmUtils\"\nimport { ValueTransformer } from \"../decorator/options/ValueTransformer\"\nimport { ApplyValueTransformers } from \"../util/ApplyValueTransformers\"\nimport { ObjectUtils } from \"../util/ObjectUtils\"\nimport { InstanceChecker } from \"../util/InstanceChecker\"\n\n/**\n * This metadata contains all information about entity's column.\n */\nexport class ColumnMetadata {\n    readonly \"@instanceof\" = Symbol.for(\"ColumnMetadata\")\n\n    // ---------------------------------------------------------------------\n    // Public Properties\n    // ---------------------------------------------------------------------\n\n    /**\n     * Target class where column decorator is used.\n     * This may not be always equal to entity metadata (for example embeds or inheritance cases).\n     */\n    target: Function | string\n\n    /**\n     * Entity metadata where this column metadata is.\n     *\n     * For example for @Column() name: string in Post, entityMetadata will be metadata of Post entity.\n     */\n    entityMetadata: EntityMetadata\n\n    /**\n     * Embedded metadata where this column metadata is.\n     * If this column is not in embed then this property value is undefined.\n     */\n    embeddedMetadata?: EmbeddedMetadata\n\n    /**\n     * If column is a foreign key of some relation then this relation's metadata will be there.\n     * If this column does not have a foreign key then this property value is undefined.\n     */\n    relationMetadata?: RelationMetadata\n\n    /**\n     * Class's property name on which this column is applied.\n     */\n    propertyName: string\n\n    /**\n     * The database type of the column.\n     */\n    type: ColumnType\n\n    /**\n     * Type's length in the database.\n     */\n    length: string = \"\"\n\n    /**\n     * Type's display width in the database.\n     */\n    width?: number\n\n    /**\n     * Defines column character set.\n     */\n    charset?: string\n\n    /**\n     * Defines column collation.\n     */\n    collation?: string\n\n    /**\n     * Indicates if this column is a primary key.\n     */\n    isPrimary: boolean = false\n\n    /**\n     * Indicates if this column is generated (auto increment or generated other way).\n     */\n    isGenerated: boolean = false\n\n    /**\n     * Indicates if column can contain nulls or not.\n     */\n    isNullable: boolean = false\n\n    /**\n     * Indicates if column is selected by query builder or not.\n     */\n    isSelect: boolean = true\n\n    /**\n     * Indicates if column is inserted by default or not.\n     */\n    isInsert: boolean = true\n\n    /**\n     * Indicates if column allows updates or not.\n     */\n    isUpdate: boolean = true\n\n    /**\n     * Specifies generation strategy if this column will use auto increment.\n     */\n    generationStrategy?: \"uuid\" | \"increment\" | \"rowid\"\n\n    /**\n     * Identity column type. Supports only in Postgres 10+.\n     */\n    generatedIdentity?: \"ALWAYS\" | \"BY DEFAULT\"\n\n    /**\n     * Column comment.\n     * This feature is not supported by all databases.\n     */\n    comment?: string\n\n    /**\n     * Default database value.\n     */\n    default?:\n        | number\n        | boolean\n        | string\n        | null\n        | (number | boolean | string)[]\n        | Record<string, object>\n        | (() => string)\n\n    /**\n     * ON UPDATE trigger. Works only for MySQL.\n     */\n    onUpdate?: string\n\n    /**\n     * The precision for a decimal (exact numeric) column (applies only for decimal column),\n     * which is the maximum number of digits that are stored for the values.\n     */\n    precision?: number | null\n\n    /**\n     * The scale for a decimal (exact numeric) column (applies only for decimal column),\n     * which represents the number of digits to the right of the decimal point and must not be greater than precision.\n     */\n    scale?: number\n\n    /**\n     * Puts ZEROFILL attribute on to numeric column. Works only for MySQL.\n     * If you specify ZEROFILL for a numeric column, MySQL automatically adds the UNSIGNED attribute to the column\n     */\n    zerofill: boolean = false\n\n    /**\n     * Puts UNSIGNED attribute on to numeric column. Works only for MySQL.\n     */\n    unsigned: boolean = false\n\n    /**\n     * Array of possible enumerated values.\n     *\n     * `postgres` and `mysql` store enum values as strings but we want to keep support\n     * for numeric and heterogeneous based typescript enums, so we need (string|number)[]\n     */\n    enum?: (string | number)[]\n\n    /**\n     * Exact name of enum\n     */\n    enumName?: string\n\n    /**\n     * Generated column expression.\n     */\n    asExpression?: string\n\n    /**\n     * Generated column type.\n     */\n    generatedType?: \"VIRTUAL\" | \"STORED\"\n\n    /**\n     * Return type of HSTORE column.\n     * Returns value as string or as object.\n     */\n    hstoreType?: \"object\" | \"string\"\n\n    /**\n     * Indicates if this column is an array.\n     */\n    isArray: boolean = false\n\n    /**\n     * Gets full path to this column property (including column property name).\n     * Full path is relevant when column is used in embeds (one or multiple nested).\n     * For example it will return \"counters.subcounters.likes\".\n     * If property is not in embeds then it returns just property name of the column.\n     */\n    propertyPath: string\n\n    /**\n     * Same as property path, but dots are replaced with '_'.\n     * Used in query builder statements.\n     */\n    propertyAliasName: string\n\n    /**\n     * Gets full path to this column database name (including column database name).\n     * Full path is relevant when column is used in embeds (one or multiple nested).\n     * For example it will return \"counters.subcounters.likes\".\n     * If property is not in embeds then it returns just database name of the column.\n     */\n    databasePath: string\n\n    /**\n     * Complete column name in the database including its embedded prefixes.\n     */\n    databaseName: string\n\n    /**\n     * Database name in the database without embedded prefixes applied.\n     */\n    databaseNameWithoutPrefixes: string\n\n    /**\n     * Database name set by entity metadata builder, not yet passed naming strategy process and without embedded prefixes.\n     */\n    givenDatabaseName?: string\n\n    /**\n     * Indicates if column is virtual. Virtual columns are not mapped to the entity.\n     */\n    isVirtual: boolean = false\n\n    /**\n     * Indicates if column is discriminator. Discriminator columns are not mapped to the entity.\n     */\n    isDiscriminator: boolean = false\n\n    /**\n     * Indicates if column is tree-level column. Tree-level columns are used in closure entities.\n     */\n    isTreeLevel: boolean = false\n\n    /**\n     * Indicates if this column contains an entity creation date.\n     */\n    isCreateDate: boolean = false\n\n    /**\n     * Indicates if this column contains an entity update date.\n     */\n    isUpdateDate: boolean = false\n\n    /**\n     * Indicates if this column contains an entity delete date.\n     */\n    isDeleteDate: boolean = false\n\n    /**\n     * Indicates if this column contains an entity version.\n     */\n    isVersion: boolean = false\n\n    /**\n     * Indicates if this column contains an object id.\n     */\n    isObjectId: boolean = false\n\n    /**\n     * If this column is foreign key then it references some other column,\n     * and this property will contain reference to this column.\n     */\n    referencedColumn: ColumnMetadata | undefined\n\n    /**\n     * If this column is primary key then this specifies the name for it.\n     */\n    primaryKeyConstraintName?: string\n\n    /**\n     * If this column is foreign key then this specifies the name for it.\n     */\n    foreignKeyConstraintName?: string\n\n    /**\n     * Specifies a value transformer that is to be used to (un)marshal\n     * this column when reading or writing to the database.\n     */\n    transformer?: ValueTransformer | ValueTransformer[]\n\n    /**\n     * Column type in the case if this column is in the closure table.\n     * Column can be ancestor or descendant in the closure tables.\n     */\n    closureType?: \"ancestor\" | \"descendant\"\n\n    /**\n     * Indicates if this column is nested set's left column.\n     * Used only in tree entities with nested-set type.\n     */\n    isNestedSetLeft: boolean = false\n\n    /**\n     * Indicates if this column is nested set's right column.\n     * Used only in tree entities with nested-set type.\n     */\n    isNestedSetRight: boolean = false\n\n    /**\n     * Indicates if this column is materialized path's path column.\n     * Used only in tree entities with materialized path type.\n     */\n    isMaterializedPath: boolean = false\n\n    /**\n     * Spatial Feature Type (Geometry, Point, Polygon, etc.)\n     */\n    spatialFeatureType?: string\n\n    /**\n     * SRID (Spatial Reference ID (EPSG code))\n     */\n    srid?: number\n\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(options: {\n        connection: DataSource\n        entityMetadata: EntityMetadata\n        embeddedMetadata?: EmbeddedMetadata\n        referencedColumn?: ColumnMetadata\n        args: ColumnMetadataArgs\n        closureType?: \"ancestor\" | \"descendant\"\n        nestedSetLeft?: boolean\n        nestedSetRight?: boolean\n        materializedPath?: boolean\n    }) {\n        this.entityMetadata = options.entityMetadata\n        this.embeddedMetadata = options.embeddedMetadata!\n        this.referencedColumn = options.referencedColumn\n        if (options.args.target) this.target = options.args.target\n        if (options.args.propertyName)\n            this.propertyName = options.args.propertyName\n        if (options.args.options.name)\n            this.givenDatabaseName = options.args.options.name\n        if (options.args.options.type) this.type = options.args.options.type\n        if (options.args.options.length)\n            this.length = options.args.options.length\n                ? options.args.options.length.toString()\n                : \"\"\n        if (options.args.options.width) this.width = options.args.options.width\n        if (options.args.options.charset)\n            this.charset = options.args.options.charset\n        if (options.args.options.collation)\n            this.collation = options.args.options.collation\n        if (options.args.options.primary)\n            this.isPrimary = options.args.options.primary\n        if (options.args.options.default === null)\n            // to make sure default: null is the same as nullable: true\n            this.isNullable = true\n        if (options.args.options.nullable !== undefined)\n            this.isNullable = options.args.options.nullable\n        if (options.args.options.select !== undefined)\n            this.isSelect = options.args.options.select\n        if (options.args.options.insert !== undefined)\n            this.isInsert = options.args.options.insert\n        if (options.args.options.update !== undefined)\n            this.isUpdate = options.args.options.update\n        if (options.args.options.readonly !== undefined)\n            this.isUpdate = !options.args.options.readonly\n        if (options.args.options.comment)\n            this.comment = options.args.options.comment\n        if (options.args.options.default !== undefined)\n            this.default = options.args.options.default\n        if (options.args.options.onUpdate)\n            this.onUpdate = options.args.options.onUpdate\n        if (options.args.options.generatedIdentity)\n            this.generatedIdentity = options.args.options.generatedIdentity\n        if (\n            options.args.options.scale !== null &&\n            options.args.options.scale !== undefined\n        )\n            this.scale = options.args.options.scale\n        if (options.args.options.zerofill) {\n            this.zerofill = options.args.options.zerofill\n            this.unsigned = true // if you specify ZEROFILL for a numeric column, MySQL automatically adds the UNSIGNED attribute to the column\n        }\n        if (options.args.options.unsigned)\n            this.unsigned = options.args.options.unsigned\n        if (options.args.options.precision !== null)\n            this.precision = options.args.options.precision\n        if (options.args.options.enum) {\n            if (\n                ObjectUtils.isObject(options.args.options.enum) &&\n                !Array.isArray(options.args.options.enum)\n            ) {\n                this.enum = Object.keys(options.args.options.enum)\n                    // remove numeric keys - typescript numeric enum types generate them\n                    // From the documentation: “declaration merging” means that the compiler merges two separate declarations\n                    // declared with the same name into a single definition. This concept is often used to merge enum with namespace\n                    // where in namespace we define e.g. utility methods for creating enum. This is well known in other languages\n                    // like Java (enum methods). Here in case if enum have function, we need to remove it from metadata, otherwise\n                    // generated SQL statements contains string representation of that function which leads into syntax error\n                    // at database side.\n                    .filter(\n                        (key) =>\n                            isNaN(+key) &&\n                            typeof (options.args.options.enum as ObjectLiteral)[\n                                key\n                            ] !== \"function\",\n                    )\n                    .map(\n                        (key) =>\n                            (options.args.options.enum as ObjectLiteral)[key],\n                    )\n            } else {\n                this.enum = options.args.options.enum\n            }\n        }\n        if (options.args.options.enumName) {\n            this.enumName = options.args.options.enumName\n        }\n        if (options.args.options.primaryKeyConstraintName) {\n            this.primaryKeyConstraintName =\n                options.args.options.primaryKeyConstraintName\n        }\n        if (options.args.options.foreignKeyConstraintName) {\n            this.foreignKeyConstraintName =\n                options.args.options.foreignKeyConstraintName\n        }\n        if (options.args.options.asExpression) {\n            this.asExpression = options.args.options.asExpression\n            this.generatedType = options.args.options.generatedType\n                ? options.args.options.generatedType\n                : \"VIRTUAL\"\n        }\n        if (options.args.options.hstoreType)\n            this.hstoreType = options.args.options.hstoreType\n        if (options.args.options.array)\n            this.isArray = options.args.options.array\n        if (options.args.mode) {\n            this.isVirtual = options.args.mode === \"virtual\"\n            this.isTreeLevel = options.args.mode === \"treeLevel\"\n            this.isCreateDate = options.args.mode === \"createDate\"\n            this.isUpdateDate = options.args.mode === \"updateDate\"\n            this.isDeleteDate = options.args.mode === \"deleteDate\"\n            this.isVersion = options.args.mode === \"version\"\n            this.isObjectId = options.args.mode === \"objectId\"\n        }\n        if (options.args.options.transformer)\n            this.transformer = options.args.options.transformer\n        if (options.args.options.spatialFeatureType)\n            this.spatialFeatureType = options.args.options.spatialFeatureType\n        if (options.args.options.srid !== undefined)\n            this.srid = options.args.options.srid\n        if (this.isTreeLevel)\n            this.type = options.connection.driver.mappedDataTypes.treeLevel\n        if (this.isCreateDate) {\n            if (!this.type)\n                this.type = options.connection.driver.mappedDataTypes.createDate\n            if (!this.default)\n                this.default = () =>\n                    options.connection.driver.mappedDataTypes.createDateDefault\n            // skip precision if it was explicitly set to \"null\" in column options. Otherwise use default precision if it exist.\n            if (\n                this.precision === undefined &&\n                options.args.options.precision === undefined &&\n                options.connection.driver.mappedDataTypes.createDatePrecision\n            )\n                this.precision =\n                    options.connection.driver.mappedDataTypes.createDatePrecision\n        }\n        if (this.isUpdateDate) {\n            if (!this.type)\n                this.type = options.connection.driver.mappedDataTypes.updateDate\n            if (!this.default)\n                this.default = () =>\n                    options.connection.driver.mappedDataTypes.updateDateDefault\n            if (!this.onUpdate)\n                this.onUpdate =\n                    options.connection.driver.mappedDataTypes.updateDateDefault\n            // skip precision if it was explicitly set to \"null\" in column options. Otherwise use default precision if it exist.\n            if (\n                this.precision === undefined &&\n                options.args.options.precision === undefined &&\n                options.connection.driver.mappedDataTypes.updateDatePrecision\n            )\n                this.precision =\n                    options.connection.driver.mappedDataTypes.updateDatePrecision\n        }\n        if (this.isDeleteDate) {\n            if (!this.type)\n                this.type = options.connection.driver.mappedDataTypes.deleteDate\n            if (!this.isNullable)\n                this.isNullable =\n                    options.connection.driver.mappedDataTypes.deleteDateNullable\n            // skip precision if it was explicitly set to \"null\" in column options. Otherwise use default precision if it exist.\n            if (\n                this.precision === undefined &&\n                options.args.options.precision === undefined &&\n                options.connection.driver.mappedDataTypes.deleteDatePrecision\n            )\n                this.precision =\n                    options.connection.driver.mappedDataTypes.deleteDatePrecision\n        }\n        if (this.isVersion)\n            this.type = options.connection.driver.mappedDataTypes.version\n        if (options.closureType) this.closureType = options.closureType\n        if (options.nestedSetLeft) this.isNestedSetLeft = options.nestedSetLeft\n        if (options.nestedSetRight)\n            this.isNestedSetRight = options.nestedSetRight\n        if (options.materializedPath)\n            this.isMaterializedPath = options.materializedPath\n    }\n\n    // ---------------------------------------------------------------------\n    // Public Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Creates entity id map from the given entity ids array.\n     */\n    createValueMap(value: any, useDatabaseName = false) {\n        // extract column value from embeds of entity if column is in embedded\n        if (this.embeddedMetadata) {\n            // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n            // we need to get value of \"id\" column from the post real entity object and return it in a\n            // { data: { information: { counters: { id: ... } } } } format\n\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n            const propertyNames = [...this.embeddedMetadata.parentPropertyNames]\n\n            // now need to access post[data][information][counters] to get column value from the counters\n            // and on each step we need to create complex literal object, e.g. first { data },\n            // then { data: { information } }, then { data: { information: { counters } } },\n            // then { data: { information: { counters: [this.propertyName]: entity[data][information][counters][this.propertyName] } } }\n            // this recursive function helps doing that\n            const extractEmbeddedColumnValue = (\n                propertyNames: string[],\n                map: ObjectLiteral,\n            ): any => {\n                const propertyName = propertyNames.shift()\n                if (propertyName) {\n                    map[propertyName] = {}\n                    extractEmbeddedColumnValue(propertyNames, map[propertyName])\n                    return map\n                }\n\n                // this is bugfix for #720 when increment number is bigint we need to make sure its a string\n                if (\n                    (this.generationStrategy === \"increment\" ||\n                        this.generationStrategy === \"rowid\") &&\n                    this.type === \"bigint\" &&\n                    value !== null\n                )\n                    value = String(value)\n\n                map[useDatabaseName ? this.databaseName : this.propertyName] =\n                    value\n                return map\n            }\n            return extractEmbeddedColumnValue(propertyNames, {})\n        } else {\n            // no embeds - no problems. Simply return column property name and its value of the entity\n\n            // this is bugfix for #720 when increment number is bigint we need to make sure its a string\n            if (\n                (this.generationStrategy === \"increment\" ||\n                    this.generationStrategy === \"rowid\") &&\n                this.type === \"bigint\" &&\n                value !== null\n            )\n                value = String(value)\n\n            return {\n                [useDatabaseName ? this.databaseName : this.propertyName]:\n                    value,\n            }\n        }\n    }\n\n    /**\n     * Extracts column value and returns its column name with this value in a literal object.\n     * If column is in embedded (or recursive embedded) it returns complex literal object.\n     *\n     * Examples what this method can return depend if this column is in embeds.\n     * { id: 1 } or { title: \"hello\" }, { counters: { code: 1 } }, { data: { information: { counters: { code: 1 } } } }\n     */\n    getEntityValueMap(\n        entity: ObjectLiteral,\n        options?: { skipNulls?: boolean },\n    ): ObjectLiteral | undefined {\n        const returnNulls = false // options && options.skipNulls === false ? false : true; // todo: remove if current will not bring problems, uncomment if it will.\n\n        // extract column value from embeds of entity if column is in embedded\n        if (this.embeddedMetadata) {\n            // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n            // we need to get value of \"id\" column from the post real entity object and return it in a\n            // { data: { information: { counters: { id: ... } } } } format\n\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n            const propertyNames = [...this.embeddedMetadata.parentPropertyNames]\n            const isEmbeddedArray = this.embeddedMetadata.isArray\n\n            // now need to access post[data][information][counters] to get column value from the counters\n            // and on each step we need to create complex literal object, e.g. first { data },\n            // then { data: { information } }, then { data: { information: { counters } } },\n            // then { data: { information: { counters: [this.propertyName]: entity[data][information][counters][this.propertyName] } } }\n            // this recursive function helps doing that\n            const extractEmbeddedColumnValue = (\n                propertyNames: string[],\n                value: ObjectLiteral,\n            ): ObjectLiteral => {\n                if (value === undefined) {\n                    return {}\n                }\n\n                const propertyName = propertyNames.shift()\n\n                if (propertyName) {\n                    const submap = extractEmbeddedColumnValue(\n                        propertyNames,\n                        value[propertyName],\n                    )\n                    if (Object.keys(submap).length > 0) {\n                        return { [propertyName]: submap }\n                    }\n                    return {}\n                }\n\n                if (isEmbeddedArray && Array.isArray(value)) {\n                    return value.map((v) => ({\n                        [this.propertyName]: v[this.propertyName],\n                    }))\n                }\n\n                if (\n                    value[this.propertyName] !== undefined &&\n                    (returnNulls === false || value[this.propertyName] !== null)\n                ) {\n                    return { [this.propertyName]: value[this.propertyName] }\n                }\n\n                return {}\n            }\n            const map = extractEmbeddedColumnValue(propertyNames, entity)\n\n            return Object.keys(map).length > 0 ? map : undefined\n        } else {\n            // no embeds - no problems. Simply return column property name and its value of the entity\n            /**\n             * Object.getOwnPropertyDescriptor checks if the relation is lazy, in which case value is a Promise\n             * DO NOT use `entity[\n                this.relationMetadata.propertyName] instanceof Promise`, which will invoke property getter and make unwanted DB request\n             * refer: https://github.com/typeorm/typeorm/pull/8676#issuecomment-1049906331\n             */\n            if (\n                this.relationMetadata &&\n                !Object.getOwnPropertyDescriptor(\n                    entity,\n                    this.relationMetadata.propertyName,\n                )?.get &&\n                entity[this.relationMetadata.propertyName] &&\n                ObjectUtils.isObject(entity[this.relationMetadata.propertyName])\n            ) {\n                const map = this.relationMetadata.joinColumns.reduce(\n                    (map, joinColumn) => {\n                        const value =\n                            joinColumn.referencedColumn!.getEntityValueMap(\n                                entity[this.relationMetadata!.propertyName],\n                            )\n                        if (value === undefined) return map\n                        return OrmUtils.mergeDeep(map, value)\n                    },\n                    {},\n                )\n                if (Object.keys(map).length > 0)\n                    return { [this.propertyName]: map }\n\n                return undefined\n            } else {\n                if (\n                    entity[this.propertyName] !== undefined &&\n                    (returnNulls === false ||\n                        entity[this.propertyName] !== null)\n                )\n                    return { [this.propertyName]: entity[this.propertyName] }\n\n                return undefined\n            }\n        }\n    }\n\n    /**\n     * Extracts column value from the given entity.\n     * If column is in embedded (or recursive embedded) it extracts its value from there.\n     */\n    getEntityValue(\n        entity: ObjectLiteral,\n        transform: boolean = false,\n    ): any | undefined {\n        if (entity === undefined || entity === null) return undefined\n\n        // extract column value from embeddeds of entity if column is in embedded\n        let value: any = undefined\n        if (this.embeddedMetadata) {\n            // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n            // we need to get value of \"id\" column from the post real entity object\n\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n            const propertyNames = [...this.embeddedMetadata.parentPropertyNames]\n            const isEmbeddedArray = this.embeddedMetadata.isArray\n\n            // next we need to access post[data][information][counters][this.propertyName] to get column value from the counters\n            // this recursive function takes array of generated property names and gets the post[data][information][counters] embed\n            const extractEmbeddedColumnValue = (\n                propertyNames: string[],\n                value: ObjectLiteral,\n            ): any => {\n                const propertyName = propertyNames.shift()\n                return propertyName && value\n                    ? extractEmbeddedColumnValue(\n                          propertyNames,\n                          value[propertyName],\n                      )\n                    : value\n            }\n\n            // once we get nested embed object we get its column, e.g. post[data][information][counters][this.propertyName]\n            const embeddedObject = extractEmbeddedColumnValue(\n                propertyNames,\n                entity,\n            )\n            if (embeddedObject) {\n                if (this.relationMetadata && this.referencedColumn) {\n                    const relatedEntity =\n                        this.relationMetadata.getEntityValue(embeddedObject)\n                    if (\n                        relatedEntity &&\n                        ObjectUtils.isObject(relatedEntity) &&\n                        !InstanceChecker.isFindOperator(relatedEntity) &&\n                        !Buffer.isBuffer(relatedEntity)\n                    ) {\n                        value =\n                            this.referencedColumn.getEntityValue(relatedEntity)\n                    } else if (\n                        embeddedObject[this.propertyName] &&\n                        ObjectUtils.isObject(\n                            embeddedObject[this.propertyName],\n                        ) &&\n                        !InstanceChecker.isFindOperator(\n                            embeddedObject[this.propertyName],\n                        ) &&\n                        !Buffer.isBuffer(embeddedObject[this.propertyName]) &&\n                        !(embeddedObject[this.propertyName] instanceof Date)\n                    ) {\n                        value = this.referencedColumn.getEntityValue(\n                            embeddedObject[this.propertyName],\n                        )\n                    } else {\n                        value = embeddedObject[this.propertyName]\n                    }\n                } else if (this.referencedColumn) {\n                    value = this.referencedColumn.getEntityValue(\n                        embeddedObject[this.propertyName],\n                    )\n                } else if (isEmbeddedArray && Array.isArray(embeddedObject)) {\n                    value = embeddedObject.map((o) => o[this.propertyName])\n                } else {\n                    value = embeddedObject[this.propertyName]\n                }\n            }\n        } else {\n            // no embeds - no problems. Simply return column name by property name of the entity\n            if (this.relationMetadata && this.referencedColumn) {\n                const relatedEntity =\n                    this.relationMetadata.getEntityValue(entity)\n                if (\n                    relatedEntity &&\n                    ObjectUtils.isObject(relatedEntity) &&\n                    !InstanceChecker.isFindOperator(relatedEntity) &&\n                    !(typeof relatedEntity === \"function\") &&\n                    !Buffer.isBuffer(relatedEntity)\n                ) {\n                    value = this.referencedColumn.getEntityValue(relatedEntity)\n                } else if (\n                    entity[this.propertyName] &&\n                    ObjectUtils.isObject(entity[this.propertyName]) &&\n                    !InstanceChecker.isFindOperator(\n                        entity[this.propertyName],\n                    ) &&\n                    !(typeof entity[this.propertyName] === \"function\") &&\n                    !Buffer.isBuffer(entity[this.propertyName]) &&\n                    !(entity[this.propertyName] instanceof Date)\n                ) {\n                    value = this.referencedColumn.getEntityValue(\n                        entity[this.propertyName],\n                    )\n                } else {\n                    value = entity[this.propertyName]\n                }\n            } else if (this.referencedColumn) {\n                value = this.referencedColumn.getEntityValue(\n                    entity[this.propertyName],\n                )\n            } else {\n                value = entity[this.propertyName]\n            }\n        }\n\n        if (transform && this.transformer)\n            value = ApplyValueTransformers.transformTo(this.transformer, value)\n\n        return value\n    }\n\n    /**\n     * Sets given entity's column value.\n     * Using of this method helps to set entity relation's value of the lazy and non-lazy relations.\n     */\n    setEntityValue(entity: ObjectLiteral, value: any): void {\n        if (this.embeddedMetadata) {\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n            const extractEmbeddedColumnValue = (\n                embeddedMetadatas: EmbeddedMetadata[],\n                map: ObjectLiteral,\n            ): any => {\n                // if (!object[embeddedMetadata.propertyName])\n                //     object[embeddedMetadata.propertyName] = embeddedMetadata.create();\n\n                const embeddedMetadata = embeddedMetadatas.shift()\n                if (embeddedMetadata) {\n                    if (!map[embeddedMetadata.propertyName])\n                        map[embeddedMetadata.propertyName] =\n                            embeddedMetadata.create()\n\n                    extractEmbeddedColumnValue(\n                        embeddedMetadatas,\n                        map[embeddedMetadata.propertyName],\n                    )\n                    return map\n                }\n                map[this.propertyName] = value\n                return map\n            }\n            return extractEmbeddedColumnValue(\n                [...this.embeddedMetadata.embeddedMetadataTree],\n                entity,\n            )\n        } else {\n            // we write a deep object in this entity only if the column is virtual\n            // because if its not virtual it means the user defined a real column for this relation\n            // also we don't do it if column is inside a junction table\n            if (\n                !this.entityMetadata.isJunction &&\n                this.isVirtual &&\n                this.referencedColumn &&\n                this.referencedColumn.propertyName !== this.propertyName\n            ) {\n                if (!(this.propertyName in entity)) {\n                    entity[this.propertyName] = {}\n                }\n\n                entity[this.propertyName][this.referencedColumn.propertyName] =\n                    value\n            } else {\n                entity[this.propertyName] = value\n            }\n        }\n    }\n\n    /**\n     * Compares given entity's column value with a given value.\n     */\n    compareEntityValue(entity: any, valueToCompareWith: any) {\n        const columnValue = this.getEntityValue(entity)\n        if (ObjectUtils.isObject(columnValue)) {\n            return columnValue.equals(valueToCompareWith)\n        }\n        return columnValue === valueToCompareWith\n    }\n\n    // ---------------------------------------------------------------------\n    // Builder Methods\n    // ---------------------------------------------------------------------\n\n    build(connection: DataSource): this {\n        this.propertyPath = this.buildPropertyPath()\n        this.propertyAliasName = this.propertyPath.replace(\".\", \"_\")\n        this.databaseName = this.buildDatabaseName(connection)\n        this.databasePath = this.buildDatabasePath()\n        this.databaseNameWithoutPrefixes = connection.namingStrategy.columnName(\n            this.propertyName,\n            this.givenDatabaseName,\n            [],\n        )\n        return this\n    }\n\n    protected buildPropertyPath(): string {\n        let path = \"\"\n        if (\n            this.embeddedMetadata &&\n            this.embeddedMetadata.parentPropertyNames.length\n        )\n            path = this.embeddedMetadata.parentPropertyNames.join(\".\") + \".\"\n\n        path += this.propertyName\n\n        // we add reference column to property path only if this column is virtual\n        // because if its not virtual it means user defined a real column for this relation\n        // also we don't do it if column is inside a junction table\n        if (\n            !this.entityMetadata.isJunction &&\n            this.isVirtual &&\n            this.referencedColumn &&\n            this.referencedColumn.propertyName !== this.propertyName\n        )\n            path += \".\" + this.referencedColumn.propertyName\n\n        return path\n    }\n\n    protected buildDatabasePath(): string {\n        let path = \"\"\n        if (\n            this.embeddedMetadata &&\n            this.embeddedMetadata.parentPropertyNames.length\n        )\n            path = this.embeddedMetadata.parentPropertyNames.join(\".\") + \".\"\n\n        path += this.databaseName\n\n        // we add reference column to property path only if this column is virtual\n        // because if its not virtual it means user defined a real column for this relation\n        // also we don't do it if column is inside a junction table\n        if (\n            !this.entityMetadata.isJunction &&\n            this.isVirtual &&\n            this.referencedColumn &&\n            this.referencedColumn.databaseName !== this.databaseName\n        )\n            path += \".\" + this.referencedColumn.databaseName\n\n        return path\n    }\n\n    protected buildDatabaseName(connection: DataSource): string {\n        let propertyNames = this.embeddedMetadata\n            ? this.embeddedMetadata.parentPrefixes\n            : []\n        if (connection.driver.options.type === \"mongodb\")\n            // we don't need to include embedded name for the mongodb column names\n            propertyNames = []\n        return connection.namingStrategy.columnName(\n            this.propertyName,\n            this.givenDatabaseName,\n            propertyNames,\n        )\n    }\n}\n"]},"metadata":{},"sourceType":"module"}