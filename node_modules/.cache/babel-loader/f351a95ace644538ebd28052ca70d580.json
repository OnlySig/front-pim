{"ast":null,"code":"import { QueryRunnerAlreadyReleasedError } from \"../../error/QueryRunnerAlreadyReleasedError\";\nimport { TransactionNotStartedError } from \"../../error/TransactionNotStartedError\";\nimport { PostgresQueryRunner } from \"../postgres/PostgresQueryRunner\";\nimport { QueryResult } from \"../../query-runner/QueryResult\";\n\nclass PostgresQueryRunnerWrapper extends PostgresQueryRunner {\n  constructor(driver, mode) {\n    super(driver, mode);\n  }\n\n}\n/**\n * Runs queries on a single postgres database connection.\n */\n\n\nexport class AuroraPostgresQueryRunner extends PostgresQueryRunnerWrapper {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(driver, client, mode) {\n    super(driver, mode);\n    this.client = client;\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Creates/uses database connection from the connection pool to perform further operations.\n   * Returns obtained database connection.\n   */\n\n\n  connect() {\n    if (this.databaseConnection) return Promise.resolve(this.databaseConnection);\n    if (this.databaseConnectionPromise) return this.databaseConnectionPromise;\n\n    if (this.mode === \"slave\" && this.driver.isReplicated) {\n      this.databaseConnectionPromise = this.driver.obtainSlaveConnection().then(_ref => {\n        let [connection, release] = _ref;\n        this.driver.connectedQueryRunners.push(this);\n        this.databaseConnection = connection;\n        this.releaseCallback = release;\n        return this.databaseConnection;\n      });\n    } else {\n      // master\n      this.databaseConnectionPromise = this.driver.obtainMasterConnection().then(_ref2 => {\n        let [connection, release] = _ref2;\n        this.driver.connectedQueryRunners.push(this);\n        this.databaseConnection = connection;\n        this.releaseCallback = release;\n        return this.databaseConnection;\n      });\n    }\n\n    return this.databaseConnectionPromise;\n  }\n  /**\n   * Starts transaction on the current connection.\n   */\n\n\n  async startTransaction(isolationLevel) {\n    this.isTransactionActive = true;\n\n    try {\n      await this.broadcaster.broadcast(\"BeforeTransactionStart\");\n    } catch (err) {\n      this.isTransactionActive = false;\n      throw err;\n    }\n\n    if (this.transactionDepth === 0) {\n      await this.client.startTransaction();\n    } else {\n      await this.query(`SAVEPOINT typeorm_${this.transactionDepth}`);\n    }\n\n    this.transactionDepth += 1;\n    await this.broadcaster.broadcast(\"AfterTransactionStart\");\n  }\n  /**\n   * Commits transaction.\n   * Error will be thrown if transaction was not started.\n   */\n\n\n  async commitTransaction() {\n    if (!this.isTransactionActive) throw new TransactionNotStartedError();\n    await this.broadcaster.broadcast(\"BeforeTransactionCommit\");\n\n    if (this.transactionDepth > 1) {\n      await this.query(`RELEASE SAVEPOINT typeorm_${this.transactionDepth - 1}`);\n    } else {\n      await this.client.commitTransaction();\n      this.isTransactionActive = false;\n    }\n\n    this.transactionDepth -= 1;\n    await this.broadcaster.broadcast(\"AfterTransactionCommit\");\n  }\n  /**\n   * Rollbacks transaction.\n   * Error will be thrown if transaction was not started.\n   */\n\n\n  async rollbackTransaction() {\n    if (!this.isTransactionActive) throw new TransactionNotStartedError();\n    await this.broadcaster.broadcast(\"BeforeTransactionRollback\");\n\n    if (this.transactionDepth > 1) {\n      await this.query(`ROLLBACK TO SAVEPOINT typeorm_${this.transactionDepth - 1}`);\n    } else {\n      await this.client.rollbackTransaction();\n      this.isTransactionActive = false;\n    }\n\n    this.transactionDepth -= 1;\n    await this.broadcaster.broadcast(\"AfterTransactionRollback\");\n  }\n  /**\n   * Executes a given SQL query.\n   */\n\n\n  async query(query, parameters) {\n    let useStructuredResult = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (this.isReleased) throw new QueryRunnerAlreadyReleasedError();\n    const raw = await this.client.query(query, parameters);\n    const result = new QueryResult();\n    result.raw = raw;\n\n    if ((raw === null || raw === void 0 ? void 0 : raw.hasOwnProperty(\"records\")) && Array.isArray(raw.records)) {\n      result.records = raw.records;\n    }\n\n    if (raw === null || raw === void 0 ? void 0 : raw.hasOwnProperty(\"numberOfRecordsUpdated\")) {\n      result.affected = raw.numberOfRecordsUpdated;\n    }\n\n    if (!useStructuredResult) {\n      return result.raw;\n    }\n\n    return result;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["QueryRunnerAlreadyReleasedError","TransactionNotStartedError","PostgresQueryRunner","QueryResult","PostgresQueryRunnerWrapper","constructor","driver","mode","AuroraPostgresQueryRunner","client","connect","databaseConnection","Promise","resolve","databaseConnectionPromise","isReplicated","obtainSlaveConnection","then","connection","release","connectedQueryRunners","push","releaseCallback","obtainMasterConnection","startTransaction","isolationLevel","isTransactionActive","broadcaster","broadcast","err","transactionDepth","query","commitTransaction","rollbackTransaction","parameters","useStructuredResult","isReleased","raw","result","hasOwnProperty","Array","isArray","records","affected","numberOfRecordsUpdated"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\driver\\aurora-postgres\\AuroraPostgresQueryRunner.ts"],"sourcesContent":["import { QueryRunnerAlreadyReleasedError } from \"../../error/QueryRunnerAlreadyReleasedError\"\nimport { TransactionNotStartedError } from \"../../error/TransactionNotStartedError\"\nimport { QueryRunner } from \"../../query-runner/QueryRunner\"\nimport { IsolationLevel } from \"../types/IsolationLevel\"\nimport { AuroraPostgresDriver } from \"./AuroraPostgresDriver\"\nimport { PostgresQueryRunner } from \"../postgres/PostgresQueryRunner\"\nimport { ReplicationMode } from \"../types/ReplicationMode\"\nimport { QueryResult } from \"../../query-runner/QueryResult\"\n\nclass PostgresQueryRunnerWrapper extends PostgresQueryRunner {\n    driver: any\n\n    constructor(driver: any, mode: ReplicationMode) {\n        super(driver, mode)\n    }\n}\n\n/**\n * Runs queries on a single postgres database connection.\n */\nexport class AuroraPostgresQueryRunner\n    extends PostgresQueryRunnerWrapper\n    implements QueryRunner\n{\n    // -------------------------------------------------------------------------\n    // Public Implemented Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Database driver used by connection.\n     */\n    driver: AuroraPostgresDriver\n\n    protected client: any\n\n    // -------------------------------------------------------------------------\n    // Protected Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Promise used to obtain a database connection for a first time.\n     */\n    protected databaseConnectionPromise: Promise<any>\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        driver: AuroraPostgresDriver,\n        client: any,\n        mode: ReplicationMode,\n    ) {\n        super(driver, mode)\n\n        this.client = client\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates/uses database connection from the connection pool to perform further operations.\n     * Returns obtained database connection.\n     */\n    connect(): Promise<any> {\n        if (this.databaseConnection)\n            return Promise.resolve(this.databaseConnection)\n\n        if (this.databaseConnectionPromise)\n            return this.databaseConnectionPromise\n\n        if (this.mode === \"slave\" && this.driver.isReplicated) {\n            this.databaseConnectionPromise = this.driver\n                .obtainSlaveConnection()\n                .then(([connection, release]: any[]) => {\n                    this.driver.connectedQueryRunners.push(this)\n                    this.databaseConnection = connection\n                    this.releaseCallback = release\n                    return this.databaseConnection\n                })\n        } else {\n            // master\n            this.databaseConnectionPromise = this.driver\n                .obtainMasterConnection()\n                .then(([connection, release]: any[]) => {\n                    this.driver.connectedQueryRunners.push(this)\n                    this.databaseConnection = connection\n                    this.releaseCallback = release\n                    return this.databaseConnection\n                })\n        }\n\n        return this.databaseConnectionPromise\n    }\n\n    /**\n     * Starts transaction on the current connection.\n     */\n    async startTransaction(isolationLevel?: IsolationLevel): Promise<void> {\n        this.isTransactionActive = true\n        try {\n            await this.broadcaster.broadcast(\"BeforeTransactionStart\")\n        } catch (err) {\n            this.isTransactionActive = false\n            throw err\n        }\n\n        if (this.transactionDepth === 0) {\n            await this.client.startTransaction()\n        } else {\n            await this.query(`SAVEPOINT typeorm_${this.transactionDepth}`)\n        }\n        this.transactionDepth += 1\n\n        await this.broadcaster.broadcast(\"AfterTransactionStart\")\n    }\n\n    /**\n     * Commits transaction.\n     * Error will be thrown if transaction was not started.\n     */\n    async commitTransaction(): Promise<void> {\n        if (!this.isTransactionActive) throw new TransactionNotStartedError()\n\n        await this.broadcaster.broadcast(\"BeforeTransactionCommit\")\n\n        if (this.transactionDepth > 1) {\n            await this.query(\n                `RELEASE SAVEPOINT typeorm_${this.transactionDepth - 1}`,\n            )\n        } else {\n            await this.client.commitTransaction()\n            this.isTransactionActive = false\n        }\n        this.transactionDepth -= 1\n\n        await this.broadcaster.broadcast(\"AfterTransactionCommit\")\n    }\n\n    /**\n     * Rollbacks transaction.\n     * Error will be thrown if transaction was not started.\n     */\n    async rollbackTransaction(): Promise<void> {\n        if (!this.isTransactionActive) throw new TransactionNotStartedError()\n\n        await this.broadcaster.broadcast(\"BeforeTransactionRollback\")\n\n        if (this.transactionDepth > 1) {\n            await this.query(\n                `ROLLBACK TO SAVEPOINT typeorm_${this.transactionDepth - 1}`,\n            )\n        } else {\n            await this.client.rollbackTransaction()\n            this.isTransactionActive = false\n        }\n        this.transactionDepth -= 1\n\n        await this.broadcaster.broadcast(\"AfterTransactionRollback\")\n    }\n\n    /**\n     * Executes a given SQL query.\n     */\n    async query(\n        query: string,\n        parameters?: any[],\n        useStructuredResult = false,\n    ): Promise<any> {\n        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError()\n\n        const raw = await this.client.query(query, parameters)\n\n        const result = new QueryResult()\n\n        result.raw = raw\n\n        if (raw?.hasOwnProperty(\"records\") && Array.isArray(raw.records)) {\n            result.records = raw.records\n        }\n\n        if (raw?.hasOwnProperty(\"numberOfRecordsUpdated\")) {\n            result.affected = raw.numberOfRecordsUpdated\n        }\n\n        if (!useStructuredResult) {\n            return result.raw\n        }\n\n        return result\n    }\n}\n"]},"metadata":{},"sourceType":"module"}