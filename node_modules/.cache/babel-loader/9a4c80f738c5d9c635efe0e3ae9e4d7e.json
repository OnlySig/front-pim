{"ast":null,"code":"import { getMetadataArgsStorage } from \"../../globals\";\n/**\n * Marks a entity property as a children of the tree.\n * \"Tree children\" will contain all children (bind) of this entity.\n */\n\nexport function TreeChildren(options) {\n  return function (object, propertyName) {\n    if (!options) options = {}; // now try to determine it its lazy relation\n\n    const reflectedType = Reflect && Reflect.getMetadata ? Reflect.getMetadata(\"design:type\", object, propertyName) : undefined;\n    const isLazy = reflectedType && typeof reflectedType.name === \"string\" && reflectedType.name.toLowerCase() === \"promise\" || false; // add one-to-many relation for this\n\n    getMetadataArgsStorage().relations.push({\n      isTreeChildren: true,\n      target: object.constructor,\n      propertyName: propertyName,\n      isLazy: isLazy,\n      relationType: \"one-to-many\",\n      type: () => object.constructor,\n      options: options\n    });\n  };\n}","map":{"version":3,"mappings":"AAAA,SAASA,sBAAT,QAAuC,eAAvC;AAIA;;;;;AAIA,OAAM,SAAUC,YAAV,CAAuBC,OAAvB,EAIL;EACG,OAAO,UAAUC,MAAV,EAA0BC,YAA1B,EAA8C;IACjD,IAAI,CAACF,OAAL,EAAcA,OAAO,GAAG,EAAV,CADmC,CAGjD;;IACA,MAAMG,aAAa,GACfC,OAAO,IAAKA,OAAe,CAACC,WAA5B,GACMD,OAAO,CAACC,WAAR,CAAoB,aAApB,EAAmCJ,MAAnC,EAA2CC,YAA3C,CADN,GAEMI,SAHV;IAIA,MAAMC,MAAM,GACPJ,aAAa,IACV,OAAOA,aAAa,CAACK,IAArB,KAA8B,QADjC,IAEGL,aAAa,CAACK,IAAd,CAAmBC,WAAnB,OAAqC,SAFzC,IAGA,KAJJ,CARiD,CAcjD;;IACAX,sBAAsB,GAAGY,SAAzB,CAAmCC,IAAnC,CAAwC;MACpCC,cAAc,EAAE,IADoB;MAEpCC,MAAM,EAAEZ,MAAM,CAACa,WAFqB;MAGpCZ,YAAY,EAAEA,YAHsB;MAIpCK,MAAM,EAAEA,MAJ4B;MAKpCQ,YAAY,EAAE,aALsB;MAMpCC,IAAI,EAAE,MAAMf,MAAM,CAACa,WANiB;MAOpCd,OAAO,EAAEA;IAP2B,CAAxC;EASH,CAxBD;AAyBH","names":["getMetadataArgsStorage","TreeChildren","options","object","propertyName","reflectedType","Reflect","getMetadata","undefined","isLazy","name","toLowerCase","relations","push","isTreeChildren","target","constructor","relationType","type"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\decorator\\tree\\TreeChildren.ts"],"sourcesContent":["import { getMetadataArgsStorage } from \"../../globals\"\nimport { RelationMetadataArgs } from \"../../metadata-args/RelationMetadataArgs\"\nimport { RelationOptions } from \"../options/RelationOptions\"\n\n/**\n * Marks a entity property as a children of the tree.\n * \"Tree children\" will contain all children (bind) of this entity.\n */\nexport function TreeChildren(options?: {\n    cascade?:\n        | boolean\n        | (\"insert\" | \"update\" | \"remove\" | \"soft-remove\" | \"recover\")[]\n}): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        if (!options) options = {} as RelationOptions\n\n        // now try to determine it its lazy relation\n        const reflectedType =\n            Reflect && (Reflect as any).getMetadata\n                ? Reflect.getMetadata(\"design:type\", object, propertyName)\n                : undefined\n        const isLazy =\n            (reflectedType &&\n                typeof reflectedType.name === \"string\" &&\n                reflectedType.name.toLowerCase() === \"promise\") ||\n            false\n\n        // add one-to-many relation for this\n        getMetadataArgsStorage().relations.push({\n            isTreeChildren: true,\n            target: object.constructor,\n            propertyName: propertyName,\n            isLazy: isLazy,\n            relationType: \"one-to-many\",\n            type: () => object.constructor,\n            options: options,\n        } as RelationMetadataArgs)\n    }\n}\n"]},"metadata":{},"sourceType":"module"}