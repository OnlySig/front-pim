{"ast":null,"code":"/**\n */\nclass LoadMapItem {\n  constructor(plainEntity, metadata, parentLoadMapItem, relation) {\n    this.plainEntity = plainEntity;\n    this.metadata = metadata;\n    this.parentLoadMapItem = parentLoadMapItem;\n    this.relation = relation;\n  }\n\n  get target() {\n    return this.metadata.target;\n  }\n\n  get id() {\n    return this.metadata.getEntityIdMixedMap(this.plainEntity);\n  }\n\n}\n\nclass LoadMap {\n  constructor() {\n    this.loadMapItems = [];\n  }\n\n  get mainLoadMapItem() {\n    return this.loadMapItems.find(item => !item.relation && !item.parentLoadMapItem);\n  }\n\n  addLoadMap(newLoadMap) {\n    const item = this.loadMapItems.find(item => item.target === newLoadMap.target && item.id === newLoadMap.id);\n    if (!item) this.loadMapItems.push(newLoadMap);\n  }\n\n  fillEntities(target, entities) {\n    entities.forEach(entity => {\n      const item = this.loadMapItems.find(loadMapItem => {\n        return loadMapItem.target === target && loadMapItem.metadata.compareEntities(entity, loadMapItem.plainEntity);\n      });\n      if (item) item.entity = entity;\n    });\n  }\n\n  groupByTargetIds() {\n    const groups = [];\n    this.loadMapItems.forEach(loadMapItem => {\n      let group = groups.find(group => group.target === loadMapItem.target);\n\n      if (!group) {\n        group = {\n          target: loadMapItem.target,\n          ids: []\n        };\n        groups.push(group);\n      }\n\n      group.ids.push(loadMapItem.id);\n    });\n    return groups;\n  }\n\n}\n/**\n * Transforms plain old javascript object\n * Entity is constructed based on its entity metadata.\n */\n\n\nexport class PlainObjectToDatabaseEntityTransformer {\n  constructor(manager) {\n    this.manager = manager;\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n\n  async transform(plainObject, metadata) {\n    // if plain object does not have id then nothing to load really\n    if (!metadata.hasAllPrimaryKeys(plainObject)) return Promise.reject(\"Given object does not have a primary column, cannot transform it to database entity.\"); // create a special load map that will hold all metadata that will be used to operate with entities easily\n\n    const loadMap = new LoadMap();\n\n    const fillLoadMap = (entity, entityMetadata, parentLoadMapItem, relation) => {\n      const item = new LoadMapItem(entity, entityMetadata, parentLoadMapItem, relation);\n      loadMap.addLoadMap(item);\n      entityMetadata.extractRelationValuesFromEntity(entity, metadata.relations).filter(value => value !== null && value !== undefined).forEach(_ref => {\n        let [relation, value, inverseEntityMetadata] = _ref;\n        return fillLoadMap(value, inverseEntityMetadata, item, relation);\n      });\n    };\n\n    fillLoadMap(plainObject, metadata); // load all entities and store them in the load map\n\n    await Promise.all(loadMap.groupByTargetIds().map(targetWithIds => {\n      // todo: fix type hinting\n      return this.manager.findByIds(targetWithIds.target, targetWithIds.ids).then(entities => loadMap.fillEntities(targetWithIds.target, entities));\n    })); // go through each item in the load map and set their entity relationship using metadata stored in load map\n\n    loadMap.loadMapItems.forEach(loadMapItem => {\n      if (!loadMapItem.relation || !loadMapItem.entity || !loadMapItem.parentLoadMapItem || !loadMapItem.parentLoadMapItem.entity) return;\n\n      if (loadMapItem.relation.isManyToMany || loadMapItem.relation.isOneToMany) {\n        if (!loadMapItem.parentLoadMapItem.entity[loadMapItem.relation.propertyName]) loadMapItem.parentLoadMapItem.entity[loadMapItem.relation.propertyName] = [];\n        loadMapItem.parentLoadMapItem.entity[loadMapItem.relation.propertyName].push(loadMapItem.entity);\n      } else {\n        loadMapItem.parentLoadMapItem.entity[loadMapItem.relation.propertyName] = loadMapItem.entity;\n      }\n    });\n    return loadMap.mainLoadMapItem ? loadMap.mainLoadMapItem.entity : undefined;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["LoadMapItem","constructor","plainEntity","metadata","parentLoadMapItem","relation","target","id","getEntityIdMixedMap","LoadMap","mainLoadMapItem","loadMapItems","find","item","addLoadMap","newLoadMap","push","fillEntities","entities","forEach","entity","loadMapItem","compareEntities","groupByTargetIds","groups","group","ids","PlainObjectToDatabaseEntityTransformer","manager","transform","plainObject","hasAllPrimaryKeys","Promise","reject","loadMap","fillLoadMap","entityMetadata","extractRelationValuesFromEntity","relations","filter","value","undefined","inverseEntityMetadata","all","map","targetWithIds","findByIds","then","isManyToMany","isOneToMany","propertyName"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\query-builder\\transformer\\PlainObjectToDatabaseEntityTransformer.ts"],"sourcesContent":["import { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { EntityMetadata } from \"../../metadata/EntityMetadata\"\nimport { EntityManager } from \"../../entity-manager/EntityManager\"\nimport { RelationMetadata } from \"../../metadata/RelationMetadata\"\n\n/**\n */\nclass LoadMapItem {\n    entity?: ObjectLiteral\n    plainEntity: ObjectLiteral\n    metadata: EntityMetadata\n    parentLoadMapItem?: LoadMapItem\n    relation?: RelationMetadata\n\n    constructor(\n        plainEntity: ObjectLiteral,\n        metadata: EntityMetadata,\n        parentLoadMapItem?: LoadMapItem,\n        relation?: RelationMetadata,\n    ) {\n        this.plainEntity = plainEntity\n        this.metadata = metadata\n        this.parentLoadMapItem = parentLoadMapItem\n        this.relation = relation\n    }\n\n    get target(): Function | string {\n        return this.metadata.target\n    }\n\n    get id(): any {\n        return this.metadata.getEntityIdMixedMap(this.plainEntity)\n    }\n}\n\nclass LoadMap {\n    loadMapItems: LoadMapItem[] = []\n\n    get mainLoadMapItem(): LoadMapItem | undefined {\n        return this.loadMapItems.find(\n            (item) => !item.relation && !item.parentLoadMapItem,\n        )\n    }\n\n    addLoadMap(newLoadMap: LoadMapItem) {\n        const item = this.loadMapItems.find(\n            (item) =>\n                item.target === newLoadMap.target && item.id === newLoadMap.id,\n        )\n        if (!item) this.loadMapItems.push(newLoadMap)\n    }\n\n    fillEntities(target: Function | string, entities: any[]) {\n        entities.forEach((entity) => {\n            const item = this.loadMapItems.find((loadMapItem) => {\n                return (\n                    loadMapItem.target === target &&\n                    loadMapItem.metadata.compareEntities(\n                        entity,\n                        loadMapItem.plainEntity,\n                    )\n                )\n            })\n            if (item) item.entity = entity\n        })\n    }\n\n    groupByTargetIds(): { target: Function | string; ids: any[] }[] {\n        const groups: { target: Function | string; ids: any[] }[] = []\n        this.loadMapItems.forEach((loadMapItem) => {\n            let group = groups.find(\n                (group) => group.target === loadMapItem.target,\n            )\n            if (!group) {\n                group = { target: loadMapItem.target, ids: [] }\n                groups.push(group)\n            }\n\n            group.ids.push(loadMapItem.id)\n        })\n        return groups\n    }\n}\n\n/**\n * Transforms plain old javascript object\n * Entity is constructed based on its entity metadata.\n */\nexport class PlainObjectToDatabaseEntityTransformer {\n    constructor(private manager: EntityManager) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    async transform(\n        plainObject: ObjectLiteral,\n        metadata: EntityMetadata,\n    ): Promise<ObjectLiteral | undefined> {\n        // if plain object does not have id then nothing to load really\n        if (!metadata.hasAllPrimaryKeys(plainObject))\n            return Promise.reject(\n                \"Given object does not have a primary column, cannot transform it to database entity.\",\n            )\n\n        // create a special load map that will hold all metadata that will be used to operate with entities easily\n        const loadMap = new LoadMap()\n        const fillLoadMap = (\n            entity: ObjectLiteral,\n            entityMetadata: EntityMetadata,\n            parentLoadMapItem?: LoadMapItem,\n            relation?: RelationMetadata,\n        ) => {\n            const item = new LoadMapItem(\n                entity,\n                entityMetadata,\n                parentLoadMapItem,\n                relation,\n            )\n            loadMap.addLoadMap(item)\n\n            entityMetadata\n                .extractRelationValuesFromEntity(entity, metadata.relations)\n                .filter((value) => value !== null && value !== undefined)\n                .forEach(([relation, value, inverseEntityMetadata]) =>\n                    fillLoadMap(value, inverseEntityMetadata, item, relation),\n                )\n        }\n        fillLoadMap(plainObject, metadata)\n        // load all entities and store them in the load map\n        await Promise.all(\n            loadMap.groupByTargetIds().map((targetWithIds) => {\n                // todo: fix type hinting\n                return this.manager\n                    .findByIds<ObjectLiteral>(\n                        targetWithIds.target as any,\n                        targetWithIds.ids,\n                    )\n                    .then((entities) =>\n                        loadMap.fillEntities(targetWithIds.target, entities),\n                    )\n            }),\n        )\n\n        // go through each item in the load map and set their entity relationship using metadata stored in load map\n        loadMap.loadMapItems.forEach((loadMapItem) => {\n            if (\n                !loadMapItem.relation ||\n                !loadMapItem.entity ||\n                !loadMapItem.parentLoadMapItem ||\n                !loadMapItem.parentLoadMapItem.entity\n            )\n                return\n\n            if (\n                loadMapItem.relation.isManyToMany ||\n                loadMapItem.relation.isOneToMany\n            ) {\n                if (\n                    !loadMapItem.parentLoadMapItem.entity[\n                        loadMapItem.relation.propertyName\n                    ]\n                )\n                    loadMapItem.parentLoadMapItem.entity[\n                        loadMapItem.relation.propertyName\n                    ] = []\n                loadMapItem.parentLoadMapItem.entity[\n                    loadMapItem.relation.propertyName\n                ].push(loadMapItem.entity)\n            } else {\n                loadMapItem.parentLoadMapItem.entity[\n                    loadMapItem.relation.propertyName\n                ] = loadMapItem.entity\n            }\n        })\n\n        return loadMap.mainLoadMapItem\n            ? loadMap.mainLoadMapItem.entity\n            : undefined\n    }\n}\n"]},"metadata":{},"sourceType":"module"}