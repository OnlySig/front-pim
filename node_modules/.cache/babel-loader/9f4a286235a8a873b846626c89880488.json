{"ast":null,"code":"import { QueryRunnerAlreadyReleasedError } from \"../../error/QueryRunnerAlreadyReleasedError\";\nimport { AbstractSqliteQueryRunner } from \"../sqlite-abstract/AbstractSqliteQueryRunner\";\nimport { Broadcaster } from \"../../subscriber/Broadcaster\";\nimport { QueryFailedError } from \"../../error/QueryFailedError\";\nimport { QueryResult } from \"../../query-runner/QueryResult\";\n/**\n * Runs queries on a single sqlite database connection.\n */\n\nexport class SqljsQueryRunner extends AbstractSqliteQueryRunner {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(driver) {\n    super();\n    /**\n     * Flag to determine if a modification has happened since the last time this query runner has requested a save.\n     */\n\n    this.isDirty = false;\n    this.driver = driver;\n    this.connection = driver.connection;\n    this.broadcaster = new Broadcaster(this);\n  } // -------------------------------------------------------------------------\n  // Public methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Called before migrations are run.\n   */\n\n\n  async beforeMigration() {\n    await this.query(`PRAGMA foreign_keys = OFF`);\n  }\n  /**\n   * Called after migrations are run.\n   */\n\n\n  async afterMigration() {\n    await this.query(`PRAGMA foreign_keys = ON`);\n  }\n\n  async flush() {\n    if (this.isDirty) {\n      await this.driver.autoSave();\n      this.isDirty = false;\n    }\n  }\n\n  async release() {\n    await this.flush();\n    return super.release();\n  }\n  /**\n   * Commits transaction.\n   * Error will be thrown if transaction was not started.\n   */\n\n\n  async commitTransaction() {\n    await super.commitTransaction();\n\n    if (!this.isTransactionActive) {\n      await this.flush();\n    }\n  }\n  /**\n   * Executes a given SQL query.\n   */\n\n\n  async query(query) {\n    let parameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let useStructuredResult = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (this.isReleased) throw new QueryRunnerAlreadyReleasedError();\n    const command = query.trim().split(\" \", 1)[0];\n    const databaseConnection = this.driver.databaseConnection;\n    this.driver.connection.logger.logQuery(query, parameters, this);\n    const queryStartTime = +new Date();\n    let statement;\n\n    try {\n      statement = databaseConnection.prepare(query);\n\n      if (parameters) {\n        parameters = parameters.map(p => typeof p !== \"undefined\" ? p : null);\n        statement.bind(parameters);\n      } // log slow queries if maxQueryExecution time is set\n\n\n      const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;\n      const queryEndTime = +new Date();\n      const queryExecutionTime = queryEndTime - queryStartTime;\n      if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);\n      const records = [];\n\n      while (statement.step()) {\n        records.push(statement.getAsObject());\n      }\n\n      const result = new QueryResult();\n      result.affected = databaseConnection.getRowsModified();\n      result.records = records;\n      result.raw = records;\n      statement.free();\n\n      if (command !== \"SELECT\") {\n        this.isDirty = true;\n      }\n\n      if (useStructuredResult) {\n        return result;\n      } else {\n        return result.raw;\n      }\n    } catch (e) {\n      if (statement) {\n        statement.free();\n      }\n\n      this.driver.connection.logger.logQueryError(e, query, parameters, this);\n      throw new QueryFailedError(query, parameters, e);\n    }\n  }\n\n}","map":{"version":3,"mappings":"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","names":["QueryRunnerAlreadyReleasedError","AbstractSqliteQueryRunner","Broadcaster","QueryFailedError","QueryResult","SqljsQueryRunner","constructor","driver","connection","broadcaster","beforeMigration","query","afterMigration","flush","isDirty","autoSave","release","commitTransaction","isTransactionActive","parameters","useStructuredResult","isReleased","command","trim","split","databaseConnection","logger","logQuery","queryStartTime","Date","statement","prepare","map","p","bind","maxQueryExecutionTime","options","queryEndTime","queryExecutionTime","logQuerySlow","records","step","push","getAsObject","result","affected","getRowsModified","raw","free","e","logQueryError"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\driver\\sqljs\\SqljsQueryRunner.ts"],"sourcesContent":["import { QueryRunnerAlreadyReleasedError } from \"../../error/QueryRunnerAlreadyReleasedError\"\nimport { AbstractSqliteQueryRunner } from \"../sqlite-abstract/AbstractSqliteQueryRunner\"\nimport { SqljsDriver } from \"./SqljsDriver\"\nimport { Broadcaster } from \"../../subscriber/Broadcaster\"\nimport { QueryFailedError } from \"../../error/QueryFailedError\"\nimport { QueryResult } from \"../../query-runner/QueryResult\"\n\n/**\n * Runs queries on a single sqlite database connection.\n */\nexport class SqljsQueryRunner extends AbstractSqliteQueryRunner {\n    /**\n     * Flag to determine if a modification has happened since the last time this query runner has requested a save.\n     */\n    private isDirty = false\n\n    /**\n     * Database driver used by connection.\n     */\n    driver: SqljsDriver\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(driver: SqljsDriver) {\n        super()\n        this.driver = driver\n        this.connection = driver.connection\n        this.broadcaster = new Broadcaster(this)\n    }\n\n    // -------------------------------------------------------------------------\n    // Public methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Called before migrations are run.\n     */\n    async beforeMigration(): Promise<void> {\n        await this.query(`PRAGMA foreign_keys = OFF`)\n    }\n\n    /**\n     * Called after migrations are run.\n     */\n    async afterMigration(): Promise<void> {\n        await this.query(`PRAGMA foreign_keys = ON`)\n    }\n\n    private async flush() {\n        if (this.isDirty) {\n            await this.driver.autoSave()\n            this.isDirty = false\n        }\n    }\n\n    async release(): Promise<void> {\n        await this.flush()\n        return super.release()\n    }\n\n    /**\n     * Commits transaction.\n     * Error will be thrown if transaction was not started.\n     */\n    async commitTransaction(): Promise<void> {\n        await super.commitTransaction()\n        if (!this.isTransactionActive) {\n            await this.flush()\n        }\n    }\n\n    /**\n     * Executes a given SQL query.\n     */\n    async query(\n        query: string,\n        parameters: any[] = [],\n        useStructuredResult = false,\n    ): Promise<any> {\n        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError()\n\n        const command = query.trim().split(\" \", 1)[0]\n\n        const databaseConnection = this.driver.databaseConnection\n        this.driver.connection.logger.logQuery(query, parameters, this)\n        const queryStartTime = +new Date()\n        let statement: any\n        try {\n            statement = databaseConnection.prepare(query)\n            if (parameters) {\n                parameters = parameters.map((p) =>\n                    typeof p !== \"undefined\" ? p : null,\n                )\n\n                statement.bind(parameters)\n            }\n\n            // log slow queries if maxQueryExecution time is set\n            const maxQueryExecutionTime =\n                this.driver.options.maxQueryExecutionTime\n            const queryEndTime = +new Date()\n            const queryExecutionTime = queryEndTime - queryStartTime\n            if (\n                maxQueryExecutionTime &&\n                queryExecutionTime > maxQueryExecutionTime\n            )\n                this.driver.connection.logger.logQuerySlow(\n                    queryExecutionTime,\n                    query,\n                    parameters,\n                    this,\n                )\n\n            const records: any[] = []\n\n            while (statement.step()) {\n                records.push(statement.getAsObject())\n            }\n\n            const result = new QueryResult()\n\n            result.affected = databaseConnection.getRowsModified()\n            result.records = records\n            result.raw = records\n\n            statement.free()\n\n            if (command !== \"SELECT\") {\n                this.isDirty = true\n            }\n\n            if (useStructuredResult) {\n                return result\n            } else {\n                return result.raw\n            }\n        } catch (e) {\n            if (statement) {\n                statement.free()\n            }\n\n            this.driver.connection.logger.logQueryError(\n                e,\n                query,\n                parameters,\n                this,\n            )\n            throw new QueryFailedError(query, parameters, e)\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}