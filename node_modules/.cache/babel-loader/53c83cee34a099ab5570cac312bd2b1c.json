{"ast":null,"code":"import { QueryResult } from \"../../query-runner/QueryResult\";\nimport { TransactionNotStartedError } from \"../../error/TransactionNotStartedError\";\nimport { TableColumn } from \"../../schema-builder/table/TableColumn\";\nimport { Table } from \"../../schema-builder/table/Table\";\nimport { TableForeignKey } from \"../../schema-builder/table/TableForeignKey\";\nimport { TableIndex } from \"../../schema-builder/table/TableIndex\";\nimport { QueryRunnerAlreadyReleasedError } from \"../../error/QueryRunnerAlreadyReleasedError\";\nimport { View } from \"../../schema-builder/view/View\";\nimport { Query } from \"../Query\";\nimport { OrmUtils } from \"../../util/OrmUtils\";\nimport { TableUnique } from \"../../schema-builder/table/TableUnique\";\nimport { BaseQueryRunner } from \"../../query-runner/BaseQueryRunner\";\nimport { Broadcaster } from \"../../subscriber/Broadcaster\";\nimport { TypeORMError } from \"../../error\";\nimport { MetadataTableType } from \"../types/MetadataTableType\";\nimport { InstanceChecker } from \"../../util/InstanceChecker\";\n/**\n * Runs queries on a single mysql database connection.\n */\n\nexport class AuroraMysqlQueryRunner extends BaseQueryRunner {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(driver, client) {\n    super();\n    this.driver = driver;\n    this.connection = driver.connection;\n    this.client = client;\n    this.broadcaster = new Broadcaster(this);\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Creates/uses database connection from the connection pool to perform further operations.\n   * Returns obtained database connection.\n   */\n\n\n  async connect() {\n    return {};\n  }\n  /**\n   * Releases used database connection.\n   * You cannot use query runner methods once its released.\n   */\n\n\n  release() {\n    this.isReleased = true;\n    if (this.databaseConnection) this.databaseConnection.release();\n    return Promise.resolve();\n  }\n  /**\n   * Starts transaction on the current connection.\n   */\n\n\n  async startTransaction(isolationLevel) {\n    this.isTransactionActive = true;\n\n    try {\n      await this.broadcaster.broadcast(\"BeforeTransactionStart\");\n    } catch (err) {\n      this.isTransactionActive = false;\n      throw err;\n    }\n\n    if (this.transactionDepth === 0) {\n      await this.client.startTransaction();\n    } else {\n      await this.query(`SAVEPOINT typeorm_${this.transactionDepth}`);\n    }\n\n    this.transactionDepth += 1;\n    await this.broadcaster.broadcast(\"AfterTransactionStart\");\n  }\n  /**\n   * Commits transaction.\n   * Error will be thrown if transaction was not started.\n   */\n\n\n  async commitTransaction() {\n    if (!this.isTransactionActive) throw new TransactionNotStartedError();\n    await this.broadcaster.broadcast(\"BeforeTransactionCommit\");\n\n    if (this.transactionDepth > 1) {\n      await this.query(`RELEASE SAVEPOINT typeorm_${this.transactionDepth - 1}`);\n    } else {\n      await this.client.commitTransaction();\n      this.isTransactionActive = false;\n    }\n\n    this.transactionDepth -= 1;\n    await this.broadcaster.broadcast(\"AfterTransactionCommit\");\n  }\n  /**\n   * Rollbacks transaction.\n   * Error will be thrown if transaction was not started.\n   */\n\n\n  async rollbackTransaction() {\n    if (!this.isTransactionActive) throw new TransactionNotStartedError();\n    await this.broadcaster.broadcast(\"BeforeTransactionRollback\");\n\n    if (this.transactionDepth > 1) {\n      await this.query(`ROLLBACK TO SAVEPOINT typeorm_${this.transactionDepth - 1}`);\n    } else {\n      await this.client.rollbackTransaction();\n      this.isTransactionActive = false;\n    }\n\n    this.transactionDepth -= 1;\n    await this.broadcaster.broadcast(\"AfterTransactionRollback\");\n  }\n  /**\n   * Executes a raw SQL query.\n   */\n\n\n  async query(query, parameters) {\n    let useStructuredResult = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (this.isReleased) throw new QueryRunnerAlreadyReleasedError();\n    const raw = await this.client.query(query, parameters);\n    const result = new QueryResult();\n    result.raw = raw;\n\n    if ((raw === null || raw === void 0 ? void 0 : raw.hasOwnProperty(\"records\")) && Array.isArray(raw.records)) {\n      result.records = raw.records;\n    }\n\n    if (raw === null || raw === void 0 ? void 0 : raw.hasOwnProperty(\"numberOfRecordsUpdated\")) {\n      result.affected = raw.numberOfRecordsUpdated;\n    }\n\n    if (!useStructuredResult) {\n      return result.raw;\n    }\n\n    return result;\n  }\n  /**\n   * Returns raw data stream.\n   */\n\n\n  stream(query, parameters, onEnd, onError) {\n    if (this.isReleased) throw new QueryRunnerAlreadyReleasedError();\n    return new Promise(async (ok, fail) => {\n      try {\n        const databaseConnection = await this.connect();\n        const stream = databaseConnection.query(query, parameters);\n        if (onEnd) stream.on(\"end\", onEnd);\n        if (onError) stream.on(\"error\", onError);\n        ok(stream);\n      } catch (err) {\n        fail(err);\n      }\n    });\n  }\n  /**\n   * Returns all available database names including system databases.\n   */\n\n\n  async getDatabases() {\n    return Promise.resolve([]);\n  }\n  /**\n   * Returns all available schema names including system schemas.\n   * If database parameter specified, returns schemas of that database.\n   */\n\n\n  async getSchemas(database) {\n    throw new TypeORMError(`MySql driver does not support table schemas`);\n  }\n  /**\n   * Checks if database with the given name exist.\n   */\n\n\n  async hasDatabase(database) {\n    const result = await this.query(`SELECT * FROM \\`INFORMATION_SCHEMA\\`.\\`SCHEMATA\\` WHERE \\`SCHEMA_NAME\\` = '${database}'`);\n    return result.length ? true : false;\n  }\n  /**\n   * Loads currently using database\n   */\n\n\n  async getCurrentDatabase() {\n    const query = await this.query(`SELECT DATABASE() AS \\`db_name\\``);\n    return query[0][\"db_name\"];\n  }\n  /**\n   * Checks if schema with the given name exist.\n   */\n\n\n  async hasSchema(schema) {\n    throw new TypeORMError(`MySql driver does not support table schemas`);\n  }\n  /**\n   * Loads currently using database schema\n   */\n\n\n  async getCurrentSchema() {\n    const query = await this.query(`SELECT SCHEMA() AS \\`schema_name\\``);\n    return query[0][\"schema_name\"];\n  }\n  /**\n   * Checks if table with the given name exist in the database.\n   */\n\n\n  async hasTable(tableOrName) {\n    const parsedTableName = this.driver.parseTableName(tableOrName);\n    const sql = `SELECT * FROM \\`INFORMATION_SCHEMA\\`.\\`COLUMNS\\` WHERE \\`TABLE_SCHEMA\\` = '${parsedTableName.database}' AND \\`TABLE_NAME\\` = '${parsedTableName.tableName}'`;\n    const result = await this.query(sql);\n    return result.length ? true : false;\n  }\n  /**\n   * Checks if column with the given name exist in the given table.\n   */\n\n\n  async hasColumn(tableOrName, column) {\n    const parsedTableName = this.driver.parseTableName(tableOrName);\n    const columnName = InstanceChecker.isTableColumn(column) ? column.name : column;\n    const sql = `SELECT * FROM \\`INFORMATION_SCHEMA\\`.\\`COLUMNS\\` WHERE \\`TABLE_SCHEMA\\` = '${parsedTableName.database}' AND \\`TABLE_NAME\\` = '${parsedTableName.tableName}' AND \\`COLUMN_NAME\\` = '${columnName}'`;\n    const result = await this.query(sql);\n    return result.length ? true : false;\n  }\n  /**\n   * Creates a new database.\n   */\n\n\n  async createDatabase(database, ifNotExist) {\n    const up = ifNotExist ? `CREATE DATABASE IF NOT EXISTS \\`${database}\\`` : `CREATE DATABASE \\`${database}\\``;\n    const down = `DROP DATABASE \\`${database}\\``;\n    await this.executeQueries(new Query(up), new Query(down));\n  }\n  /**\n   * Drops database.\n   */\n\n\n  async dropDatabase(database, ifExist) {\n    const up = ifExist ? `DROP DATABASE IF EXISTS \\`${database}\\`` : `DROP DATABASE \\`${database}\\``;\n    const down = `CREATE DATABASE \\`${database}\\``;\n    await this.executeQueries(new Query(up), new Query(down));\n  }\n  /**\n   * Creates a new table schema.\n   */\n\n\n  async createSchema(schemaPath, ifNotExist) {\n    throw new TypeORMError(`Schema create queries are not supported by MySql driver.`);\n  }\n  /**\n   * Drops table schema.\n   */\n\n\n  async dropSchema(schemaPath, ifExist) {\n    throw new TypeORMError(`Schema drop queries are not supported by MySql driver.`);\n  }\n  /**\n   * Creates a new table.\n   */\n\n\n  async createTable(table) {\n    let ifNotExist = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let createForeignKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n    if (ifNotExist) {\n      const isTableExist = await this.hasTable(table);\n      if (isTableExist) return Promise.resolve();\n    }\n\n    const upQueries = [];\n    const downQueries = [];\n    upQueries.push(this.createTableSql(table, createForeignKeys));\n    downQueries.push(this.dropTableSql(table)); // we must first drop indices, than drop foreign keys, because drop queries runs in reversed order\n    // and foreign keys will be dropped first as indices. This order is very important, because we can't drop index\n    // if it related to the foreign key.\n    // createTable does not need separate method to create indices, because it create indices in the same query with table creation.\n\n    table.indices.forEach(index => downQueries.push(this.dropIndexSql(table, index))); // if createForeignKeys is true, we must drop created foreign keys in down query.\n    // createTable does not need separate method to create foreign keys, because it create fk's in the same query with table creation.\n\n    if (createForeignKeys) table.foreignKeys.forEach(foreignKey => downQueries.push(this.dropForeignKeySql(table, foreignKey)));\n    return this.executeQueries(upQueries, downQueries);\n  }\n  /**\n   * Drop the table.\n   */\n\n\n  async dropTable(target, ifExist) {\n    let dropForeignKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n    // It needs because if table does not exist and dropForeignKeys or dropIndices is true, we don't need\n    // to perform drop queries for foreign keys and indices.\n    if (ifExist) {\n      const isTableExist = await this.hasTable(target);\n      if (!isTableExist) return Promise.resolve();\n    } // if dropTable called with dropForeignKeys = true, we must create foreign keys in down query.\n\n\n    const createForeignKeys = dropForeignKeys;\n    const tablePath = this.getTablePath(target);\n    const table = await this.getCachedTable(tablePath);\n    const upQueries = [];\n    const downQueries = [];\n    if (dropForeignKeys) table.foreignKeys.forEach(foreignKey => upQueries.push(this.dropForeignKeySql(table, foreignKey)));\n    table.indices.forEach(index => upQueries.push(this.dropIndexSql(table, index)));\n    upQueries.push(this.dropTableSql(table));\n    downQueries.push(this.createTableSql(table, createForeignKeys));\n    await this.executeQueries(upQueries, downQueries);\n  }\n  /**\n   * Creates a new view.\n   */\n\n\n  async createView(view) {\n    const upQueries = [];\n    const downQueries = [];\n    upQueries.push(this.createViewSql(view));\n    upQueries.push(await this.insertViewDefinitionSql(view));\n    downQueries.push(this.dropViewSql(view));\n    downQueries.push(await this.deleteViewDefinitionSql(view));\n    await this.executeQueries(upQueries, downQueries);\n  }\n  /**\n   * Drops the view.\n   */\n\n\n  async dropView(target) {\n    const viewName = InstanceChecker.isView(target) ? target.name : target;\n    const view = await this.getCachedView(viewName);\n    const upQueries = [];\n    const downQueries = [];\n    upQueries.push(await this.deleteViewDefinitionSql(view));\n    upQueries.push(this.dropViewSql(view));\n    downQueries.push(await this.insertViewDefinitionSql(view));\n    downQueries.push(this.createViewSql(view));\n    await this.executeQueries(upQueries, downQueries);\n  }\n  /**\n   * Renames a table.\n   */\n\n\n  async renameTable(oldTableOrName, newTableName) {\n    const upQueries = [];\n    const downQueries = [];\n    const oldTable = InstanceChecker.isTable(oldTableOrName) ? oldTableOrName : await this.getCachedTable(oldTableOrName);\n    const newTable = oldTable.clone();\n    const {\n      database\n    } = this.driver.parseTableName(oldTable);\n    newTable.name = database ? `${database}.${newTableName}` : newTableName; // rename table\n\n    upQueries.push(new Query(`RENAME TABLE ${this.escapePath(oldTable)} TO ${this.escapePath(newTable)}`));\n    downQueries.push(new Query(`RENAME TABLE ${this.escapePath(newTable)} TO ${this.escapePath(oldTable)}`)); // rename index constraints\n\n    newTable.indices.forEach(index => {\n      // build new constraint name\n      const columnNames = index.columnNames.map(column => `\\`${column}\\``).join(\", \");\n      const newIndexName = this.connection.namingStrategy.indexName(newTable, index.columnNames, index.where); // build queries\n\n      let indexType = \"\";\n      if (index.isUnique) indexType += \"UNIQUE \";\n      if (index.isSpatial) indexType += \"SPATIAL \";\n      if (index.isFulltext) indexType += \"FULLTEXT \";\n      upQueries.push(new Query(`ALTER TABLE ${this.escapePath(newTable)} DROP INDEX \\`${index.name}\\`, ADD ${indexType}INDEX \\`${newIndexName}\\` (${columnNames})`));\n      downQueries.push(new Query(`ALTER TABLE ${this.escapePath(newTable)} DROP INDEX \\`${newIndexName}\\`, ADD ${indexType}INDEX \\`${index.name}\\` (${columnNames})`)); // replace constraint name\n\n      index.name = newIndexName;\n    }); // rename foreign key constraint\n\n    newTable.foreignKeys.forEach(foreignKey => {\n      // build new constraint name\n      const columnNames = foreignKey.columnNames.map(column => `\\`${column}\\``).join(\", \");\n      const referencedColumnNames = foreignKey.referencedColumnNames.map(column => `\\`${column}\\``).join(\",\");\n      const newForeignKeyName = this.connection.namingStrategy.foreignKeyName(newTable, foreignKey.columnNames); // build queries\n\n      let up = `ALTER TABLE ${this.escapePath(newTable)} DROP FOREIGN KEY \\`${foreignKey.name}\\`, ADD CONSTRAINT \\`${newForeignKeyName}\\` FOREIGN KEY (${columnNames}) ` + `REFERENCES ${this.escapePath(this.getTablePath(foreignKey))}(${referencedColumnNames})`;\n      if (foreignKey.onDelete) up += ` ON DELETE ${foreignKey.onDelete}`;\n      if (foreignKey.onUpdate) up += ` ON UPDATE ${foreignKey.onUpdate}`;\n      let down = `ALTER TABLE ${this.escapePath(newTable)} DROP FOREIGN KEY \\`${newForeignKeyName}\\`, ADD CONSTRAINT \\`${foreignKey.name}\\` FOREIGN KEY (${columnNames}) ` + `REFERENCES ${this.escapePath(this.getTablePath(foreignKey))}(${referencedColumnNames})`;\n      if (foreignKey.onDelete) down += ` ON DELETE ${foreignKey.onDelete}`;\n      if (foreignKey.onUpdate) down += ` ON UPDATE ${foreignKey.onUpdate}`;\n      upQueries.push(new Query(up));\n      downQueries.push(new Query(down)); // replace constraint name\n\n      foreignKey.name = newForeignKeyName;\n    });\n    await this.executeQueries(upQueries, downQueries); // rename old table and replace it in cached tabled;\n\n    oldTable.name = newTable.name;\n    this.replaceCachedTable(oldTable, newTable);\n  }\n  /**\n   * Creates a new column from the column in the table.\n   */\n\n\n  async addColumn(tableOrName, column) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const clonedTable = table.clone();\n    const upQueries = [];\n    const downQueries = [];\n    const skipColumnLevelPrimary = clonedTable.primaryColumns.length > 0;\n    upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(column, skipColumnLevelPrimary, false)}`));\n    downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN \\`${column.name}\\``)); // create or update primary key constraint\n\n    if (column.isPrimary && skipColumnLevelPrimary) {\n      // if we already have generated column, we must temporary drop AUTO_INCREMENT property.\n      const generatedColumn = clonedTable.columns.find(column => column.isGenerated && column.generationStrategy === \"increment\");\n\n      if (generatedColumn) {\n        const nonGeneratedColumn = generatedColumn.clone();\n        nonGeneratedColumn.isGenerated = false;\n        nonGeneratedColumn.generationStrategy = undefined;\n        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \\`${column.name}\\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));\n        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \\`${nonGeneratedColumn.name}\\` ${this.buildCreateColumnSql(column, true)}`));\n      }\n\n      const primaryColumns = clonedTable.primaryColumns;\n      let columnNames = primaryColumns.map(column => `\\`${column.name}\\``).join(\", \");\n      upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`));\n      downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNames})`));\n      primaryColumns.push(column);\n      columnNames = primaryColumns.map(column => `\\`${column.name}\\``).join(\", \");\n      upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNames})`));\n      downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`)); // if we previously dropped AUTO_INCREMENT property, we must bring it back\n\n      if (generatedColumn) {\n        const nonGeneratedColumn = generatedColumn.clone();\n        nonGeneratedColumn.isGenerated = false;\n        nonGeneratedColumn.generationStrategy = undefined;\n        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \\`${nonGeneratedColumn.name}\\` ${this.buildCreateColumnSql(column, true)}`));\n        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \\`${column.name}\\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));\n      }\n    } // create column index\n\n\n    const columnIndex = clonedTable.indices.find(index => index.columnNames.length === 1 && index.columnNames[0] === column.name);\n\n    if (columnIndex) {\n      upQueries.push(this.createIndexSql(table, columnIndex));\n      downQueries.push(this.dropIndexSql(table, columnIndex));\n    } else if (column.isUnique) {\n      const uniqueIndex = new TableIndex({\n        name: this.connection.namingStrategy.indexName(table, [column.name]),\n        columnNames: [column.name],\n        isUnique: true\n      });\n      clonedTable.indices.push(uniqueIndex);\n      clonedTable.uniques.push(new TableUnique({\n        name: uniqueIndex.name,\n        columnNames: uniqueIndex.columnNames\n      }));\n      upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD UNIQUE INDEX \\`${uniqueIndex.name}\\` (\\`${column.name}\\`)`));\n      downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP INDEX \\`${uniqueIndex.name}\\``));\n    }\n\n    await this.executeQueries(upQueries, downQueries);\n    clonedTable.addColumn(column);\n    this.replaceCachedTable(table, clonedTable);\n  }\n  /**\n   * Creates a new columns from the column in the table.\n   */\n\n\n  async addColumns(tableOrName, columns) {\n    for (const column of columns) {\n      await this.addColumn(tableOrName, column);\n    }\n  }\n  /**\n   * Renames column in the given table.\n   */\n\n\n  async renameColumn(tableOrName, oldTableColumnOrName, newTableColumnOrName) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const oldColumn = InstanceChecker.isTableColumn(oldTableColumnOrName) ? oldTableColumnOrName : table.columns.find(c => c.name === oldTableColumnOrName);\n    if (!oldColumn) throw new TypeORMError(`Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`);\n    let newColumn = undefined;\n\n    if (InstanceChecker.isTableColumn(newTableColumnOrName)) {\n      newColumn = newTableColumnOrName;\n    } else {\n      newColumn = oldColumn.clone();\n      newColumn.name = newTableColumnOrName;\n    }\n\n    await this.changeColumn(table, oldColumn, newColumn);\n  }\n  /**\n   * Changes a column in the table.\n   */\n\n\n  async changeColumn(tableOrName, oldColumnOrName, newColumn) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    let clonedTable = table.clone();\n    const upQueries = [];\n    const downQueries = [];\n    const oldColumn = InstanceChecker.isTableColumn(oldColumnOrName) ? oldColumnOrName : table.columns.find(column => column.name === oldColumnOrName);\n    if (!oldColumn) throw new TypeORMError(`Column \"${oldColumnOrName}\" was not found in the \"${table.name}\" table.`);\n\n    if (newColumn.isGenerated !== oldColumn.isGenerated && newColumn.generationStrategy !== \"uuid\" || oldColumn.type !== newColumn.type || oldColumn.length !== newColumn.length || oldColumn.generatedType !== newColumn.generatedType) {\n      await this.dropColumn(table, oldColumn);\n      await this.addColumn(table, newColumn); // update cloned table\n\n      clonedTable = table.clone();\n    } else {\n      if (newColumn.name !== oldColumn.name) {\n        // We don't change any column properties, just rename it.\n        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \\`${oldColumn.name}\\` \\`${newColumn.name}\\` ${this.buildCreateColumnSql(oldColumn, true, true)}`));\n        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \\`${newColumn.name}\\` \\`${oldColumn.name}\\` ${this.buildCreateColumnSql(oldColumn, true, true)}`)); // rename index constraints\n\n        clonedTable.findColumnIndices(oldColumn).forEach(index => {\n          // build new constraint name\n          index.columnNames.splice(index.columnNames.indexOf(oldColumn.name), 1);\n          index.columnNames.push(newColumn.name);\n          const columnNames = index.columnNames.map(column => `\\`${column}\\``).join(\", \");\n          const newIndexName = this.connection.namingStrategy.indexName(clonedTable, index.columnNames, index.where); // build queries\n\n          let indexType = \"\";\n          if (index.isUnique) indexType += \"UNIQUE \";\n          if (index.isSpatial) indexType += \"SPATIAL \";\n          if (index.isFulltext) indexType += \"FULLTEXT \";\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP INDEX \\`${index.name}\\`, ADD ${indexType}INDEX \\`${newIndexName}\\` (${columnNames})`));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP INDEX \\`${newIndexName}\\`, ADD ${indexType}INDEX \\`${index.name}\\` (${columnNames})`)); // replace constraint name\n\n          index.name = newIndexName;\n        }); // rename foreign key constraints\n\n        clonedTable.findColumnForeignKeys(oldColumn).forEach(foreignKey => {\n          // build new constraint name\n          foreignKey.columnNames.splice(foreignKey.columnNames.indexOf(oldColumn.name), 1);\n          foreignKey.columnNames.push(newColumn.name);\n          const columnNames = foreignKey.columnNames.map(column => `\\`${column}\\``).join(\", \");\n          const referencedColumnNames = foreignKey.referencedColumnNames.map(column => `\\`${column}\\``).join(\",\");\n          const newForeignKeyName = this.connection.namingStrategy.foreignKeyName(clonedTable, foreignKey.columnNames); // build queries\n\n          let up = `ALTER TABLE ${this.escapePath(table)} DROP FOREIGN KEY \\`${foreignKey.name}\\`, ADD CONSTRAINT \\`${newForeignKeyName}\\` FOREIGN KEY (${columnNames}) ` + `REFERENCES ${this.escapePath(this.getTablePath(foreignKey))}(${referencedColumnNames})`;\n          if (foreignKey.onDelete) up += ` ON DELETE ${foreignKey.onDelete}`;\n          if (foreignKey.onUpdate) up += ` ON UPDATE ${foreignKey.onUpdate}`;\n          let down = `ALTER TABLE ${this.escapePath(table)} DROP FOREIGN KEY \\`${newForeignKeyName}\\`, ADD CONSTRAINT \\`${foreignKey.name}\\` FOREIGN KEY (${columnNames}) ` + `REFERENCES ${this.escapePath(this.getTablePath(foreignKey))}(${referencedColumnNames})`;\n          if (foreignKey.onDelete) down += ` ON DELETE ${foreignKey.onDelete}`;\n          if (foreignKey.onUpdate) down += ` ON UPDATE ${foreignKey.onUpdate}`;\n          upQueries.push(new Query(up));\n          downQueries.push(new Query(down)); // replace constraint name\n\n          foreignKey.name = newForeignKeyName;\n        }); // rename old column in the Table object\n\n        const oldTableColumn = clonedTable.columns.find(column => column.name === oldColumn.name);\n        clonedTable.columns[clonedTable.columns.indexOf(oldTableColumn)].name = newColumn.name;\n        oldColumn.name = newColumn.name;\n      }\n\n      if (this.isColumnChanged(oldColumn, newColumn, true)) {\n        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \\`${oldColumn.name}\\` ${this.buildCreateColumnSql(newColumn, true)}`));\n        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \\`${newColumn.name}\\` ${this.buildCreateColumnSql(oldColumn, true)}`));\n      }\n\n      if (newColumn.isPrimary !== oldColumn.isPrimary) {\n        // if table have generated column, we must drop AUTO_INCREMENT before changing primary constraints.\n        const generatedColumn = clonedTable.columns.find(column => column.isGenerated && column.generationStrategy === \"increment\");\n\n        if (generatedColumn) {\n          const nonGeneratedColumn = generatedColumn.clone();\n          nonGeneratedColumn.isGenerated = false;\n          nonGeneratedColumn.generationStrategy = undefined;\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \\`${generatedColumn.name}\\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \\`${nonGeneratedColumn.name}\\` ${this.buildCreateColumnSql(generatedColumn, true)}`));\n        }\n\n        const primaryColumns = clonedTable.primaryColumns; // if primary column state changed, we must always drop existed constraint.\n\n        if (primaryColumns.length > 0) {\n          const columnNames = primaryColumns.map(column => `\\`${column.name}\\``).join(\", \");\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNames})`));\n        }\n\n        if (newColumn.isPrimary === true) {\n          primaryColumns.push(newColumn); // update column in table\n\n          const column = clonedTable.columns.find(column => column.name === newColumn.name);\n          column.isPrimary = true;\n          const columnNames = primaryColumns.map(column => `\\`${column.name}\\``).join(\", \");\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNames})`));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`));\n        } else {\n          const primaryColumn = primaryColumns.find(c => c.name === newColumn.name);\n          primaryColumns.splice(primaryColumns.indexOf(primaryColumn), 1); // update column in table\n\n          const column = clonedTable.columns.find(column => column.name === newColumn.name);\n          column.isPrimary = false; // if we have another primary keys, we must recreate constraint.\n\n          if (primaryColumns.length > 0) {\n            const columnNames = primaryColumns.map(column => `\\`${column.name}\\``).join(\", \");\n            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNames})`));\n            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`));\n          }\n        } // if we have generated column, and we dropped AUTO_INCREMENT property before, we must bring it back\n\n\n        if (generatedColumn) {\n          const nonGeneratedColumn = generatedColumn.clone();\n          nonGeneratedColumn.isGenerated = false;\n          nonGeneratedColumn.generationStrategy = undefined;\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \\`${nonGeneratedColumn.name}\\` ${this.buildCreateColumnSql(generatedColumn, true)}`));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \\`${generatedColumn.name}\\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));\n        }\n      }\n\n      if (newColumn.isUnique !== oldColumn.isUnique) {\n        if (newColumn.isUnique === true) {\n          const uniqueIndex = new TableIndex({\n            name: this.connection.namingStrategy.indexName(table, [newColumn.name]),\n            columnNames: [newColumn.name],\n            isUnique: true\n          });\n          clonedTable.indices.push(uniqueIndex);\n          clonedTable.uniques.push(new TableUnique({\n            name: uniqueIndex.name,\n            columnNames: uniqueIndex.columnNames\n          }));\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD UNIQUE INDEX \\`${uniqueIndex.name}\\` (\\`${newColumn.name}\\`)`));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP INDEX \\`${uniqueIndex.name}\\``));\n        } else {\n          const uniqueIndex = clonedTable.indices.find(index => {\n            return index.columnNames.length === 1 && index.isUnique === true && !!index.columnNames.find(columnName => columnName === newColumn.name);\n          });\n          clonedTable.indices.splice(clonedTable.indices.indexOf(uniqueIndex), 1);\n          const tableUnique = clonedTable.uniques.find(unique => unique.name === uniqueIndex.name);\n          clonedTable.uniques.splice(clonedTable.uniques.indexOf(tableUnique), 1);\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP INDEX \\`${uniqueIndex.name}\\``));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD UNIQUE INDEX \\`${uniqueIndex.name}\\` (\\`${newColumn.name}\\`)`));\n        }\n      }\n    }\n\n    await this.executeQueries(upQueries, downQueries);\n    this.replaceCachedTable(table, clonedTable);\n  }\n  /**\n   * Changes a column in the table.\n   */\n\n\n  async changeColumns(tableOrName, changedColumns) {\n    for (const {\n      oldColumn,\n      newColumn\n    } of changedColumns) {\n      await this.changeColumn(tableOrName, oldColumn, newColumn);\n    }\n  }\n  /**\n   * Drops column in the table.\n   */\n\n\n  async dropColumn(tableOrName, columnOrName) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const column = InstanceChecker.isTableColumn(columnOrName) ? columnOrName : table.findColumnByName(columnOrName);\n    if (!column) throw new TypeORMError(`Column \"${columnOrName}\" was not found in table \"${table.name}\"`);\n    const clonedTable = table.clone();\n    const upQueries = [];\n    const downQueries = []; // drop primary key constraint\n\n    if (column.isPrimary) {\n      // if table have generated column, we must drop AUTO_INCREMENT before changing primary constraints.\n      const generatedColumn = clonedTable.columns.find(column => column.isGenerated && column.generationStrategy === \"increment\");\n\n      if (generatedColumn) {\n        const nonGeneratedColumn = generatedColumn.clone();\n        nonGeneratedColumn.isGenerated = false;\n        nonGeneratedColumn.generationStrategy = undefined;\n        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \\`${generatedColumn.name}\\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));\n        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \\`${nonGeneratedColumn.name}\\` ${this.buildCreateColumnSql(generatedColumn, true)}`));\n      } // dropping primary key constraint\n\n\n      const columnNames = clonedTable.primaryColumns.map(primaryColumn => `\\`${primaryColumn.name}\\``).join(\", \");\n      upQueries.push(new Query(`ALTER TABLE ${this.escapePath(clonedTable)} DROP PRIMARY KEY`));\n      downQueries.push(new Query(`ALTER TABLE ${this.escapePath(clonedTable)} ADD PRIMARY KEY (${columnNames})`)); // update column in table\n\n      const tableColumn = clonedTable.findColumnByName(column.name);\n      tableColumn.isPrimary = false; // if primary key have multiple columns, we must recreate it without dropped column\n\n      if (clonedTable.primaryColumns.length > 0) {\n        const columnNames = clonedTable.primaryColumns.map(primaryColumn => `\\`${primaryColumn.name}\\``).join(\", \");\n        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(clonedTable)} ADD PRIMARY KEY (${columnNames})`));\n        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(clonedTable)} DROP PRIMARY KEY`));\n      } // if we have generated column, and we dropped AUTO_INCREMENT property before, and this column is not current dropping column, we must bring it back\n\n\n      if (generatedColumn && generatedColumn.name !== column.name) {\n        const nonGeneratedColumn = generatedColumn.clone();\n        nonGeneratedColumn.isGenerated = false;\n        nonGeneratedColumn.generationStrategy = undefined;\n        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \\`${nonGeneratedColumn.name}\\` ${this.buildCreateColumnSql(generatedColumn, true)}`));\n        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \\`${generatedColumn.name}\\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));\n      }\n    } // drop column index\n\n\n    const columnIndex = clonedTable.indices.find(index => index.columnNames.length === 1 && index.columnNames[0] === column.name);\n\n    if (columnIndex) {\n      clonedTable.indices.splice(clonedTable.indices.indexOf(columnIndex), 1);\n      upQueries.push(this.dropIndexSql(table, columnIndex));\n      downQueries.push(this.createIndexSql(table, columnIndex));\n    } else if (column.isUnique) {\n      // we splice constraints both from table uniques and indices.\n      const uniqueName = this.connection.namingStrategy.uniqueConstraintName(table, [column.name]);\n      const foundUnique = clonedTable.uniques.find(unique => unique.name === uniqueName);\n      if (foundUnique) clonedTable.uniques.splice(clonedTable.uniques.indexOf(foundUnique), 1);\n      const indexName = this.connection.namingStrategy.indexName(table, [column.name]);\n      const foundIndex = clonedTable.indices.find(index => index.name === indexName);\n      if (foundIndex) clonedTable.indices.splice(clonedTable.indices.indexOf(foundIndex), 1);\n      upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP INDEX \\`${indexName}\\``));\n      downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD UNIQUE INDEX \\`${indexName}\\` (\\`${column.name}\\`)`));\n    }\n\n    upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN \\`${column.name}\\``));\n    downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(column, true)}`));\n    await this.executeQueries(upQueries, downQueries);\n    clonedTable.removeColumn(column);\n    this.replaceCachedTable(table, clonedTable);\n  }\n  /**\n   * Drops the columns in the table.\n   */\n\n\n  async dropColumns(tableOrName, columns) {\n    for (const column of columns) {\n      await this.dropColumn(tableOrName, column);\n    }\n  }\n  /**\n   * Creates a new primary key.\n   */\n\n\n  async createPrimaryKey(tableOrName, columnNames) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const clonedTable = table.clone();\n    const up = this.createPrimaryKeySql(table, columnNames);\n    const down = this.dropPrimaryKeySql(table);\n    await this.executeQueries(up, down);\n    clonedTable.columns.forEach(column => {\n      if (columnNames.find(columnName => columnName === column.name)) column.isPrimary = true;\n    });\n    this.replaceCachedTable(table, clonedTable);\n  }\n  /**\n   * Updates composite primary keys.\n   */\n\n\n  async updatePrimaryKeys(tableOrName, columns) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const clonedTable = table.clone();\n    const columnNames = columns.map(column => column.name);\n    const upQueries = [];\n    const downQueries = []; // if table have generated column, we must drop AUTO_INCREMENT before changing primary constraints.\n\n    const generatedColumn = clonedTable.columns.find(column => column.isGenerated && column.generationStrategy === \"increment\");\n\n    if (generatedColumn) {\n      const nonGeneratedColumn = generatedColumn.clone();\n      nonGeneratedColumn.isGenerated = false;\n      nonGeneratedColumn.generationStrategy = undefined;\n      upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \\`${generatedColumn.name}\\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));\n      downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \\`${nonGeneratedColumn.name}\\` ${this.buildCreateColumnSql(generatedColumn, true)}`));\n    } // if table already have primary columns, we must drop them.\n\n\n    const primaryColumns = clonedTable.primaryColumns;\n\n    if (primaryColumns.length > 0) {\n      const columnNames = primaryColumns.map(column => `\\`${column.name}\\``).join(\", \");\n      upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`));\n      downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNames})`));\n    } // update columns in table.\n\n\n    clonedTable.columns.filter(column => columnNames.indexOf(column.name) !== -1).forEach(column => column.isPrimary = true);\n    const columnNamesString = columnNames.map(columnName => `\\`${columnName}\\``).join(\", \");\n    upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNamesString})`));\n    downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`)); // if we already have generated column or column is changed to generated, and we dropped AUTO_INCREMENT property before, we must bring it back\n\n    const newOrExistGeneratedColumn = generatedColumn ? generatedColumn : columns.find(column => column.isGenerated && column.generationStrategy === \"increment\");\n\n    if (newOrExistGeneratedColumn) {\n      const nonGeneratedColumn = newOrExistGeneratedColumn.clone();\n      nonGeneratedColumn.isGenerated = false;\n      nonGeneratedColumn.generationStrategy = undefined;\n      upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \\`${nonGeneratedColumn.name}\\` ${this.buildCreateColumnSql(newOrExistGeneratedColumn, true)}`));\n      downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \\`${newOrExistGeneratedColumn.name}\\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`)); // if column changed to generated, we must update it in table\n\n      const changedGeneratedColumn = clonedTable.columns.find(column => column.name === newOrExistGeneratedColumn.name);\n      changedGeneratedColumn.isGenerated = true;\n      changedGeneratedColumn.generationStrategy = \"increment\";\n    }\n\n    await this.executeQueries(upQueries, downQueries);\n    this.replaceCachedTable(table, clonedTable);\n  }\n  /**\n   * Drops a primary key.\n   */\n\n\n  async dropPrimaryKey(tableOrName) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const up = this.dropPrimaryKeySql(table);\n    const down = this.createPrimaryKeySql(table, table.primaryColumns.map(column => column.name));\n    await this.executeQueries(up, down);\n    table.primaryColumns.forEach(column => {\n      column.isPrimary = false;\n    });\n  }\n  /**\n   * Creates a new unique constraint.\n   */\n\n\n  async createUniqueConstraint(tableOrName, uniqueConstraint) {\n    throw new TypeORMError(`MySql does not support unique constraints. Use unique index instead.`);\n  }\n  /**\n   * Creates a new unique constraints.\n   */\n\n\n  async createUniqueConstraints(tableOrName, uniqueConstraints) {\n    throw new TypeORMError(`MySql does not support unique constraints. Use unique index instead.`);\n  }\n  /**\n   * Drops an unique constraint.\n   */\n\n\n  async dropUniqueConstraint(tableOrName, uniqueOrName) {\n    throw new TypeORMError(`MySql does not support unique constraints. Use unique index instead.`);\n  }\n  /**\n   * Drops an unique constraints.\n   */\n\n\n  async dropUniqueConstraints(tableOrName, uniqueConstraints) {\n    throw new TypeORMError(`MySql does not support unique constraints. Use unique index instead.`);\n  }\n  /**\n   * Creates a new check constraint.\n   */\n\n\n  async createCheckConstraint(tableOrName, checkConstraint) {\n    throw new TypeORMError(`MySql does not support check constraints.`);\n  }\n  /**\n   * Creates a new check constraints.\n   */\n\n\n  async createCheckConstraints(tableOrName, checkConstraints) {\n    throw new TypeORMError(`MySql does not support check constraints.`);\n  }\n  /**\n   * Drops check constraint.\n   */\n\n\n  async dropCheckConstraint(tableOrName, checkOrName) {\n    throw new TypeORMError(`MySql does not support check constraints.`);\n  }\n  /**\n   * Drops check constraints.\n   */\n\n\n  async dropCheckConstraints(tableOrName, checkConstraints) {\n    throw new TypeORMError(`MySql does not support check constraints.`);\n  }\n  /**\n   * Creates a new exclusion constraint.\n   */\n\n\n  async createExclusionConstraint(tableOrName, exclusionConstraint) {\n    throw new TypeORMError(`MySql does not support exclusion constraints.`);\n  }\n  /**\n   * Creates a new exclusion constraints.\n   */\n\n\n  async createExclusionConstraints(tableOrName, exclusionConstraints) {\n    throw new TypeORMError(`MySql does not support exclusion constraints.`);\n  }\n  /**\n   * Drops exclusion constraint.\n   */\n\n\n  async dropExclusionConstraint(tableOrName, exclusionOrName) {\n    throw new TypeORMError(`MySql does not support exclusion constraints.`);\n  }\n  /**\n   * Drops exclusion constraints.\n   */\n\n\n  async dropExclusionConstraints(tableOrName, exclusionConstraints) {\n    throw new TypeORMError(`MySql does not support exclusion constraints.`);\n  }\n  /**\n   * Creates a new foreign key.\n   */\n\n\n  async createForeignKey(tableOrName, foreignKey) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName); // new FK may be passed without name. In this case we generate FK name manually.\n\n    if (!foreignKey.name) foreignKey.name = this.connection.namingStrategy.foreignKeyName(table, foreignKey.columnNames);\n    const up = this.createForeignKeySql(table, foreignKey);\n    const down = this.dropForeignKeySql(table, foreignKey);\n    await this.executeQueries(up, down);\n    table.addForeignKey(foreignKey);\n  }\n  /**\n   * Creates a new foreign keys.\n   */\n\n\n  async createForeignKeys(tableOrName, foreignKeys) {\n    const promises = foreignKeys.map(foreignKey => this.createForeignKey(tableOrName, foreignKey));\n    await Promise.all(promises);\n  }\n  /**\n   * Drops a foreign key.\n   */\n\n\n  async dropForeignKey(tableOrName, foreignKeyOrName) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const foreignKey = InstanceChecker.isTableForeignKey(foreignKeyOrName) ? foreignKeyOrName : table.foreignKeys.find(fk => fk.name === foreignKeyOrName);\n    if (!foreignKey) throw new TypeORMError(`Supplied foreign key was not found in table ${table.name}`);\n    const up = this.dropForeignKeySql(table, foreignKey);\n    const down = this.createForeignKeySql(table, foreignKey);\n    await this.executeQueries(up, down);\n    table.removeForeignKey(foreignKey);\n  }\n  /**\n   * Drops a foreign keys from the table.\n   */\n\n\n  async dropForeignKeys(tableOrName, foreignKeys) {\n    const promises = foreignKeys.map(foreignKey => this.dropForeignKey(tableOrName, foreignKey));\n    await Promise.all(promises);\n  }\n  /**\n   * Creates a new index.\n   */\n\n\n  async createIndex(tableOrName, index) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName); // new index may be passed without name. In this case we generate index name manually.\n\n    if (!index.name) index.name = this.generateIndexName(table, index);\n    const up = this.createIndexSql(table, index);\n    const down = this.dropIndexSql(table, index);\n    await this.executeQueries(up, down);\n    table.addIndex(index, true);\n  }\n  /**\n   * Creates a new indices\n   */\n\n\n  async createIndices(tableOrName, indices) {\n    const promises = indices.map(index => this.createIndex(tableOrName, index));\n    await Promise.all(promises);\n  }\n  /**\n   * Drops an index.\n   */\n\n\n  async dropIndex(tableOrName, indexOrName) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const index = InstanceChecker.isTableIndex(indexOrName) ? indexOrName : table.indices.find(i => i.name === indexOrName);\n    if (!index) throw new TypeORMError(`Supplied index ${indexOrName} was not found in table ${table.name}`); // old index may be passed without name. In this case we generate index name manually.\n\n    if (!index.name) index.name = this.generateIndexName(table, index);\n    const up = this.dropIndexSql(table, index);\n    const down = this.createIndexSql(table, index);\n    await this.executeQueries(up, down);\n    table.removeIndex(index, true);\n  }\n  /**\n   * Drops an indices from the table.\n   */\n\n\n  async dropIndices(tableOrName, indices) {\n    const promises = indices.map(index => this.dropIndex(tableOrName, index));\n    await Promise.all(promises);\n  }\n  /**\n   * Clears all table contents.\n   * Note: this operation uses SQL's TRUNCATE query which cannot be reverted in transactions.\n   */\n\n\n  async clearTable(tableOrName) {\n    await this.query(`TRUNCATE TABLE ${this.escapePath(tableOrName)}`);\n  }\n  /**\n   * Removes all tables from the currently connected database.\n   * Be careful using this method and avoid using it in production or migrations\n   * (because it can clear all your database).\n   */\n\n\n  async clearDatabase(database) {\n    const dbName = database ? database : this.driver.database;\n\n    if (dbName) {\n      const isDatabaseExist = await this.hasDatabase(dbName);\n      if (!isDatabaseExist) return Promise.resolve();\n    } else {\n      throw new TypeORMError(`Can not clear database. No database is specified`);\n    }\n\n    const isAnotherTransactionActive = this.isTransactionActive;\n    if (!isAnotherTransactionActive) await this.startTransaction();\n\n    try {\n      const selectViewDropsQuery = `SELECT concat('DROP VIEW IF EXISTS \\`', table_schema, '\\`.\\`', table_name, '\\`') AS \\`query\\` FROM \\`INFORMATION_SCHEMA\\`.\\`VIEWS\\` WHERE \\`TABLE_SCHEMA\\` = '${dbName}'`;\n      const dropViewQueries = await this.query(selectViewDropsQuery);\n      await Promise.all(dropViewQueries.map(q => this.query(q[\"query\"])));\n      const disableForeignKeysCheckQuery = `SET FOREIGN_KEY_CHECKS = 0;`;\n      const dropTablesQuery = `SELECT concat('DROP TABLE IF EXISTS \\`', table_schema, '\\`.\\`', table_name, '\\`') AS \\`query\\` FROM \\`INFORMATION_SCHEMA\\`.\\`TABLES\\` WHERE \\`TABLE_SCHEMA\\` = '${dbName}'`;\n      const enableForeignKeysCheckQuery = `SET FOREIGN_KEY_CHECKS = 1;`;\n      await this.query(disableForeignKeysCheckQuery);\n      const dropQueries = await this.query(dropTablesQuery);\n      await Promise.all(dropQueries.map(query => this.query(query[\"query\"])));\n      await this.query(enableForeignKeysCheckQuery);\n\n      if (!isAnotherTransactionActive) {\n        await this.commitTransaction();\n      }\n    } catch (error) {\n      try {\n        // we throw original error even if rollback thrown an error\n        if (!isAnotherTransactionActive) {\n          await this.rollbackTransaction();\n        }\n      } catch (rollbackError) {}\n\n      throw error;\n    }\n  } // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n\n  async loadViews(viewNames) {\n    const hasTable = await this.hasTable(this.getTypeormMetadataTableName());\n\n    if (!hasTable) {\n      return [];\n    }\n\n    if (!viewNames) {\n      viewNames = [];\n    }\n\n    const currentDatabase = await this.getCurrentDatabase();\n    const viewsCondition = viewNames.map(tableName => {\n      let {\n        database,\n        tableName: name\n      } = this.driver.parseTableName(tableName);\n\n      if (!database) {\n        database = currentDatabase;\n      }\n\n      return `(\\`t\\`.\\`schema\\` = '${database}' AND \\`t\\`.\\`name\\` = '${name}')`;\n    }).join(\" OR \");\n    const query = `SELECT \\`t\\`.*, \\`v\\`.\\`check_option\\` FROM ${this.escapePath(this.getTypeormMetadataTableName())} \\`t\\` ` + `INNER JOIN \\`information_schema\\`.\\`views\\` \\`v\\` ON \\`v\\`.\\`table_schema\\` = \\`t\\`.\\`schema\\` AND \\`v\\`.\\`table_name\\` = \\`t\\`.\\`name\\` WHERE \\`t\\`.\\`type\\` = '${MetadataTableType.VIEW}' ${viewsCondition ? `AND (${viewsCondition})` : \"\"}`;\n    const dbViews = await this.query(query);\n    return dbViews.map(dbView => {\n      const view = new View();\n      const db = dbView[\"schema\"] === currentDatabase ? undefined : dbView[\"schema\"];\n      view.database = dbView[\"schema\"];\n      view.name = this.driver.buildTableName(dbView[\"name\"], undefined, db);\n      view.expression = dbView[\"value\"];\n      return view;\n    });\n  }\n  /**\n   * Loads all tables (with given names) from the database and creates a Table from them.\n   */\n\n\n  async loadTables(tableNames) {\n    // if no tables given then no need to proceed\n    if (tableNames && tableNames.length === 0) {\n      return [];\n    }\n\n    const dbTables = [];\n    const currentDatabase = await this.getCurrentDatabase();\n\n    if (!tableNames) {\n      const tablesSql = `SELECT TABLE_NAME, TABLE_SCHEMA FROM \\`INFORMATION_SCHEMA\\`.\\`TABLES\\``;\n      dbTables.push(...(await this.query(tablesSql)));\n    } else {\n      const tablesCondition = tableNames.map(tableName => {\n        let [database, name] = tableName.split(\".\");\n\n        if (!name) {\n          name = database;\n          database = this.driver.database || currentDatabase;\n        }\n\n        return `(\\`TABLE_SCHEMA\\` = '${database}' AND \\`TABLE_NAME\\` = '${name}')`;\n      }).join(\" OR \");\n      const tablesSql = `SELECT TABLE_NAME, TABLE_SCHEMA FROM \\`INFORMATION_SCHEMA\\`.\\`TABLES\\` WHERE ` + tablesCondition;\n      dbTables.push(...(await this.query(tablesSql)));\n    }\n\n    if (dbTables.length === 0) {\n      return [];\n    }\n\n    const columnsCondition = dbTables.map(_ref => {\n      let {\n        TABLE_NAME,\n        TABLE_SCHEMA\n      } = _ref;\n      return `(\\`TABLE_SCHEMA\\` = '${TABLE_SCHEMA}' AND \\`TABLE_NAME\\` = '${TABLE_NAME}')`;\n    }).join(\" OR \");\n    const columnsSql = `SELECT * FROM \\`INFORMATION_SCHEMA\\`.\\`COLUMNS\\` WHERE ` + columnsCondition;\n    const primaryKeySql = `SELECT * FROM \\`INFORMATION_SCHEMA\\`.\\`KEY_COLUMN_USAGE\\` WHERE \\`CONSTRAINT_NAME\\` = 'PRIMARY' AND (${columnsCondition})`;\n    const collationsSql = `SELECT \\`SCHEMA_NAME\\`, \\`DEFAULT_CHARACTER_SET_NAME\\` as \\`CHARSET\\`, \\`DEFAULT_COLLATION_NAME\\` AS \\`COLLATION\\` FROM \\`INFORMATION_SCHEMA\\`.\\`SCHEMATA\\``;\n    const indicesCondition = dbTables.map(_ref2 => {\n      let {\n        TABLE_NAME,\n        TABLE_SCHEMA\n      } = _ref2;\n      return `(\\`s\\`.\\`TABLE_SCHEMA\\` = '${TABLE_SCHEMA}' AND \\`s\\`.\\`TABLE_NAME\\` = '${TABLE_NAME}')`;\n    }).join(\" OR \");\n    const indicesSql = `SELECT \\`s\\`.* FROM \\`INFORMATION_SCHEMA\\`.\\`STATISTICS\\` \\`s\\` ` + `LEFT JOIN \\`INFORMATION_SCHEMA\\`.\\`REFERENTIAL_CONSTRAINTS\\` \\`rc\\` ON \\`s\\`.\\`INDEX_NAME\\` = \\`rc\\`.\\`CONSTRAINT_NAME\\` ` + `WHERE (${indicesCondition}) AND \\`s\\`.\\`INDEX_NAME\\` != 'PRIMARY' AND \\`rc\\`.\\`CONSTRAINT_NAME\\` IS NULL`;\n    const foreignKeysCondition = dbTables.map(_ref3 => {\n      let {\n        TABLE_NAME,\n        TABLE_SCHEMA\n      } = _ref3;\n      return `(\\`kcu\\`.\\`TABLE_SCHEMA\\` = '${TABLE_SCHEMA}' AND \\`kcu\\`.\\`TABLE_NAME\\` = '${TABLE_NAME}')`;\n    }).join(\" OR \");\n    const foreignKeysSql = `SELECT \\`kcu\\`.\\`TABLE_SCHEMA\\`, \\`kcu\\`.\\`TABLE_NAME\\`, \\`kcu\\`.\\`CONSTRAINT_NAME\\`, \\`kcu\\`.\\`COLUMN_NAME\\`, \\`kcu\\`.\\`REFERENCED_TABLE_SCHEMA\\`, ` + `\\`kcu\\`.\\`REFERENCED_TABLE_NAME\\`, \\`kcu\\`.\\`REFERENCED_COLUMN_NAME\\`, \\`rc\\`.\\`DELETE_RULE\\` \\`ON_DELETE\\`, \\`rc\\`.\\`UPDATE_RULE\\` \\`ON_UPDATE\\` ` + `FROM \\`INFORMATION_SCHEMA\\`.\\`KEY_COLUMN_USAGE\\` \\`kcu\\` ` + `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`REFERENTIAL_CONSTRAINTS\\` \\`rc\\` ON \\`rc\\`.\\`constraint_name\\` = \\`kcu\\`.\\`constraint_name\\` ` + `WHERE ` + foreignKeysCondition;\n    const [dbColumns, dbPrimaryKeys, dbCollations, dbIndices, dbForeignKeys] = await Promise.all([this.query(columnsSql), this.query(primaryKeySql), this.query(collationsSql), this.query(indicesSql), this.query(foreignKeysSql)]); // create tables for loaded tables\n\n    return Promise.all(dbTables.map(async dbTable => {\n      const table = new Table();\n      const dbCollation = dbCollations.find(coll => coll[\"SCHEMA_NAME\"] === dbTable[\"TABLE_SCHEMA\"]);\n      const defaultCollation = dbCollation[\"COLLATION\"];\n      const defaultCharset = dbCollation[\"CHARSET\"]; // We do not need to join database name, when database is by default.\n\n      const db = dbTable[\"TABLE_SCHEMA\"] === currentDatabase ? undefined : dbTable[\"TABLE_SCHEMA\"];\n      table.database = dbTable[\"TABLE_SCHEMA\"];\n      table.name = this.driver.buildTableName(dbTable[\"TABLE_NAME\"], undefined, db); // create columns from the loaded columns\n\n      table.columns = dbColumns.filter(dbColumn => dbColumn[\"TABLE_NAME\"] === dbTable[\"TABLE_NAME\"] && dbColumn[\"TABLE_SCHEMA\"] === dbTable[\"TABLE_SCHEMA\"]).map(dbColumn => {\n        const columnUniqueIndices = dbIndices.filter(dbIndex => {\n          return dbIndex[\"TABLE_NAME\"] === dbTable[\"TABLE_NAME\"] && dbIndex[\"TABLE_SCHEMA\"] === dbTable[\"TABLE_SCHEMA\"] && dbIndex[\"COLUMN_NAME\"] === dbColumn[\"COLUMN_NAME\"] && parseInt(dbIndex[\"NON_UNIQUE\"], 10) === 0;\n        });\n        const tableMetadata = this.connection.entityMetadatas.find(metadata => this.getTablePath(table) === this.getTablePath(metadata));\n        const hasIgnoredIndex = columnUniqueIndices.length > 0 && tableMetadata && tableMetadata.indices.some(index => {\n          return columnUniqueIndices.some(uniqueIndex => {\n            return index.name === uniqueIndex[\"INDEX_NAME\"] && index.synchronize === false;\n          });\n        });\n        const isConstraintComposite = columnUniqueIndices.every(uniqueIndex => {\n          return dbIndices.some(dbIndex => dbIndex[\"INDEX_NAME\"] === uniqueIndex[\"INDEX_NAME\"] && dbIndex[\"COLUMN_NAME\"] !== dbColumn[\"COLUMN_NAME\"]);\n        });\n        const tableColumn = new TableColumn();\n        tableColumn.name = dbColumn[\"COLUMN_NAME\"];\n        tableColumn.type = dbColumn[\"DATA_TYPE\"].toLowerCase();\n\n        if (this.driver.withWidthColumnTypes.indexOf(tableColumn.type) !== -1) {\n          const width = dbColumn[\"COLUMN_TYPE\"].substring(dbColumn[\"COLUMN_TYPE\"].indexOf(\"(\") + 1, dbColumn[\"COLUMN_TYPE\"].indexOf(\")\"));\n          tableColumn.width = width && !this.isDefaultColumnWidth(table, tableColumn, parseInt(width)) ? parseInt(width) : undefined;\n        }\n\n        if (dbColumn[\"COLUMN_DEFAULT\"] === null || dbColumn[\"COLUMN_DEFAULT\"] === undefined) {\n          tableColumn.default = undefined;\n        } else {\n          tableColumn.default = dbColumn[\"COLUMN_DEFAULT\"] === \"CURRENT_TIMESTAMP\" ? dbColumn[\"COLUMN_DEFAULT\"] : `'${dbColumn[\"COLUMN_DEFAULT\"]}'`;\n        }\n\n        if (dbColumn[\"EXTRA\"].indexOf(\"on update\") !== -1) {\n          tableColumn.onUpdate = dbColumn[\"EXTRA\"].substring(dbColumn[\"EXTRA\"].indexOf(\"on update\") + 10);\n        }\n\n        if (dbColumn[\"GENERATION_EXPRESSION\"]) {\n          tableColumn.asExpression = dbColumn[\"GENERATION_EXPRESSION\"];\n          tableColumn.generatedType = dbColumn[\"EXTRA\"].indexOf(\"VIRTUAL\") !== -1 ? \"VIRTUAL\" : \"STORED\";\n        }\n\n        tableColumn.isUnique = columnUniqueIndices.length > 0 && !hasIgnoredIndex && !isConstraintComposite;\n        tableColumn.isNullable = dbColumn[\"IS_NULLABLE\"] === \"YES\";\n        tableColumn.isPrimary = dbPrimaryKeys.some(dbPrimaryKey => {\n          return dbPrimaryKey[\"TABLE_NAME\"] === dbColumn[\"TABLE_NAME\"] && dbPrimaryKey[\"TABLE_SCHEMA\"] === dbColumn[\"TABLE_SCHEMA\"] && dbPrimaryKey[\"COLUMN_NAME\"] === dbColumn[\"COLUMN_NAME\"];\n        });\n        tableColumn.zerofill = dbColumn[\"COLUMN_TYPE\"].indexOf(\"zerofill\") !== -1;\n        tableColumn.unsigned = tableColumn.zerofill ? true : dbColumn[\"COLUMN_TYPE\"].indexOf(\"unsigned\") !== -1;\n        tableColumn.isGenerated = dbColumn[\"EXTRA\"].indexOf(\"auto_increment\") !== -1;\n        if (tableColumn.isGenerated) tableColumn.generationStrategy = \"increment\";\n        tableColumn.comment = typeof dbColumn[\"COLUMN_COMMENT\"] === \"string\" && dbColumn[\"COLUMN_COMMENT\"].length === 0 ? undefined : dbColumn[\"COLUMN_COMMENT\"];\n        if (dbColumn[\"CHARACTER_SET_NAME\"]) tableColumn.charset = dbColumn[\"CHARACTER_SET_NAME\"] === defaultCharset ? undefined : dbColumn[\"CHARACTER_SET_NAME\"];\n        if (dbColumn[\"COLLATION_NAME\"]) tableColumn.collation = dbColumn[\"COLLATION_NAME\"] === defaultCollation ? undefined : dbColumn[\"COLLATION_NAME\"]; // check only columns that have length property\n\n        if (this.driver.withLengthColumnTypes.indexOf(tableColumn.type) !== -1 && dbColumn[\"CHARACTER_MAXIMUM_LENGTH\"]) {\n          const length = dbColumn[\"CHARACTER_MAXIMUM_LENGTH\"].toString();\n          tableColumn.length = !this.isDefaultColumnLength(table, tableColumn, length) ? length : \"\";\n        }\n\n        if (tableColumn.type === \"decimal\" || tableColumn.type === \"double\" || tableColumn.type === \"float\") {\n          if (dbColumn[\"NUMERIC_PRECISION\"] !== null && !this.isDefaultColumnPrecision(table, tableColumn, dbColumn[\"NUMERIC_PRECISION\"])) tableColumn.precision = parseInt(dbColumn[\"NUMERIC_PRECISION\"]);\n          if (dbColumn[\"NUMERIC_SCALE\"] !== null && !this.isDefaultColumnScale(table, tableColumn, dbColumn[\"NUMERIC_SCALE\"])) tableColumn.scale = parseInt(dbColumn[\"NUMERIC_SCALE\"]);\n        }\n\n        if (tableColumn.type === \"enum\" || tableColumn.type === \"simple-enum\" || tableColumn.type === \"set\") {\n          const colType = dbColumn[\"COLUMN_TYPE\"];\n          const items = colType.substring(colType.indexOf(\"(\") + 1, colType.lastIndexOf(\")\")).split(\",\");\n          tableColumn.enum = items.map(item => {\n            return item.substring(1, item.length - 1);\n          });\n          tableColumn.length = \"\";\n        }\n\n        if ((tableColumn.type === \"datetime\" || tableColumn.type === \"time\" || tableColumn.type === \"timestamp\") && dbColumn[\"DATETIME_PRECISION\"] !== null && dbColumn[\"DATETIME_PRECISION\"] !== undefined && !this.isDefaultColumnPrecision(table, tableColumn, parseInt(dbColumn[\"DATETIME_PRECISION\"]))) {\n          tableColumn.precision = parseInt(dbColumn[\"DATETIME_PRECISION\"]);\n        }\n\n        return tableColumn;\n      }); // find foreign key constraints of table, group them by constraint name and build TableForeignKey.\n\n      const tableForeignKeyConstraints = OrmUtils.uniq(dbForeignKeys.filter(dbForeignKey => {\n        return dbForeignKey[\"TABLE_NAME\"] === dbTable[\"TABLE_NAME\"] && dbForeignKey[\"TABLE_SCHEMA\"] === dbTable[\"TABLE_SCHEMA\"];\n      }), dbForeignKey => dbForeignKey[\"CONSTRAINT_NAME\"]);\n      table.foreignKeys = tableForeignKeyConstraints.map(dbForeignKey => {\n        const foreignKeys = dbForeignKeys.filter(dbFk => dbFk[\"CONSTRAINT_NAME\"] === dbForeignKey[\"CONSTRAINT_NAME\"]); // if referenced table located in currently used db, we don't need to concat db name to table name.\n\n        const database = dbForeignKey[\"REFERENCED_TABLE_SCHEMA\"] === currentDatabase ? undefined : dbForeignKey[\"REFERENCED_TABLE_SCHEMA\"];\n        const referencedTableName = this.driver.buildTableName(dbForeignKey[\"REFERENCED_TABLE_NAME\"], undefined, database);\n        return new TableForeignKey({\n          name: dbForeignKey[\"CONSTRAINT_NAME\"],\n          columnNames: foreignKeys.map(dbFk => dbFk[\"COLUMN_NAME\"]),\n          referencedDatabase: dbForeignKey[\"REFERENCED_TABLE_SCHEMA\"],\n          referencedTableName: referencedTableName,\n          referencedColumnNames: foreignKeys.map(dbFk => dbFk[\"REFERENCED_COLUMN_NAME\"]),\n          onDelete: dbForeignKey[\"ON_DELETE\"],\n          onUpdate: dbForeignKey[\"ON_UPDATE\"]\n        });\n      }); // find index constraints of table, group them by constraint name and build TableIndex.\n\n      const tableIndexConstraints = OrmUtils.uniq(dbIndices.filter(dbIndex => {\n        return dbIndex[\"TABLE_NAME\"] === dbTable[\"TABLE_NAME\"] && dbIndex[\"TABLE_SCHEMA\"] === dbTable[\"TABLE_SCHEMA\"];\n      }), dbIndex => dbIndex[\"INDEX_NAME\"]);\n      table.indices = tableIndexConstraints.map(constraint => {\n        const indices = dbIndices.filter(index => {\n          return index[\"TABLE_SCHEMA\"] === constraint[\"TABLE_SCHEMA\"] && index[\"TABLE_NAME\"] === constraint[\"TABLE_NAME\"] && index[\"INDEX_NAME\"] === constraint[\"INDEX_NAME\"];\n        });\n        const nonUnique = parseInt(constraint[\"NON_UNIQUE\"], 10);\n        return new TableIndex({\n          table: table,\n          name: constraint[\"INDEX_NAME\"],\n          columnNames: indices.map(i => i[\"COLUMN_NAME\"]),\n          isUnique: nonUnique === 0,\n          isSpatial: constraint[\"INDEX_TYPE\"] === \"SPATIAL\",\n          isFulltext: constraint[\"INDEX_TYPE\"] === \"FULLTEXT\"\n        });\n      });\n      return table;\n    }));\n  }\n  /**\n   * Builds create table sql\n   */\n\n\n  createTableSql(table, createForeignKeys) {\n    const columnDefinitions = table.columns.map(column => this.buildCreateColumnSql(column, true)).join(\", \");\n    let sql = `CREATE TABLE ${this.escapePath(table)} (${columnDefinitions}`; // we create unique indexes instead of unique constraints, because MySql does not have unique constraints.\n    // if we mark column as Unique, it means that we create UNIQUE INDEX.\n\n    table.columns.filter(column => column.isUnique).forEach(column => {\n      const isUniqueIndexExist = table.indices.some(index => {\n        return index.columnNames.length === 1 && !!index.isUnique && index.columnNames.indexOf(column.name) !== -1;\n      });\n      const isUniqueConstraintExist = table.uniques.some(unique => {\n        return unique.columnNames.length === 1 && unique.columnNames.indexOf(column.name) !== -1;\n      });\n      if (!isUniqueIndexExist && !isUniqueConstraintExist) table.indices.push(new TableIndex({\n        name: this.connection.namingStrategy.uniqueConstraintName(table, [column.name]),\n        columnNames: [column.name],\n        isUnique: true\n      }));\n    }); // as MySql does not have unique constraints, we must create table indices from table uniques and mark them as unique.\n\n    if (table.uniques.length > 0) {\n      table.uniques.forEach(unique => {\n        const uniqueExist = table.indices.some(index => index.name === unique.name);\n\n        if (!uniqueExist) {\n          table.indices.push(new TableIndex({\n            name: unique.name,\n            columnNames: unique.columnNames,\n            isUnique: true\n          }));\n        }\n      });\n    }\n\n    if (table.indices.length > 0) {\n      const indicesSql = table.indices.map(index => {\n        const columnNames = index.columnNames.map(columnName => `\\`${columnName}\\``).join(\", \");\n        if (!index.name) index.name = this.connection.namingStrategy.indexName(table, index.columnNames, index.where);\n        let indexType = \"\";\n        if (index.isUnique) indexType += \"UNIQUE \";\n        if (index.isSpatial) indexType += \"SPATIAL \";\n        if (index.isFulltext) indexType += \"FULLTEXT \";\n        return `${indexType}INDEX \\`${index.name}\\` (${columnNames})`;\n      }).join(\", \");\n      sql += `, ${indicesSql}`;\n    }\n\n    if (table.foreignKeys.length > 0 && createForeignKeys) {\n      const foreignKeysSql = table.foreignKeys.map(fk => {\n        const columnNames = fk.columnNames.map(columnName => `\\`${columnName}\\``).join(\", \");\n        if (!fk.name) fk.name = this.connection.namingStrategy.foreignKeyName(table, fk.columnNames);\n        const referencedColumnNames = fk.referencedColumnNames.map(columnName => `\\`${columnName}\\``).join(\", \");\n        let constraint = `CONSTRAINT \\`${fk.name}\\` FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(fk))} (${referencedColumnNames})`;\n        if (fk.onDelete) constraint += ` ON DELETE ${fk.onDelete}`;\n        if (fk.onUpdate) constraint += ` ON UPDATE ${fk.onUpdate}`;\n        return constraint;\n      }).join(\", \");\n      sql += `, ${foreignKeysSql}`;\n    }\n\n    if (table.primaryColumns.length > 0) {\n      const columnNames = table.primaryColumns.map(column => `\\`${column.name}\\``).join(\", \");\n      sql += `, PRIMARY KEY (${columnNames})`;\n    }\n\n    sql += `) ENGINE=${table.engine || \"InnoDB\"}`;\n    return new Query(sql);\n  }\n  /**\n   * Builds drop table sql\n   */\n\n\n  dropTableSql(tableOrName) {\n    return new Query(`DROP TABLE ${this.escapePath(tableOrName)}`);\n  }\n\n  createViewSql(view) {\n    if (typeof view.expression === \"string\") {\n      return new Query(`CREATE VIEW ${this.escapePath(view)} AS ${view.expression}`);\n    } else {\n      return new Query(`CREATE VIEW ${this.escapePath(view)} AS ${view.expression(this.connection).getQuery()}`);\n    }\n  }\n\n  async insertViewDefinitionSql(view) {\n    const currentDatabase = await this.getCurrentDatabase();\n    const expression = typeof view.expression === \"string\" ? view.expression.trim() : view.expression(this.connection).getQuery();\n    return this.insertTypeormMetadataSql({\n      type: MetadataTableType.VIEW,\n      schema: currentDatabase,\n      name: view.name,\n      value: expression\n    });\n  }\n  /**\n   * Builds drop view sql.\n   */\n\n\n  dropViewSql(viewOrPath) {\n    return new Query(`DROP VIEW ${this.escapePath(viewOrPath)}`);\n  }\n  /**\n   * Builds remove view sql.\n   */\n\n\n  async deleteViewDefinitionSql(viewOrPath) {\n    const currentDatabase = await this.getCurrentDatabase();\n    const viewName = InstanceChecker.isView(viewOrPath) ? viewOrPath.name : viewOrPath;\n    return this.deleteTypeormMetadataSql({\n      type: MetadataTableType.VIEW,\n      schema: currentDatabase,\n      name: viewName\n    });\n  }\n  /**\n   * Builds create index sql.\n   */\n\n\n  createIndexSql(table, index) {\n    const columns = index.columnNames.map(columnName => `\\`${columnName}\\``).join(\", \");\n    let indexType = \"\";\n    if (index.isUnique) indexType += \"UNIQUE \";\n    if (index.isSpatial) indexType += \"SPATIAL \";\n    if (index.isFulltext) indexType += \"FULLTEXT \";\n    return new Query(`CREATE ${indexType}INDEX \\`${index.name}\\` ON ${this.escapePath(table)} (${columns})`);\n  }\n  /**\n   * Builds drop index sql.\n   */\n\n\n  dropIndexSql(table, indexOrName) {\n    let indexName = InstanceChecker.isTableIndex(indexOrName) ? indexOrName.name : indexOrName;\n    return new Query(`DROP INDEX \\`${indexName}\\` ON ${this.escapePath(table)}`);\n  }\n  /**\n   * Builds create primary key sql.\n   */\n\n\n  createPrimaryKeySql(table, columnNames) {\n    const columnNamesString = columnNames.map(columnName => `\\`${columnName}\\``).join(\", \");\n    return new Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNamesString})`);\n  }\n  /**\n   * Builds drop primary key sql.\n   */\n\n\n  dropPrimaryKeySql(table) {\n    return new Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`);\n  }\n  /**\n   * Builds create foreign key sql.\n   */\n\n\n  createForeignKeySql(table, foreignKey) {\n    const columnNames = foreignKey.columnNames.map(column => `\\`${column}\\``).join(\", \");\n    const referencedColumnNames = foreignKey.referencedColumnNames.map(column => `\\`${column}\\``).join(\",\");\n    let sql = `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \\`${foreignKey.name}\\` FOREIGN KEY (${columnNames}) ` + `REFERENCES ${this.escapePath(this.getTablePath(foreignKey))}(${referencedColumnNames})`;\n    if (foreignKey.onDelete) sql += ` ON DELETE ${foreignKey.onDelete}`;\n    if (foreignKey.onUpdate) sql += ` ON UPDATE ${foreignKey.onUpdate}`;\n    return new Query(sql);\n  }\n  /**\n   * Builds drop foreign key sql.\n   */\n\n\n  dropForeignKeySql(table, foreignKeyOrName) {\n    const foreignKeyName = InstanceChecker.isTableForeignKey(foreignKeyOrName) ? foreignKeyOrName.name : foreignKeyOrName;\n    return new Query(`ALTER TABLE ${this.escapePath(table)} DROP FOREIGN KEY \\`${foreignKeyName}\\``);\n  }\n  /**\n   * Escapes a given comment so it's safe to include in a query.\n   */\n\n\n  escapeComment(comment) {\n    if (!comment || comment.length === 0) {\n      return `''`;\n    }\n\n    comment = comment.replace(/\\\\/g, \"\\\\\\\\\") // MySQL allows escaping characters via backslashes\n    .replace(/'/g, \"''\").replace(/\\u0000/g, \"\"); // Null bytes aren't allowed in comments\n\n    return `'${comment}'`;\n  }\n  /**\n   * Escapes given table or view path.\n   */\n\n\n  escapePath(target) {\n    const {\n      database,\n      tableName\n    } = this.driver.parseTableName(target);\n\n    if (database && database !== this.driver.database) {\n      return `\\`${database}\\`.\\`${tableName}\\``;\n    }\n\n    return `\\`${tableName}\\``;\n  }\n  /**\n   * Builds a part of query to create/change a column.\n   */\n\n\n  buildCreateColumnSql(column, skipPrimary) {\n    let skipName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let c = \"\";\n\n    if (skipName) {\n      c = this.connection.driver.createFullType(column);\n    } else {\n      c = `\\`${column.name}\\` ${this.connection.driver.createFullType(column)}`;\n    }\n\n    if (column.asExpression) c += ` AS (${column.asExpression}) ${column.generatedType ? column.generatedType : \"VIRTUAL\"}`; // if you specify ZEROFILL for a numeric column, MySQL automatically adds the UNSIGNED attribute to that column.\n\n    if (column.zerofill) {\n      c += \" ZEROFILL\";\n    } else if (column.unsigned) {\n      c += \" UNSIGNED\";\n    }\n\n    if (column.enum) c += ` (${column.enum.map(value => \"'\" + value + \"'\").join(\", \")})`;\n    if (column.charset) c += ` CHARACTER SET \"${column.charset}\"`;\n    if (column.collation) c += ` COLLATE \"${column.collation}\"`;\n    if (!column.isNullable) c += \" NOT NULL\";\n    if (column.isNullable) c += \" NULL\";\n    if (column.isPrimary && !skipPrimary) c += \" PRIMARY KEY\";\n    if (column.isGenerated && column.generationStrategy === \"increment\") // don't use skipPrimary here since updates can update already exist primary without auto inc.\n      c += \" AUTO_INCREMENT\";\n    if (column.comment) c += ` COMMENT ${this.escapeComment(column.comment)}`;\n    if (column.default !== undefined && column.default !== null) c += ` DEFAULT ${column.default}`;\n    if (column.onUpdate) c += ` ON UPDATE ${column.onUpdate}`;\n    return c;\n  }\n  /**\n   * Checks if column display width is by default.\n   */\n\n\n  isDefaultColumnWidth(table, column, width) {\n    // if table have metadata, we check if length is specified in column metadata\n    if (this.connection.hasMetadata(table.name)) {\n      const metadata = this.connection.getMetadata(table.name);\n      const columnMetadata = metadata.findColumnWithDatabaseName(column.name);\n      if (columnMetadata && columnMetadata.width) return false;\n    }\n\n    const defaultWidthForType = this.connection.driver.dataTypeDefaults && this.connection.driver.dataTypeDefaults[column.type] && this.connection.driver.dataTypeDefaults[column.type].width;\n\n    if (defaultWidthForType) {\n      return defaultWidthForType === width;\n    }\n\n    return false;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["QueryResult","TransactionNotStartedError","TableColumn","Table","TableForeignKey","TableIndex","QueryRunnerAlreadyReleasedError","View","Query","OrmUtils","TableUnique","BaseQueryRunner","Broadcaster","TypeORMError","MetadataTableType","InstanceChecker","AuroraMysqlQueryRunner","constructor","driver","client","connection","broadcaster","connect","release","isReleased","databaseConnection","Promise","resolve","startTransaction","isolationLevel","isTransactionActive","broadcast","err","transactionDepth","query","commitTransaction","rollbackTransaction","parameters","useStructuredResult","raw","result","hasOwnProperty","Array","isArray","records","affected","numberOfRecordsUpdated","stream","onEnd","onError","ok","fail","on","getDatabases","getSchemas","database","hasDatabase","length","getCurrentDatabase","hasSchema","schema","getCurrentSchema","hasTable","tableOrName","parsedTableName","parseTableName","sql","tableName","hasColumn","column","columnName","isTableColumn","name","createDatabase","ifNotExist","up","down","executeQueries","dropDatabase","ifExist","createSchema","schemaPath","dropSchema","createTable","table","createForeignKeys","isTableExist","upQueries","downQueries","push","createTableSql","dropTableSql","indices","forEach","index","dropIndexSql","foreignKeys","foreignKey","dropForeignKeySql","dropTable","target","dropForeignKeys","tablePath","getTablePath","getCachedTable","createView","view","createViewSql","insertViewDefinitionSql","dropViewSql","deleteViewDefinitionSql","dropView","viewName","isView","getCachedView","renameTable","oldTableOrName","newTableName","oldTable","isTable","newTable","clone","escapePath","columnNames","map","join","newIndexName","namingStrategy","indexName","where","indexType","isUnique","isSpatial","isFulltext","referencedColumnNames","newForeignKeyName","foreignKeyName","onDelete","onUpdate","replaceCachedTable","addColumn","clonedTable","skipColumnLevelPrimary","primaryColumns","buildCreateColumnSql","isPrimary","generatedColumn","columns","find","isGenerated","generationStrategy","nonGeneratedColumn","undefined","columnIndex","createIndexSql","uniqueIndex","uniques","addColumns","renameColumn","oldTableColumnOrName","newTableColumnOrName","oldColumn","c","newColumn","changeColumn","oldColumnOrName","type","generatedType","dropColumn","findColumnIndices","splice","indexOf","findColumnForeignKeys","oldTableColumn","isColumnChanged","primaryColumn","tableUnique","unique","changeColumns","changedColumns","columnOrName","findColumnByName","tableColumn","uniqueName","uniqueConstraintName","foundUnique","foundIndex","removeColumn","dropColumns","createPrimaryKey","createPrimaryKeySql","dropPrimaryKeySql","updatePrimaryKeys","filter","columnNamesString","newOrExistGeneratedColumn","changedGeneratedColumn","dropPrimaryKey","createUniqueConstraint","uniqueConstraint","createUniqueConstraints","uniqueConstraints","dropUniqueConstraint","uniqueOrName","dropUniqueConstraints","createCheckConstraint","checkConstraint","createCheckConstraints","checkConstraints","dropCheckConstraint","checkOrName","dropCheckConstraints","createExclusionConstraint","exclusionConstraint","createExclusionConstraints","exclusionConstraints","dropExclusionConstraint","exclusionOrName","dropExclusionConstraints","createForeignKey","createForeignKeySql","addForeignKey","promises","all","dropForeignKey","foreignKeyOrName","isTableForeignKey","fk","removeForeignKey","createIndex","generateIndexName","addIndex","createIndices","dropIndex","indexOrName","isTableIndex","i","removeIndex","dropIndices","clearTable","clearDatabase","dbName","isDatabaseExist","isAnotherTransactionActive","selectViewDropsQuery","dropViewQueries","q","disableForeignKeysCheckQuery","dropTablesQuery","enableForeignKeysCheckQuery","dropQueries","error","rollbackError","loadViews","viewNames","getTypeormMetadataTableName","currentDatabase","viewsCondition","VIEW","dbViews","dbView","db","buildTableName","expression","loadTables","tableNames","dbTables","tablesSql","tablesCondition","split","columnsCondition","TABLE_NAME","TABLE_SCHEMA","columnsSql","primaryKeySql","collationsSql","indicesCondition","indicesSql","foreignKeysCondition","foreignKeysSql","dbColumns","dbPrimaryKeys","dbCollations","dbIndices","dbForeignKeys","dbTable","dbCollation","coll","defaultCollation","defaultCharset","dbColumn","columnUniqueIndices","dbIndex","parseInt","tableMetadata","entityMetadatas","metadata","hasIgnoredIndex","some","synchronize","isConstraintComposite","every","toLowerCase","withWidthColumnTypes","width","substring","isDefaultColumnWidth","default","asExpression","isNullable","dbPrimaryKey","zerofill","unsigned","comment","charset","collation","withLengthColumnTypes","toString","isDefaultColumnLength","isDefaultColumnPrecision","precision","isDefaultColumnScale","scale","colType","items","lastIndexOf","enum","item","tableForeignKeyConstraints","uniq","dbForeignKey","dbFk","referencedTableName","referencedDatabase","tableIndexConstraints","constraint","nonUnique","columnDefinitions","isUniqueIndexExist","isUniqueConstraintExist","uniqueExist","engine","getQuery","trim","insertTypeormMetadataSql","value","viewOrPath","deleteTypeormMetadataSql","escapeComment","replace","skipPrimary","skipName","createFullType","hasMetadata","getMetadata","columnMetadata","findColumnWithDatabaseName","defaultWidthForType","dataTypeDefaults"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\driver\\aurora-mysql\\AuroraMysqlQueryRunner.ts"],"sourcesContent":["import { QueryResult } from \"../../query-runner/QueryResult\"\nimport { QueryRunner } from \"../../query-runner/QueryRunner\"\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { TransactionNotStartedError } from \"../../error/TransactionNotStartedError\"\nimport { TableColumn } from \"../../schema-builder/table/TableColumn\"\nimport { Table } from \"../../schema-builder/table/Table\"\nimport { TableForeignKey } from \"../../schema-builder/table/TableForeignKey\"\nimport { TableIndex } from \"../../schema-builder/table/TableIndex\"\nimport { QueryRunnerAlreadyReleasedError } from \"../../error/QueryRunnerAlreadyReleasedError\"\nimport { View } from \"../../schema-builder/view/View\"\nimport { Query } from \"../Query\"\nimport { AuroraMysqlDriver } from \"./AuroraMysqlDriver\"\nimport { ReadStream } from \"../../platform/PlatformTools\"\nimport { OrmUtils } from \"../../util/OrmUtils\"\nimport { TableIndexOptions } from \"../../schema-builder/options/TableIndexOptions\"\nimport { TableUnique } from \"../../schema-builder/table/TableUnique\"\nimport { BaseQueryRunner } from \"../../query-runner/BaseQueryRunner\"\nimport { Broadcaster } from \"../../subscriber/Broadcaster\"\nimport { ColumnType } from \"../types/ColumnTypes\"\nimport { TableCheck } from \"../../schema-builder/table/TableCheck\"\nimport { IsolationLevel } from \"../types/IsolationLevel\"\nimport { TableExclusion } from \"../../schema-builder/table/TableExclusion\"\nimport { TypeORMError } from \"../../error\"\nimport { MetadataTableType } from \"../types/MetadataTableType\"\nimport { InstanceChecker } from \"../../util/InstanceChecker\"\n\n/**\n * Runs queries on a single mysql database connection.\n */\nexport class AuroraMysqlQueryRunner\n    extends BaseQueryRunner\n    implements QueryRunner\n{\n    // -------------------------------------------------------------------------\n    // Public Implemented Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Database driver used by connection.\n     */\n\n    driver: AuroraMysqlDriver\n\n    protected client: any\n\n    // -------------------------------------------------------------------------\n    // Protected Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Promise used to obtain a database connection from a pool for a first time.\n     */\n    protected databaseConnectionPromise: Promise<any>\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(driver: AuroraMysqlDriver, client: any) {\n        super()\n        this.driver = driver\n        this.connection = driver.connection\n        this.client = client\n        this.broadcaster = new Broadcaster(this)\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates/uses database connection from the connection pool to perform further operations.\n     * Returns obtained database connection.\n     */\n    async connect(): Promise<any> {\n        return {}\n    }\n\n    /**\n     * Releases used database connection.\n     * You cannot use query runner methods once its released.\n     */\n    release(): Promise<void> {\n        this.isReleased = true\n        if (this.databaseConnection) this.databaseConnection.release()\n        return Promise.resolve()\n    }\n\n    /**\n     * Starts transaction on the current connection.\n     */\n    async startTransaction(isolationLevel?: IsolationLevel): Promise<void> {\n        this.isTransactionActive = true\n        try {\n            await this.broadcaster.broadcast(\"BeforeTransactionStart\")\n        } catch (err) {\n            this.isTransactionActive = false\n            throw err\n        }\n\n        if (this.transactionDepth === 0) {\n            await this.client.startTransaction()\n        } else {\n            await this.query(`SAVEPOINT typeorm_${this.transactionDepth}`)\n        }\n        this.transactionDepth += 1\n\n        await this.broadcaster.broadcast(\"AfterTransactionStart\")\n    }\n\n    /**\n     * Commits transaction.\n     * Error will be thrown if transaction was not started.\n     */\n    async commitTransaction(): Promise<void> {\n        if (!this.isTransactionActive) throw new TransactionNotStartedError()\n\n        await this.broadcaster.broadcast(\"BeforeTransactionCommit\")\n\n        if (this.transactionDepth > 1) {\n            await this.query(\n                `RELEASE SAVEPOINT typeorm_${this.transactionDepth - 1}`,\n            )\n        } else {\n            await this.client.commitTransaction()\n            this.isTransactionActive = false\n        }\n        this.transactionDepth -= 1\n\n        await this.broadcaster.broadcast(\"AfterTransactionCommit\")\n    }\n\n    /**\n     * Rollbacks transaction.\n     * Error will be thrown if transaction was not started.\n     */\n    async rollbackTransaction(): Promise<void> {\n        if (!this.isTransactionActive) throw new TransactionNotStartedError()\n\n        await this.broadcaster.broadcast(\"BeforeTransactionRollback\")\n\n        if (this.transactionDepth > 1) {\n            await this.query(\n                `ROLLBACK TO SAVEPOINT typeorm_${this.transactionDepth - 1}`,\n            )\n        } else {\n            await this.client.rollbackTransaction()\n            this.isTransactionActive = false\n        }\n        this.transactionDepth -= 1\n\n        await this.broadcaster.broadcast(\"AfterTransactionRollback\")\n    }\n\n    /**\n     * Executes a raw SQL query.\n     */\n    async query(\n        query: string,\n        parameters?: any[],\n        useStructuredResult = false,\n    ): Promise<any> {\n        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError()\n\n        const raw = await this.client.query(query, parameters)\n\n        const result = new QueryResult()\n\n        result.raw = raw\n\n        if (raw?.hasOwnProperty(\"records\") && Array.isArray(raw.records)) {\n            result.records = raw.records\n        }\n\n        if (raw?.hasOwnProperty(\"numberOfRecordsUpdated\")) {\n            result.affected = raw.numberOfRecordsUpdated\n        }\n\n        if (!useStructuredResult) {\n            return result.raw\n        }\n\n        return result\n    }\n\n    /**\n     * Returns raw data stream.\n     */\n    stream(\n        query: string,\n        parameters?: any[],\n        onEnd?: Function,\n        onError?: Function,\n    ): Promise<ReadStream> {\n        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError()\n\n        return new Promise(async (ok, fail) => {\n            try {\n                const databaseConnection = await this.connect()\n                const stream = databaseConnection.query(query, parameters)\n                if (onEnd) stream.on(\"end\", onEnd)\n                if (onError) stream.on(\"error\", onError)\n                ok(stream)\n            } catch (err) {\n                fail(err)\n            }\n        })\n    }\n\n    /**\n     * Returns all available database names including system databases.\n     */\n    async getDatabases(): Promise<string[]> {\n        return Promise.resolve([])\n    }\n\n    /**\n     * Returns all available schema names including system schemas.\n     * If database parameter specified, returns schemas of that database.\n     */\n    async getSchemas(database?: string): Promise<string[]> {\n        throw new TypeORMError(`MySql driver does not support table schemas`)\n    }\n\n    /**\n     * Checks if database with the given name exist.\n     */\n    async hasDatabase(database: string): Promise<boolean> {\n        const result = await this.query(\n            `SELECT * FROM \\`INFORMATION_SCHEMA\\`.\\`SCHEMATA\\` WHERE \\`SCHEMA_NAME\\` = '${database}'`,\n        )\n        return result.length ? true : false\n    }\n\n    /**\n     * Loads currently using database\n     */\n    async getCurrentDatabase(): Promise<string> {\n        const query = await this.query(`SELECT DATABASE() AS \\`db_name\\``)\n        return query[0][\"db_name\"]\n    }\n\n    /**\n     * Checks if schema with the given name exist.\n     */\n    async hasSchema(schema: string): Promise<boolean> {\n        throw new TypeORMError(`MySql driver does not support table schemas`)\n    }\n\n    /**\n     * Loads currently using database schema\n     */\n    async getCurrentSchema(): Promise<string> {\n        const query = await this.query(`SELECT SCHEMA() AS \\`schema_name\\``)\n        return query[0][\"schema_name\"]\n    }\n\n    /**\n     * Checks if table with the given name exist in the database.\n     */\n    async hasTable(tableOrName: Table | string): Promise<boolean> {\n        const parsedTableName = this.driver.parseTableName(tableOrName)\n        const sql = `SELECT * FROM \\`INFORMATION_SCHEMA\\`.\\`COLUMNS\\` WHERE \\`TABLE_SCHEMA\\` = '${parsedTableName.database}' AND \\`TABLE_NAME\\` = '${parsedTableName.tableName}'`\n        const result = await this.query(sql)\n        return result.length ? true : false\n    }\n\n    /**\n     * Checks if column with the given name exist in the given table.\n     */\n    async hasColumn(\n        tableOrName: Table | string,\n        column: TableColumn | string,\n    ): Promise<boolean> {\n        const parsedTableName = this.driver.parseTableName(tableOrName)\n        const columnName = InstanceChecker.isTableColumn(column)\n            ? column.name\n            : column\n        const sql = `SELECT * FROM \\`INFORMATION_SCHEMA\\`.\\`COLUMNS\\` WHERE \\`TABLE_SCHEMA\\` = '${parsedTableName.database}' AND \\`TABLE_NAME\\` = '${parsedTableName.tableName}' AND \\`COLUMN_NAME\\` = '${columnName}'`\n        const result = await this.query(sql)\n        return result.length ? true : false\n    }\n\n    /**\n     * Creates a new database.\n     */\n    async createDatabase(\n        database: string,\n        ifNotExist?: boolean,\n    ): Promise<void> {\n        const up = ifNotExist\n            ? `CREATE DATABASE IF NOT EXISTS \\`${database}\\``\n            : `CREATE DATABASE \\`${database}\\``\n        const down = `DROP DATABASE \\`${database}\\``\n        await this.executeQueries(new Query(up), new Query(down))\n    }\n\n    /**\n     * Drops database.\n     */\n    async dropDatabase(database: string, ifExist?: boolean): Promise<void> {\n        const up = ifExist\n            ? `DROP DATABASE IF EXISTS \\`${database}\\``\n            : `DROP DATABASE \\`${database}\\``\n        const down = `CREATE DATABASE \\`${database}\\``\n        await this.executeQueries(new Query(up), new Query(down))\n    }\n\n    /**\n     * Creates a new table schema.\n     */\n    async createSchema(\n        schemaPath: string,\n        ifNotExist?: boolean,\n    ): Promise<void> {\n        throw new TypeORMError(\n            `Schema create queries are not supported by MySql driver.`,\n        )\n    }\n\n    /**\n     * Drops table schema.\n     */\n    async dropSchema(schemaPath: string, ifExist?: boolean): Promise<void> {\n        throw new TypeORMError(\n            `Schema drop queries are not supported by MySql driver.`,\n        )\n    }\n\n    /**\n     * Creates a new table.\n     */\n    async createTable(\n        table: Table,\n        ifNotExist: boolean = false,\n        createForeignKeys: boolean = true,\n    ): Promise<void> {\n        if (ifNotExist) {\n            const isTableExist = await this.hasTable(table)\n            if (isTableExist) return Promise.resolve()\n        }\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        upQueries.push(this.createTableSql(table, createForeignKeys))\n        downQueries.push(this.dropTableSql(table))\n\n        // we must first drop indices, than drop foreign keys, because drop queries runs in reversed order\n        // and foreign keys will be dropped first as indices. This order is very important, because we can't drop index\n        // if it related to the foreign key.\n\n        // createTable does not need separate method to create indices, because it create indices in the same query with table creation.\n        table.indices.forEach((index) =>\n            downQueries.push(this.dropIndexSql(table, index)),\n        )\n\n        // if createForeignKeys is true, we must drop created foreign keys in down query.\n        // createTable does not need separate method to create foreign keys, because it create fk's in the same query with table creation.\n        if (createForeignKeys)\n            table.foreignKeys.forEach((foreignKey) =>\n                downQueries.push(this.dropForeignKeySql(table, foreignKey)),\n            )\n\n        return this.executeQueries(upQueries, downQueries)\n    }\n\n    /**\n     * Drop the table.\n     */\n    async dropTable(\n        target: Table | string,\n        ifExist?: boolean,\n        dropForeignKeys: boolean = true,\n    ): Promise<void> {\n        // It needs because if table does not exist and dropForeignKeys or dropIndices is true, we don't need\n        // to perform drop queries for foreign keys and indices.\n        if (ifExist) {\n            const isTableExist = await this.hasTable(target)\n            if (!isTableExist) return Promise.resolve()\n        }\n\n        // if dropTable called with dropForeignKeys = true, we must create foreign keys in down query.\n        const createForeignKeys: boolean = dropForeignKeys\n        const tablePath = this.getTablePath(target)\n        const table = await this.getCachedTable(tablePath)\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        if (dropForeignKeys)\n            table.foreignKeys.forEach((foreignKey) =>\n                upQueries.push(this.dropForeignKeySql(table, foreignKey)),\n            )\n\n        table.indices.forEach((index) =>\n            upQueries.push(this.dropIndexSql(table, index)),\n        )\n\n        upQueries.push(this.dropTableSql(table))\n        downQueries.push(this.createTableSql(table, createForeignKeys))\n\n        await this.executeQueries(upQueries, downQueries)\n    }\n\n    /**\n     * Creates a new view.\n     */\n    async createView(view: View): Promise<void> {\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n        upQueries.push(this.createViewSql(view))\n        upQueries.push(await this.insertViewDefinitionSql(view))\n        downQueries.push(this.dropViewSql(view))\n        downQueries.push(await this.deleteViewDefinitionSql(view))\n        await this.executeQueries(upQueries, downQueries)\n    }\n\n    /**\n     * Drops the view.\n     */\n    async dropView(target: View | string): Promise<void> {\n        const viewName = InstanceChecker.isView(target) ? target.name : target\n        const view = await this.getCachedView(viewName)\n\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n        upQueries.push(await this.deleteViewDefinitionSql(view))\n        upQueries.push(this.dropViewSql(view))\n        downQueries.push(await this.insertViewDefinitionSql(view))\n        downQueries.push(this.createViewSql(view))\n        await this.executeQueries(upQueries, downQueries)\n    }\n\n    /**\n     * Renames a table.\n     */\n    async renameTable(\n        oldTableOrName: Table | string,\n        newTableName: string,\n    ): Promise<void> {\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n        const oldTable = InstanceChecker.isTable(oldTableOrName)\n            ? oldTableOrName\n            : await this.getCachedTable(oldTableOrName)\n        const newTable = oldTable.clone()\n\n        const { database } = this.driver.parseTableName(oldTable)\n        newTable.name = database ? `${database}.${newTableName}` : newTableName\n\n        // rename table\n        upQueries.push(\n            new Query(\n                `RENAME TABLE ${this.escapePath(oldTable)} TO ${this.escapePath(\n                    newTable,\n                )}`,\n            ),\n        )\n        downQueries.push(\n            new Query(\n                `RENAME TABLE ${this.escapePath(newTable)} TO ${this.escapePath(\n                    oldTable,\n                )}`,\n            ),\n        )\n\n        // rename index constraints\n        newTable.indices.forEach((index) => {\n            // build new constraint name\n            const columnNames = index.columnNames\n                .map((column) => `\\`${column}\\``)\n                .join(\", \")\n            const newIndexName = this.connection.namingStrategy.indexName(\n                newTable,\n                index.columnNames,\n                index.where,\n            )\n\n            // build queries\n            let indexType = \"\"\n            if (index.isUnique) indexType += \"UNIQUE \"\n            if (index.isSpatial) indexType += \"SPATIAL \"\n            if (index.isFulltext) indexType += \"FULLTEXT \"\n            upQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(newTable)} DROP INDEX \\`${\n                        index.name\n                    }\\`, ADD ${indexType}INDEX \\`${newIndexName}\\` (${columnNames})`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        newTable,\n                    )} DROP INDEX \\`${newIndexName}\\`, ADD ${indexType}INDEX \\`${\n                        index.name\n                    }\\` (${columnNames})`,\n                ),\n            )\n\n            // replace constraint name\n            index.name = newIndexName\n        })\n\n        // rename foreign key constraint\n        newTable.foreignKeys.forEach((foreignKey) => {\n            // build new constraint name\n            const columnNames = foreignKey.columnNames\n                .map((column) => `\\`${column}\\``)\n                .join(\", \")\n            const referencedColumnNames = foreignKey.referencedColumnNames\n                .map((column) => `\\`${column}\\``)\n                .join(\",\")\n            const newForeignKeyName =\n                this.connection.namingStrategy.foreignKeyName(\n                    newTable,\n                    foreignKey.columnNames,\n                )\n\n            // build queries\n            let up =\n                `ALTER TABLE ${this.escapePath(newTable)} DROP FOREIGN KEY \\`${\n                    foreignKey.name\n                }\\`, ADD CONSTRAINT \\`${newForeignKeyName}\\` FOREIGN KEY (${columnNames}) ` +\n                `REFERENCES ${this.escapePath(\n                    this.getTablePath(foreignKey),\n                )}(${referencedColumnNames})`\n            if (foreignKey.onDelete) up += ` ON DELETE ${foreignKey.onDelete}`\n            if (foreignKey.onUpdate) up += ` ON UPDATE ${foreignKey.onUpdate}`\n\n            let down =\n                `ALTER TABLE ${this.escapePath(\n                    newTable,\n                )} DROP FOREIGN KEY \\`${newForeignKeyName}\\`, ADD CONSTRAINT \\`${\n                    foreignKey.name\n                }\\` FOREIGN KEY (${columnNames}) ` +\n                `REFERENCES ${this.escapePath(\n                    this.getTablePath(foreignKey),\n                )}(${referencedColumnNames})`\n            if (foreignKey.onDelete) down += ` ON DELETE ${foreignKey.onDelete}`\n            if (foreignKey.onUpdate) down += ` ON UPDATE ${foreignKey.onUpdate}`\n\n            upQueries.push(new Query(up))\n            downQueries.push(new Query(down))\n\n            // replace constraint name\n            foreignKey.name = newForeignKeyName\n        })\n\n        await this.executeQueries(upQueries, downQueries)\n\n        // rename old table and replace it in cached tabled;\n        oldTable.name = newTable.name\n        this.replaceCachedTable(oldTable, newTable)\n    }\n\n    /**\n     * Creates a new column from the column in the table.\n     */\n    async addColumn(\n        tableOrName: Table | string,\n        column: TableColumn,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const clonedTable = table.clone()\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n        const skipColumnLevelPrimary = clonedTable.primaryColumns.length > 0\n\n        upQueries.push(\n            new Query(\n                `ALTER TABLE ${this.escapePath(\n                    table,\n                )} ADD ${this.buildCreateColumnSql(\n                    column,\n                    skipColumnLevelPrimary,\n                    false,\n                )}`,\n            ),\n        )\n        downQueries.push(\n            new Query(\n                `ALTER TABLE ${this.escapePath(table)} DROP COLUMN \\`${\n                    column.name\n                }\\``,\n            ),\n        )\n\n        // create or update primary key constraint\n        if (column.isPrimary && skipColumnLevelPrimary) {\n            // if we already have generated column, we must temporary drop AUTO_INCREMENT property.\n            const generatedColumn = clonedTable.columns.find(\n                (column) =>\n                    column.isGenerated &&\n                    column.generationStrategy === \"increment\",\n            )\n            if (generatedColumn) {\n                const nonGeneratedColumn = generatedColumn.clone()\n                nonGeneratedColumn.isGenerated = false\n                nonGeneratedColumn.generationStrategy = undefined\n                upQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(table)} CHANGE \\`${\n                            column.name\n                        }\\` ${this.buildCreateColumnSql(\n                            nonGeneratedColumn,\n                            true,\n                        )}`,\n                    ),\n                )\n                downQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(table)} CHANGE \\`${\n                            nonGeneratedColumn.name\n                        }\\` ${this.buildCreateColumnSql(column, true)}`,\n                    ),\n                )\n            }\n\n            const primaryColumns = clonedTable.primaryColumns\n            let columnNames = primaryColumns\n                .map((column) => `\\`${column.name}\\``)\n                .join(\", \")\n            upQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        table,\n                    )} ADD PRIMARY KEY (${columnNames})`,\n                ),\n            )\n\n            primaryColumns.push(column)\n            columnNames = primaryColumns\n                .map((column) => `\\`${column.name}\\``)\n                .join(\", \")\n            upQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        table,\n                    )} ADD PRIMARY KEY (${columnNames})`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`,\n                ),\n            )\n\n            // if we previously dropped AUTO_INCREMENT property, we must bring it back\n            if (generatedColumn) {\n                const nonGeneratedColumn = generatedColumn.clone()\n                nonGeneratedColumn.isGenerated = false\n                nonGeneratedColumn.generationStrategy = undefined\n                upQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(table)} CHANGE \\`${\n                            nonGeneratedColumn.name\n                        }\\` ${this.buildCreateColumnSql(column, true)}`,\n                    ),\n                )\n                downQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(table)} CHANGE \\`${\n                            column.name\n                        }\\` ${this.buildCreateColumnSql(\n                            nonGeneratedColumn,\n                            true,\n                        )}`,\n                    ),\n                )\n            }\n        }\n\n        // create column index\n        const columnIndex = clonedTable.indices.find(\n            (index) =>\n                index.columnNames.length === 1 &&\n                index.columnNames[0] === column.name,\n        )\n        if (columnIndex) {\n            upQueries.push(this.createIndexSql(table, columnIndex))\n            downQueries.push(this.dropIndexSql(table, columnIndex))\n        } else if (column.isUnique) {\n            const uniqueIndex = new TableIndex({\n                name: this.connection.namingStrategy.indexName(table, [\n                    column.name,\n                ]),\n                columnNames: [column.name],\n                isUnique: true,\n            })\n            clonedTable.indices.push(uniqueIndex)\n            clonedTable.uniques.push(\n                new TableUnique({\n                    name: uniqueIndex.name,\n                    columnNames: uniqueIndex.columnNames,\n                }),\n            )\n            upQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(table)} ADD UNIQUE INDEX \\`${\n                        uniqueIndex.name\n                    }\\` (\\`${column.name}\\`)`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(table)} DROP INDEX \\`${\n                        uniqueIndex.name\n                    }\\``,\n                ),\n            )\n        }\n\n        await this.executeQueries(upQueries, downQueries)\n\n        clonedTable.addColumn(column)\n        this.replaceCachedTable(table, clonedTable)\n    }\n\n    /**\n     * Creates a new columns from the column in the table.\n     */\n    async addColumns(\n        tableOrName: Table | string,\n        columns: TableColumn[],\n    ): Promise<void> {\n        for (const column of columns) {\n            await this.addColumn(tableOrName, column)\n        }\n    }\n\n    /**\n     * Renames column in the given table.\n     */\n    async renameColumn(\n        tableOrName: Table | string,\n        oldTableColumnOrName: TableColumn | string,\n        newTableColumnOrName: TableColumn | string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const oldColumn = InstanceChecker.isTableColumn(oldTableColumnOrName)\n            ? oldTableColumnOrName\n            : table.columns.find((c) => c.name === oldTableColumnOrName)\n        if (!oldColumn)\n            throw new TypeORMError(\n                `Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`,\n            )\n\n        let newColumn: TableColumn | undefined = undefined\n        if (InstanceChecker.isTableColumn(newTableColumnOrName)) {\n            newColumn = newTableColumnOrName\n        } else {\n            newColumn = oldColumn.clone()\n            newColumn.name = newTableColumnOrName\n        }\n\n        await this.changeColumn(table, oldColumn, newColumn)\n    }\n\n    /**\n     * Changes a column in the table.\n     */\n    async changeColumn(\n        tableOrName: Table | string,\n        oldColumnOrName: TableColumn | string,\n        newColumn: TableColumn,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        let clonedTable = table.clone()\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        const oldColumn = InstanceChecker.isTableColumn(oldColumnOrName)\n            ? oldColumnOrName\n            : table.columns.find((column) => column.name === oldColumnOrName)\n        if (!oldColumn)\n            throw new TypeORMError(\n                `Column \"${oldColumnOrName}\" was not found in the \"${table.name}\" table.`,\n            )\n\n        if (\n            (newColumn.isGenerated !== oldColumn.isGenerated &&\n                newColumn.generationStrategy !== \"uuid\") ||\n            oldColumn.type !== newColumn.type ||\n            oldColumn.length !== newColumn.length ||\n            oldColumn.generatedType !== newColumn.generatedType\n        ) {\n            await this.dropColumn(table, oldColumn)\n            await this.addColumn(table, newColumn)\n\n            // update cloned table\n            clonedTable = table.clone()\n        } else {\n            if (newColumn.name !== oldColumn.name) {\n                // We don't change any column properties, just rename it.\n                upQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(table)} CHANGE \\`${\n                            oldColumn.name\n                        }\\` \\`${newColumn.name}\\` ${this.buildCreateColumnSql(\n                            oldColumn,\n                            true,\n                            true,\n                        )}`,\n                    ),\n                )\n                downQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(table)} CHANGE \\`${\n                            newColumn.name\n                        }\\` \\`${oldColumn.name}\\` ${this.buildCreateColumnSql(\n                            oldColumn,\n                            true,\n                            true,\n                        )}`,\n                    ),\n                )\n\n                // rename index constraints\n                clonedTable.findColumnIndices(oldColumn).forEach((index) => {\n                    // build new constraint name\n                    index.columnNames.splice(\n                        index.columnNames.indexOf(oldColumn.name),\n                        1,\n                    )\n                    index.columnNames.push(newColumn.name)\n                    const columnNames = index.columnNames\n                        .map((column) => `\\`${column}\\``)\n                        .join(\", \")\n                    const newIndexName =\n                        this.connection.namingStrategy.indexName(\n                            clonedTable,\n                            index.columnNames,\n                            index.where,\n                        )\n\n                    // build queries\n                    let indexType = \"\"\n                    if (index.isUnique) indexType += \"UNIQUE \"\n                    if (index.isSpatial) indexType += \"SPATIAL \"\n                    if (index.isFulltext) indexType += \"FULLTEXT \"\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} DROP INDEX \\`${\n                                index.name\n                            }\\`, ADD ${indexType}INDEX \\`${newIndexName}\\` (${columnNames})`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} DROP INDEX \\`${newIndexName}\\`, ADD ${indexType}INDEX \\`${\n                                index.name\n                            }\\` (${columnNames})`,\n                        ),\n                    )\n\n                    // replace constraint name\n                    index.name = newIndexName\n                })\n\n                // rename foreign key constraints\n                clonedTable\n                    .findColumnForeignKeys(oldColumn)\n                    .forEach((foreignKey) => {\n                        // build new constraint name\n                        foreignKey.columnNames.splice(\n                            foreignKey.columnNames.indexOf(oldColumn.name),\n                            1,\n                        )\n                        foreignKey.columnNames.push(newColumn.name)\n                        const columnNames = foreignKey.columnNames\n                            .map((column) => `\\`${column}\\``)\n                            .join(\", \")\n                        const referencedColumnNames =\n                            foreignKey.referencedColumnNames\n                                .map((column) => `\\`${column}\\``)\n                                .join(\",\")\n                        const newForeignKeyName =\n                            this.connection.namingStrategy.foreignKeyName(\n                                clonedTable,\n                                foreignKey.columnNames,\n                            )\n\n                        // build queries\n                        let up =\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} DROP FOREIGN KEY \\`${\n                                foreignKey.name\n                            }\\`, ADD CONSTRAINT \\`${newForeignKeyName}\\` FOREIGN KEY (${columnNames}) ` +\n                            `REFERENCES ${this.escapePath(\n                                this.getTablePath(foreignKey),\n                            )}(${referencedColumnNames})`\n                        if (foreignKey.onDelete)\n                            up += ` ON DELETE ${foreignKey.onDelete}`\n                        if (foreignKey.onUpdate)\n                            up += ` ON UPDATE ${foreignKey.onUpdate}`\n\n                        let down =\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} DROP FOREIGN KEY \\`${newForeignKeyName}\\`, ADD CONSTRAINT \\`${\n                                foreignKey.name\n                            }\\` FOREIGN KEY (${columnNames}) ` +\n                            `REFERENCES ${this.escapePath(\n                                this.getTablePath(foreignKey),\n                            )}(${referencedColumnNames})`\n                        if (foreignKey.onDelete)\n                            down += ` ON DELETE ${foreignKey.onDelete}`\n                        if (foreignKey.onUpdate)\n                            down += ` ON UPDATE ${foreignKey.onUpdate}`\n\n                        upQueries.push(new Query(up))\n                        downQueries.push(new Query(down))\n\n                        // replace constraint name\n                        foreignKey.name = newForeignKeyName\n                    })\n\n                // rename old column in the Table object\n                const oldTableColumn = clonedTable.columns.find(\n                    (column) => column.name === oldColumn.name,\n                )\n                clonedTable.columns[\n                    clonedTable.columns.indexOf(oldTableColumn!)\n                ].name = newColumn.name\n                oldColumn.name = newColumn.name\n            }\n\n            if (this.isColumnChanged(oldColumn, newColumn, true)) {\n                upQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(table)} CHANGE \\`${\n                            oldColumn.name\n                        }\\` ${this.buildCreateColumnSql(newColumn, true)}`,\n                    ),\n                )\n                downQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(table)} CHANGE \\`${\n                            newColumn.name\n                        }\\` ${this.buildCreateColumnSql(oldColumn, true)}`,\n                    ),\n                )\n            }\n\n            if (newColumn.isPrimary !== oldColumn.isPrimary) {\n                // if table have generated column, we must drop AUTO_INCREMENT before changing primary constraints.\n                const generatedColumn = clonedTable.columns.find(\n                    (column) =>\n                        column.isGenerated &&\n                        column.generationStrategy === \"increment\",\n                )\n                if (generatedColumn) {\n                    const nonGeneratedColumn = generatedColumn.clone()\n                    nonGeneratedColumn.isGenerated = false\n                    nonGeneratedColumn.generationStrategy = undefined\n\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(table)} CHANGE \\`${\n                                generatedColumn.name\n                            }\\` ${this.buildCreateColumnSql(\n                                nonGeneratedColumn,\n                                true,\n                            )}`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(table)} CHANGE \\`${\n                                nonGeneratedColumn.name\n                            }\\` ${this.buildCreateColumnSql(\n                                generatedColumn,\n                                true,\n                            )}`,\n                        ),\n                    )\n                }\n\n                const primaryColumns = clonedTable.primaryColumns\n\n                // if primary column state changed, we must always drop existed constraint.\n                if (primaryColumns.length > 0) {\n                    const columnNames = primaryColumns\n                        .map((column) => `\\`${column.name}\\``)\n                        .join(\", \")\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} DROP PRIMARY KEY`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ADD PRIMARY KEY (${columnNames})`,\n                        ),\n                    )\n                }\n\n                if (newColumn.isPrimary === true) {\n                    primaryColumns.push(newColumn)\n                    // update column in table\n                    const column = clonedTable.columns.find(\n                        (column) => column.name === newColumn.name,\n                    )\n                    column!.isPrimary = true\n                    const columnNames = primaryColumns\n                        .map((column) => `\\`${column.name}\\``)\n                        .join(\", \")\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ADD PRIMARY KEY (${columnNames})`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} DROP PRIMARY KEY`,\n                        ),\n                    )\n                } else {\n                    const primaryColumn = primaryColumns.find(\n                        (c) => c.name === newColumn.name,\n                    )\n                    primaryColumns.splice(\n                        primaryColumns.indexOf(primaryColumn!),\n                        1,\n                    )\n                    // update column in table\n                    const column = clonedTable.columns.find(\n                        (column) => column.name === newColumn.name,\n                    )\n                    column!.isPrimary = false\n\n                    // if we have another primary keys, we must recreate constraint.\n                    if (primaryColumns.length > 0) {\n                        const columnNames = primaryColumns\n                            .map((column) => `\\`${column.name}\\``)\n                            .join(\", \")\n                        upQueries.push(\n                            new Query(\n                                `ALTER TABLE ${this.escapePath(\n                                    table,\n                                )} ADD PRIMARY KEY (${columnNames})`,\n                            ),\n                        )\n                        downQueries.push(\n                            new Query(\n                                `ALTER TABLE ${this.escapePath(\n                                    table,\n                                )} DROP PRIMARY KEY`,\n                            ),\n                        )\n                    }\n                }\n\n                // if we have generated column, and we dropped AUTO_INCREMENT property before, we must bring it back\n                if (generatedColumn) {\n                    const nonGeneratedColumn = generatedColumn.clone()\n                    nonGeneratedColumn.isGenerated = false\n                    nonGeneratedColumn.generationStrategy = undefined\n\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(table)} CHANGE \\`${\n                                nonGeneratedColumn.name\n                            }\\` ${this.buildCreateColumnSql(\n                                generatedColumn,\n                                true,\n                            )}`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(table)} CHANGE \\`${\n                                generatedColumn.name\n                            }\\` ${this.buildCreateColumnSql(\n                                nonGeneratedColumn,\n                                true,\n                            )}`,\n                        ),\n                    )\n                }\n            }\n\n            if (newColumn.isUnique !== oldColumn.isUnique) {\n                if (newColumn.isUnique === true) {\n                    const uniqueIndex = new TableIndex({\n                        name: this.connection.namingStrategy.indexName(table, [\n                            newColumn.name,\n                        ]),\n                        columnNames: [newColumn.name],\n                        isUnique: true,\n                    })\n                    clonedTable.indices.push(uniqueIndex)\n                    clonedTable.uniques.push(\n                        new TableUnique({\n                            name: uniqueIndex.name,\n                            columnNames: uniqueIndex.columnNames,\n                        }),\n                    )\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ADD UNIQUE INDEX \\`${uniqueIndex.name}\\` (\\`${\n                                newColumn.name\n                            }\\`)`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} DROP INDEX \\`${uniqueIndex.name}\\``,\n                        ),\n                    )\n                } else {\n                    const uniqueIndex = clonedTable.indices.find((index) => {\n                        return (\n                            index.columnNames.length === 1 &&\n                            index.isUnique === true &&\n                            !!index.columnNames.find(\n                                (columnName) => columnName === newColumn.name,\n                            )\n                        )\n                    })\n                    clonedTable.indices.splice(\n                        clonedTable.indices.indexOf(uniqueIndex!),\n                        1,\n                    )\n\n                    const tableUnique = clonedTable.uniques.find(\n                        (unique) => unique.name === uniqueIndex!.name,\n                    )\n                    clonedTable.uniques.splice(\n                        clonedTable.uniques.indexOf(tableUnique!),\n                        1,\n                    )\n\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} DROP INDEX \\`${uniqueIndex!.name}\\``,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ADD UNIQUE INDEX \\`${uniqueIndex!.name}\\` (\\`${\n                                newColumn.name\n                            }\\`)`,\n                        ),\n                    )\n                }\n            }\n        }\n\n        await this.executeQueries(upQueries, downQueries)\n        this.replaceCachedTable(table, clonedTable)\n    }\n\n    /**\n     * Changes a column in the table.\n     */\n    async changeColumns(\n        tableOrName: Table | string,\n        changedColumns: { newColumn: TableColumn; oldColumn: TableColumn }[],\n    ): Promise<void> {\n        for (const { oldColumn, newColumn } of changedColumns) {\n            await this.changeColumn(tableOrName, oldColumn, newColumn)\n        }\n    }\n\n    /**\n     * Drops column in the table.\n     */\n    async dropColumn(\n        tableOrName: Table | string,\n        columnOrName: TableColumn | string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const column = InstanceChecker.isTableColumn(columnOrName)\n            ? columnOrName\n            : table.findColumnByName(columnOrName)\n        if (!column)\n            throw new TypeORMError(\n                `Column \"${columnOrName}\" was not found in table \"${table.name}\"`,\n            )\n\n        const clonedTable = table.clone()\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        // drop primary key constraint\n        if (column.isPrimary) {\n            // if table have generated column, we must drop AUTO_INCREMENT before changing primary constraints.\n            const generatedColumn = clonedTable.columns.find(\n                (column) =>\n                    column.isGenerated &&\n                    column.generationStrategy === \"increment\",\n            )\n            if (generatedColumn) {\n                const nonGeneratedColumn = generatedColumn.clone()\n                nonGeneratedColumn.isGenerated = false\n                nonGeneratedColumn.generationStrategy = undefined\n\n                upQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(table)} CHANGE \\`${\n                            generatedColumn.name\n                        }\\` ${this.buildCreateColumnSql(\n                            nonGeneratedColumn,\n                            true,\n                        )}`,\n                    ),\n                )\n                downQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(table)} CHANGE \\`${\n                            nonGeneratedColumn.name\n                        }\\` ${this.buildCreateColumnSql(\n                            generatedColumn,\n                            true,\n                        )}`,\n                    ),\n                )\n            }\n\n            // dropping primary key constraint\n            const columnNames = clonedTable.primaryColumns\n                .map((primaryColumn) => `\\`${primaryColumn.name}\\``)\n                .join(\", \")\n            upQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        clonedTable,\n                    )} DROP PRIMARY KEY`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        clonedTable,\n                    )} ADD PRIMARY KEY (${columnNames})`,\n                ),\n            )\n\n            // update column in table\n            const tableColumn = clonedTable.findColumnByName(column.name)\n            tableColumn!.isPrimary = false\n\n            // if primary key have multiple columns, we must recreate it without dropped column\n            if (clonedTable.primaryColumns.length > 0) {\n                const columnNames = clonedTable.primaryColumns\n                    .map((primaryColumn) => `\\`${primaryColumn.name}\\``)\n                    .join(\", \")\n                upQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(\n                            clonedTable,\n                        )} ADD PRIMARY KEY (${columnNames})`,\n                    ),\n                )\n                downQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(\n                            clonedTable,\n                        )} DROP PRIMARY KEY`,\n                    ),\n                )\n            }\n\n            // if we have generated column, and we dropped AUTO_INCREMENT property before, and this column is not current dropping column, we must bring it back\n            if (generatedColumn && generatedColumn.name !== column.name) {\n                const nonGeneratedColumn = generatedColumn.clone()\n                nonGeneratedColumn.isGenerated = false\n                nonGeneratedColumn.generationStrategy = undefined\n\n                upQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(table)} CHANGE \\`${\n                            nonGeneratedColumn.name\n                        }\\` ${this.buildCreateColumnSql(\n                            generatedColumn,\n                            true,\n                        )}`,\n                    ),\n                )\n                downQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(table)} CHANGE \\`${\n                            generatedColumn.name\n                        }\\` ${this.buildCreateColumnSql(\n                            nonGeneratedColumn,\n                            true,\n                        )}`,\n                    ),\n                )\n            }\n        }\n\n        // drop column index\n        const columnIndex = clonedTable.indices.find(\n            (index) =>\n                index.columnNames.length === 1 &&\n                index.columnNames[0] === column.name,\n        )\n        if (columnIndex) {\n            clonedTable.indices.splice(\n                clonedTable.indices.indexOf(columnIndex),\n                1,\n            )\n            upQueries.push(this.dropIndexSql(table, columnIndex))\n            downQueries.push(this.createIndexSql(table, columnIndex))\n        } else if (column.isUnique) {\n            // we splice constraints both from table uniques and indices.\n            const uniqueName =\n                this.connection.namingStrategy.uniqueConstraintName(table, [\n                    column.name,\n                ])\n            const foundUnique = clonedTable.uniques.find(\n                (unique) => unique.name === uniqueName,\n            )\n            if (foundUnique)\n                clonedTable.uniques.splice(\n                    clonedTable.uniques.indexOf(foundUnique),\n                    1,\n                )\n\n            const indexName = this.connection.namingStrategy.indexName(table, [\n                column.name,\n            ])\n            const foundIndex = clonedTable.indices.find(\n                (index) => index.name === indexName,\n            )\n            if (foundIndex)\n                clonedTable.indices.splice(\n                    clonedTable.indices.indexOf(foundIndex),\n                    1,\n                )\n\n            upQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        table,\n                    )} DROP INDEX \\`${indexName}\\``,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        table,\n                    )} ADD UNIQUE INDEX \\`${indexName}\\` (\\`${column.name}\\`)`,\n                ),\n            )\n        }\n\n        upQueries.push(\n            new Query(\n                `ALTER TABLE ${this.escapePath(table)} DROP COLUMN \\`${\n                    column.name\n                }\\``,\n            ),\n        )\n        downQueries.push(\n            new Query(\n                `ALTER TABLE ${this.escapePath(\n                    table,\n                )} ADD ${this.buildCreateColumnSql(column, true)}`,\n            ),\n        )\n\n        await this.executeQueries(upQueries, downQueries)\n\n        clonedTable.removeColumn(column)\n        this.replaceCachedTable(table, clonedTable)\n    }\n\n    /**\n     * Drops the columns in the table.\n     */\n    async dropColumns(\n        tableOrName: Table | string,\n        columns: TableColumn[] | string[],\n    ): Promise<void> {\n        for (const column of columns) {\n            await this.dropColumn(tableOrName, column)\n        }\n    }\n\n    /**\n     * Creates a new primary key.\n     */\n    async createPrimaryKey(\n        tableOrName: Table | string,\n        columnNames: string[],\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const clonedTable = table.clone()\n\n        const up = this.createPrimaryKeySql(table, columnNames)\n        const down = this.dropPrimaryKeySql(table)\n\n        await this.executeQueries(up, down)\n        clonedTable.columns.forEach((column) => {\n            if (columnNames.find((columnName) => columnName === column.name))\n                column.isPrimary = true\n        })\n        this.replaceCachedTable(table, clonedTable)\n    }\n\n    /**\n     * Updates composite primary keys.\n     */\n    async updatePrimaryKeys(\n        tableOrName: Table | string,\n        columns: TableColumn[],\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const clonedTable = table.clone()\n        const columnNames = columns.map((column) => column.name)\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        // if table have generated column, we must drop AUTO_INCREMENT before changing primary constraints.\n        const generatedColumn = clonedTable.columns.find(\n            (column) =>\n                column.isGenerated && column.generationStrategy === \"increment\",\n        )\n        if (generatedColumn) {\n            const nonGeneratedColumn = generatedColumn.clone()\n            nonGeneratedColumn.isGenerated = false\n            nonGeneratedColumn.generationStrategy = undefined\n\n            upQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(table)} CHANGE \\`${\n                        generatedColumn.name\n                    }\\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(table)} CHANGE \\`${\n                        nonGeneratedColumn.name\n                    }\\` ${this.buildCreateColumnSql(generatedColumn, true)}`,\n                ),\n            )\n        }\n\n        // if table already have primary columns, we must drop them.\n        const primaryColumns = clonedTable.primaryColumns\n        if (primaryColumns.length > 0) {\n            const columnNames = primaryColumns\n                .map((column) => `\\`${column.name}\\``)\n                .join(\", \")\n            upQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        table,\n                    )} ADD PRIMARY KEY (${columnNames})`,\n                ),\n            )\n        }\n\n        // update columns in table.\n        clonedTable.columns\n            .filter((column) => columnNames.indexOf(column.name) !== -1)\n            .forEach((column) => (column.isPrimary = true))\n\n        const columnNamesString = columnNames\n            .map((columnName) => `\\`${columnName}\\``)\n            .join(\", \")\n        upQueries.push(\n            new Query(\n                `ALTER TABLE ${this.escapePath(\n                    table,\n                )} ADD PRIMARY KEY (${columnNamesString})`,\n            ),\n        )\n        downQueries.push(\n            new Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`),\n        )\n\n        // if we already have generated column or column is changed to generated, and we dropped AUTO_INCREMENT property before, we must bring it back\n        const newOrExistGeneratedColumn = generatedColumn\n            ? generatedColumn\n            : columns.find(\n                  (column) =>\n                      column.isGenerated &&\n                      column.generationStrategy === \"increment\",\n              )\n        if (newOrExistGeneratedColumn) {\n            const nonGeneratedColumn = newOrExistGeneratedColumn.clone()\n            nonGeneratedColumn.isGenerated = false\n            nonGeneratedColumn.generationStrategy = undefined\n\n            upQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(table)} CHANGE \\`${\n                        nonGeneratedColumn.name\n                    }\\` ${this.buildCreateColumnSql(\n                        newOrExistGeneratedColumn,\n                        true,\n                    )}`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(table)} CHANGE \\`${\n                        newOrExistGeneratedColumn.name\n                    }\\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`,\n                ),\n            )\n\n            // if column changed to generated, we must update it in table\n            const changedGeneratedColumn = clonedTable.columns.find(\n                (column) => column.name === newOrExistGeneratedColumn.name,\n            )\n            changedGeneratedColumn!.isGenerated = true\n            changedGeneratedColumn!.generationStrategy = \"increment\"\n        }\n\n        await this.executeQueries(upQueries, downQueries)\n        this.replaceCachedTable(table, clonedTable)\n    }\n\n    /**\n     * Drops a primary key.\n     */\n    async dropPrimaryKey(tableOrName: Table | string): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const up = this.dropPrimaryKeySql(table)\n        const down = this.createPrimaryKeySql(\n            table,\n            table.primaryColumns.map((column) => column.name),\n        )\n        await this.executeQueries(up, down)\n        table.primaryColumns.forEach((column) => {\n            column.isPrimary = false\n        })\n    }\n\n    /**\n     * Creates a new unique constraint.\n     */\n    async createUniqueConstraint(\n        tableOrName: Table | string,\n        uniqueConstraint: TableUnique,\n    ): Promise<void> {\n        throw new TypeORMError(\n            `MySql does not support unique constraints. Use unique index instead.`,\n        )\n    }\n\n    /**\n     * Creates a new unique constraints.\n     */\n    async createUniqueConstraints(\n        tableOrName: Table | string,\n        uniqueConstraints: TableUnique[],\n    ): Promise<void> {\n        throw new TypeORMError(\n            `MySql does not support unique constraints. Use unique index instead.`,\n        )\n    }\n\n    /**\n     * Drops an unique constraint.\n     */\n    async dropUniqueConstraint(\n        tableOrName: Table | string,\n        uniqueOrName: TableUnique | string,\n    ): Promise<void> {\n        throw new TypeORMError(\n            `MySql does not support unique constraints. Use unique index instead.`,\n        )\n    }\n\n    /**\n     * Drops an unique constraints.\n     */\n    async dropUniqueConstraints(\n        tableOrName: Table | string,\n        uniqueConstraints: TableUnique[],\n    ): Promise<void> {\n        throw new TypeORMError(\n            `MySql does not support unique constraints. Use unique index instead.`,\n        )\n    }\n\n    /**\n     * Creates a new check constraint.\n     */\n    async createCheckConstraint(\n        tableOrName: Table | string,\n        checkConstraint: TableCheck,\n    ): Promise<void> {\n        throw new TypeORMError(`MySql does not support check constraints.`)\n    }\n\n    /**\n     * Creates a new check constraints.\n     */\n    async createCheckConstraints(\n        tableOrName: Table | string,\n        checkConstraints: TableCheck[],\n    ): Promise<void> {\n        throw new TypeORMError(`MySql does not support check constraints.`)\n    }\n\n    /**\n     * Drops check constraint.\n     */\n    async dropCheckConstraint(\n        tableOrName: Table | string,\n        checkOrName: TableCheck | string,\n    ): Promise<void> {\n        throw new TypeORMError(`MySql does not support check constraints.`)\n    }\n\n    /**\n     * Drops check constraints.\n     */\n    async dropCheckConstraints(\n        tableOrName: Table | string,\n        checkConstraints: TableCheck[],\n    ): Promise<void> {\n        throw new TypeORMError(`MySql does not support check constraints.`)\n    }\n\n    /**\n     * Creates a new exclusion constraint.\n     */\n    async createExclusionConstraint(\n        tableOrName: Table | string,\n        exclusionConstraint: TableExclusion,\n    ): Promise<void> {\n        throw new TypeORMError(`MySql does not support exclusion constraints.`)\n    }\n\n    /**\n     * Creates a new exclusion constraints.\n     */\n    async createExclusionConstraints(\n        tableOrName: Table | string,\n        exclusionConstraints: TableExclusion[],\n    ): Promise<void> {\n        throw new TypeORMError(`MySql does not support exclusion constraints.`)\n    }\n\n    /**\n     * Drops exclusion constraint.\n     */\n    async dropExclusionConstraint(\n        tableOrName: Table | string,\n        exclusionOrName: TableExclusion | string,\n    ): Promise<void> {\n        throw new TypeORMError(`MySql does not support exclusion constraints.`)\n    }\n\n    /**\n     * Drops exclusion constraints.\n     */\n    async dropExclusionConstraints(\n        tableOrName: Table | string,\n        exclusionConstraints: TableExclusion[],\n    ): Promise<void> {\n        throw new TypeORMError(`MySql does not support exclusion constraints.`)\n    }\n\n    /**\n     * Creates a new foreign key.\n     */\n    async createForeignKey(\n        tableOrName: Table | string,\n        foreignKey: TableForeignKey,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n\n        // new FK may be passed without name. In this case we generate FK name manually.\n        if (!foreignKey.name)\n            foreignKey.name = this.connection.namingStrategy.foreignKeyName(\n                table,\n                foreignKey.columnNames,\n            )\n\n        const up = this.createForeignKeySql(table, foreignKey)\n        const down = this.dropForeignKeySql(table, foreignKey)\n        await this.executeQueries(up, down)\n        table.addForeignKey(foreignKey)\n    }\n\n    /**\n     * Creates a new foreign keys.\n     */\n    async createForeignKeys(\n        tableOrName: Table | string,\n        foreignKeys: TableForeignKey[],\n    ): Promise<void> {\n        const promises = foreignKeys.map((foreignKey) =>\n            this.createForeignKey(tableOrName, foreignKey),\n        )\n        await Promise.all(promises)\n    }\n\n    /**\n     * Drops a foreign key.\n     */\n    async dropForeignKey(\n        tableOrName: Table | string,\n        foreignKeyOrName: TableForeignKey | string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const foreignKey = InstanceChecker.isTableForeignKey(foreignKeyOrName)\n            ? foreignKeyOrName\n            : table.foreignKeys.find((fk) => fk.name === foreignKeyOrName)\n        if (!foreignKey)\n            throw new TypeORMError(\n                `Supplied foreign key was not found in table ${table.name}`,\n            )\n\n        const up = this.dropForeignKeySql(table, foreignKey)\n        const down = this.createForeignKeySql(table, foreignKey)\n        await this.executeQueries(up, down)\n        table.removeForeignKey(foreignKey)\n    }\n\n    /**\n     * Drops a foreign keys from the table.\n     */\n    async dropForeignKeys(\n        tableOrName: Table | string,\n        foreignKeys: TableForeignKey[],\n    ): Promise<void> {\n        const promises = foreignKeys.map((foreignKey) =>\n            this.dropForeignKey(tableOrName, foreignKey),\n        )\n        await Promise.all(promises)\n    }\n\n    /**\n     * Creates a new index.\n     */\n    async createIndex(\n        tableOrName: Table | string,\n        index: TableIndex,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n\n        // new index may be passed without name. In this case we generate index name manually.\n        if (!index.name) index.name = this.generateIndexName(table, index)\n\n        const up = this.createIndexSql(table, index)\n        const down = this.dropIndexSql(table, index)\n        await this.executeQueries(up, down)\n        table.addIndex(index, true)\n    }\n\n    /**\n     * Creates a new indices\n     */\n    async createIndices(\n        tableOrName: Table | string,\n        indices: TableIndex[],\n    ): Promise<void> {\n        const promises = indices.map((index) =>\n            this.createIndex(tableOrName, index),\n        )\n        await Promise.all(promises)\n    }\n\n    /**\n     * Drops an index.\n     */\n    async dropIndex(\n        tableOrName: Table | string,\n        indexOrName: TableIndex | string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const index = InstanceChecker.isTableIndex(indexOrName)\n            ? indexOrName\n            : table.indices.find((i) => i.name === indexOrName)\n        if (!index)\n            throw new TypeORMError(\n                `Supplied index ${indexOrName} was not found in table ${table.name}`,\n            )\n\n        // old index may be passed without name. In this case we generate index name manually.\n        if (!index.name) index.name = this.generateIndexName(table, index)\n\n        const up = this.dropIndexSql(table, index)\n        const down = this.createIndexSql(table, index)\n        await this.executeQueries(up, down)\n        table.removeIndex(index, true)\n    }\n\n    /**\n     * Drops an indices from the table.\n     */\n    async dropIndices(\n        tableOrName: Table | string,\n        indices: TableIndex[],\n    ): Promise<void> {\n        const promises = indices.map((index) =>\n            this.dropIndex(tableOrName, index),\n        )\n        await Promise.all(promises)\n    }\n\n    /**\n     * Clears all table contents.\n     * Note: this operation uses SQL's TRUNCATE query which cannot be reverted in transactions.\n     */\n    async clearTable(tableOrName: Table | string): Promise<void> {\n        await this.query(`TRUNCATE TABLE ${this.escapePath(tableOrName)}`)\n    }\n\n    /**\n     * Removes all tables from the currently connected database.\n     * Be careful using this method and avoid using it in production or migrations\n     * (because it can clear all your database).\n     */\n    async clearDatabase(database?: string): Promise<void> {\n        const dbName = database ? database : this.driver.database\n        if (dbName) {\n            const isDatabaseExist = await this.hasDatabase(dbName)\n            if (!isDatabaseExist) return Promise.resolve()\n        } else {\n            throw new TypeORMError(\n                `Can not clear database. No database is specified`,\n            )\n        }\n\n        const isAnotherTransactionActive = this.isTransactionActive\n        if (!isAnotherTransactionActive) await this.startTransaction()\n        try {\n            const selectViewDropsQuery = `SELECT concat('DROP VIEW IF EXISTS \\`', table_schema, '\\`.\\`', table_name, '\\`') AS \\`query\\` FROM \\`INFORMATION_SCHEMA\\`.\\`VIEWS\\` WHERE \\`TABLE_SCHEMA\\` = '${dbName}'`\n            const dropViewQueries: ObjectLiteral[] = await this.query(\n                selectViewDropsQuery,\n            )\n            await Promise.all(\n                dropViewQueries.map((q) => this.query(q[\"query\"])),\n            )\n\n            const disableForeignKeysCheckQuery = `SET FOREIGN_KEY_CHECKS = 0;`\n            const dropTablesQuery = `SELECT concat('DROP TABLE IF EXISTS \\`', table_schema, '\\`.\\`', table_name, '\\`') AS \\`query\\` FROM \\`INFORMATION_SCHEMA\\`.\\`TABLES\\` WHERE \\`TABLE_SCHEMA\\` = '${dbName}'`\n            const enableForeignKeysCheckQuery = `SET FOREIGN_KEY_CHECKS = 1;`\n\n            await this.query(disableForeignKeysCheckQuery)\n            const dropQueries: ObjectLiteral[] = await this.query(\n                dropTablesQuery,\n            )\n            await Promise.all(\n                dropQueries.map((query) => this.query(query[\"query\"])),\n            )\n            await this.query(enableForeignKeysCheckQuery)\n\n            if (!isAnotherTransactionActive) {\n                await this.commitTransaction()\n            }\n        } catch (error) {\n            try {\n                // we throw original error even if rollback thrown an error\n                if (!isAnotherTransactionActive) {\n                    await this.rollbackTransaction()\n                }\n            } catch (rollbackError) {}\n            throw error\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    protected async loadViews(viewNames?: string[]): Promise<View[]> {\n        const hasTable = await this.hasTable(this.getTypeormMetadataTableName())\n        if (!hasTable) {\n            return []\n        }\n\n        if (!viewNames) {\n            viewNames = []\n        }\n\n        const currentDatabase = await this.getCurrentDatabase()\n        const viewsCondition = viewNames\n            .map((tableName) => {\n                let { database, tableName: name } =\n                    this.driver.parseTableName(tableName)\n\n                if (!database) {\n                    database = currentDatabase\n                }\n\n                return `(\\`t\\`.\\`schema\\` = '${database}' AND \\`t\\`.\\`name\\` = '${name}')`\n            })\n            .join(\" OR \")\n\n        const query =\n            `SELECT \\`t\\`.*, \\`v\\`.\\`check_option\\` FROM ${this.escapePath(\n                this.getTypeormMetadataTableName(),\n            )} \\`t\\` ` +\n            `INNER JOIN \\`information_schema\\`.\\`views\\` \\`v\\` ON \\`v\\`.\\`table_schema\\` = \\`t\\`.\\`schema\\` AND \\`v\\`.\\`table_name\\` = \\`t\\`.\\`name\\` WHERE \\`t\\`.\\`type\\` = '${\n                MetadataTableType.VIEW\n            }' ${viewsCondition ? `AND (${viewsCondition})` : \"\"}`\n        const dbViews = await this.query(query)\n        return dbViews.map((dbView: any) => {\n            const view = new View()\n            const db =\n                dbView[\"schema\"] === currentDatabase\n                    ? undefined\n                    : dbView[\"schema\"]\n            view.database = dbView[\"schema\"]\n            view.name = this.driver.buildTableName(\n                dbView[\"name\"],\n                undefined,\n                db,\n            )\n            view.expression = dbView[\"value\"]\n            return view\n        })\n    }\n\n    /**\n     * Loads all tables (with given names) from the database and creates a Table from them.\n     */\n    protected async loadTables(tableNames?: string[]): Promise<Table[]> {\n        // if no tables given then no need to proceed\n        if (tableNames && tableNames.length === 0) {\n            return []\n        }\n\n        const dbTables: { TABLE_NAME: string; TABLE_SCHEMA: string }[] = []\n\n        const currentDatabase = await this.getCurrentDatabase()\n\n        if (!tableNames) {\n            const tablesSql = `SELECT TABLE_NAME, TABLE_SCHEMA FROM \\`INFORMATION_SCHEMA\\`.\\`TABLES\\``\n\n            dbTables.push(...(await this.query(tablesSql)))\n        } else {\n            const tablesCondition = tableNames\n                .map((tableName) => {\n                    let [database, name] = tableName.split(\".\")\n                    if (!name) {\n                        name = database\n                        database = this.driver.database || currentDatabase\n                    }\n                    return `(\\`TABLE_SCHEMA\\` = '${database}' AND \\`TABLE_NAME\\` = '${name}')`\n                })\n                .join(\" OR \")\n            const tablesSql =\n                `SELECT TABLE_NAME, TABLE_SCHEMA FROM \\`INFORMATION_SCHEMA\\`.\\`TABLES\\` WHERE ` +\n                tablesCondition\n\n            dbTables.push(...(await this.query(tablesSql)))\n        }\n\n        if (dbTables.length === 0) {\n            return []\n        }\n\n        const columnsCondition = dbTables\n            .map(({ TABLE_NAME, TABLE_SCHEMA }) => {\n                return `(\\`TABLE_SCHEMA\\` = '${TABLE_SCHEMA}' AND \\`TABLE_NAME\\` = '${TABLE_NAME}')`\n            })\n            .join(\" OR \")\n        const columnsSql =\n            `SELECT * FROM \\`INFORMATION_SCHEMA\\`.\\`COLUMNS\\` WHERE ` +\n            columnsCondition\n\n        const primaryKeySql = `SELECT * FROM \\`INFORMATION_SCHEMA\\`.\\`KEY_COLUMN_USAGE\\` WHERE \\`CONSTRAINT_NAME\\` = 'PRIMARY' AND (${columnsCondition})`\n\n        const collationsSql = `SELECT \\`SCHEMA_NAME\\`, \\`DEFAULT_CHARACTER_SET_NAME\\` as \\`CHARSET\\`, \\`DEFAULT_COLLATION_NAME\\` AS \\`COLLATION\\` FROM \\`INFORMATION_SCHEMA\\`.\\`SCHEMATA\\``\n\n        const indicesCondition = dbTables\n            .map(({ TABLE_NAME, TABLE_SCHEMA }) => {\n                return `(\\`s\\`.\\`TABLE_SCHEMA\\` = '${TABLE_SCHEMA}' AND \\`s\\`.\\`TABLE_NAME\\` = '${TABLE_NAME}')`\n            })\n            .join(\" OR \")\n        const indicesSql =\n            `SELECT \\`s\\`.* FROM \\`INFORMATION_SCHEMA\\`.\\`STATISTICS\\` \\`s\\` ` +\n            `LEFT JOIN \\`INFORMATION_SCHEMA\\`.\\`REFERENTIAL_CONSTRAINTS\\` \\`rc\\` ON \\`s\\`.\\`INDEX_NAME\\` = \\`rc\\`.\\`CONSTRAINT_NAME\\` ` +\n            `WHERE (${indicesCondition}) AND \\`s\\`.\\`INDEX_NAME\\` != 'PRIMARY' AND \\`rc\\`.\\`CONSTRAINT_NAME\\` IS NULL`\n\n        const foreignKeysCondition = dbTables\n            .map(({ TABLE_NAME, TABLE_SCHEMA }) => {\n                return `(\\`kcu\\`.\\`TABLE_SCHEMA\\` = '${TABLE_SCHEMA}' AND \\`kcu\\`.\\`TABLE_NAME\\` = '${TABLE_NAME}')`\n            })\n            .join(\" OR \")\n        const foreignKeysSql =\n            `SELECT \\`kcu\\`.\\`TABLE_SCHEMA\\`, \\`kcu\\`.\\`TABLE_NAME\\`, \\`kcu\\`.\\`CONSTRAINT_NAME\\`, \\`kcu\\`.\\`COLUMN_NAME\\`, \\`kcu\\`.\\`REFERENCED_TABLE_SCHEMA\\`, ` +\n            `\\`kcu\\`.\\`REFERENCED_TABLE_NAME\\`, \\`kcu\\`.\\`REFERENCED_COLUMN_NAME\\`, \\`rc\\`.\\`DELETE_RULE\\` \\`ON_DELETE\\`, \\`rc\\`.\\`UPDATE_RULE\\` \\`ON_UPDATE\\` ` +\n            `FROM \\`INFORMATION_SCHEMA\\`.\\`KEY_COLUMN_USAGE\\` \\`kcu\\` ` +\n            `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`REFERENTIAL_CONSTRAINTS\\` \\`rc\\` ON \\`rc\\`.\\`constraint_name\\` = \\`kcu\\`.\\`constraint_name\\` ` +\n            `WHERE ` +\n            foreignKeysCondition\n        const [\n            dbColumns,\n            dbPrimaryKeys,\n            dbCollations,\n            dbIndices,\n            dbForeignKeys,\n        ]: ObjectLiteral[][] = await Promise.all([\n            this.query(columnsSql),\n            this.query(primaryKeySql),\n            this.query(collationsSql),\n            this.query(indicesSql),\n            this.query(foreignKeysSql),\n        ])\n\n        // create tables for loaded tables\n        return Promise.all(\n            dbTables.map(async (dbTable) => {\n                const table = new Table()\n\n                const dbCollation = dbCollations.find(\n                    (coll) => coll[\"SCHEMA_NAME\"] === dbTable[\"TABLE_SCHEMA\"],\n                )!\n                const defaultCollation = dbCollation[\"COLLATION\"]\n                const defaultCharset = dbCollation[\"CHARSET\"]\n\n                // We do not need to join database name, when database is by default.\n                const db =\n                    dbTable[\"TABLE_SCHEMA\"] === currentDatabase\n                        ? undefined\n                        : dbTable[\"TABLE_SCHEMA\"]\n                table.database = dbTable[\"TABLE_SCHEMA\"]\n                table.name = this.driver.buildTableName(\n                    dbTable[\"TABLE_NAME\"],\n                    undefined,\n                    db,\n                )\n\n                // create columns from the loaded columns\n                table.columns = dbColumns\n                    .filter(\n                        (dbColumn) =>\n                            dbColumn[\"TABLE_NAME\"] === dbTable[\"TABLE_NAME\"] &&\n                            dbColumn[\"TABLE_SCHEMA\"] ===\n                                dbTable[\"TABLE_SCHEMA\"],\n                    )\n                    .map((dbColumn) => {\n                        const columnUniqueIndices = dbIndices.filter(\n                            (dbIndex) => {\n                                return (\n                                    dbIndex[\"TABLE_NAME\"] ===\n                                        dbTable[\"TABLE_NAME\"] &&\n                                    dbIndex[\"TABLE_SCHEMA\"] ===\n                                        dbTable[\"TABLE_SCHEMA\"] &&\n                                    dbIndex[\"COLUMN_NAME\"] ===\n                                        dbColumn[\"COLUMN_NAME\"] &&\n                                    parseInt(dbIndex[\"NON_UNIQUE\"], 10) === 0\n                                )\n                            },\n                        )\n\n                        const tableMetadata =\n                            this.connection.entityMetadatas.find(\n                                (metadata) =>\n                                    this.getTablePath(table) ===\n                                    this.getTablePath(metadata),\n                            )\n                        const hasIgnoredIndex =\n                            columnUniqueIndices.length > 0 &&\n                            tableMetadata &&\n                            tableMetadata.indices.some((index) => {\n                                return columnUniqueIndices.some(\n                                    (uniqueIndex) => {\n                                        return (\n                                            index.name ===\n                                                uniqueIndex[\"INDEX_NAME\"] &&\n                                            index.synchronize === false\n                                        )\n                                    },\n                                )\n                            })\n\n                        const isConstraintComposite = columnUniqueIndices.every(\n                            (uniqueIndex) => {\n                                return dbIndices.some(\n                                    (dbIndex) =>\n                                        dbIndex[\"INDEX_NAME\"] ===\n                                            uniqueIndex[\"INDEX_NAME\"] &&\n                                        dbIndex[\"COLUMN_NAME\"] !==\n                                            dbColumn[\"COLUMN_NAME\"],\n                                )\n                            },\n                        )\n\n                        const tableColumn = new TableColumn()\n                        tableColumn.name = dbColumn[\"COLUMN_NAME\"]\n                        tableColumn.type = dbColumn[\"DATA_TYPE\"].toLowerCase()\n\n                        if (\n                            this.driver.withWidthColumnTypes.indexOf(\n                                tableColumn.type as ColumnType,\n                            ) !== -1\n                        ) {\n                            const width = dbColumn[\"COLUMN_TYPE\"].substring(\n                                dbColumn[\"COLUMN_TYPE\"].indexOf(\"(\") + 1,\n                                dbColumn[\"COLUMN_TYPE\"].indexOf(\")\"),\n                            )\n                            tableColumn.width =\n                                width &&\n                                !this.isDefaultColumnWidth(\n                                    table,\n                                    tableColumn,\n                                    parseInt(width),\n                                )\n                                    ? parseInt(width)\n                                    : undefined\n                        }\n\n                        if (\n                            dbColumn[\"COLUMN_DEFAULT\"] === null ||\n                            dbColumn[\"COLUMN_DEFAULT\"] === undefined\n                        ) {\n                            tableColumn.default = undefined\n                        } else {\n                            tableColumn.default =\n                                dbColumn[\"COLUMN_DEFAULT\"] ===\n                                \"CURRENT_TIMESTAMP\"\n                                    ? dbColumn[\"COLUMN_DEFAULT\"]\n                                    : `'${dbColumn[\"COLUMN_DEFAULT\"]}'`\n                        }\n\n                        if (dbColumn[\"EXTRA\"].indexOf(\"on update\") !== -1) {\n                            tableColumn.onUpdate = dbColumn[\"EXTRA\"].substring(\n                                dbColumn[\"EXTRA\"].indexOf(\"on update\") + 10,\n                            )\n                        }\n\n                        if (dbColumn[\"GENERATION_EXPRESSION\"]) {\n                            tableColumn.asExpression =\n                                dbColumn[\"GENERATION_EXPRESSION\"]\n                            tableColumn.generatedType =\n                                dbColumn[\"EXTRA\"].indexOf(\"VIRTUAL\") !== -1\n                                    ? \"VIRTUAL\"\n                                    : \"STORED\"\n                        }\n\n                        tableColumn.isUnique =\n                            columnUniqueIndices.length > 0 &&\n                            !hasIgnoredIndex &&\n                            !isConstraintComposite\n                        tableColumn.isNullable =\n                            dbColumn[\"IS_NULLABLE\"] === \"YES\"\n                        tableColumn.isPrimary = dbPrimaryKeys.some(\n                            (dbPrimaryKey) => {\n                                return (\n                                    dbPrimaryKey[\"TABLE_NAME\"] ===\n                                        dbColumn[\"TABLE_NAME\"] &&\n                                    dbPrimaryKey[\"TABLE_SCHEMA\"] ===\n                                        dbColumn[\"TABLE_SCHEMA\"] &&\n                                    dbPrimaryKey[\"COLUMN_NAME\"] ===\n                                        dbColumn[\"COLUMN_NAME\"]\n                                )\n                            },\n                        )\n                        tableColumn.zerofill =\n                            dbColumn[\"COLUMN_TYPE\"].indexOf(\"zerofill\") !== -1\n                        tableColumn.unsigned = tableColumn.zerofill\n                            ? true\n                            : dbColumn[\"COLUMN_TYPE\"].indexOf(\"unsigned\") !== -1\n                        tableColumn.isGenerated =\n                            dbColumn[\"EXTRA\"].indexOf(\"auto_increment\") !== -1\n                        if (tableColumn.isGenerated)\n                            tableColumn.generationStrategy = \"increment\"\n\n                        tableColumn.comment =\n                            typeof dbColumn[\"COLUMN_COMMENT\"] === \"string\" &&\n                            dbColumn[\"COLUMN_COMMENT\"].length === 0\n                                ? undefined\n                                : dbColumn[\"COLUMN_COMMENT\"]\n                        if (dbColumn[\"CHARACTER_SET_NAME\"])\n                            tableColumn.charset =\n                                dbColumn[\"CHARACTER_SET_NAME\"] ===\n                                defaultCharset\n                                    ? undefined\n                                    : dbColumn[\"CHARACTER_SET_NAME\"]\n                        if (dbColumn[\"COLLATION_NAME\"])\n                            tableColumn.collation =\n                                dbColumn[\"COLLATION_NAME\"] === defaultCollation\n                                    ? undefined\n                                    : dbColumn[\"COLLATION_NAME\"]\n\n                        // check only columns that have length property\n                        if (\n                            this.driver.withLengthColumnTypes.indexOf(\n                                tableColumn.type as ColumnType,\n                            ) !== -1 &&\n                            dbColumn[\"CHARACTER_MAXIMUM_LENGTH\"]\n                        ) {\n                            const length =\n                                dbColumn[\"CHARACTER_MAXIMUM_LENGTH\"].toString()\n                            tableColumn.length = !this.isDefaultColumnLength(\n                                table,\n                                tableColumn,\n                                length,\n                            )\n                                ? length\n                                : \"\"\n                        }\n\n                        if (\n                            tableColumn.type === \"decimal\" ||\n                            tableColumn.type === \"double\" ||\n                            tableColumn.type === \"float\"\n                        ) {\n                            if (\n                                dbColumn[\"NUMERIC_PRECISION\"] !== null &&\n                                !this.isDefaultColumnPrecision(\n                                    table,\n                                    tableColumn,\n                                    dbColumn[\"NUMERIC_PRECISION\"],\n                                )\n                            )\n                                tableColumn.precision = parseInt(\n                                    dbColumn[\"NUMERIC_PRECISION\"],\n                                )\n                            if (\n                                dbColumn[\"NUMERIC_SCALE\"] !== null &&\n                                !this.isDefaultColumnScale(\n                                    table,\n                                    tableColumn,\n                                    dbColumn[\"NUMERIC_SCALE\"],\n                                )\n                            )\n                                tableColumn.scale = parseInt(\n                                    dbColumn[\"NUMERIC_SCALE\"],\n                                )\n                        }\n\n                        if (\n                            tableColumn.type === \"enum\" ||\n                            tableColumn.type === \"simple-enum\" ||\n                            tableColumn.type === \"set\"\n                        ) {\n                            const colType = dbColumn[\"COLUMN_TYPE\"]\n                            const items = colType\n                                .substring(\n                                    colType.indexOf(\"(\") + 1,\n                                    colType.lastIndexOf(\")\"),\n                                )\n                                .split(\",\")\n                            tableColumn.enum = (items as string[]).map(\n                                (item) => {\n                                    return item.substring(1, item.length - 1)\n                                },\n                            )\n                            tableColumn.length = \"\"\n                        }\n\n                        if (\n                            (tableColumn.type === \"datetime\" ||\n                                tableColumn.type === \"time\" ||\n                                tableColumn.type === \"timestamp\") &&\n                            dbColumn[\"DATETIME_PRECISION\"] !== null &&\n                            dbColumn[\"DATETIME_PRECISION\"] !== undefined &&\n                            !this.isDefaultColumnPrecision(\n                                table,\n                                tableColumn,\n                                parseInt(dbColumn[\"DATETIME_PRECISION\"]),\n                            )\n                        ) {\n                            tableColumn.precision = parseInt(\n                                dbColumn[\"DATETIME_PRECISION\"],\n                            )\n                        }\n\n                        return tableColumn\n                    })\n\n                // find foreign key constraints of table, group them by constraint name and build TableForeignKey.\n                const tableForeignKeyConstraints = OrmUtils.uniq(\n                    dbForeignKeys.filter((dbForeignKey) => {\n                        return (\n                            dbForeignKey[\"TABLE_NAME\"] ===\n                                dbTable[\"TABLE_NAME\"] &&\n                            dbForeignKey[\"TABLE_SCHEMA\"] ===\n                                dbTable[\"TABLE_SCHEMA\"]\n                        )\n                    }),\n                    (dbForeignKey) => dbForeignKey[\"CONSTRAINT_NAME\"],\n                )\n\n                table.foreignKeys = tableForeignKeyConstraints.map(\n                    (dbForeignKey) => {\n                        const foreignKeys = dbForeignKeys.filter(\n                            (dbFk) =>\n                                dbFk[\"CONSTRAINT_NAME\"] ===\n                                dbForeignKey[\"CONSTRAINT_NAME\"],\n                        )\n\n                        // if referenced table located in currently used db, we don't need to concat db name to table name.\n                        const database =\n                            dbForeignKey[\"REFERENCED_TABLE_SCHEMA\"] ===\n                            currentDatabase\n                                ? undefined\n                                : dbForeignKey[\"REFERENCED_TABLE_SCHEMA\"]\n                        const referencedTableName = this.driver.buildTableName(\n                            dbForeignKey[\"REFERENCED_TABLE_NAME\"],\n                            undefined,\n                            database,\n                        )\n\n                        return new TableForeignKey({\n                            name: dbForeignKey[\"CONSTRAINT_NAME\"],\n                            columnNames: foreignKeys.map(\n                                (dbFk) => dbFk[\"COLUMN_NAME\"],\n                            ),\n                            referencedDatabase:\n                                dbForeignKey[\"REFERENCED_TABLE_SCHEMA\"],\n                            referencedTableName: referencedTableName,\n                            referencedColumnNames: foreignKeys.map(\n                                (dbFk) => dbFk[\"REFERENCED_COLUMN_NAME\"],\n                            ),\n                            onDelete: dbForeignKey[\"ON_DELETE\"],\n                            onUpdate: dbForeignKey[\"ON_UPDATE\"],\n                        })\n                    },\n                )\n\n                // find index constraints of table, group them by constraint name and build TableIndex.\n                const tableIndexConstraints = OrmUtils.uniq(\n                    dbIndices.filter((dbIndex) => {\n                        return (\n                            dbIndex[\"TABLE_NAME\"] === dbTable[\"TABLE_NAME\"] &&\n                            dbIndex[\"TABLE_SCHEMA\"] === dbTable[\"TABLE_SCHEMA\"]\n                        )\n                    }),\n                    (dbIndex) => dbIndex[\"INDEX_NAME\"],\n                )\n\n                table.indices = tableIndexConstraints.map((constraint) => {\n                    const indices = dbIndices.filter((index) => {\n                        return (\n                            index[\"TABLE_SCHEMA\"] ===\n                                constraint[\"TABLE_SCHEMA\"] &&\n                            index[\"TABLE_NAME\"] === constraint[\"TABLE_NAME\"] &&\n                            index[\"INDEX_NAME\"] === constraint[\"INDEX_NAME\"]\n                        )\n                    })\n\n                    const nonUnique = parseInt(constraint[\"NON_UNIQUE\"], 10)\n\n                    return new TableIndex(<TableIndexOptions>{\n                        table: table,\n                        name: constraint[\"INDEX_NAME\"],\n                        columnNames: indices.map((i) => i[\"COLUMN_NAME\"]),\n                        isUnique: nonUnique === 0,\n                        isSpatial: constraint[\"INDEX_TYPE\"] === \"SPATIAL\",\n                        isFulltext: constraint[\"INDEX_TYPE\"] === \"FULLTEXT\",\n                    })\n                })\n\n                return table\n            }),\n        )\n    }\n\n    /**\n     * Builds create table sql\n     */\n    protected createTableSql(table: Table, createForeignKeys?: boolean): Query {\n        const columnDefinitions = table.columns\n            .map((column) => this.buildCreateColumnSql(column, true))\n            .join(\", \")\n        let sql = `CREATE TABLE ${this.escapePath(table)} (${columnDefinitions}`\n\n        // we create unique indexes instead of unique constraints, because MySql does not have unique constraints.\n        // if we mark column as Unique, it means that we create UNIQUE INDEX.\n        table.columns\n            .filter((column) => column.isUnique)\n            .forEach((column) => {\n                const isUniqueIndexExist = table.indices.some((index) => {\n                    return (\n                        index.columnNames.length === 1 &&\n                        !!index.isUnique &&\n                        index.columnNames.indexOf(column.name) !== -1\n                    )\n                })\n                const isUniqueConstraintExist = table.uniques.some((unique) => {\n                    return (\n                        unique.columnNames.length === 1 &&\n                        unique.columnNames.indexOf(column.name) !== -1\n                    )\n                })\n                if (!isUniqueIndexExist && !isUniqueConstraintExist)\n                    table.indices.push(\n                        new TableIndex({\n                            name: this.connection.namingStrategy.uniqueConstraintName(\n                                table,\n                                [column.name],\n                            ),\n                            columnNames: [column.name],\n                            isUnique: true,\n                        }),\n                    )\n            })\n\n        // as MySql does not have unique constraints, we must create table indices from table uniques and mark them as unique.\n        if (table.uniques.length > 0) {\n            table.uniques.forEach((unique) => {\n                const uniqueExist = table.indices.some(\n                    (index) => index.name === unique.name,\n                )\n                if (!uniqueExist) {\n                    table.indices.push(\n                        new TableIndex({\n                            name: unique.name,\n                            columnNames: unique.columnNames,\n                            isUnique: true,\n                        }),\n                    )\n                }\n            })\n        }\n\n        if (table.indices.length > 0) {\n            const indicesSql = table.indices\n                .map((index) => {\n                    const columnNames = index.columnNames\n                        .map((columnName) => `\\`${columnName}\\``)\n                        .join(\", \")\n                    if (!index.name)\n                        index.name = this.connection.namingStrategy.indexName(\n                            table,\n                            index.columnNames,\n                            index.where,\n                        )\n\n                    let indexType = \"\"\n                    if (index.isUnique) indexType += \"UNIQUE \"\n                    if (index.isSpatial) indexType += \"SPATIAL \"\n                    if (index.isFulltext) indexType += \"FULLTEXT \"\n                    return `${indexType}INDEX \\`${index.name}\\` (${columnNames})`\n                })\n                .join(\", \")\n\n            sql += `, ${indicesSql}`\n        }\n\n        if (table.foreignKeys.length > 0 && createForeignKeys) {\n            const foreignKeysSql = table.foreignKeys\n                .map((fk) => {\n                    const columnNames = fk.columnNames\n                        .map((columnName) => `\\`${columnName}\\``)\n                        .join(\", \")\n                    if (!fk.name)\n                        fk.name = this.connection.namingStrategy.foreignKeyName(\n                            table,\n                            fk.columnNames,\n                        )\n                    const referencedColumnNames = fk.referencedColumnNames\n                        .map((columnName) => `\\`${columnName}\\``)\n                        .join(\", \")\n\n                    let constraint = `CONSTRAINT \\`${\n                        fk.name\n                    }\\` FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(\n                        this.getTablePath(fk),\n                    )} (${referencedColumnNames})`\n                    if (fk.onDelete) constraint += ` ON DELETE ${fk.onDelete}`\n                    if (fk.onUpdate) constraint += ` ON UPDATE ${fk.onUpdate}`\n\n                    return constraint\n                })\n                .join(\", \")\n\n            sql += `, ${foreignKeysSql}`\n        }\n\n        if (table.primaryColumns.length > 0) {\n            const columnNames = table.primaryColumns\n                .map((column) => `\\`${column.name}\\``)\n                .join(\", \")\n            sql += `, PRIMARY KEY (${columnNames})`\n        }\n\n        sql += `) ENGINE=${table.engine || \"InnoDB\"}`\n\n        return new Query(sql)\n    }\n\n    /**\n     * Builds drop table sql\n     */\n    protected dropTableSql(tableOrName: Table | string): Query {\n        return new Query(`DROP TABLE ${this.escapePath(tableOrName)}`)\n    }\n\n    protected createViewSql(view: View): Query {\n        if (typeof view.expression === \"string\") {\n            return new Query(\n                `CREATE VIEW ${this.escapePath(view)} AS ${view.expression}`,\n            )\n        } else {\n            return new Query(\n                `CREATE VIEW ${this.escapePath(view)} AS ${view\n                    .expression(this.connection)\n                    .getQuery()}`,\n            )\n        }\n    }\n\n    protected async insertViewDefinitionSql(view: View): Promise<Query> {\n        const currentDatabase = await this.getCurrentDatabase()\n        const expression =\n            typeof view.expression === \"string\"\n                ? view.expression.trim()\n                : view.expression(this.connection).getQuery()\n        return this.insertTypeormMetadataSql({\n            type: MetadataTableType.VIEW,\n            schema: currentDatabase,\n            name: view.name,\n            value: expression,\n        })\n    }\n\n    /**\n     * Builds drop view sql.\n     */\n    protected dropViewSql(viewOrPath: View | string): Query {\n        return new Query(`DROP VIEW ${this.escapePath(viewOrPath)}`)\n    }\n\n    /**\n     * Builds remove view sql.\n     */\n    protected async deleteViewDefinitionSql(\n        viewOrPath: View | string,\n    ): Promise<Query> {\n        const currentDatabase = await this.getCurrentDatabase()\n        const viewName = InstanceChecker.isView(viewOrPath)\n            ? viewOrPath.name\n            : viewOrPath\n        return this.deleteTypeormMetadataSql({\n            type: MetadataTableType.VIEW,\n            schema: currentDatabase,\n            name: viewName,\n        })\n    }\n\n    /**\n     * Builds create index sql.\n     */\n    protected createIndexSql(table: Table, index: TableIndex): Query {\n        const columns = index.columnNames\n            .map((columnName) => `\\`${columnName}\\``)\n            .join(\", \")\n        let indexType = \"\"\n        if (index.isUnique) indexType += \"UNIQUE \"\n        if (index.isSpatial) indexType += \"SPATIAL \"\n        if (index.isFulltext) indexType += \"FULLTEXT \"\n        return new Query(\n            `CREATE ${indexType}INDEX \\`${index.name}\\` ON ${this.escapePath(\n                table,\n            )} (${columns})`,\n        )\n    }\n\n    /**\n     * Builds drop index sql.\n     */\n    protected dropIndexSql(\n        table: Table,\n        indexOrName: TableIndex | string,\n    ): Query {\n        let indexName = InstanceChecker.isTableIndex(indexOrName)\n            ? indexOrName.name\n            : indexOrName\n        return new Query(\n            `DROP INDEX \\`${indexName}\\` ON ${this.escapePath(table)}`,\n        )\n    }\n\n    /**\n     * Builds create primary key sql.\n     */\n    protected createPrimaryKeySql(table: Table, columnNames: string[]): Query {\n        const columnNamesString = columnNames\n            .map((columnName) => `\\`${columnName}\\``)\n            .join(\", \")\n        return new Query(\n            `ALTER TABLE ${this.escapePath(\n                table,\n            )} ADD PRIMARY KEY (${columnNamesString})`,\n        )\n    }\n\n    /**\n     * Builds drop primary key sql.\n     */\n    protected dropPrimaryKeySql(table: Table): Query {\n        return new Query(\n            `ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`,\n        )\n    }\n\n    /**\n     * Builds create foreign key sql.\n     */\n    protected createForeignKeySql(\n        table: Table,\n        foreignKey: TableForeignKey,\n    ): Query {\n        const columnNames = foreignKey.columnNames\n            .map((column) => `\\`${column}\\``)\n            .join(\", \")\n        const referencedColumnNames = foreignKey.referencedColumnNames\n            .map((column) => `\\`${column}\\``)\n            .join(\",\")\n        let sql =\n            `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \\`${\n                foreignKey.name\n            }\\` FOREIGN KEY (${columnNames}) ` +\n            `REFERENCES ${this.escapePath(\n                this.getTablePath(foreignKey),\n            )}(${referencedColumnNames})`\n        if (foreignKey.onDelete) sql += ` ON DELETE ${foreignKey.onDelete}`\n        if (foreignKey.onUpdate) sql += ` ON UPDATE ${foreignKey.onUpdate}`\n\n        return new Query(sql)\n    }\n\n    /**\n     * Builds drop foreign key sql.\n     */\n    protected dropForeignKeySql(\n        table: Table,\n        foreignKeyOrName: TableForeignKey | string,\n    ): Query {\n        const foreignKeyName = InstanceChecker.isTableForeignKey(\n            foreignKeyOrName,\n        )\n            ? foreignKeyOrName.name\n            : foreignKeyOrName\n        return new Query(\n            `ALTER TABLE ${this.escapePath(\n                table,\n            )} DROP FOREIGN KEY \\`${foreignKeyName}\\``,\n        )\n    }\n\n    /**\n     * Escapes a given comment so it's safe to include in a query.\n     */\n    protected escapeComment(comment?: string) {\n        if (!comment || comment.length === 0) {\n            return `''`\n        }\n\n        comment = comment\n            .replace(/\\\\/g, \"\\\\\\\\\") // MySQL allows escaping characters via backslashes\n            .replace(/'/g, \"''\")\n            .replace(/\\u0000/g, \"\") // Null bytes aren't allowed in comments\n\n        return `'${comment}'`\n    }\n\n    /**\n     * Escapes given table or view path.\n     */\n    protected escapePath(target: Table | View | string): string {\n        const { database, tableName } = this.driver.parseTableName(target)\n\n        if (database && database !== this.driver.database) {\n            return `\\`${database}\\`.\\`${tableName}\\``\n        }\n\n        return `\\`${tableName}\\``\n    }\n\n    /**\n     * Builds a part of query to create/change a column.\n     */\n    protected buildCreateColumnSql(\n        column: TableColumn,\n        skipPrimary: boolean,\n        skipName: boolean = false,\n    ) {\n        let c = \"\"\n        if (skipName) {\n            c = this.connection.driver.createFullType(column)\n        } else {\n            c = `\\`${column.name}\\` ${this.connection.driver.createFullType(\n                column,\n            )}`\n        }\n        if (column.asExpression)\n            c += ` AS (${column.asExpression}) ${\n                column.generatedType ? column.generatedType : \"VIRTUAL\"\n            }`\n\n        // if you specify ZEROFILL for a numeric column, MySQL automatically adds the UNSIGNED attribute to that column.\n        if (column.zerofill) {\n            c += \" ZEROFILL\"\n        } else if (column.unsigned) {\n            c += \" UNSIGNED\"\n        }\n        if (column.enum)\n            c += ` (${column.enum\n                .map((value) => \"'\" + value + \"'\")\n                .join(\", \")})`\n        if (column.charset) c += ` CHARACTER SET \"${column.charset}\"`\n        if (column.collation) c += ` COLLATE \"${column.collation}\"`\n        if (!column.isNullable) c += \" NOT NULL\"\n        if (column.isNullable) c += \" NULL\"\n        if (column.isPrimary && !skipPrimary) c += \" PRIMARY KEY\"\n        if (column.isGenerated && column.generationStrategy === \"increment\")\n            // don't use skipPrimary here since updates can update already exist primary without auto inc.\n            c += \" AUTO_INCREMENT\"\n        if (column.comment)\n            c += ` COMMENT ${this.escapeComment(column.comment)}`\n        if (column.default !== undefined && column.default !== null)\n            c += ` DEFAULT ${column.default}`\n        if (column.onUpdate) c += ` ON UPDATE ${column.onUpdate}`\n\n        return c\n    }\n\n    /**\n     * Checks if column display width is by default.\n     */\n    protected isDefaultColumnWidth(\n        table: Table,\n        column: TableColumn,\n        width: number,\n    ): boolean {\n        // if table have metadata, we check if length is specified in column metadata\n        if (this.connection.hasMetadata(table.name)) {\n            const metadata = this.connection.getMetadata(table.name)\n            const columnMetadata = metadata.findColumnWithDatabaseName(\n                column.name,\n            )\n            if (columnMetadata && columnMetadata.width) return false\n        }\n\n        const defaultWidthForType =\n            this.connection.driver.dataTypeDefaults &&\n            this.connection.driver.dataTypeDefaults[column.type] &&\n            this.connection.driver.dataTypeDefaults[column.type].width\n\n        if (defaultWidthForType) {\n            return defaultWidthForType === width\n        }\n        return false\n    }\n}\n"]},"metadata":{},"sourceType":"module"}