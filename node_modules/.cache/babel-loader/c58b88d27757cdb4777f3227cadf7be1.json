{"ast":null,"code":"import { QueryBuilderUtils } from \"./QueryBuilderUtils\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\nimport { TypeORMError } from \"../error\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\n/**\n * Stores all join attributes which will be used to build a JOIN query.\n */\n\nexport class JoinAttribute {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection, queryExpressionMap, joinAttribute) {\n    this.connection = connection;\n    this.queryExpressionMap = queryExpressionMap;\n    this.isSelectedEvaluated = false;\n    this.relationEvaluated = false;\n    ObjectUtils.assign(this, joinAttribute || {});\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n\n  get isMany() {\n    if (this.isMappingMany !== undefined) return this.isMappingMany;\n    if (this.relation) return this.relation.isManyToMany || this.relation.isOneToMany;\n    return false;\n  }\n  /**\n   * Indicates if this join is selected.\n   */\n\n\n  get isSelected() {\n    if (!this.isSelectedEvaluated) {\n      let getValue = () => {\n        for (const select of this.queryExpressionMap.selects) {\n          if (select.selection === this.alias.name) return true;\n          if (this.metadata && !!this.metadata.columns.find(column => select.selection === this.alias.name + \".\" + column.propertyPath)) return true;\n        }\n\n        return false;\n      };\n\n      this.isSelectedCache = getValue();\n      this.isSelectedEvaluated = true;\n    }\n\n    return this.isSelectedCache;\n  }\n  /**\n   * Name of the table which we should join.\n   */\n\n\n  get tablePath() {\n    return this.metadata ? this.metadata.tablePath : this.entityOrProperty;\n  }\n  /**\n   * Alias of the parent of this join.\n   * For example, if we join (\"post.category\", \"categoryAlias\") then \"post\" is a parent alias.\n   * This value is extracted from entityOrProperty value.\n   * This is available when join was made using \"post.category\" syntax.\n   */\n\n\n  get parentAlias() {\n    if (!QueryBuilderUtils.isAliasProperty(this.entityOrProperty)) return undefined;\n    return this.entityOrProperty.substr(0, this.entityOrProperty.indexOf(\".\"));\n  }\n  /**\n   * Relation property name of the parent.\n   * This is used to understand what is joined.\n   * For example, if we join (\"post.category\", \"categoryAlias\") then \"category\" is a relation property.\n   * This value is extracted from entityOrProperty value.\n   * This is available when join was made using \"post.category\" syntax.\n   */\n\n\n  get relationPropertyPath() {\n    if (!QueryBuilderUtils.isAliasProperty(this.entityOrProperty)) return undefined;\n    return this.entityOrProperty.substr(this.entityOrProperty.indexOf(\".\") + 1);\n  }\n  /**\n   * Relation of the parent.\n   * This is used to understand what is joined.\n   * This is available when join was made using \"post.category\" syntax.\n   * Relation can be undefined if entityOrProperty is regular entity or custom table.\n   */\n\n\n  get relation() {\n    if (!this.relationEvaluated) {\n      let getValue = () => {\n        if (!QueryBuilderUtils.isAliasProperty(this.entityOrProperty)) return undefined;\n        const relationOwnerSelection = this.queryExpressionMap.findAliasByName(this.parentAlias);\n        let relation = relationOwnerSelection.metadata.findRelationWithPropertyPath(this.relationPropertyPath);\n\n        if (relation) {\n          return relation;\n        }\n\n        if (relationOwnerSelection.metadata.parentEntityMetadata) {\n          relation = relationOwnerSelection.metadata.parentEntityMetadata.findRelationWithPropertyPath(this.relationPropertyPath);\n\n          if (relation) {\n            return relation;\n          }\n        }\n\n        throw new TypeORMError(`Relation with property path ${this.relationPropertyPath} in entity was not found.`);\n      };\n\n      this.relationCache = getValue.bind(this)();\n      this.relationEvaluated = true;\n    }\n\n    return this.relationCache;\n  }\n  /**\n   * Metadata of the joined entity.\n   * If table without entity was joined, then it will return undefined.\n   */\n\n\n  get metadata() {\n    // entityOrProperty is relation, e.g. \"post.category\"\n    if (this.relation) return this.relation.inverseEntityMetadata; // entityOrProperty is Entity class\n\n    if (this.connection.hasMetadata(this.entityOrProperty)) return this.connection.getMetadata(this.entityOrProperty);\n    return undefined;\n    /*if (typeof this.entityOrProperty === \"string\") { // entityOrProperty is a custom table\n         // first try to find entity with such name, this is needed when entity does not have a target class,\n        // and its target is a string name (scenario when plain old javascript is used or entity schema is loaded from files)\n        const metadata = this.connection.entityMetadatas.find(metadata => metadata.name === this.entityOrProperty);\n        if (metadata)\n            return metadata;\n         // check if we have entity with such table name, and use its metadata if found\n        return this.connection.entityMetadatas.find(metadata => metadata.tableName === this.entityOrProperty);\n    }*/\n  }\n  /**\n   * Generates alias of junction table, whose ids we get.\n   */\n\n\n  get junctionAlias() {\n    if (!this.relation) throw new TypeORMError(`Cannot get junction table for join without relation.`);\n\n    if (this.relation.isOwning) {\n      return DriverUtils.buildAlias(this.connection.driver, this.parentAlias, this.alias.name);\n    } else {\n      return DriverUtils.buildAlias(this.connection.driver, this.alias.name, this.parentAlias);\n    }\n  }\n\n  get mapToPropertyParentAlias() {\n    if (!this.mapToProperty) return undefined;\n    return this.mapToProperty.split(\".\")[0];\n  }\n\n  get mapToPropertyPropertyName() {\n    if (!this.mapToProperty) return undefined;\n    return this.mapToProperty.split(\".\")[1];\n  }\n\n}","map":{"version":3,"mappings":"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","names":["QueryBuilderUtils","ObjectUtils","TypeORMError","DriverUtils","JoinAttribute","constructor","connection","queryExpressionMap","joinAttribute","assign","isMany","isMappingMany","undefined","relation","isManyToMany","isOneToMany","isSelected","isSelectedEvaluated","getValue","select","selects","selection","alias","name","metadata","columns","find","column","propertyPath","isSelectedCache","tablePath","entityOrProperty","parentAlias","isAliasProperty","substr","indexOf","relationPropertyPath","relationEvaluated","relationOwnerSelection","findAliasByName","findRelationWithPropertyPath","parentEntityMetadata","relationCache","bind","inverseEntityMetadata","hasMetadata","getMetadata","junctionAlias","isOwning","buildAlias","driver","mapToPropertyParentAlias","mapToProperty","split","mapToPropertyPropertyName"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\query-builder\\JoinAttribute.ts"],"sourcesContent":["import { EntityMetadata } from \"../metadata/EntityMetadata\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { RelationMetadata } from \"../metadata/RelationMetadata\"\nimport { QueryBuilderUtils } from \"./QueryBuilderUtils\"\nimport { QueryExpressionMap } from \"./QueryExpressionMap\"\nimport { Alias } from \"./Alias\"\nimport { ObjectUtils } from \"../util/ObjectUtils\"\nimport { TypeORMError } from \"../error\"\nimport { DriverUtils } from \"../driver/DriverUtils\"\n\n/**\n * Stores all join attributes which will be used to build a JOIN query.\n */\nexport class JoinAttribute {\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Join direction.\n     */\n    direction: \"LEFT\" | \"INNER\"\n\n    /**\n     * Alias of the joined (destination) table.\n     */\n    alias: Alias\n\n    /**\n     * Joined table, entity target, or relation in \"post.category\" format.\n     */\n    entityOrProperty: Function | string\n\n    /**\n     * Extra condition applied to \"ON\" section of join.\n     */\n    condition?: string\n\n    /**\n     * Property + alias of the object where to joined data should be mapped.\n     */\n    mapToProperty?: string\n\n    /**\n     * Indicates if user maps one or many objects from the join.\n     */\n    isMappingMany?: boolean\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        private connection: DataSource,\n        private queryExpressionMap: QueryExpressionMap,\n        joinAttribute?: JoinAttribute,\n    ) {\n        ObjectUtils.assign(this, joinAttribute || {})\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    get isMany(): boolean {\n        if (this.isMappingMany !== undefined) return this.isMappingMany\n\n        if (this.relation)\n            return this.relation.isManyToMany || this.relation.isOneToMany\n\n        return false\n    }\n\n    isSelectedCache: boolean\n    isSelectedEvaluated: boolean = false\n    /**\n     * Indicates if this join is selected.\n     */\n    get isSelected(): boolean {\n        if (!this.isSelectedEvaluated) {\n            let getValue = () => {\n                for (const select of this.queryExpressionMap.selects) {\n                    if (select.selection === this.alias.name) return true\n\n                    if (\n                        this.metadata &&\n                        !!this.metadata.columns.find(\n                            (column) =>\n                                select.selection ===\n                                this.alias.name + \".\" + column.propertyPath,\n                        )\n                    )\n                        return true\n                }\n\n                return false\n            }\n            this.isSelectedCache = getValue()\n            this.isSelectedEvaluated = true\n        }\n        return this.isSelectedCache\n    }\n\n    /**\n     * Name of the table which we should join.\n     */\n    get tablePath(): string {\n        return this.metadata\n            ? this.metadata.tablePath\n            : (this.entityOrProperty as string)\n    }\n\n    /**\n     * Alias of the parent of this join.\n     * For example, if we join (\"post.category\", \"categoryAlias\") then \"post\" is a parent alias.\n     * This value is extracted from entityOrProperty value.\n     * This is available when join was made using \"post.category\" syntax.\n     */\n    get parentAlias(): string | undefined {\n        if (!QueryBuilderUtils.isAliasProperty(this.entityOrProperty))\n            return undefined\n\n        return this.entityOrProperty.substr(\n            0,\n            this.entityOrProperty.indexOf(\".\"),\n        )\n    }\n\n    /**\n     * Relation property name of the parent.\n     * This is used to understand what is joined.\n     * For example, if we join (\"post.category\", \"categoryAlias\") then \"category\" is a relation property.\n     * This value is extracted from entityOrProperty value.\n     * This is available when join was made using \"post.category\" syntax.\n     */\n    get relationPropertyPath(): string | undefined {\n        if (!QueryBuilderUtils.isAliasProperty(this.entityOrProperty))\n            return undefined\n\n        return this.entityOrProperty.substr(\n            this.entityOrProperty.indexOf(\".\") + 1,\n        )\n    }\n\n    relationCache: RelationMetadata | undefined\n    relationEvaluated: boolean = false\n    /**\n     * Relation of the parent.\n     * This is used to understand what is joined.\n     * This is available when join was made using \"post.category\" syntax.\n     * Relation can be undefined if entityOrProperty is regular entity or custom table.\n     */\n    get relation(): RelationMetadata | undefined {\n        if (!this.relationEvaluated) {\n            let getValue = () => {\n                if (!QueryBuilderUtils.isAliasProperty(this.entityOrProperty))\n                    return undefined\n\n                const relationOwnerSelection =\n                    this.queryExpressionMap.findAliasByName(this.parentAlias!)\n                let relation =\n                    relationOwnerSelection.metadata.findRelationWithPropertyPath(\n                        this.relationPropertyPath!,\n                    )\n\n                if (relation) {\n                    return relation\n                }\n\n                if (relationOwnerSelection.metadata.parentEntityMetadata) {\n                    relation =\n                        relationOwnerSelection.metadata.parentEntityMetadata.findRelationWithPropertyPath(\n                            this.relationPropertyPath!,\n                        )\n                    if (relation) {\n                        return relation\n                    }\n                }\n\n                throw new TypeORMError(\n                    `Relation with property path ${this.relationPropertyPath} in entity was not found.`,\n                )\n            }\n            this.relationCache = getValue.bind(this)()\n            this.relationEvaluated = true\n        }\n        return this.relationCache\n    }\n\n    /**\n     * Metadata of the joined entity.\n     * If table without entity was joined, then it will return undefined.\n     */\n    get metadata(): EntityMetadata | undefined {\n        // entityOrProperty is relation, e.g. \"post.category\"\n        if (this.relation) return this.relation.inverseEntityMetadata\n\n        // entityOrProperty is Entity class\n        if (this.connection.hasMetadata(this.entityOrProperty))\n            return this.connection.getMetadata(this.entityOrProperty)\n\n        return undefined\n\n        /*if (typeof this.entityOrProperty === \"string\") { // entityOrProperty is a custom table\n\n            // first try to find entity with such name, this is needed when entity does not have a target class,\n            // and its target is a string name (scenario when plain old javascript is used or entity schema is loaded from files)\n            const metadata = this.connection.entityMetadatas.find(metadata => metadata.name === this.entityOrProperty);\n            if (metadata)\n                return metadata;\n\n            // check if we have entity with such table name, and use its metadata if found\n            return this.connection.entityMetadatas.find(metadata => metadata.tableName === this.entityOrProperty);\n        }*/\n    }\n\n    /**\n     * Generates alias of junction table, whose ids we get.\n     */\n    get junctionAlias(): string {\n        if (!this.relation)\n            throw new TypeORMError(\n                `Cannot get junction table for join without relation.`,\n            )\n\n        if (this.relation.isOwning) {\n            return DriverUtils.buildAlias(\n                this.connection.driver,\n                this.parentAlias!,\n                this.alias.name,\n            )\n        } else {\n            return DriverUtils.buildAlias(\n                this.connection.driver,\n                this.alias.name,\n                this.parentAlias!,\n            )\n        }\n    }\n\n    get mapToPropertyParentAlias(): string | undefined {\n        if (!this.mapToProperty) return undefined\n\n        return this.mapToProperty!.split(\".\")[0]\n    }\n\n    get mapToPropertyPropertyName(): string | undefined {\n        if (!this.mapToProperty) return undefined\n\n        return this.mapToProperty!.split(\".\")[1]\n    }\n}\n"]},"metadata":{},"sourceType":"module"}