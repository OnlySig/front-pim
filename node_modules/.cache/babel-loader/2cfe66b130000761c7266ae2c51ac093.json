{"ast":null,"code":"import { Table } from \"./table/Table\";\nimport { TableColumn } from \"./table/TableColumn\";\nimport { TableForeignKey } from \"./table/TableForeignKey\";\nimport { TableIndex } from \"./table/TableIndex\";\nimport { TableUtils } from \"./util/TableUtils\";\nimport { TableUnique } from \"./table/TableUnique\";\nimport { TableCheck } from \"./table/TableCheck\";\nimport { TableExclusion } from \"./table/TableExclusion\";\nimport { View } from \"./view/View\";\nimport { ViewUtils } from \"./util/ViewUtils\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\n/**\n * Creates complete tables schemas in the database based on the entity metadatas.\n *\n * Steps how schema is being built:\n * 1. load list of all tables with complete column and keys information from the db\n * 2. drop all (old) foreign keys that exist in the table, but does not exist in the metadata\n * 3. create new tables that does not exist in the db, but exist in the metadata\n * 4. drop all columns exist (left old) in the db table, but does not exist in the metadata\n * 5. add columns from metadata which does not exist in the table\n * 6. update all exist columns which metadata has changed\n * 7. update primary keys - update old and create new primary key from changed columns\n * 8. create foreign keys which does not exist in the table yet\n * 9. create indices which are missing in db yet, and drops indices which exist in the db, but does not exist in the metadata anymore\n */\n\nexport class RdbmsSchemaBuilder {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection) {\n    this.connection = connection;\n    this[\"@instanceof\"] = Symbol.for(\"RdbmsSchemaBuilder\");\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Creates complete schemas for the given entity metadatas.\n   */\n\n\n  async build() {\n    this.queryRunner = this.connection.createQueryRunner(); // this.connection.driver.database || this.currentDatabase;\n\n    this.currentDatabase = this.connection.driver.database;\n    this.currentSchema = this.connection.driver.schema; // CockroachDB implements asynchronous schema sync operations which can not been executed in transaction.\n    // E.g. if you try to DROP column and ADD it again in the same transaction, crdb throws error.\n    // In Spanner queries against the INFORMATION_SCHEMA can be used in a read-only transaction,\n    // but not in a read-write transaction.\n\n    const isUsingTransactions = !(this.connection.driver.options.type === \"cockroachdb\") && !(this.connection.driver.options.type === \"spanner\") && this.connection.options.migrationsTransactionMode !== \"none\";\n    await this.queryRunner.beforeMigration();\n\n    if (isUsingTransactions) {\n      await this.queryRunner.startTransaction();\n    }\n\n    try {\n      await this.createMetadataTableIfNecessary(this.queryRunner); // Flush the queryrunner table & view cache\n\n      const tablePaths = this.entityToSyncMetadatas.map(metadata => this.getTablePath(metadata));\n      await this.queryRunner.getTables(tablePaths);\n      await this.queryRunner.getViews([]);\n      await this.executeSchemaSyncOperationsInProperOrder(); // if cache is enabled then perform cache-synchronization as well\n\n      if (this.connection.queryResultCache) await this.connection.queryResultCache.synchronize(this.queryRunner);\n\n      if (isUsingTransactions) {\n        await this.queryRunner.commitTransaction();\n      }\n    } catch (error) {\n      try {\n        // we throw original error even if rollback thrown an error\n        if (isUsingTransactions) {\n          await this.queryRunner.rollbackTransaction();\n        }\n      } catch (rollbackError) {}\n\n      throw error;\n    } finally {\n      await this.queryRunner.afterMigration();\n      await this.queryRunner.release();\n    }\n  }\n  /**\n   * Create the typeorm_metadata table if necessary.\n   */\n\n\n  async createMetadataTableIfNecessary(queryRunner) {\n    if (this.viewEntityToSyncMetadatas.length > 0 || this.hasGeneratedColumns()) {\n      await this.createTypeormMetadataTable(queryRunner);\n    }\n  }\n  /**\n   * Returns sql queries to be executed by schema builder.\n   */\n\n\n  async log() {\n    this.queryRunner = this.connection.createQueryRunner();\n\n    try {\n      // Flush the queryrunner table & view cache\n      const tablePaths = this.entityToSyncMetadatas.map(metadata => this.getTablePath(metadata));\n      await this.queryRunner.getTables(tablePaths);\n      await this.queryRunner.getViews([]);\n      this.queryRunner.enableSqlMemory();\n      await this.executeSchemaSyncOperationsInProperOrder(); // if cache is enabled then perform cache-synchronization as well\n\n      if (this.connection.queryResultCache) // todo: check this functionality\n        await this.connection.queryResultCache.synchronize(this.queryRunner);\n      return this.queryRunner.getMemorySql();\n    } finally {\n      // its important to disable this mode despite the fact we are release query builder\n      // because there exist drivers which reuse same query runner. Also its important to disable\n      // sql memory after call of getMemorySql() method because last one flushes sql memory.\n      this.queryRunner.disableSqlMemory();\n      await this.queryRunner.release();\n    }\n  } // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Returns only entities that should be synced in the database.\n   */\n\n\n  get entityToSyncMetadatas() {\n    return this.connection.entityMetadatas.filter(metadata => metadata.synchronize && metadata.tableType !== \"entity-child\" && metadata.tableType !== \"view\");\n  }\n  /**\n   * Returns only entities that should be synced in the database.\n   */\n\n\n  get viewEntityToSyncMetadatas() {\n    return this.connection.entityMetadatas.filter(metadata => metadata.tableType === \"view\" && metadata.synchronize) // sort views in creation order by dependencies\n    .sort(ViewUtils.viewMetadataCmp);\n  }\n  /**\n   * Checks if there are at least one generated column.\n   */\n\n\n  hasGeneratedColumns() {\n    return this.connection.entityMetadatas.some(entityMetadata => {\n      return entityMetadata.columns.some(column => column.generatedType);\n    });\n  }\n  /**\n   * Executes schema sync operations in a proper order.\n   * Order of operations matter here.\n   */\n\n\n  async executeSchemaSyncOperationsInProperOrder() {\n    await this.dropOldViews();\n    await this.dropOldForeignKeys();\n    await this.dropOldIndices();\n    await this.dropOldChecks();\n    await this.dropOldExclusions();\n    await this.dropCompositeUniqueConstraints(); // await this.renameTables();\n\n    await this.renameColumns();\n    await this.createNewTables();\n    await this.dropRemovedColumns();\n    await this.addNewColumns();\n    await this.updatePrimaryKeys();\n    await this.updateExistColumns();\n    await this.createNewIndices();\n    await this.createNewChecks();\n    await this.createNewExclusions();\n    await this.createCompositeUniqueConstraints();\n    await this.createForeignKeys();\n    await this.createViews();\n  }\n\n  getTablePath(target) {\n    const parsed = this.connection.driver.parseTableName(target);\n    return this.connection.driver.buildTableName(parsed.tableName, parsed.schema || this.currentSchema, parsed.database || this.currentDatabase);\n  }\n  /**\n   * Drops all (old) foreign keys that exist in the tables, but do not exist in the entity metadata.\n   */\n\n\n  async dropOldForeignKeys() {\n    for (const metadata of this.entityToSyncMetadatas) {\n      const table = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === this.getTablePath(metadata));\n      if (!table) continue; // find foreign keys that exist in the schemas but does not exist in the entity metadata\n\n      const tableForeignKeysToDrop = table.foreignKeys.filter(tableForeignKey => {\n        const metadataFK = metadata.foreignKeys.find(metadataForeignKey => tableForeignKey.name === metadataForeignKey.name && this.getTablePath(tableForeignKey) === this.getTablePath(metadataForeignKey.referencedEntityMetadata));\n        return !metadataFK || metadataFK.onDelete && metadataFK.onDelete !== tableForeignKey.onDelete || metadataFK.onUpdate && metadataFK.onUpdate !== tableForeignKey.onUpdate;\n      });\n      if (tableForeignKeysToDrop.length === 0) continue;\n      this.connection.logger.logSchemaBuild(`dropping old foreign keys of ${table.name}: ${tableForeignKeysToDrop.map(dbForeignKey => dbForeignKey.name).join(\", \")}`); // drop foreign keys from the database\n\n      await this.queryRunner.dropForeignKeys(table, tableForeignKeysToDrop);\n    }\n  }\n  /**\n   * Rename tables\n   */\n\n\n  async renameTables() {// for (const metadata of this.entityToSyncMetadatas) {\n    //     const table = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === this.getTablePath(metadata));\n    // }\n  }\n  /**\n   * Renames columns.\n   * Works if only one column per table was changed.\n   * Changes only column name. If something besides name was changed, these changes will be ignored.\n   */\n\n\n  async renameColumns() {\n    for (const metadata of this.entityToSyncMetadatas) {\n      const table = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === this.getTablePath(metadata));\n      if (!table) continue;\n      if (metadata.columns.length !== table.columns.length) continue;\n      const renamedMetadataColumns = metadata.columns.filter(column => {\n        return !table.columns.find(tableColumn => {\n          return tableColumn.name === column.databaseName && tableColumn.type === this.connection.driver.normalizeType(column) && tableColumn.isNullable === column.isNullable && tableColumn.isUnique === this.connection.driver.normalizeIsUnique(column);\n        });\n      });\n      if (renamedMetadataColumns.length === 0 || renamedMetadataColumns.length > 1) continue;\n      const renamedTableColumns = table.columns.filter(tableColumn => {\n        return !metadata.columns.find(column => {\n          return column.databaseName === tableColumn.name && this.connection.driver.normalizeType(column) === tableColumn.type && column.isNullable === tableColumn.isNullable && this.connection.driver.normalizeIsUnique(column) === tableColumn.isUnique;\n        });\n      });\n      if (renamedTableColumns.length === 0 || renamedTableColumns.length > 1) continue;\n      const renamedColumn = renamedTableColumns[0].clone();\n      renamedColumn.name = renamedMetadataColumns[0].databaseName;\n      this.connection.logger.logSchemaBuild(`renaming column \"${renamedTableColumns[0].name}\" in to \"${renamedColumn.name}\"`);\n      await this.queryRunner.renameColumn(table, renamedTableColumns[0], renamedColumn);\n    }\n  }\n\n  async dropOldIndices() {\n    for (const metadata of this.entityToSyncMetadatas) {\n      const table = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === this.getTablePath(metadata));\n      if (!table) continue;\n      const dropQueries = table.indices.filter(tableIndex => {\n        const indexMetadata = metadata.indices.find(index => index.name === tableIndex.name);\n\n        if (indexMetadata) {\n          if (indexMetadata.synchronize === false) return false;\n          if (indexMetadata.isUnique !== tableIndex.isUnique) return true;\n          if (indexMetadata.isSpatial !== tableIndex.isSpatial) return true;\n          if (this.connection.driver.isFullTextColumnTypeSupported() && indexMetadata.isFulltext !== tableIndex.isFulltext) return true;\n          if (indexMetadata.columns.length !== tableIndex.columnNames.length) return true;\n          return !indexMetadata.columns.every(column => tableIndex.columnNames.indexOf(column.databaseName) !== -1);\n        }\n\n        return true;\n      }).map(async tableIndex => {\n        this.connection.logger.logSchemaBuild(`dropping an index: \"${tableIndex.name}\" from table ${table.name}`);\n        await this.queryRunner.dropIndex(table, tableIndex);\n      });\n      await Promise.all(dropQueries);\n    }\n  }\n\n  async dropOldChecks() {\n    // Mysql does not support check constraints\n    if (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === \"aurora-mysql\") return;\n\n    for (const metadata of this.entityToSyncMetadatas) {\n      const table = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === this.getTablePath(metadata));\n      if (!table) continue;\n      const oldChecks = table.checks.filter(tableCheck => {\n        return !metadata.checks.find(checkMetadata => checkMetadata.name === tableCheck.name);\n      });\n      if (oldChecks.length === 0) continue;\n      this.connection.logger.logSchemaBuild(`dropping old check constraint: ${oldChecks.map(check => `\"${check.name}\"`).join(\", \")} from table \"${table.name}\"`);\n      await this.queryRunner.dropCheckConstraints(table, oldChecks);\n    }\n  }\n\n  async dropCompositeUniqueConstraints() {\n    for (const metadata of this.entityToSyncMetadatas) {\n      const table = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === this.getTablePath(metadata));\n      if (!table) continue;\n      const compositeUniques = table.uniques.filter(tableUnique => {\n        return tableUnique.columnNames.length > 1 && !metadata.uniques.find(uniqueMetadata => uniqueMetadata.name === tableUnique.name);\n      });\n      if (compositeUniques.length === 0) continue;\n      this.connection.logger.logSchemaBuild(`dropping old unique constraint: ${compositeUniques.map(unique => `\"${unique.name}\"`).join(\", \")} from table \"${table.name}\"`);\n      await this.queryRunner.dropUniqueConstraints(table, compositeUniques);\n    }\n  }\n\n  async dropOldExclusions() {\n    // Only PostgreSQL supports exclusion constraints\n    if (!(this.connection.driver.options.type === \"postgres\")) return;\n\n    for (const metadata of this.entityToSyncMetadatas) {\n      const table = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === this.getTablePath(metadata));\n      if (!table) continue;\n      const oldExclusions = table.exclusions.filter(tableExclusion => {\n        return !metadata.exclusions.find(exclusionMetadata => exclusionMetadata.name === tableExclusion.name);\n      });\n      if (oldExclusions.length === 0) continue;\n      this.connection.logger.logSchemaBuild(`dropping old exclusion constraint: ${oldExclusions.map(exclusion => `\"${exclusion.name}\"`).join(\", \")} from table \"${table.name}\"`);\n      await this.queryRunner.dropExclusionConstraints(table, oldExclusions);\n    }\n  }\n  /**\n   * Creates tables that do not exist in the database yet.\n   * New tables are created without foreign and primary keys.\n   * Primary key only can be created in conclusion with auto generated column.\n   */\n\n\n  async createNewTables() {\n    for (const metadata of this.entityToSyncMetadatas) {\n      // check if table does not exist yet\n      const existTable = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === this.getTablePath(metadata));\n      if (existTable) continue;\n      this.connection.logger.logSchemaBuild(`creating a new table: ${this.getTablePath(metadata)}`); // create a new table and sync it in the database\n\n      const table = Table.create(metadata, this.connection.driver);\n      await this.queryRunner.createTable(table, false, false);\n      this.queryRunner.loadedTables.push(table);\n    }\n  }\n\n  async createViews() {\n    for (const metadata of this.viewEntityToSyncMetadatas) {\n      // check if view does not exist yet\n      const existView = this.queryRunner.loadedViews.find(view => {\n        const viewExpression = typeof view.expression === \"string\" ? view.expression.trim() : view.expression(this.connection).getQuery();\n        const metadataExpression = typeof metadata.expression === \"string\" ? metadata.expression.trim() : metadata.expression(this.connection).getQuery();\n        return this.getTablePath(view) === this.getTablePath(metadata) && viewExpression === metadataExpression;\n      });\n      if (existView) continue;\n      this.connection.logger.logSchemaBuild(`creating a new view: ${this.getTablePath(metadata)}`); // create a new view and sync it in the database\n\n      const view = View.create(metadata, this.connection.driver);\n      await this.queryRunner.createView(view);\n      this.queryRunner.loadedViews.push(view);\n    }\n  }\n\n  async dropOldViews() {\n    const droppedViews = [];\n    const viewEntityToSyncMetadatas = this.viewEntityToSyncMetadatas; // BuIld lookup cache for finding views metadata\n\n    const viewToMetadata = new Map();\n\n    for (const view of this.queryRunner.loadedViews) {\n      const viewMetadata = viewEntityToSyncMetadatas.find(metadata => {\n        return this.getTablePath(view) === this.getTablePath(metadata);\n      });\n\n      if (viewMetadata) {\n        viewToMetadata.set(view, viewMetadata);\n      }\n    } // Gather all changed view, that need a drop\n\n\n    for (const view of this.queryRunner.loadedViews) {\n      const viewMetadata = viewToMetadata.get(view);\n\n      if (!viewMetadata) {\n        continue;\n      }\n\n      const viewExpression = typeof view.expression === \"string\" ? view.expression.trim() : view.expression(this.connection).getQuery();\n      const metadataExpression = typeof viewMetadata.expression === \"string\" ? viewMetadata.expression.trim() : viewMetadata.expression(this.connection).getQuery();\n      if (viewExpression === metadataExpression) continue;\n      this.connection.logger.logSchemaBuild(`dropping an old view: ${view.name}`); // Collect view to be dropped\n\n      droppedViews.push(view);\n    } // Helper function that for a given view, will recursively return list of the view and all views that depend on it\n\n\n    const viewDependencyChain = view => {\n      // Get the view metadata\n      const viewMetadata = viewToMetadata.get(view);\n      let viewWithDependencies = [view]; // If no metadata is known for the view, simply return the view itself\n\n      if (!viewMetadata) {\n        return viewWithDependencies;\n      } // Iterate over all known views\n\n\n      for (const [currentView, currentMetadata] of viewToMetadata.entries()) {\n        // Ignore self reference\n        if (currentView === view) {\n          continue;\n        } // If the currently iterated view depends on the passed in view\n\n\n        if (currentMetadata.dependsOn && (currentMetadata.dependsOn.has(viewMetadata.target) || currentMetadata.dependsOn.has(viewMetadata.name))) {\n          // Recursively add currently iterate view and its dependents\n          viewWithDependencies = viewWithDependencies.concat(viewDependencyChain(currentView));\n        }\n      } // Return all collected views\n\n\n      return viewWithDependencies;\n    }; // Collect final list of views to be dropped in a Set so there are no duplicates\n\n\n    const droppedViewsWithDependencies = new Set( // Collect all dropped views, and their dependencies\n    droppedViews.map(view => viewDependencyChain(view)) // Flattened to single Array ( can be replaced with flatMap, once supported)\n    .reduce((all, segment) => {\n      return all.concat(segment);\n    }, []) // Sort the views to be dropped in creation order\n    .sort((a, b) => {\n      return ViewUtils.viewMetadataCmp(viewToMetadata.get(a), viewToMetadata.get(b));\n    }) // reverse order to get drop order\n    .reverse()); // Finally emit all drop views\n\n    for (const view of droppedViewsWithDependencies) {\n      await this.queryRunner.dropView(view);\n    }\n\n    this.queryRunner.loadedViews = this.queryRunner.loadedViews.filter(view => !droppedViewsWithDependencies.has(view));\n  }\n  /**\n   * Drops all columns that exist in the table, but does not exist in the metadata (left old).\n   * We drop their keys too, since it should be safe.\n   */\n\n\n  async dropRemovedColumns() {\n    for (const metadata of this.entityToSyncMetadatas) {\n      const table = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === this.getTablePath(metadata));\n      if (!table) continue; // find columns that exist in the database but does not exist in the metadata\n\n      const droppedTableColumns = table.columns.filter(tableColumn => {\n        return !metadata.columns.find(columnMetadata => columnMetadata.databaseName === tableColumn.name);\n      });\n      if (droppedTableColumns.length === 0) continue;\n      this.connection.logger.logSchemaBuild(`columns dropped in ${table.name}: ` + droppedTableColumns.map(column => column.name).join(\", \")); // drop columns from the database\n\n      await this.queryRunner.dropColumns(table, droppedTableColumns);\n    }\n  }\n  /**\n   * Adds columns from metadata which does not exist in the table.\n   * Columns are created without keys.\n   */\n\n\n  async addNewColumns() {\n    for (const metadata of this.entityToSyncMetadatas) {\n      const table = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === this.getTablePath(metadata));\n      if (!table) continue; // find which columns are new\n\n      const newColumnMetadatas = metadata.columns.filter(columnMetadata => {\n        return !table.columns.find(tableColumn => tableColumn.name === columnMetadata.databaseName);\n      });\n      if (newColumnMetadatas.length === 0) continue; // create columns in the database\n\n      const newTableColumnOptions = this.metadataColumnsToTableColumnOptions(newColumnMetadatas);\n      const newTableColumns = newTableColumnOptions.map(option => new TableColumn(option));\n      if (newTableColumns.length === 0) continue;\n      this.connection.logger.logSchemaBuild(`new columns added: ` + newColumnMetadatas.map(column => column.databaseName).join(\", \"));\n      await this.queryRunner.addColumns(table, newTableColumns);\n    }\n  }\n  /**\n   * Updates composite primary keys.\n   */\n\n\n  async updatePrimaryKeys() {\n    for (const metadata of this.entityToSyncMetadatas) {\n      const table = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === this.getTablePath(metadata));\n      if (!table) continue;\n      const primaryMetadataColumns = metadata.columns.filter(column => column.isPrimary);\n      const primaryTableColumns = table.columns.filter(column => column.isPrimary);\n\n      if (primaryTableColumns.length !== primaryMetadataColumns.length && primaryMetadataColumns.length > 1) {\n        const changedPrimaryColumns = primaryMetadataColumns.map(primaryMetadataColumn => {\n          return new TableColumn(TableUtils.createTableColumnOptions(primaryMetadataColumn, this.connection.driver));\n        });\n        await this.queryRunner.updatePrimaryKeys(table, changedPrimaryColumns);\n      }\n    }\n  }\n  /**\n   * Update all exist columns which metadata has changed.\n   * Still don't create keys. Also we don't touch foreign keys of the changed columns.\n   */\n\n\n  async updateExistColumns() {\n    for (const metadata of this.entityToSyncMetadatas) {\n      const table = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === this.getTablePath(metadata));\n      if (!table) continue;\n      const changedColumns = this.connection.driver.findChangedColumns(table.columns, metadata.columns);\n      if (changedColumns.length === 0) continue; // drop all foreign keys that point to this column\n\n      for (const changedColumn of changedColumns) {\n        await this.dropColumnReferencedForeignKeys(this.getTablePath(metadata), changedColumn.databaseName);\n      } // drop all composite indices related to this column\n\n\n      for (const changedColumn of changedColumns) {\n        await this.dropColumnCompositeIndices(this.getTablePath(metadata), changedColumn.databaseName);\n      } // drop all composite uniques related to this column\n      // Mysql does not support unique constraints.\n\n\n      if (!(DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === \"aurora-mysql\" || this.connection.driver.options.type === \"spanner\")) {\n        for (const changedColumn of changedColumns) {\n          await this.dropColumnCompositeUniques(this.getTablePath(metadata), changedColumn.databaseName);\n        }\n      } // generate a map of new/old columns\n\n\n      const newAndOldTableColumns = changedColumns.map(changedColumn => {\n        const oldTableColumn = table.columns.find(column => column.name === changedColumn.databaseName);\n        const newTableColumnOptions = TableUtils.createTableColumnOptions(changedColumn, this.connection.driver);\n        const newTableColumn = new TableColumn(newTableColumnOptions);\n        return {\n          oldColumn: oldTableColumn,\n          newColumn: newTableColumn\n        };\n      });\n      if (newAndOldTableColumns.length === 0) continue;\n      this.connection.logger.logSchemaBuild(`columns changed in \"${table.name}\". updating: ` + changedColumns.map(column => column.databaseName).join(\", \"));\n      await this.queryRunner.changeColumns(table, newAndOldTableColumns);\n    }\n  }\n  /**\n   * Creates composite indices which are missing in db yet.\n   */\n\n\n  async createNewIndices() {\n    for (const metadata of this.entityToSyncMetadatas) {\n      const table = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === this.getTablePath(metadata));\n      if (!table) continue;\n      const newIndices = metadata.indices.filter(indexMetadata => !table.indices.find(tableIndex => tableIndex.name === indexMetadata.name) && indexMetadata.synchronize === true).map(indexMetadata => TableIndex.create(indexMetadata));\n      if (newIndices.length === 0) continue;\n      this.connection.logger.logSchemaBuild(`adding new indices ${newIndices.map(index => `\"${index.name}\"`).join(\", \")} in table \"${table.name}\"`);\n      await this.queryRunner.createIndices(table, newIndices);\n    }\n  }\n\n  async createNewChecks() {\n    // Mysql does not support check constraints\n    if (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === \"aurora-mysql\") return;\n\n    for (const metadata of this.entityToSyncMetadatas) {\n      const table = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === this.getTablePath(metadata));\n      if (!table) continue;\n      const newChecks = metadata.checks.filter(checkMetadata => !table.checks.find(tableCheck => tableCheck.name === checkMetadata.name)).map(checkMetadata => TableCheck.create(checkMetadata));\n      if (newChecks.length === 0) continue;\n      this.connection.logger.logSchemaBuild(`adding new check constraints: ${newChecks.map(index => `\"${index.name}\"`).join(\", \")} in table \"${table.name}\"`);\n      await this.queryRunner.createCheckConstraints(table, newChecks);\n    }\n  }\n  /**\n   * Creates composite uniques which are missing in db yet.\n   */\n\n\n  async createCompositeUniqueConstraints() {\n    for (const metadata of this.entityToSyncMetadatas) {\n      const table = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === this.getTablePath(metadata));\n      if (!table) continue;\n      const compositeUniques = metadata.uniques.filter(uniqueMetadata => uniqueMetadata.columns.length > 1 && !table.uniques.find(tableUnique => tableUnique.name === uniqueMetadata.name)).map(uniqueMetadata => TableUnique.create(uniqueMetadata));\n      if (compositeUniques.length === 0) continue;\n      this.connection.logger.logSchemaBuild(`adding new unique constraints: ${compositeUniques.map(unique => `\"${unique.name}\"`).join(\", \")} in table \"${table.name}\"`);\n      await this.queryRunner.createUniqueConstraints(table, compositeUniques);\n    }\n  }\n  /**\n   * Creates exclusions which are missing in db yet.\n   */\n\n\n  async createNewExclusions() {\n    // Only PostgreSQL supports exclusion constraints\n    if (!(this.connection.driver.options.type === \"postgres\")) return;\n\n    for (const metadata of this.entityToSyncMetadatas) {\n      const table = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === this.getTablePath(metadata));\n      if (!table) continue;\n      const newExclusions = metadata.exclusions.filter(exclusionMetadata => !table.exclusions.find(tableExclusion => tableExclusion.name === exclusionMetadata.name)).map(exclusionMetadata => TableExclusion.create(exclusionMetadata));\n      if (newExclusions.length === 0) continue;\n      this.connection.logger.logSchemaBuild(`adding new exclusion constraints: ${newExclusions.map(exclusion => `\"${exclusion.name}\"`).join(\", \")} in table \"${table.name}\"`);\n      await this.queryRunner.createExclusionConstraints(table, newExclusions);\n    }\n  }\n  /**\n   * Creates foreign keys which does not exist in the table yet.\n   */\n\n\n  async createForeignKeys() {\n    for (const metadata of this.entityToSyncMetadatas) {\n      const table = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === this.getTablePath(metadata));\n      if (!table) continue;\n      const newKeys = metadata.foreignKeys.filter(foreignKey => {\n        return !table.foreignKeys.find(dbForeignKey => dbForeignKey.name === foreignKey.name && this.getTablePath(dbForeignKey) === this.getTablePath(foreignKey.referencedEntityMetadata));\n      });\n      if (newKeys.length === 0) continue;\n      const dbForeignKeys = newKeys.map(foreignKeyMetadata => TableForeignKey.create(foreignKeyMetadata, this.connection.driver));\n      this.connection.logger.logSchemaBuild(`creating a foreign keys: ${newKeys.map(key => key.name).join(\", \")} on table \"${table.name}\"`);\n      await this.queryRunner.createForeignKeys(table, dbForeignKeys);\n    }\n  }\n  /**\n   * Drops all foreign keys where given column of the given table is being used.\n   */\n\n\n  async dropColumnReferencedForeignKeys(tablePath, columnName) {\n    const table = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === tablePath);\n    if (!table) return;\n    const tablesWithFK = [];\n    const columnForeignKey = table.foreignKeys.find(foreignKey => foreignKey.columnNames.indexOf(columnName) !== -1);\n\n    if (columnForeignKey) {\n      const clonedTable = table.clone();\n      clonedTable.foreignKeys = [columnForeignKey];\n      tablesWithFK.push(clonedTable);\n      table.removeForeignKey(columnForeignKey);\n    }\n\n    for (const loadedTable of this.queryRunner.loadedTables) {\n      const dependForeignKeys = loadedTable.foreignKeys.filter(foreignKey => {\n        return this.getTablePath(foreignKey) === tablePath && foreignKey.referencedColumnNames.indexOf(columnName) !== -1;\n      });\n\n      if (dependForeignKeys.length > 0) {\n        const clonedTable = loadedTable.clone();\n        clonedTable.foreignKeys = dependForeignKeys;\n        tablesWithFK.push(clonedTable);\n        dependForeignKeys.forEach(dependForeignKey => loadedTable.removeForeignKey(dependForeignKey));\n      }\n    }\n\n    if (tablesWithFK.length > 0) {\n      for (const tableWithFK of tablesWithFK) {\n        this.connection.logger.logSchemaBuild(`dropping related foreign keys of ${tableWithFK.name}: ${tableWithFK.foreignKeys.map(foreignKey => foreignKey.name).join(\", \")}`);\n        await this.queryRunner.dropForeignKeys(tableWithFK, tableWithFK.foreignKeys);\n      }\n    }\n  }\n  /**\n   * Drops all composite indices, related to given column.\n   */\n\n\n  async dropColumnCompositeIndices(tablePath, columnName) {\n    const table = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === tablePath);\n    if (!table) return;\n    const relatedIndices = table.indices.filter(index => index.columnNames.length > 1 && index.columnNames.indexOf(columnName) !== -1);\n    if (relatedIndices.length === 0) return;\n    this.connection.logger.logSchemaBuild(`dropping related indices of \"${tablePath}\".\"${columnName}\": ${relatedIndices.map(index => index.name).join(\", \")}`);\n    await this.queryRunner.dropIndices(table, relatedIndices);\n  }\n  /**\n   * Drops all composite uniques, related to given column.\n   */\n\n\n  async dropColumnCompositeUniques(tablePath, columnName) {\n    const table = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === tablePath);\n    if (!table) return;\n    const relatedUniques = table.uniques.filter(unique => unique.columnNames.length > 1 && unique.columnNames.indexOf(columnName) !== -1);\n    if (relatedUniques.length === 0) return;\n    this.connection.logger.logSchemaBuild(`dropping related unique constraints of \"${tablePath}\".\"${columnName}\": ${relatedUniques.map(unique => unique.name).join(\", \")}`);\n    await this.queryRunner.dropUniqueConstraints(table, relatedUniques);\n  }\n  /**\n   * Creates new columns from the given column metadatas.\n   */\n\n\n  metadataColumnsToTableColumnOptions(columns) {\n    return columns.map(columnMetadata => TableUtils.createTableColumnOptions(columnMetadata, this.connection.driver));\n  }\n  /**\n   * Creates typeorm service table for storing user defined Views and generate columns.\n   */\n\n\n  async createTypeormMetadataTable(queryRunner) {\n    const schema = this.currentSchema;\n    const database = this.currentDatabase;\n    const typeormMetadataTable = this.connection.driver.buildTableName(this.connection.metadataTableName, schema, database); // Spanner requires at least one primary key in a table.\n    // Since we don't have unique column in \"typeorm_metadata\" table\n    // and we should avoid breaking changes, we mark all columns as primary for Spanner driver.\n\n    const isPrimary = this.connection.driver.options.type === \"spanner\";\n    await queryRunner.createTable(new Table({\n      database: database,\n      schema: schema,\n      name: typeormMetadataTable,\n      columns: [{\n        name: \"type\",\n        type: this.connection.driver.normalizeType({\n          type: this.connection.driver.mappedDataTypes.metadataType\n        }),\n        isNullable: false,\n        isPrimary\n      }, {\n        name: \"database\",\n        type: this.connection.driver.normalizeType({\n          type: this.connection.driver.mappedDataTypes.metadataDatabase\n        }),\n        isNullable: true,\n        isPrimary\n      }, {\n        name: \"schema\",\n        type: this.connection.driver.normalizeType({\n          type: this.connection.driver.mappedDataTypes.metadataSchema\n        }),\n        isNullable: true,\n        isPrimary\n      }, {\n        name: \"table\",\n        type: this.connection.driver.normalizeType({\n          type: this.connection.driver.mappedDataTypes.metadataTable\n        }),\n        isNullable: true,\n        isPrimary\n      }, {\n        name: \"name\",\n        type: this.connection.driver.normalizeType({\n          type: this.connection.driver.mappedDataTypes.metadataName\n        }),\n        isNullable: true,\n        isPrimary\n      }, {\n        name: \"value\",\n        type: this.connection.driver.normalizeType({\n          type: this.connection.driver.mappedDataTypes.metadataValue\n        }),\n        isNullable: true,\n        isPrimary\n      }]\n    }), true);\n  }\n\n}","map":{"version":3,"mappings":"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","names":["Table","TableColumn","TableForeignKey","TableIndex","TableUtils","TableUnique","TableCheck","TableExclusion","View","ViewUtils","DriverUtils","RdbmsSchemaBuilder","constructor","connection","Symbol","for","build","queryRunner","createQueryRunner","currentDatabase","driver","database","currentSchema","schema","isUsingTransactions","options","type","migrationsTransactionMode","beforeMigration","startTransaction","createMetadataTableIfNecessary","tablePaths","entityToSyncMetadatas","map","metadata","getTablePath","getTables","getViews","executeSchemaSyncOperationsInProperOrder","queryResultCache","synchronize","commitTransaction","error","rollbackTransaction","rollbackError","afterMigration","release","viewEntityToSyncMetadatas","length","hasGeneratedColumns","createTypeormMetadataTable","log","enableSqlMemory","getMemorySql","disableSqlMemory","entityMetadatas","filter","tableType","sort","viewMetadataCmp","some","entityMetadata","columns","column","generatedType","dropOldViews","dropOldForeignKeys","dropOldIndices","dropOldChecks","dropOldExclusions","dropCompositeUniqueConstraints","renameColumns","createNewTables","dropRemovedColumns","addNewColumns","updatePrimaryKeys","updateExistColumns","createNewIndices","createNewChecks","createNewExclusions","createCompositeUniqueConstraints","createForeignKeys","createViews","target","parsed","parseTableName","buildTableName","tableName","table","loadedTables","find","tableForeignKeysToDrop","foreignKeys","tableForeignKey","metadataFK","metadataForeignKey","name","referencedEntityMetadata","onDelete","onUpdate","logger","logSchemaBuild","dbForeignKey","join","dropForeignKeys","renameTables","renamedMetadataColumns","tableColumn","databaseName","normalizeType","isNullable","isUnique","normalizeIsUnique","renamedTableColumns","renamedColumn","clone","renameColumn","dropQueries","indices","tableIndex","indexMetadata","index","isSpatial","isFullTextColumnTypeSupported","isFulltext","columnNames","every","indexOf","dropIndex","Promise","all","isMySQLFamily","oldChecks","checks","tableCheck","checkMetadata","check","dropCheckConstraints","compositeUniques","uniques","tableUnique","uniqueMetadata","unique","dropUniqueConstraints","oldExclusions","exclusions","tableExclusion","exclusionMetadata","exclusion","dropExclusionConstraints","existTable","create","createTable","push","existView","loadedViews","view","viewExpression","expression","trim","getQuery","metadataExpression","createView","droppedViews","viewToMetadata","Map","viewMetadata","set","get","viewDependencyChain","viewWithDependencies","currentView","currentMetadata","entries","dependsOn","has","concat","droppedViewsWithDependencies","Set","reduce","segment","a","b","reverse","dropView","droppedTableColumns","columnMetadata","dropColumns","newColumnMetadatas","newTableColumnOptions","metadataColumnsToTableColumnOptions","newTableColumns","option","addColumns","primaryMetadataColumns","isPrimary","primaryTableColumns","changedPrimaryColumns","primaryMetadataColumn","createTableColumnOptions","changedColumns","findChangedColumns","changedColumn","dropColumnReferencedForeignKeys","dropColumnCompositeIndices","dropColumnCompositeUniques","newAndOldTableColumns","oldTableColumn","newTableColumn","oldColumn","newColumn","changeColumns","newIndices","createIndices","newChecks","createCheckConstraints","createUniqueConstraints","newExclusions","createExclusionConstraints","newKeys","foreignKey","dbForeignKeys","foreignKeyMetadata","key","tablePath","columnName","tablesWithFK","columnForeignKey","clonedTable","removeForeignKey","loadedTable","dependForeignKeys","referencedColumnNames","forEach","dependForeignKey","tableWithFK","relatedIndices","dropIndices","relatedUniques","typeormMetadataTable","metadataTableName","mappedDataTypes","metadataType","metadataDatabase","metadataSchema","metadataTable","metadataName","metadataValue"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\schema-builder\\RdbmsSchemaBuilder.ts"],"sourcesContent":["import { Table } from \"./table/Table\"\nimport { TableColumn } from \"./table/TableColumn\"\nimport { TableForeignKey } from \"./table/TableForeignKey\"\nimport { TableIndex } from \"./table/TableIndex\"\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\nimport { ColumnMetadata } from \"../metadata/ColumnMetadata\"\nimport { EntityMetadata } from \"../metadata/EntityMetadata\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { SchemaBuilder } from \"./SchemaBuilder\"\nimport { SqlInMemory } from \"../driver/SqlInMemory\"\nimport { TableUtils } from \"./util/TableUtils\"\nimport { TableColumnOptions } from \"./options/TableColumnOptions\"\nimport { TableUnique } from \"./table/TableUnique\"\nimport { TableCheck } from \"./table/TableCheck\"\nimport { TableExclusion } from \"./table/TableExclusion\"\nimport { View } from \"./view/View\"\nimport { ViewUtils } from \"./util/ViewUtils\"\nimport { DriverUtils } from \"../driver/DriverUtils\"\n\n/**\n * Creates complete tables schemas in the database based on the entity metadatas.\n *\n * Steps how schema is being built:\n * 1. load list of all tables with complete column and keys information from the db\n * 2. drop all (old) foreign keys that exist in the table, but does not exist in the metadata\n * 3. create new tables that does not exist in the db, but exist in the metadata\n * 4. drop all columns exist (left old) in the db table, but does not exist in the metadata\n * 5. add columns from metadata which does not exist in the table\n * 6. update all exist columns which metadata has changed\n * 7. update primary keys - update old and create new primary key from changed columns\n * 8. create foreign keys which does not exist in the table yet\n * 9. create indices which are missing in db yet, and drops indices which exist in the db, but does not exist in the metadata anymore\n */\nexport class RdbmsSchemaBuilder implements SchemaBuilder {\n    readonly \"@instanceof\" = Symbol.for(\"RdbmsSchemaBuilder\")\n\n    /**\n     * Used to execute schema creation queries in a single connection.\n     */\n    protected queryRunner: QueryRunner\n\n    private currentDatabase?: string\n\n    private currentSchema?: string\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(protected connection: DataSource) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates complete schemas for the given entity metadatas.\n     */\n    async build(): Promise<void> {\n        this.queryRunner = this.connection.createQueryRunner()\n\n        // this.connection.driver.database || this.currentDatabase;\n        this.currentDatabase = this.connection.driver.database\n        this.currentSchema = this.connection.driver.schema\n\n        // CockroachDB implements asynchronous schema sync operations which can not been executed in transaction.\n        // E.g. if you try to DROP column and ADD it again in the same transaction, crdb throws error.\n        // In Spanner queries against the INFORMATION_SCHEMA can be used in a read-only transaction,\n        // but not in a read-write transaction.\n        const isUsingTransactions =\n            !(this.connection.driver.options.type === \"cockroachdb\") &&\n            !(this.connection.driver.options.type === \"spanner\") &&\n            this.connection.options.migrationsTransactionMode !== \"none\"\n\n        await this.queryRunner.beforeMigration()\n\n        if (isUsingTransactions) {\n            await this.queryRunner.startTransaction()\n        }\n\n        try {\n            await this.createMetadataTableIfNecessary(this.queryRunner)\n            // Flush the queryrunner table & view cache\n            const tablePaths = this.entityToSyncMetadatas.map((metadata) =>\n                this.getTablePath(metadata),\n            )\n\n            await this.queryRunner.getTables(tablePaths)\n            await this.queryRunner.getViews([])\n\n            await this.executeSchemaSyncOperationsInProperOrder()\n\n            // if cache is enabled then perform cache-synchronization as well\n            if (this.connection.queryResultCache)\n                await this.connection.queryResultCache.synchronize(\n                    this.queryRunner,\n                )\n\n            if (isUsingTransactions) {\n                await this.queryRunner.commitTransaction()\n            }\n        } catch (error) {\n            try {\n                // we throw original error even if rollback thrown an error\n                if (isUsingTransactions) {\n                    await this.queryRunner.rollbackTransaction()\n                }\n            } catch (rollbackError) {}\n            throw error\n        } finally {\n            await this.queryRunner.afterMigration()\n\n            await this.queryRunner.release()\n        }\n    }\n\n    /**\n     * Create the typeorm_metadata table if necessary.\n     */\n    async createMetadataTableIfNecessary(\n        queryRunner: QueryRunner,\n    ): Promise<void> {\n        if (\n            this.viewEntityToSyncMetadatas.length > 0 ||\n            this.hasGeneratedColumns()\n        ) {\n            await this.createTypeormMetadataTable(queryRunner)\n        }\n    }\n\n    /**\n     * Returns sql queries to be executed by schema builder.\n     */\n    async log(): Promise<SqlInMemory> {\n        this.queryRunner = this.connection.createQueryRunner()\n        try {\n            // Flush the queryrunner table & view cache\n            const tablePaths = this.entityToSyncMetadatas.map((metadata) =>\n                this.getTablePath(metadata),\n            )\n            await this.queryRunner.getTables(tablePaths)\n            await this.queryRunner.getViews([])\n\n            this.queryRunner.enableSqlMemory()\n            await this.executeSchemaSyncOperationsInProperOrder()\n\n            // if cache is enabled then perform cache-synchronization as well\n            if (this.connection.queryResultCache)\n                // todo: check this functionality\n                await this.connection.queryResultCache.synchronize(\n                    this.queryRunner,\n                )\n\n            return this.queryRunner.getMemorySql()\n        } finally {\n            // its important to disable this mode despite the fact we are release query builder\n            // because there exist drivers which reuse same query runner. Also its important to disable\n            // sql memory after call of getMemorySql() method because last one flushes sql memory.\n            this.queryRunner.disableSqlMemory()\n            await this.queryRunner.release()\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Returns only entities that should be synced in the database.\n     */\n    protected get entityToSyncMetadatas(): EntityMetadata[] {\n        return this.connection.entityMetadatas.filter(\n            (metadata) =>\n                metadata.synchronize &&\n                metadata.tableType !== \"entity-child\" &&\n                metadata.tableType !== \"view\",\n        )\n    }\n\n    /**\n     * Returns only entities that should be synced in the database.\n     */\n    protected get viewEntityToSyncMetadatas(): EntityMetadata[] {\n        return (\n            this.connection.entityMetadatas\n                .filter(\n                    (metadata) =>\n                        metadata.tableType === \"view\" && metadata.synchronize,\n                )\n                // sort views in creation order by dependencies\n                .sort(ViewUtils.viewMetadataCmp)\n        )\n    }\n\n    /**\n     * Checks if there are at least one generated column.\n     */\n    protected hasGeneratedColumns(): boolean {\n        return this.connection.entityMetadatas.some((entityMetadata) => {\n            return entityMetadata.columns.some((column) => column.generatedType)\n        })\n    }\n\n    /**\n     * Executes schema sync operations in a proper order.\n     * Order of operations matter here.\n     */\n    protected async executeSchemaSyncOperationsInProperOrder(): Promise<void> {\n        await this.dropOldViews()\n        await this.dropOldForeignKeys()\n        await this.dropOldIndices()\n        await this.dropOldChecks()\n        await this.dropOldExclusions()\n        await this.dropCompositeUniqueConstraints()\n        // await this.renameTables();\n        await this.renameColumns()\n        await this.createNewTables()\n        await this.dropRemovedColumns()\n        await this.addNewColumns()\n        await this.updatePrimaryKeys()\n        await this.updateExistColumns()\n        await this.createNewIndices()\n        await this.createNewChecks()\n        await this.createNewExclusions()\n        await this.createCompositeUniqueConstraints()\n        await this.createForeignKeys()\n        await this.createViews()\n    }\n\n    private getTablePath(\n        target: EntityMetadata | Table | View | TableForeignKey | string,\n    ): string {\n        const parsed = this.connection.driver.parseTableName(target)\n\n        return this.connection.driver.buildTableName(\n            parsed.tableName,\n            parsed.schema || this.currentSchema,\n            parsed.database || this.currentDatabase,\n        )\n    }\n\n    /**\n     * Drops all (old) foreign keys that exist in the tables, but do not exist in the entity metadata.\n     */\n    protected async dropOldForeignKeys(): Promise<void> {\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find(\n                (table) =>\n                    this.getTablePath(table) === this.getTablePath(metadata),\n            )\n            if (!table) continue\n\n            // find foreign keys that exist in the schemas but does not exist in the entity metadata\n            const tableForeignKeysToDrop = table.foreignKeys.filter(\n                (tableForeignKey) => {\n                    const metadataFK = metadata.foreignKeys.find(\n                        (metadataForeignKey) =>\n                            tableForeignKey.name === metadataForeignKey.name &&\n                            this.getTablePath(tableForeignKey) ===\n                                this.getTablePath(\n                                    metadataForeignKey.referencedEntityMetadata,\n                                ),\n                    )\n                    return (\n                        !metadataFK ||\n                        (metadataFK.onDelete &&\n                            metadataFK.onDelete !== tableForeignKey.onDelete) ||\n                        (metadataFK.onUpdate &&\n                            metadataFK.onUpdate !== tableForeignKey.onUpdate)\n                    )\n                },\n            )\n            if (tableForeignKeysToDrop.length === 0) continue\n\n            this.connection.logger.logSchemaBuild(\n                `dropping old foreign keys of ${\n                    table.name\n                }: ${tableForeignKeysToDrop\n                    .map((dbForeignKey) => dbForeignKey.name)\n                    .join(\", \")}`,\n            )\n\n            // drop foreign keys from the database\n            await this.queryRunner.dropForeignKeys(\n                table,\n                tableForeignKeysToDrop,\n            )\n        }\n    }\n\n    /**\n     * Rename tables\n     */\n    protected async renameTables(): Promise<void> {\n        // for (const metadata of this.entityToSyncMetadatas) {\n        //     const table = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === this.getTablePath(metadata));\n        // }\n    }\n\n    /**\n     * Renames columns.\n     * Works if only one column per table was changed.\n     * Changes only column name. If something besides name was changed, these changes will be ignored.\n     */\n    protected async renameColumns(): Promise<void> {\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find(\n                (table) =>\n                    this.getTablePath(table) === this.getTablePath(metadata),\n            )\n            if (!table) continue\n\n            if (metadata.columns.length !== table.columns.length) continue\n\n            const renamedMetadataColumns = metadata.columns.filter((column) => {\n                return !table.columns.find((tableColumn) => {\n                    return (\n                        tableColumn.name === column.databaseName &&\n                        tableColumn.type ===\n                            this.connection.driver.normalizeType(column) &&\n                        tableColumn.isNullable === column.isNullable &&\n                        tableColumn.isUnique ===\n                            this.connection.driver.normalizeIsUnique(column)\n                    )\n                })\n            })\n\n            if (\n                renamedMetadataColumns.length === 0 ||\n                renamedMetadataColumns.length > 1\n            )\n                continue\n\n            const renamedTableColumns = table.columns.filter((tableColumn) => {\n                return !metadata.columns.find((column) => {\n                    return (\n                        column.databaseName === tableColumn.name &&\n                        this.connection.driver.normalizeType(column) ===\n                            tableColumn.type &&\n                        column.isNullable === tableColumn.isNullable &&\n                        this.connection.driver.normalizeIsUnique(column) ===\n                            tableColumn.isUnique\n                    )\n                })\n            })\n\n            if (\n                renamedTableColumns.length === 0 ||\n                renamedTableColumns.length > 1\n            )\n                continue\n\n            const renamedColumn = renamedTableColumns[0].clone()\n            renamedColumn.name = renamedMetadataColumns[0].databaseName\n\n            this.connection.logger.logSchemaBuild(\n                `renaming column \"${renamedTableColumns[0].name}\" in to \"${renamedColumn.name}\"`,\n            )\n            await this.queryRunner.renameColumn(\n                table,\n                renamedTableColumns[0],\n                renamedColumn,\n            )\n        }\n    }\n\n    protected async dropOldIndices(): Promise<void> {\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find(\n                (table) =>\n                    this.getTablePath(table) === this.getTablePath(metadata),\n            )\n            if (!table) continue\n\n            const dropQueries = table.indices\n                .filter((tableIndex) => {\n                    const indexMetadata = metadata.indices.find(\n                        (index) => index.name === tableIndex.name,\n                    )\n                    if (indexMetadata) {\n                        if (indexMetadata.synchronize === false) return false\n\n                        if (indexMetadata.isUnique !== tableIndex.isUnique)\n                            return true\n\n                        if (indexMetadata.isSpatial !== tableIndex.isSpatial)\n                            return true\n\n                        if (\n                            this.connection.driver.isFullTextColumnTypeSupported() &&\n                            indexMetadata.isFulltext !== tableIndex.isFulltext\n                        )\n                            return true\n\n                        if (\n                            indexMetadata.columns.length !==\n                            tableIndex.columnNames.length\n                        )\n                            return true\n\n                        return !indexMetadata.columns.every(\n                            (column) =>\n                                tableIndex.columnNames.indexOf(\n                                    column.databaseName,\n                                ) !== -1,\n                        )\n                    }\n\n                    return true\n                })\n                .map(async (tableIndex) => {\n                    this.connection.logger.logSchemaBuild(\n                        `dropping an index: \"${tableIndex.name}\" from table ${table.name}`,\n                    )\n                    await this.queryRunner.dropIndex(table, tableIndex)\n                })\n\n            await Promise.all(dropQueries)\n        }\n    }\n\n    protected async dropOldChecks(): Promise<void> {\n        // Mysql does not support check constraints\n        if (\n            DriverUtils.isMySQLFamily(this.connection.driver) ||\n            this.connection.driver.options.type === \"aurora-mysql\"\n        )\n            return\n\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find(\n                (table) =>\n                    this.getTablePath(table) === this.getTablePath(metadata),\n            )\n            if (!table) continue\n\n            const oldChecks = table.checks.filter((tableCheck) => {\n                return !metadata.checks.find(\n                    (checkMetadata) => checkMetadata.name === tableCheck.name,\n                )\n            })\n\n            if (oldChecks.length === 0) continue\n\n            this.connection.logger.logSchemaBuild(\n                `dropping old check constraint: ${oldChecks\n                    .map((check) => `\"${check.name}\"`)\n                    .join(\", \")} from table \"${table.name}\"`,\n            )\n            await this.queryRunner.dropCheckConstraints(table, oldChecks)\n        }\n    }\n\n    protected async dropCompositeUniqueConstraints(): Promise<void> {\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find(\n                (table) =>\n                    this.getTablePath(table) === this.getTablePath(metadata),\n            )\n            if (!table) continue\n\n            const compositeUniques = table.uniques.filter((tableUnique) => {\n                return (\n                    tableUnique.columnNames.length > 1 &&\n                    !metadata.uniques.find(\n                        (uniqueMetadata) =>\n                            uniqueMetadata.name === tableUnique.name,\n                    )\n                )\n            })\n\n            if (compositeUniques.length === 0) continue\n\n            this.connection.logger.logSchemaBuild(\n                `dropping old unique constraint: ${compositeUniques\n                    .map((unique) => `\"${unique.name}\"`)\n                    .join(\", \")} from table \"${table.name}\"`,\n            )\n            await this.queryRunner.dropUniqueConstraints(\n                table,\n                compositeUniques,\n            )\n        }\n    }\n\n    protected async dropOldExclusions(): Promise<void> {\n        // Only PostgreSQL supports exclusion constraints\n        if (!(this.connection.driver.options.type === \"postgres\")) return\n\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find(\n                (table) =>\n                    this.getTablePath(table) === this.getTablePath(metadata),\n            )\n            if (!table) continue\n\n            const oldExclusions = table.exclusions.filter((tableExclusion) => {\n                return !metadata.exclusions.find(\n                    (exclusionMetadata) =>\n                        exclusionMetadata.name === tableExclusion.name,\n                )\n            })\n\n            if (oldExclusions.length === 0) continue\n\n            this.connection.logger.logSchemaBuild(\n                `dropping old exclusion constraint: ${oldExclusions\n                    .map((exclusion) => `\"${exclusion.name}\"`)\n                    .join(\", \")} from table \"${table.name}\"`,\n            )\n            await this.queryRunner.dropExclusionConstraints(\n                table,\n                oldExclusions,\n            )\n        }\n    }\n\n    /**\n     * Creates tables that do not exist in the database yet.\n     * New tables are created without foreign and primary keys.\n     * Primary key only can be created in conclusion with auto generated column.\n     */\n    protected async createNewTables(): Promise<void> {\n        for (const metadata of this.entityToSyncMetadatas) {\n            // check if table does not exist yet\n            const existTable = this.queryRunner.loadedTables.find(\n                (table) =>\n                    this.getTablePath(table) === this.getTablePath(metadata),\n            )\n            if (existTable) continue\n\n            this.connection.logger.logSchemaBuild(\n                `creating a new table: ${this.getTablePath(metadata)}`,\n            )\n\n            // create a new table and sync it in the database\n            const table = Table.create(metadata, this.connection.driver)\n            await this.queryRunner.createTable(table, false, false)\n            this.queryRunner.loadedTables.push(table)\n        }\n    }\n\n    protected async createViews(): Promise<void> {\n        for (const metadata of this.viewEntityToSyncMetadatas) {\n            // check if view does not exist yet\n            const existView = this.queryRunner.loadedViews.find((view) => {\n                const viewExpression =\n                    typeof view.expression === \"string\"\n                        ? view.expression.trim()\n                        : view.expression(this.connection).getQuery()\n                const metadataExpression =\n                    typeof metadata.expression === \"string\"\n                        ? metadata.expression.trim()\n                        : metadata.expression!(this.connection).getQuery()\n                return (\n                    this.getTablePath(view) === this.getTablePath(metadata) &&\n                    viewExpression === metadataExpression\n                )\n            })\n            if (existView) continue\n\n            this.connection.logger.logSchemaBuild(\n                `creating a new view: ${this.getTablePath(metadata)}`,\n            )\n\n            // create a new view and sync it in the database\n            const view = View.create(metadata, this.connection.driver)\n            await this.queryRunner.createView(view)\n            this.queryRunner.loadedViews.push(view)\n        }\n    }\n\n    protected async dropOldViews(): Promise<void> {\n        const droppedViews: Array<View> = []\n        const viewEntityToSyncMetadatas = this.viewEntityToSyncMetadatas\n        // BuIld lookup cache for finding views metadata\n        const viewToMetadata = new Map<View, EntityMetadata>()\n        for (const view of this.queryRunner.loadedViews) {\n            const viewMetadata = viewEntityToSyncMetadatas.find((metadata) => {\n                return this.getTablePath(view) === this.getTablePath(metadata)\n            })\n            if (viewMetadata) {\n                viewToMetadata.set(view, viewMetadata)\n            }\n        }\n        // Gather all changed view, that need a drop\n        for (const view of this.queryRunner.loadedViews) {\n            const viewMetadata = viewToMetadata.get(view)\n            if (!viewMetadata) {\n                continue\n            }\n            const viewExpression =\n                typeof view.expression === \"string\"\n                    ? view.expression.trim()\n                    : view.expression(this.connection).getQuery()\n            const metadataExpression =\n                typeof viewMetadata.expression === \"string\"\n                    ? viewMetadata.expression.trim()\n                    : viewMetadata.expression!(this.connection).getQuery()\n\n            if (viewExpression === metadataExpression) continue\n\n            this.connection.logger.logSchemaBuild(\n                `dropping an old view: ${view.name}`,\n            )\n\n            // Collect view to be dropped\n            droppedViews.push(view)\n        }\n\n        // Helper function that for a given view, will recursively return list of the view and all views that depend on it\n        const viewDependencyChain = (view: View): View[] => {\n            // Get the view metadata\n            const viewMetadata = viewToMetadata.get(view)\n            let viewWithDependencies = [view]\n            // If no metadata is known for the view, simply return the view itself\n            if (!viewMetadata) {\n                return viewWithDependencies\n            }\n            // Iterate over all known views\n            for (const [\n                currentView,\n                currentMetadata,\n            ] of viewToMetadata.entries()) {\n                // Ignore self reference\n                if (currentView === view) {\n                    continue\n                }\n                // If the currently iterated view depends on the passed in view\n                if (\n                    currentMetadata.dependsOn &&\n                    (currentMetadata.dependsOn.has(viewMetadata.target) ||\n                        currentMetadata.dependsOn.has(viewMetadata.name))\n                ) {\n                    // Recursively add currently iterate view and its dependents\n                    viewWithDependencies = viewWithDependencies.concat(\n                        viewDependencyChain(currentView),\n                    )\n                }\n            }\n            // Return all collected views\n            return viewWithDependencies\n        }\n\n        // Collect final list of views to be dropped in a Set so there are no duplicates\n        const droppedViewsWithDependencies: Set<View> = new Set(\n            // Collect all dropped views, and their dependencies\n            droppedViews\n                .map((view) => viewDependencyChain(view))\n                // Flattened to single Array ( can be replaced with flatMap, once supported)\n                .reduce((all, segment) => {\n                    return all.concat(segment)\n                }, [])\n                // Sort the views to be dropped in creation order\n                .sort((a, b) => {\n                    return ViewUtils.viewMetadataCmp(\n                        viewToMetadata.get(a),\n                        viewToMetadata.get(b),\n                    )\n                })\n                // reverse order to get drop order\n                .reverse(),\n        )\n\n        // Finally emit all drop views\n        for (const view of droppedViewsWithDependencies) {\n            await this.queryRunner.dropView(view)\n        }\n        this.queryRunner.loadedViews = this.queryRunner.loadedViews.filter(\n            (view) => !droppedViewsWithDependencies.has(view),\n        )\n    }\n\n    /**\n     * Drops all columns that exist in the table, but does not exist in the metadata (left old).\n     * We drop their keys too, since it should be safe.\n     */\n    protected async dropRemovedColumns(): Promise<void> {\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find(\n                (table) =>\n                    this.getTablePath(table) === this.getTablePath(metadata),\n            )\n            if (!table) continue\n\n            // find columns that exist in the database but does not exist in the metadata\n            const droppedTableColumns = table.columns.filter((tableColumn) => {\n                return !metadata.columns.find(\n                    (columnMetadata) =>\n                        columnMetadata.databaseName === tableColumn.name,\n                )\n            })\n            if (droppedTableColumns.length === 0) continue\n\n            this.connection.logger.logSchemaBuild(\n                `columns dropped in ${table.name}: ` +\n                    droppedTableColumns.map((column) => column.name).join(\", \"),\n            )\n\n            // drop columns from the database\n            await this.queryRunner.dropColumns(table, droppedTableColumns)\n        }\n    }\n\n    /**\n     * Adds columns from metadata which does not exist in the table.\n     * Columns are created without keys.\n     */\n    protected async addNewColumns(): Promise<void> {\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find(\n                (table) =>\n                    this.getTablePath(table) === this.getTablePath(metadata),\n            )\n            if (!table) continue\n\n            // find which columns are new\n            const newColumnMetadatas = metadata.columns.filter(\n                (columnMetadata) => {\n                    return !table.columns.find(\n                        (tableColumn) =>\n                            tableColumn.name === columnMetadata.databaseName,\n                    )\n                },\n            )\n            if (newColumnMetadatas.length === 0) continue\n\n            // create columns in the database\n            const newTableColumnOptions =\n                this.metadataColumnsToTableColumnOptions(newColumnMetadatas)\n            const newTableColumns = newTableColumnOptions.map(\n                (option) => new TableColumn(option),\n            )\n\n            if (newTableColumns.length === 0) continue\n\n            this.connection.logger.logSchemaBuild(\n                `new columns added: ` +\n                    newColumnMetadatas\n                        .map((column) => column.databaseName)\n                        .join(\", \"),\n            )\n            await this.queryRunner.addColumns(table, newTableColumns)\n        }\n    }\n\n    /**\n     * Updates composite primary keys.\n     */\n    protected async updatePrimaryKeys(): Promise<void> {\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find(\n                (table) =>\n                    this.getTablePath(table) === this.getTablePath(metadata),\n            )\n            if (!table) continue\n\n            const primaryMetadataColumns = metadata.columns.filter(\n                (column) => column.isPrimary,\n            )\n            const primaryTableColumns = table.columns.filter(\n                (column) => column.isPrimary,\n            )\n            if (\n                primaryTableColumns.length !== primaryMetadataColumns.length &&\n                primaryMetadataColumns.length > 1\n            ) {\n                const changedPrimaryColumns = primaryMetadataColumns.map(\n                    (primaryMetadataColumn) => {\n                        return new TableColumn(\n                            TableUtils.createTableColumnOptions(\n                                primaryMetadataColumn,\n                                this.connection.driver,\n                            ),\n                        )\n                    },\n                )\n                await this.queryRunner.updatePrimaryKeys(\n                    table,\n                    changedPrimaryColumns,\n                )\n            }\n        }\n    }\n\n    /**\n     * Update all exist columns which metadata has changed.\n     * Still don't create keys. Also we don't touch foreign keys of the changed columns.\n     */\n    protected async updateExistColumns(): Promise<void> {\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find(\n                (table) =>\n                    this.getTablePath(table) === this.getTablePath(metadata),\n            )\n            if (!table) continue\n\n            const changedColumns = this.connection.driver.findChangedColumns(\n                table.columns,\n                metadata.columns,\n            )\n            if (changedColumns.length === 0) continue\n\n            // drop all foreign keys that point to this column\n            for (const changedColumn of changedColumns) {\n                await this.dropColumnReferencedForeignKeys(\n                    this.getTablePath(metadata),\n                    changedColumn.databaseName,\n                )\n            }\n\n            // drop all composite indices related to this column\n            for (const changedColumn of changedColumns) {\n                await this.dropColumnCompositeIndices(\n                    this.getTablePath(metadata),\n                    changedColumn.databaseName,\n                )\n            }\n\n            // drop all composite uniques related to this column\n            // Mysql does not support unique constraints.\n            if (\n                !(\n                    DriverUtils.isMySQLFamily(this.connection.driver) ||\n                    this.connection.driver.options.type === \"aurora-mysql\" ||\n                    this.connection.driver.options.type === \"spanner\"\n                )\n            ) {\n                for (const changedColumn of changedColumns) {\n                    await this.dropColumnCompositeUniques(\n                        this.getTablePath(metadata),\n                        changedColumn.databaseName,\n                    )\n                }\n            }\n\n            // generate a map of new/old columns\n            const newAndOldTableColumns = changedColumns.map(\n                (changedColumn) => {\n                    const oldTableColumn = table.columns.find(\n                        (column) => column.name === changedColumn.databaseName,\n                    )!\n                    const newTableColumnOptions =\n                        TableUtils.createTableColumnOptions(\n                            changedColumn,\n                            this.connection.driver,\n                        )\n                    const newTableColumn = new TableColumn(\n                        newTableColumnOptions,\n                    )\n\n                    return {\n                        oldColumn: oldTableColumn,\n                        newColumn: newTableColumn,\n                    }\n                },\n            )\n\n            if (newAndOldTableColumns.length === 0) continue\n\n            this.connection.logger.logSchemaBuild(\n                `columns changed in \"${table.name}\". updating: ` +\n                    changedColumns\n                        .map((column) => column.databaseName)\n                        .join(\", \"),\n            )\n            await this.queryRunner.changeColumns(table, newAndOldTableColumns)\n        }\n    }\n\n    /**\n     * Creates composite indices which are missing in db yet.\n     */\n    protected async createNewIndices(): Promise<void> {\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find(\n                (table) =>\n                    this.getTablePath(table) === this.getTablePath(metadata),\n            )\n            if (!table) continue\n\n            const newIndices = metadata.indices\n                .filter(\n                    (indexMetadata) =>\n                        !table.indices.find(\n                            (tableIndex) =>\n                                tableIndex.name === indexMetadata.name,\n                        ) && indexMetadata.synchronize === true,\n                )\n                .map((indexMetadata) => TableIndex.create(indexMetadata))\n\n            if (newIndices.length === 0) continue\n\n            this.connection.logger.logSchemaBuild(\n                `adding new indices ${newIndices\n                    .map((index) => `\"${index.name}\"`)\n                    .join(\", \")} in table \"${table.name}\"`,\n            )\n            await this.queryRunner.createIndices(table, newIndices)\n        }\n    }\n\n    protected async createNewChecks(): Promise<void> {\n        // Mysql does not support check constraints\n        if (\n            DriverUtils.isMySQLFamily(this.connection.driver) ||\n            this.connection.driver.options.type === \"aurora-mysql\"\n        )\n            return\n\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find(\n                (table) =>\n                    this.getTablePath(table) === this.getTablePath(metadata),\n            )\n            if (!table) continue\n\n            const newChecks = metadata.checks\n                .filter(\n                    (checkMetadata) =>\n                        !table.checks.find(\n                            (tableCheck) =>\n                                tableCheck.name === checkMetadata.name,\n                        ),\n                )\n                .map((checkMetadata) => TableCheck.create(checkMetadata))\n\n            if (newChecks.length === 0) continue\n\n            this.connection.logger.logSchemaBuild(\n                `adding new check constraints: ${newChecks\n                    .map((index) => `\"${index.name}\"`)\n                    .join(\", \")} in table \"${table.name}\"`,\n            )\n            await this.queryRunner.createCheckConstraints(table, newChecks)\n        }\n    }\n\n    /**\n     * Creates composite uniques which are missing in db yet.\n     */\n    protected async createCompositeUniqueConstraints(): Promise<void> {\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find(\n                (table) =>\n                    this.getTablePath(table) === this.getTablePath(metadata),\n            )\n            if (!table) continue\n\n            const compositeUniques = metadata.uniques\n                .filter(\n                    (uniqueMetadata) =>\n                        uniqueMetadata.columns.length > 1 &&\n                        !table.uniques.find(\n                            (tableUnique) =>\n                                tableUnique.name === uniqueMetadata.name,\n                        ),\n                )\n                .map((uniqueMetadata) => TableUnique.create(uniqueMetadata))\n\n            if (compositeUniques.length === 0) continue\n\n            this.connection.logger.logSchemaBuild(\n                `adding new unique constraints: ${compositeUniques\n                    .map((unique) => `\"${unique.name}\"`)\n                    .join(\", \")} in table \"${table.name}\"`,\n            )\n            await this.queryRunner.createUniqueConstraints(\n                table,\n                compositeUniques,\n            )\n        }\n    }\n\n    /**\n     * Creates exclusions which are missing in db yet.\n     */\n    protected async createNewExclusions(): Promise<void> {\n        // Only PostgreSQL supports exclusion constraints\n        if (!(this.connection.driver.options.type === \"postgres\")) return\n\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find(\n                (table) =>\n                    this.getTablePath(table) === this.getTablePath(metadata),\n            )\n            if (!table) continue\n\n            const newExclusions = metadata.exclusions\n                .filter(\n                    (exclusionMetadata) =>\n                        !table.exclusions.find(\n                            (tableExclusion) =>\n                                tableExclusion.name === exclusionMetadata.name,\n                        ),\n                )\n                .map((exclusionMetadata) =>\n                    TableExclusion.create(exclusionMetadata),\n                )\n\n            if (newExclusions.length === 0) continue\n\n            this.connection.logger.logSchemaBuild(\n                `adding new exclusion constraints: ${newExclusions\n                    .map((exclusion) => `\"${exclusion.name}\"`)\n                    .join(\", \")} in table \"${table.name}\"`,\n            )\n            await this.queryRunner.createExclusionConstraints(\n                table,\n                newExclusions,\n            )\n        }\n    }\n\n    /**\n     * Creates foreign keys which does not exist in the table yet.\n     */\n    protected async createForeignKeys(): Promise<void> {\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find(\n                (table) =>\n                    this.getTablePath(table) === this.getTablePath(metadata),\n            )\n            if (!table) continue\n\n            const newKeys = metadata.foreignKeys.filter((foreignKey) => {\n                return !table.foreignKeys.find(\n                    (dbForeignKey) =>\n                        dbForeignKey.name === foreignKey.name &&\n                        this.getTablePath(dbForeignKey) ===\n                            this.getTablePath(\n                                foreignKey.referencedEntityMetadata,\n                            ),\n                )\n            })\n            if (newKeys.length === 0) continue\n\n            const dbForeignKeys = newKeys.map((foreignKeyMetadata) =>\n                TableForeignKey.create(\n                    foreignKeyMetadata,\n                    this.connection.driver,\n                ),\n            )\n            this.connection.logger.logSchemaBuild(\n                `creating a foreign keys: ${newKeys\n                    .map((key) => key.name)\n                    .join(\", \")} on table \"${table.name}\"`,\n            )\n            await this.queryRunner.createForeignKeys(table, dbForeignKeys)\n        }\n    }\n\n    /**\n     * Drops all foreign keys where given column of the given table is being used.\n     */\n    protected async dropColumnReferencedForeignKeys(\n        tablePath: string,\n        columnName: string,\n    ): Promise<void> {\n        const table = this.queryRunner.loadedTables.find(\n            (table) => this.getTablePath(table) === tablePath,\n        )\n        if (!table) return\n\n        const tablesWithFK: Table[] = []\n        const columnForeignKey = table.foreignKeys.find(\n            (foreignKey) => foreignKey.columnNames.indexOf(columnName) !== -1,\n        )\n        if (columnForeignKey) {\n            const clonedTable = table.clone()\n            clonedTable.foreignKeys = [columnForeignKey]\n            tablesWithFK.push(clonedTable)\n            table.removeForeignKey(columnForeignKey)\n        }\n\n        for (const loadedTable of this.queryRunner.loadedTables) {\n            const dependForeignKeys = loadedTable.foreignKeys.filter(\n                (foreignKey) => {\n                    return (\n                        this.getTablePath(foreignKey) === tablePath &&\n                        foreignKey.referencedColumnNames.indexOf(columnName) !==\n                            -1\n                    )\n                },\n            )\n\n            if (dependForeignKeys.length > 0) {\n                const clonedTable = loadedTable.clone()\n                clonedTable.foreignKeys = dependForeignKeys\n                tablesWithFK.push(clonedTable)\n                dependForeignKeys.forEach((dependForeignKey) =>\n                    loadedTable.removeForeignKey(dependForeignKey),\n                )\n            }\n        }\n\n        if (tablesWithFK.length > 0) {\n            for (const tableWithFK of tablesWithFK) {\n                this.connection.logger.logSchemaBuild(\n                    `dropping related foreign keys of ${\n                        tableWithFK.name\n                    }: ${tableWithFK.foreignKeys\n                        .map((foreignKey) => foreignKey.name)\n                        .join(\", \")}`,\n                )\n                await this.queryRunner.dropForeignKeys(\n                    tableWithFK,\n                    tableWithFK.foreignKeys,\n                )\n            }\n        }\n    }\n\n    /**\n     * Drops all composite indices, related to given column.\n     */\n    protected async dropColumnCompositeIndices(\n        tablePath: string,\n        columnName: string,\n    ): Promise<void> {\n        const table = this.queryRunner.loadedTables.find(\n            (table) => this.getTablePath(table) === tablePath,\n        )\n        if (!table) return\n\n        const relatedIndices = table.indices.filter(\n            (index) =>\n                index.columnNames.length > 1 &&\n                index.columnNames.indexOf(columnName) !== -1,\n        )\n        if (relatedIndices.length === 0) return\n\n        this.connection.logger.logSchemaBuild(\n            `dropping related indices of \"${tablePath}\".\"${columnName}\": ${relatedIndices\n                .map((index) => index.name)\n                .join(\", \")}`,\n        )\n        await this.queryRunner.dropIndices(table, relatedIndices)\n    }\n\n    /**\n     * Drops all composite uniques, related to given column.\n     */\n    protected async dropColumnCompositeUniques(\n        tablePath: string,\n        columnName: string,\n    ): Promise<void> {\n        const table = this.queryRunner.loadedTables.find(\n            (table) => this.getTablePath(table) === tablePath,\n        )\n        if (!table) return\n\n        const relatedUniques = table.uniques.filter(\n            (unique) =>\n                unique.columnNames.length > 1 &&\n                unique.columnNames.indexOf(columnName) !== -1,\n        )\n        if (relatedUniques.length === 0) return\n\n        this.connection.logger.logSchemaBuild(\n            `dropping related unique constraints of \"${tablePath}\".\"${columnName}\": ${relatedUniques\n                .map((unique) => unique.name)\n                .join(\", \")}`,\n        )\n        await this.queryRunner.dropUniqueConstraints(table, relatedUniques)\n    }\n\n    /**\n     * Creates new columns from the given column metadatas.\n     */\n    protected metadataColumnsToTableColumnOptions(\n        columns: ColumnMetadata[],\n    ): TableColumnOptions[] {\n        return columns.map((columnMetadata) =>\n            TableUtils.createTableColumnOptions(\n                columnMetadata,\n                this.connection.driver,\n            ),\n        )\n    }\n\n    /**\n     * Creates typeorm service table for storing user defined Views and generate columns.\n     */\n    protected async createTypeormMetadataTable(queryRunner: QueryRunner) {\n        const schema = this.currentSchema\n        const database = this.currentDatabase\n        const typeormMetadataTable = this.connection.driver.buildTableName(\n            this.connection.metadataTableName,\n            schema,\n            database,\n        )\n\n        // Spanner requires at least one primary key in a table.\n        // Since we don't have unique column in \"typeorm_metadata\" table\n        // and we should avoid breaking changes, we mark all columns as primary for Spanner driver.\n        const isPrimary = this.connection.driver.options.type === \"spanner\"\n        await queryRunner.createTable(\n            new Table({\n                database: database,\n                schema: schema,\n                name: typeormMetadataTable,\n                columns: [\n                    {\n                        name: \"type\",\n                        type: this.connection.driver.normalizeType({\n                            type: this.connection.driver.mappedDataTypes\n                                .metadataType,\n                        }),\n                        isNullable: false,\n                        isPrimary,\n                    },\n                    {\n                        name: \"database\",\n                        type: this.connection.driver.normalizeType({\n                            type: this.connection.driver.mappedDataTypes\n                                .metadataDatabase,\n                        }),\n                        isNullable: true,\n                        isPrimary,\n                    },\n                    {\n                        name: \"schema\",\n                        type: this.connection.driver.normalizeType({\n                            type: this.connection.driver.mappedDataTypes\n                                .metadataSchema,\n                        }),\n                        isNullable: true,\n                        isPrimary,\n                    },\n                    {\n                        name: \"table\",\n                        type: this.connection.driver.normalizeType({\n                            type: this.connection.driver.mappedDataTypes\n                                .metadataTable,\n                        }),\n                        isNullable: true,\n                        isPrimary,\n                    },\n                    {\n                        name: \"name\",\n                        type: this.connection.driver.normalizeType({\n                            type: this.connection.driver.mappedDataTypes\n                                .metadataName,\n                        }),\n                        isNullable: true,\n                        isPrimary,\n                    },\n                    {\n                        name: \"value\",\n                        type: this.connection.driver.normalizeType({\n                            type: this.connection.driver.mappedDataTypes\n                                .metadataValue,\n                        }),\n                        isNullable: true,\n                        isPrimary,\n                    },\n                ],\n            }),\n            true,\n        )\n    }\n}\n"]},"metadata":{},"sourceType":"module"}