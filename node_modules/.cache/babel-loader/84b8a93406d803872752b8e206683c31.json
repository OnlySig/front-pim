{"ast":null,"code":"/**\n * Container to be used by this library for inversion control. If container was not implicitly set then by default\n * container simply creates a new instance of the given class.\n *\n * @deprecated\n */\nconst defaultContainer = new class {\n  constructor() {\n    this.instances = [];\n  }\n\n  get(someClass) {\n    let instance = this.instances.find(i => i.type === someClass);\n\n    if (!instance) {\n      instance = {\n        type: someClass,\n        object: new someClass()\n      };\n      this.instances.push(instance);\n    }\n\n    return instance.object;\n  }\n\n}();\nlet userContainer;\nlet userContainerOptions;\n/**\n * Sets container to be used by this library.\n *\n * @deprecated\n */\n\nexport function useContainer(iocContainer, options) {\n  userContainer = iocContainer;\n  userContainerOptions = options;\n}\n/**\n * Gets the IOC container used by this library.\n *\n * @deprecated\n */\n\nexport function getFromContainer(someClass) {\n  if (userContainer) {\n    try {\n      const instance = userContainer.get(someClass);\n      if (instance) return instance;\n      if (!userContainerOptions || !userContainerOptions.fallback) return instance;\n    } catch (error) {\n      if (!userContainerOptions || !userContainerOptions.fallbackOnErrors) throw error;\n    }\n  }\n\n  return defaultContainer.get(someClass);\n}","map":{"version":3,"mappings":"AA6BA;;;;;;AAMA,MAAMA,gBAAgB,GAAuB,IAAK;EAAAC;IAGtC,iBAA+C,EAA/C;EAcX;;EAZGC,GAAG,CAAIC,SAAJ,EAA+B;IAC9B,IAAIC,QAAQ,GAAG,KAAKC,SAAL,CAAeC,IAAf,CAAqBC,CAAD,IAAOA,CAAC,CAACC,IAAF,KAAWL,SAAtC,CAAf;;IACA,IAAI,CAACC,QAAL,EAAe;MACXA,QAAQ,GAAG;QACPI,IAAI,EAAEL,SADC;QAEPM,MAAM,EAAE,IAAKN,SAAL;MAFD,CAAX;MAIA,KAAKE,SAAL,CAAeK,IAAf,CAAoBN,QAApB;IACH;;IAED,OAAOA,QAAQ,CAACK,MAAhB;EACH;;AAhB6C,CAAL,EAA7C;AAmBA,IAAIE,aAAJ;AACA,IAAIC,oBAAJ;AAEA;;;;;;AAKA,OAAM,SAAUC,YAAV,CACFC,YADE,EAEFC,OAFE,EAE2B;EAE7BJ,aAAa,GAAGG,YAAhB;EACAF,oBAAoB,GAAGG,OAAvB;AACH;AAED;;;;;;AAKA,OAAM,SAAUC,gBAAV,CAA8Bb,SAA9B,EAAyD;EAC3D,IAAIQ,aAAJ,EAAmB;IACf,IAAI;MACA,MAAMP,QAAQ,GAAGO,aAAa,CAACT,GAAd,CAAkBC,SAAlB,CAAjB;MACA,IAAIC,QAAJ,EAAc,OAAOA,QAAP;MAEd,IAAI,CAACQ,oBAAD,IAAyB,CAACA,oBAAoB,CAACK,QAAnD,EACI,OAAOb,QAAP;IACP,CAND,CAME,OAAOc,KAAP,EAAc;MACZ,IAAI,CAACN,oBAAD,IAAyB,CAACA,oBAAoB,CAACO,gBAAnD,EACI,MAAMD,KAAN;IACP;EACJ;;EACD,OAAOlB,gBAAgB,CAACE,GAAjB,CAAwBC,SAAxB,CAAP;AACH","names":["defaultContainer","constructor","get","someClass","instance","instances","find","i","type","object","push","userContainer","userContainerOptions","useContainer","iocContainer","options","getFromContainer","fallback","error","fallbackOnErrors"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\container.ts"],"sourcesContent":["/**\n * Container options.\n *\n * @deprecated\n */\nexport interface UseContainerOptions {\n    /**\n     * If set to true, then default container will be used in the case if given container haven't returned anything.\n     */\n    fallback?: boolean\n\n    /**\n     * If set to true, then default container will be used in the case if given container thrown an exception.\n     */\n    fallbackOnErrors?: boolean\n}\n\n/**\n * @deprecated\n */\nexport type ContainedType<T> = { new (...args: any[]): T } | Function\n\n/**\n * @deprecated\n */\nexport interface ContainerInterface {\n    get<T>(someClass: ContainedType<T>): T\n}\n\n/**\n * Container to be used by this library for inversion control. If container was not implicitly set then by default\n * container simply creates a new instance of the given class.\n *\n * @deprecated\n */\nconst defaultContainer: ContainerInterface = new (class\n    implements ContainerInterface\n{\n    private instances: { type: Function; object: any }[] = []\n\n    get<T>(someClass: ContainedType<T>): T {\n        let instance = this.instances.find((i) => i.type === someClass)\n        if (!instance) {\n            instance = {\n                type: someClass,\n                object: new (someClass as new () => T)(),\n            }\n            this.instances.push(instance)\n        }\n\n        return instance.object\n    }\n})()\n\nlet userContainer: ContainerInterface\nlet userContainerOptions: UseContainerOptions | undefined\n\n/**\n * Sets container to be used by this library.\n *\n * @deprecated\n */\nexport function useContainer(\n    iocContainer: ContainerInterface,\n    options?: UseContainerOptions,\n) {\n    userContainer = iocContainer\n    userContainerOptions = options\n}\n\n/**\n * Gets the IOC container used by this library.\n *\n * @deprecated\n */\nexport function getFromContainer<T>(someClass: ContainedType<T>): T {\n    if (userContainer) {\n        try {\n            const instance = userContainer.get(someClass)\n            if (instance) return instance\n\n            if (!userContainerOptions || !userContainerOptions.fallback)\n                return instance\n        } catch (error) {\n            if (!userContainerOptions || !userContainerOptions.fallbackOnErrors)\n                throw error\n        }\n    }\n    return defaultContainer.get<T>(someClass)\n}\n"]},"metadata":{},"sourceType":"module"}