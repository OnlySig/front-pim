{"ast":null,"code":"import { AbstractSqliteDriver } from \"../sqlite-abstract/AbstractSqliteDriver\";\nimport { SqljsQueryRunner } from \"./SqljsQueryRunner\";\nimport { DriverPackageNotInstalledError } from \"../../error/DriverPackageNotInstalledError\";\nimport { DriverOptionNotSetError } from \"../../error/DriverOptionNotSetError\";\nimport { PlatformTools } from \"../../platform/PlatformTools\";\nimport { OrmUtils } from \"../../util/OrmUtils\";\nimport { TypeORMError } from \"../../error\";\nexport class SqljsDriver extends AbstractSqliteDriver {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection) {\n    super(connection); // If autoSave is enabled by user, location or autoSaveCallback have to be set\n    // because either autoSave saves to location or calls autoSaveCallback.\n\n    if (this.options.autoSave && !this.options.location && !this.options.autoSaveCallback) {\n      throw new DriverOptionNotSetError(`location or autoSaveCallback`);\n    } // load sql.js package\n\n\n    this.loadDependencies();\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Performs connection to the database.\n   */\n\n\n  async connect() {\n    this.databaseConnection = await this.createDatabaseConnection();\n  }\n  /**\n   * Closes connection with database.\n   */\n\n\n  async disconnect() {\n    this.queryRunner = undefined;\n    this.databaseConnection.close();\n  }\n  /**\n   * Creates a query runner used to execute database queries.\n   */\n\n\n  createQueryRunner(mode) {\n    if (!this.queryRunner) this.queryRunner = new SqljsQueryRunner(this);\n    return this.queryRunner;\n  }\n  /**\n   * Loads a database from a given file (Node.js), local storage key (browser) or array.\n   * This will delete the current database!\n   */\n\n\n  async load(fileNameOrLocalStorageOrData) {\n    let checkIfFileOrLocalStorageExists = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    if (typeof fileNameOrLocalStorageOrData === \"string\") {\n      // content has to be loaded\n      if (PlatformTools.type === \"node\") {\n        // Node.js\n        // fileNameOrLocalStorageOrData should be a path to the file\n        if (PlatformTools.fileExist(fileNameOrLocalStorageOrData)) {\n          const database = PlatformTools.readFileSync(fileNameOrLocalStorageOrData);\n          return this.createDatabaseConnectionWithImport(database);\n        } else if (checkIfFileOrLocalStorageExists) {\n          throw new TypeORMError(`File ${fileNameOrLocalStorageOrData} does not exist`);\n        } else {\n          // File doesn't exist and checkIfFileOrLocalStorageExists is set to false.\n          // Therefore open a database without importing an existing file.\n          // File will be written on first write operation.\n          return this.createDatabaseConnectionWithImport();\n        }\n      } else {\n        // browser\n        // fileNameOrLocalStorageOrData should be a local storage / indexedDB key\n        let localStorageContent = null;\n\n        if (this.options.useLocalForage) {\n          if (window.localforage) {\n            localStorageContent = await window.localforage.getItem(fileNameOrLocalStorageOrData);\n          } else {\n            throw new TypeORMError(`localforage is not defined - please import localforage.js into your site`);\n          }\n        } else {\n          localStorageContent = PlatformTools.getGlobalVariable().localStorage.getItem(fileNameOrLocalStorageOrData);\n        }\n\n        if (localStorageContent != null) {\n          // localStorage value exists.\n          return this.createDatabaseConnectionWithImport(JSON.parse(localStorageContent));\n        } else if (checkIfFileOrLocalStorageExists) {\n          throw new TypeORMError(`File ${fileNameOrLocalStorageOrData} does not exist`);\n        } else {\n          // localStorage value doesn't exist and checkIfFileOrLocalStorageExists is set to false.\n          // Therefore open a database without importing anything.\n          // localStorage value will be written on first write operation.\n          return this.createDatabaseConnectionWithImport();\n        }\n      }\n    } else {\n      return this.createDatabaseConnectionWithImport(fileNameOrLocalStorageOrData);\n    }\n  }\n  /**\n   * Saved the current database to the given file (Node.js), local storage key (browser) or\n   * indexedDB key (browser with enabled useLocalForage option).\n   * If no location path is given, the location path in the options (if specified) will be used.\n   */\n\n\n  async save(location) {\n    if (!location && !this.options.location) {\n      throw new TypeORMError(`No location is set, specify a location parameter or add the location option to your configuration`);\n    }\n\n    let path = \"\";\n\n    if (location) {\n      path = location;\n    } else if (this.options.location) {\n      path = this.options.location;\n    }\n\n    if (PlatformTools.type === \"node\") {\n      try {\n        const content = Buffer.from(this.databaseConnection.export());\n        await PlatformTools.writeFile(path, content);\n      } catch (e) {\n        throw new TypeORMError(`Could not save database, error: ${e}`);\n      }\n    } else {\n      const database = this.databaseConnection.export(); // convert Uint8Array to number array to improve local-storage storage\n\n      const databaseArray = [].slice.call(database);\n\n      if (this.options.useLocalForage) {\n        if (window.localforage) {\n          await window.localforage.setItem(path, JSON.stringify(databaseArray));\n        } else {\n          throw new TypeORMError(`localforage is not defined - please import localforage.js into your site`);\n        }\n      } else {\n        PlatformTools.getGlobalVariable().localStorage.setItem(path, JSON.stringify(databaseArray));\n      }\n    }\n  }\n  /**\n   * This gets called by the QueryRunner when a change to the database is made.\n   * If a custom autoSaveCallback is specified, it get's called with the database as Uint8Array,\n   * otherwise the save method is called which saves it to file (Node.js), local storage (browser)\n   * or indexedDB (browser with enabled useLocalForage option).\n   * Don't auto-save when in transaction as the call to export will end the current transaction\n   */\n\n\n  async autoSave() {\n    var _a;\n\n    if (this.options.autoSave && !((_a = this.queryRunner) === null || _a === void 0 ? void 0 : _a.isTransactionActive)) {\n      if (this.options.autoSaveCallback) {\n        await this.options.autoSaveCallback(this.export());\n      } else {\n        await this.save();\n      }\n    }\n  }\n  /**\n   * Returns the current database as Uint8Array.\n   */\n\n\n  export() {\n    return this.databaseConnection.export();\n  }\n  /**\n   * Creates generated map of values generated or returned by database after INSERT query.\n   */\n\n\n  createGeneratedMap(metadata, insertResult) {\n    const generatedMap = metadata.generatedColumns.reduce((map, generatedColumn) => {\n      // seems to be the only way to get the inserted id, see https://github.com/kripken/sql.js/issues/77\n      if (generatedColumn.isPrimary && generatedColumn.generationStrategy === \"increment\") {\n        const query = \"SELECT last_insert_rowid()\";\n\n        try {\n          let result = this.databaseConnection.exec(query);\n          this.connection.logger.logQuery(query);\n          return OrmUtils.mergeDeep(map, generatedColumn.createValueMap(result[0].values[0][0]));\n        } catch (e) {\n          this.connection.logger.logQueryError(e, query, []);\n        }\n      }\n\n      return map;\n    }, {});\n    return Object.keys(generatedMap).length > 0 ? generatedMap : undefined;\n  } // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Creates connection with the database.\n   * If the location option is set, the database is loaded first.\n   */\n\n\n  createDatabaseConnection() {\n    if (this.options.location) {\n      return this.load(this.options.location, false);\n    }\n\n    return this.createDatabaseConnectionWithImport(this.options.database);\n  }\n  /**\n   * Creates connection with an optional database.\n   * If database is specified it is loaded, otherwise a new empty database is created.\n   */\n\n\n  async createDatabaseConnectionWithImport(database) {\n    // sql.js < 1.0 exposes an object with a `Database` method.\n    const isLegacyVersion = typeof this.sqlite.Database === \"function\";\n    const sqlite = isLegacyVersion ? this.sqlite : await this.sqlite(this.options.sqlJsConfig);\n\n    if (database && database.length > 0) {\n      this.databaseConnection = new sqlite.Database(database);\n    } else {\n      this.databaseConnection = new sqlite.Database();\n    }\n\n    this.databaseConnection.exec(`PRAGMA foreign_keys = ON`);\n    return this.databaseConnection;\n  }\n  /**\n   * If driver dependency is not given explicitly, then try to load it via \"require\".\n   */\n\n\n  loadDependencies() {\n    if (PlatformTools.type === \"browser\") {\n      const sqlite = this.options.driver || window.SQL;\n      this.sqlite = sqlite;\n    } else {\n      try {\n        const sqlite = this.options.driver || PlatformTools.load(\"sql.js\");\n        this.sqlite = sqlite;\n      } catch (e) {\n        throw new DriverPackageNotInstalledError(\"sql.js\", \"sql.js\");\n      }\n    }\n  }\n\n}","map":{"version":3,"mappings":"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","names":["AbstractSqliteDriver","SqljsQueryRunner","DriverPackageNotInstalledError","DriverOptionNotSetError","PlatformTools","OrmUtils","TypeORMError","SqljsDriver","constructor","connection","options","autoSave","location","autoSaveCallback","loadDependencies","connect","databaseConnection","createDatabaseConnection","disconnect","queryRunner","undefined","close","createQueryRunner","mode","load","fileNameOrLocalStorageOrData","checkIfFileOrLocalStorageExists","type","fileExist","database","readFileSync","createDatabaseConnectionWithImport","localStorageContent","useLocalForage","window","localforage","getItem","getGlobalVariable","localStorage","JSON","parse","save","path","content","Buffer","from","export","writeFile","e","databaseArray","slice","call","setItem","stringify","_a","isTransactionActive","createGeneratedMap","metadata","insertResult","generatedMap","generatedColumns","reduce","map","generatedColumn","isPrimary","generationStrategy","query","result","exec","logger","logQuery","mergeDeep","createValueMap","values","logQueryError","Object","keys","length","isLegacyVersion","sqlite","Database","sqlJsConfig","driver","SQL"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\driver\\sqljs\\SqljsDriver.ts"],"sourcesContent":["import { AbstractSqliteDriver } from \"../sqlite-abstract/AbstractSqliteDriver\"\nimport { SqljsConnectionOptions } from \"./SqljsConnectionOptions\"\nimport { SqljsQueryRunner } from \"./SqljsQueryRunner\"\nimport { QueryRunner } from \"../../query-runner/QueryRunner\"\nimport { DataSource } from \"../../data-source/DataSource\"\nimport { DriverPackageNotInstalledError } from \"../../error/DriverPackageNotInstalledError\"\nimport { DriverOptionNotSetError } from \"../../error/DriverOptionNotSetError\"\nimport { PlatformTools } from \"../../platform/PlatformTools\"\nimport { EntityMetadata } from \"../../metadata/EntityMetadata\"\nimport { OrmUtils } from \"../../util/OrmUtils\"\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { ReplicationMode } from \"../types/ReplicationMode\"\nimport { TypeORMError } from \"../../error\"\n\n// This is needed to satisfy the typescript compiler.\ninterface Window {\n    SQL: any\n    localforage: any\n}\ndeclare let window: Window\n\nexport class SqljsDriver extends AbstractSqliteDriver {\n    // The driver specific options.\n    options: SqljsConnectionOptions\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(connection: DataSource) {\n        super(connection)\n\n        // If autoSave is enabled by user, location or autoSaveCallback have to be set\n        // because either autoSave saves to location or calls autoSaveCallback.\n        if (\n            this.options.autoSave &&\n            !this.options.location &&\n            !this.options.autoSaveCallback\n        ) {\n            throw new DriverOptionNotSetError(`location or autoSaveCallback`)\n        }\n\n        // load sql.js package\n        this.loadDependencies()\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Performs connection to the database.\n     */\n    async connect(): Promise<void> {\n        this.databaseConnection = await this.createDatabaseConnection()\n    }\n\n    /**\n     * Closes connection with database.\n     */\n    async disconnect(): Promise<void> {\n        this.queryRunner = undefined\n        this.databaseConnection.close()\n    }\n\n    /**\n     * Creates a query runner used to execute database queries.\n     */\n    createQueryRunner(mode: ReplicationMode): QueryRunner {\n        if (!this.queryRunner) this.queryRunner = new SqljsQueryRunner(this)\n\n        return this.queryRunner\n    }\n\n    /**\n     * Loads a database from a given file (Node.js), local storage key (browser) or array.\n     * This will delete the current database!\n     */\n    async load(\n        fileNameOrLocalStorageOrData: string | Uint8Array,\n        checkIfFileOrLocalStorageExists: boolean = true,\n    ): Promise<any> {\n        if (typeof fileNameOrLocalStorageOrData === \"string\") {\n            // content has to be loaded\n            if (PlatformTools.type === \"node\") {\n                // Node.js\n                // fileNameOrLocalStorageOrData should be a path to the file\n                if (PlatformTools.fileExist(fileNameOrLocalStorageOrData)) {\n                    const database = PlatformTools.readFileSync(\n                        fileNameOrLocalStorageOrData,\n                    )\n                    return this.createDatabaseConnectionWithImport(database)\n                } else if (checkIfFileOrLocalStorageExists) {\n                    throw new TypeORMError(\n                        `File ${fileNameOrLocalStorageOrData} does not exist`,\n                    )\n                } else {\n                    // File doesn't exist and checkIfFileOrLocalStorageExists is set to false.\n                    // Therefore open a database without importing an existing file.\n                    // File will be written on first write operation.\n                    return this.createDatabaseConnectionWithImport()\n                }\n            } else {\n                // browser\n                // fileNameOrLocalStorageOrData should be a local storage / indexedDB key\n                let localStorageContent = null\n                if (this.options.useLocalForage) {\n                    if (window.localforage) {\n                        localStorageContent = await window.localforage.getItem(\n                            fileNameOrLocalStorageOrData,\n                        )\n                    } else {\n                        throw new TypeORMError(\n                            `localforage is not defined - please import localforage.js into your site`,\n                        )\n                    }\n                } else {\n                    localStorageContent =\n                        PlatformTools.getGlobalVariable().localStorage.getItem(\n                            fileNameOrLocalStorageOrData,\n                        )\n                }\n\n                if (localStorageContent != null) {\n                    // localStorage value exists.\n                    return this.createDatabaseConnectionWithImport(\n                        JSON.parse(localStorageContent),\n                    )\n                } else if (checkIfFileOrLocalStorageExists) {\n                    throw new TypeORMError(\n                        `File ${fileNameOrLocalStorageOrData} does not exist`,\n                    )\n                } else {\n                    // localStorage value doesn't exist and checkIfFileOrLocalStorageExists is set to false.\n                    // Therefore open a database without importing anything.\n                    // localStorage value will be written on first write operation.\n                    return this.createDatabaseConnectionWithImport()\n                }\n            }\n        } else {\n            return this.createDatabaseConnectionWithImport(\n                fileNameOrLocalStorageOrData,\n            )\n        }\n    }\n\n    /**\n     * Saved the current database to the given file (Node.js), local storage key (browser) or\n     * indexedDB key (browser with enabled useLocalForage option).\n     * If no location path is given, the location path in the options (if specified) will be used.\n     */\n    async save(location?: string) {\n        if (!location && !this.options.location) {\n            throw new TypeORMError(\n                `No location is set, specify a location parameter or add the location option to your configuration`,\n            )\n        }\n\n        let path = \"\"\n        if (location) {\n            path = location\n        } else if (this.options.location) {\n            path = this.options.location\n        }\n\n        if (PlatformTools.type === \"node\") {\n            try {\n                const content = Buffer.from(this.databaseConnection.export())\n                await PlatformTools.writeFile(path, content)\n            } catch (e) {\n                throw new TypeORMError(`Could not save database, error: ${e}`)\n            }\n        } else {\n            const database: Uint8Array = this.databaseConnection.export()\n            // convert Uint8Array to number array to improve local-storage storage\n            const databaseArray = [].slice.call(database)\n            if (this.options.useLocalForage) {\n                if (window.localforage) {\n                    await window.localforage.setItem(\n                        path,\n                        JSON.stringify(databaseArray),\n                    )\n                } else {\n                    throw new TypeORMError(\n                        `localforage is not defined - please import localforage.js into your site`,\n                    )\n                }\n            } else {\n                PlatformTools.getGlobalVariable().localStorage.setItem(\n                    path,\n                    JSON.stringify(databaseArray),\n                )\n            }\n        }\n    }\n\n    /**\n     * This gets called by the QueryRunner when a change to the database is made.\n     * If a custom autoSaveCallback is specified, it get's called with the database as Uint8Array,\n     * otherwise the save method is called which saves it to file (Node.js), local storage (browser)\n     * or indexedDB (browser with enabled useLocalForage option).\n     * Don't auto-save when in transaction as the call to export will end the current transaction\n     */\n    async autoSave() {\n        if (this.options.autoSave && !this.queryRunner?.isTransactionActive) {\n            if (this.options.autoSaveCallback) {\n                await this.options.autoSaveCallback(this.export())\n            } else {\n                await this.save()\n            }\n        }\n    }\n\n    /**\n     * Returns the current database as Uint8Array.\n     */\n    export(): Uint8Array {\n        return this.databaseConnection.export()\n    }\n\n    /**\n     * Creates generated map of values generated or returned by database after INSERT query.\n     */\n    createGeneratedMap(metadata: EntityMetadata, insertResult: any) {\n        const generatedMap = metadata.generatedColumns.reduce(\n            (map, generatedColumn) => {\n                // seems to be the only way to get the inserted id, see https://github.com/kripken/sql.js/issues/77\n                if (\n                    generatedColumn.isPrimary &&\n                    generatedColumn.generationStrategy === \"increment\"\n                ) {\n                    const query = \"SELECT last_insert_rowid()\"\n                    try {\n                        let result = this.databaseConnection.exec(query)\n                        this.connection.logger.logQuery(query)\n                        return OrmUtils.mergeDeep(\n                            map,\n                            generatedColumn.createValueMap(\n                                result[0].values[0][0],\n                            ),\n                        )\n                    } catch (e) {\n                        this.connection.logger.logQueryError(e, query, [])\n                    }\n                }\n\n                return map\n            },\n            {} as ObjectLiteral,\n        )\n\n        return Object.keys(generatedMap).length > 0 ? generatedMap : undefined\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates connection with the database.\n     * If the location option is set, the database is loaded first.\n     */\n    protected createDatabaseConnection(): Promise<any> {\n        if (this.options.location) {\n            return this.load(this.options.location, false)\n        }\n\n        return this.createDatabaseConnectionWithImport(this.options.database)\n    }\n\n    /**\n     * Creates connection with an optional database.\n     * If database is specified it is loaded, otherwise a new empty database is created.\n     */\n    protected async createDatabaseConnectionWithImport(\n        database?: Uint8Array,\n    ): Promise<any> {\n        // sql.js < 1.0 exposes an object with a `Database` method.\n        const isLegacyVersion = typeof this.sqlite.Database === \"function\"\n        const sqlite = isLegacyVersion\n            ? this.sqlite\n            : await this.sqlite(this.options.sqlJsConfig)\n        if (database && database.length > 0) {\n            this.databaseConnection = new sqlite.Database(database)\n        } else {\n            this.databaseConnection = new sqlite.Database()\n        }\n\n        this.databaseConnection.exec(`PRAGMA foreign_keys = ON`)\n\n        return this.databaseConnection\n    }\n\n    /**\n     * If driver dependency is not given explicitly, then try to load it via \"require\".\n     */\n    protected loadDependencies(): void {\n        if (PlatformTools.type === \"browser\") {\n            const sqlite = this.options.driver || window.SQL\n            this.sqlite = sqlite\n        } else {\n            try {\n                const sqlite =\n                    this.options.driver || PlatformTools.load(\"sql.js\")\n                this.sqlite = sqlite\n            } catch (e) {\n                throw new DriverPackageNotInstalledError(\"sql.js\", \"sql.js\")\n            }\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}