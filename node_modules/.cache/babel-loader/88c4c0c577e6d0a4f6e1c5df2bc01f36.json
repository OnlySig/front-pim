{"ast":null,"code":"import { Table } from \"../schema-builder/table/Table\";\nimport { Migration } from \"./Migration\";\nimport { MssqlParameter } from \"../driver/sqlserver/MssqlParameter\";\nimport { TypeORMError } from \"../error\";\nimport { InstanceChecker } from \"../util/InstanceChecker\";\n/**\n * Executes migrations: runs pending and reverts previously executed migrations.\n */\n\nexport class MigrationExecutor {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection, queryRunner) {\n    this.connection = connection;\n    this.queryRunner = queryRunner; // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Indicates how migrations should be run in transactions.\n     *   all: all migrations are run in a single transaction\n     *   none: all migrations are run without a transaction\n     *   each: each migration is run in a separate transaction\n     */\n\n    this.transaction = \"all\";\n    const {\n      schema\n    } = this.connection.driver.options;\n    const database = this.connection.driver.database;\n    this.migrationsDatabase = database;\n    this.migrationsSchema = schema;\n    this.migrationsTableName = connection.options.migrationsTableName || \"migrations\";\n    this.migrationsTable = this.connection.driver.buildTableName(this.migrationsTableName, schema, database);\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Tries to execute a single migration given.\n   */\n\n\n  async executeMigration(migration) {\n    return this.withQueryRunner(async queryRunner => {\n      await this.createMigrationsTableIfNotExist(queryRunner);\n      await queryRunner.beforeMigration();\n      await migration.instance.up(queryRunner);\n      await queryRunner.afterMigration();\n      await this.insertExecutedMigration(queryRunner, migration);\n      return migration;\n    });\n  }\n  /**\n   * Returns an array of all migrations.\n   */\n\n\n  async getAllMigrations() {\n    return Promise.resolve(this.getMigrations());\n  }\n  /**\n   * Returns an array of all executed migrations.\n   */\n\n\n  async getExecutedMigrations() {\n    return this.withQueryRunner(async queryRunner => {\n      await this.createMigrationsTableIfNotExist(queryRunner);\n      return await this.loadExecutedMigrations(queryRunner);\n    });\n  }\n  /**\n   * Returns an array of all pending migrations.\n   */\n\n\n  async getPendingMigrations() {\n    const allMigrations = await this.getAllMigrations();\n    const executedMigrations = await this.getExecutedMigrations();\n    return allMigrations.filter(migration => !executedMigrations.find(executedMigration => executedMigration.name === migration.name));\n  }\n  /**\n   * Inserts an executed migration.\n   */\n\n\n  insertMigration(migration) {\n    return this.withQueryRunner(q => this.insertExecutedMigration(q, migration));\n  }\n  /**\n   * Deletes an executed migration.\n   */\n\n\n  deleteMigration(migration) {\n    return this.withQueryRunner(q => this.deleteExecutedMigration(q, migration));\n  }\n  /**\n   * Lists all migrations and whether they have been executed or not\n   * returns true if there are unapplied migrations\n   */\n\n\n  async showMigrations() {\n    let hasUnappliedMigrations = false;\n    const queryRunner = this.queryRunner || this.connection.createQueryRunner(); // create migrations table if its not created yet\n\n    await this.createMigrationsTableIfNotExist(queryRunner); // get all migrations that are executed and saved in the database\n\n    const executedMigrations = await this.loadExecutedMigrations(queryRunner); // get all user's migrations in the source code\n\n    const allMigrations = this.getMigrations();\n\n    for (const migration of allMigrations) {\n      const executedMigration = executedMigrations.find(executedMigration => executedMigration.name === migration.name);\n\n      if (executedMigration) {\n        this.connection.logger.logSchemaBuild(`[X] ${migration.name}`);\n      } else {\n        hasUnappliedMigrations = true;\n        this.connection.logger.logSchemaBuild(`[ ] ${migration.name}`);\n      }\n    } // if query runner was created by us then release it\n\n\n    if (!this.queryRunner) {\n      await queryRunner.release();\n    }\n\n    return hasUnappliedMigrations;\n  }\n  /**\n   * Executes all pending migrations. Pending migrations are migrations that are not yet executed,\n   * thus not saved in the database.\n   */\n\n\n  async executePendingMigrations() {\n    const queryRunner = this.queryRunner || this.connection.createQueryRunner(); // create migrations table if its not created yet\n\n    await this.createMigrationsTableIfNotExist(queryRunner); // create the typeorm_metadata table if necessary\n\n    const schemaBuilder = this.connection.driver.createSchemaBuilder();\n\n    if (InstanceChecker.isRdbmsSchemaBuilder(schemaBuilder)) {\n      await schemaBuilder.createMetadataTableIfNecessary(queryRunner);\n    } // get all migrations that are executed and saved in the database\n\n\n    const executedMigrations = await this.loadExecutedMigrations(queryRunner); // get the time when last migration was executed\n\n    let lastTimeExecutedMigration = this.getLatestTimestampMigration(executedMigrations); // get all user's migrations in the source code\n\n    const allMigrations = this.getMigrations(); // variable to store all migrations we did successfully\n\n    const successMigrations = []; // find all migrations that needs to be executed\n\n    const pendingMigrations = allMigrations.filter(migration => {\n      // check if we already have executed migration\n      const executedMigration = executedMigrations.find(executedMigration => executedMigration.name === migration.name);\n      if (executedMigration) return false; // migration is new and not executed. now check if its timestamp is correct\n      // if (lastTimeExecutedMigration && migration.timestamp < lastTimeExecutedMigration.timestamp)\n      //     throw new TypeORMError(`New migration found: ${migration.name}, however this migration's timestamp is not valid. Migration's timestamp should not be older then migrations already executed in the database.`);\n      // every check is passed means that migration was not run yet and we need to run it\n\n      return true;\n    }); // if no migrations are pending then nothing to do here\n\n    if (!pendingMigrations.length) {\n      this.connection.logger.logSchemaBuild(`No migrations are pending`); // if query runner was created by us then release it\n\n      if (!this.queryRunner) await queryRunner.release();\n      return [];\n    } // log information about migration execution\n\n\n    this.connection.logger.logSchemaBuild(`${executedMigrations.length} migrations are already loaded in the database.`);\n    this.connection.logger.logSchemaBuild(`${allMigrations.length} migrations were found in the source code.`);\n    if (lastTimeExecutedMigration) this.connection.logger.logSchemaBuild(`${lastTimeExecutedMigration.name} is the last executed migration. It was executed on ${new Date(lastTimeExecutedMigration.timestamp).toString()}.`);\n    this.connection.logger.logSchemaBuild(`${pendingMigrations.length} migrations are new migrations must be executed.`); // start transaction if its not started yet\n\n    let transactionStartedByUs = false;\n\n    if (this.transaction === \"all\" && !queryRunner.isTransactionActive) {\n      await queryRunner.startTransaction();\n      transactionStartedByUs = true;\n    } // run all pending migrations in a sequence\n\n\n    try {\n      for (const migration of pendingMigrations) {\n        if (this.fake) {\n          // directly insert migration record into the database if it is fake\n          await this.insertExecutedMigration(queryRunner, migration); // nothing else needs to be done, continue to next migration\n\n          continue;\n        }\n\n        if (this.transaction === \"each\" && !queryRunner.isTransactionActive) {\n          await queryRunner.startTransaction();\n          transactionStartedByUs = true;\n        }\n\n        await migration.instance.up(queryRunner).catch(error => {\n          // informative log about migration failure\n          this.connection.logger.logMigration(`Migration \"${migration.name}\" failed, error: ${error === null || error === void 0 ? void 0 : error.message}`);\n          throw error;\n        }).then(async () => {\n          // now when migration is executed we need to insert record about it into the database\n          await this.insertExecutedMigration(queryRunner, migration); // commit transaction if we started it\n\n          if (this.transaction === \"each\" && transactionStartedByUs) await queryRunner.commitTransaction();\n        }).then(() => {\n          // informative log about migration success\n          successMigrations.push(migration);\n          this.connection.logger.logSchemaBuild(`Migration ${migration.name} has been ${this.fake ? \"(fake)\" : \"\"} executed successfully.`);\n        });\n      } // commit transaction if we started it\n\n\n      if (this.transaction === \"all\" && transactionStartedByUs) await queryRunner.commitTransaction();\n    } catch (err) {\n      // rollback transaction if we started it\n      if (transactionStartedByUs) {\n        try {\n          // we throw original error even if rollback thrown an error\n          await queryRunner.rollbackTransaction();\n        } catch (rollbackError) {}\n      }\n\n      throw err;\n    } finally {\n      // if query runner was created by us then release it\n      if (!this.queryRunner) await queryRunner.release();\n    }\n\n    return successMigrations;\n  }\n  /**\n   * Reverts last migration that were run.\n   */\n\n\n  async undoLastMigration() {\n    const queryRunner = this.queryRunner || this.connection.createQueryRunner(); // create migrations table if its not created yet\n\n    await this.createMigrationsTableIfNotExist(queryRunner); // get all migrations that are executed and saved in the database\n\n    const executedMigrations = await this.loadExecutedMigrations(queryRunner); // get the time when last migration was executed\n\n    let lastTimeExecutedMigration = this.getLatestExecutedMigration(executedMigrations); // if no migrations found in the database then nothing to revert\n\n    if (!lastTimeExecutedMigration) {\n      this.connection.logger.logSchemaBuild(`No migrations was found in the database. Nothing to revert!`);\n      return;\n    } // get all user's migrations in the source code\n\n\n    const allMigrations = this.getMigrations(); // find the instance of the migration we need to remove\n\n    const migrationToRevert = allMigrations.find(migration => migration.name === lastTimeExecutedMigration.name); // if no migrations found in the database then nothing to revert\n\n    if (!migrationToRevert) throw new TypeORMError(`No migration ${lastTimeExecutedMigration.name} was found in the source code. Make sure you have this migration in your codebase and its included in the connection options.`); // log information about migration execution\n\n    this.connection.logger.logSchemaBuild(`${executedMigrations.length} migrations are already loaded in the database.`);\n    this.connection.logger.logSchemaBuild(`${lastTimeExecutedMigration.name} is the last executed migration. It was executed on ${new Date(lastTimeExecutedMigration.timestamp).toString()}.`);\n    this.connection.logger.logSchemaBuild(`Now reverting it...`); // start transaction if its not started yet\n\n    let transactionStartedByUs = false;\n\n    if (this.transaction !== \"none\" && !queryRunner.isTransactionActive) {\n      await queryRunner.startTransaction();\n      transactionStartedByUs = true;\n    }\n\n    try {\n      if (!this.fake) {\n        await queryRunner.beforeMigration();\n        await migrationToRevert.instance.down(queryRunner);\n        await queryRunner.afterMigration();\n      }\n\n      await this.deleteExecutedMigration(queryRunner, migrationToRevert);\n      this.connection.logger.logSchemaBuild(`Migration ${migrationToRevert.name} has been ${this.fake ? \"(fake)\" : \"\"} reverted successfully.`); // commit transaction if we started it\n\n      if (transactionStartedByUs) await queryRunner.commitTransaction();\n    } catch (err) {\n      // rollback transaction if we started it\n      if (transactionStartedByUs) {\n        try {\n          // we throw original error even if rollback thrown an error\n          await queryRunner.rollbackTransaction();\n        } catch (rollbackError) {}\n      }\n\n      throw err;\n    } finally {\n      // if query runner was created by us then release it\n      if (!this.queryRunner) await queryRunner.release();\n    }\n  } // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Creates table \"migrations\" that will store information about executed migrations.\n   */\n\n\n  async createMigrationsTableIfNotExist(queryRunner) {\n    // If driver is mongo no need to create\n    if (this.connection.driver.options.type === \"mongodb\") {\n      return;\n    }\n\n    const tableExist = await queryRunner.hasTable(this.migrationsTable); // todo: table name should be configurable\n\n    if (!tableExist) {\n      await queryRunner.createTable(new Table({\n        database: this.migrationsDatabase,\n        schema: this.migrationsSchema,\n        name: this.migrationsTable,\n        columns: [{\n          name: \"id\",\n          type: this.connection.driver.normalizeType({\n            type: this.connection.driver.mappedDataTypes.migrationId\n          }),\n          isGenerated: true,\n          generationStrategy: \"increment\",\n          isPrimary: true,\n          isNullable: false\n        }, {\n          name: \"timestamp\",\n          type: this.connection.driver.normalizeType({\n            type: this.connection.driver.mappedDataTypes.migrationTimestamp\n          }),\n          isPrimary: false,\n          isNullable: false\n        }, {\n          name: \"name\",\n          type: this.connection.driver.normalizeType({\n            type: this.connection.driver.mappedDataTypes.migrationName\n          }),\n          isNullable: false\n        }]\n      }));\n    }\n  }\n  /**\n   * Loads all migrations that were executed and saved into the database (sorts by id).\n   */\n\n\n  async loadExecutedMigrations(queryRunner) {\n    if (this.connection.driver.options.type === \"mongodb\") {\n      const mongoRunner = queryRunner;\n      return await mongoRunner.databaseConnection.db(this.connection.driver.database).collection(this.migrationsTableName).find().sort({\n        _id: -1\n      }).toArray();\n    } else {\n      const migrationsRaw = await this.connection.manager.createQueryBuilder(queryRunner).select().orderBy(this.connection.driver.escape(\"id\"), \"DESC\").from(this.migrationsTable, this.migrationsTableName).getRawMany();\n      return migrationsRaw.map(migrationRaw => {\n        return new Migration(parseInt(migrationRaw[\"id\"]), parseInt(migrationRaw[\"timestamp\"]), migrationRaw[\"name\"]);\n      });\n    }\n  }\n  /**\n   * Gets all migrations that setup for this connection.\n   */\n\n\n  getMigrations() {\n    const migrations = this.connection.migrations.map(migration => {\n      const migrationClassName = migration.name || migration.constructor.name;\n      const migrationTimestamp = parseInt(migrationClassName.substr(-13), 10);\n\n      if (!migrationTimestamp || isNaN(migrationTimestamp)) {\n        throw new TypeORMError(`${migrationClassName} migration name is wrong. Migration class name should have a JavaScript timestamp appended.`);\n      }\n\n      return new Migration(undefined, migrationTimestamp, migrationClassName, migration);\n    });\n    this.checkForDuplicateMigrations(migrations); // sort them by timestamp\n\n    return migrations.sort((a, b) => a.timestamp - b.timestamp);\n  }\n\n  checkForDuplicateMigrations(migrations) {\n    const migrationNames = migrations.map(migration => migration.name);\n    const duplicates = Array.from(new Set(migrationNames.filter((migrationName, index) => migrationNames.indexOf(migrationName) < index)));\n\n    if (duplicates.length > 0) {\n      throw Error(`Duplicate migrations: ${duplicates.join(\", \")}`);\n    }\n  }\n  /**\n   * Finds the latest migration (sorts by timestamp) in the given array of migrations.\n   */\n\n\n  getLatestTimestampMigration(migrations) {\n    const sortedMigrations = migrations.map(migration => migration).sort((a, b) => (a.timestamp - b.timestamp) * -1);\n    return sortedMigrations.length > 0 ? sortedMigrations[0] : undefined;\n  }\n  /**\n   * Finds the latest migration in the given array of migrations.\n   * PRE: Migration array must be sorted by descending id.\n   */\n\n\n  getLatestExecutedMigration(sortedMigrations) {\n    return sortedMigrations.length > 0 ? sortedMigrations[0] : undefined;\n  }\n  /**\n   * Inserts new executed migration's data into migrations table.\n   */\n\n\n  async insertExecutedMigration(queryRunner, migration) {\n    const values = {};\n\n    if (this.connection.driver.options.type === \"mssql\") {\n      values[\"timestamp\"] = new MssqlParameter(migration.timestamp, this.connection.driver.normalizeType({\n        type: this.connection.driver.mappedDataTypes.migrationTimestamp\n      }));\n      values[\"name\"] = new MssqlParameter(migration.name, this.connection.driver.normalizeType({\n        type: this.connection.driver.mappedDataTypes.migrationName\n      }));\n    } else {\n      values[\"timestamp\"] = migration.timestamp;\n      values[\"name\"] = migration.name;\n    }\n\n    if (this.connection.driver.options.type === \"mongodb\") {\n      const mongoRunner = queryRunner;\n      await mongoRunner.databaseConnection.db(this.connection.driver.database).collection(this.migrationsTableName).insertOne(values);\n    } else {\n      const qb = queryRunner.manager.createQueryBuilder();\n      await qb.insert().into(this.migrationsTable).values(values).execute();\n    }\n  }\n  /**\n   * Delete previously executed migration's data from the migrations table.\n   */\n\n\n  async deleteExecutedMigration(queryRunner, migration) {\n    const conditions = {};\n\n    if (this.connection.driver.options.type === \"mssql\") {\n      conditions[\"timestamp\"] = new MssqlParameter(migration.timestamp, this.connection.driver.normalizeType({\n        type: this.connection.driver.mappedDataTypes.migrationTimestamp\n      }));\n      conditions[\"name\"] = new MssqlParameter(migration.name, this.connection.driver.normalizeType({\n        type: this.connection.driver.mappedDataTypes.migrationName\n      }));\n    } else {\n      conditions[\"timestamp\"] = migration.timestamp;\n      conditions[\"name\"] = migration.name;\n    }\n\n    if (this.connection.driver.options.type === \"mongodb\") {\n      const mongoRunner = queryRunner;\n      await mongoRunner.databaseConnection.db(this.connection.driver.database).collection(this.migrationsTableName).deleteOne(conditions);\n    } else {\n      const qb = queryRunner.manager.createQueryBuilder();\n      await qb.delete().from(this.migrationsTable).where(`${qb.escape(\"timestamp\")} = :timestamp`).andWhere(`${qb.escape(\"name\")} = :name`).setParameters(conditions).execute();\n    }\n  }\n\n  async withQueryRunner(callback) {\n    const queryRunner = this.queryRunner || this.connection.createQueryRunner();\n\n    try {\n      return callback(queryRunner);\n    } finally {\n      if (!this.queryRunner) {\n        await queryRunner.release();\n      }\n    }\n  }\n\n}","map":{"version":3,"mappings":"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","names":["Table","Migration","MssqlParameter","TypeORMError","InstanceChecker","MigrationExecutor","constructor","connection","queryRunner","schema","driver","options","database","migrationsDatabase","migrationsSchema","migrationsTableName","migrationsTable","buildTableName","executeMigration","migration","withQueryRunner","createMigrationsTableIfNotExist","beforeMigration","instance","up","afterMigration","insertExecutedMigration","getAllMigrations","Promise","resolve","getMigrations","getExecutedMigrations","loadExecutedMigrations","getPendingMigrations","allMigrations","executedMigrations","filter","find","executedMigration","name","insertMigration","q","deleteMigration","deleteExecutedMigration","showMigrations","hasUnappliedMigrations","createQueryRunner","logger","logSchemaBuild","release","executePendingMigrations","schemaBuilder","createSchemaBuilder","isRdbmsSchemaBuilder","createMetadataTableIfNecessary","lastTimeExecutedMigration","getLatestTimestampMigration","successMigrations","pendingMigrations","length","Date","timestamp","toString","transactionStartedByUs","transaction","isTransactionActive","startTransaction","fake","catch","error","logMigration","message","then","commitTransaction","push","err","rollbackTransaction","rollbackError","undoLastMigration","getLatestExecutedMigration","migrationToRevert","down","type","tableExist","hasTable","createTable","columns","normalizeType","mappedDataTypes","migrationId","isGenerated","generationStrategy","isPrimary","isNullable","migrationTimestamp","migrationName","mongoRunner","databaseConnection","db","collection","sort","_id","toArray","migrationsRaw","manager","createQueryBuilder","select","orderBy","escape","from","getRawMany","map","migrationRaw","parseInt","migrations","migrationClassName","substr","isNaN","undefined","checkForDuplicateMigrations","a","b","migrationNames","duplicates","Array","Set","index","indexOf","Error","join","sortedMigrations","values","insertOne","qb","insert","into","execute","conditions","deleteOne","delete","where","andWhere","setParameters","callback"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\migration\\MigrationExecutor.ts"],"sourcesContent":["import { Table } from \"../schema-builder/table/Table\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { Migration } from \"./Migration\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\nimport { MssqlParameter } from \"../driver/sqlserver/MssqlParameter\"\nimport { MongoQueryRunner } from \"../driver/mongodb/MongoQueryRunner\"\nimport { TypeORMError } from \"../error\"\nimport { InstanceChecker } from \"../util/InstanceChecker\"\n\n/**\n * Executes migrations: runs pending and reverts previously executed migrations.\n */\nexport class MigrationExecutor {\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Indicates how migrations should be run in transactions.\n     *   all: all migrations are run in a single transaction\n     *   none: all migrations are run without a transaction\n     *   each: each migration is run in a separate transaction\n     */\n    transaction: \"all\" | \"none\" | \"each\" = \"all\"\n\n    /**\n     * Option to fake-run or fake-revert a migration, adding to the\n     * executed migrations table, but not actually running it. This feature is\n     * useful for when migrations are added after the fact or for\n     * interoperability between applications which are desired to each keep\n     * a consistent migration history.\n     */\n    fake: boolean\n\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n    private readonly migrationsDatabase?: string\n    private readonly migrationsSchema?: string\n    private readonly migrationsTable: string\n    private readonly migrationsTableName: string\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        protected connection: DataSource,\n        protected queryRunner?: QueryRunner,\n    ) {\n        const { schema } = this.connection.driver.options as any\n        const database = this.connection.driver.database\n        this.migrationsDatabase = database\n        this.migrationsSchema = schema\n        this.migrationsTableName =\n            connection.options.migrationsTableName || \"migrations\"\n        this.migrationsTable = this.connection.driver.buildTableName(\n            this.migrationsTableName,\n            schema,\n            database,\n        )\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Tries to execute a single migration given.\n     */\n    public async executeMigration(migration: Migration): Promise<Migration> {\n        return this.withQueryRunner(async (queryRunner) => {\n            await this.createMigrationsTableIfNotExist(queryRunner)\n            await queryRunner.beforeMigration()\n            await (migration.instance as any).up(queryRunner)\n            await queryRunner.afterMigration()\n            await this.insertExecutedMigration(queryRunner, migration)\n\n            return migration\n        })\n    }\n\n    /**\n     * Returns an array of all migrations.\n     */\n    public async getAllMigrations(): Promise<Migration[]> {\n        return Promise.resolve(this.getMigrations())\n    }\n\n    /**\n     * Returns an array of all executed migrations.\n     */\n    public async getExecutedMigrations(): Promise<Migration[]> {\n        return this.withQueryRunner(async (queryRunner) => {\n            await this.createMigrationsTableIfNotExist(queryRunner)\n\n            return await this.loadExecutedMigrations(queryRunner)\n        })\n    }\n\n    /**\n     * Returns an array of all pending migrations.\n     */\n    public async getPendingMigrations(): Promise<Migration[]> {\n        const allMigrations = await this.getAllMigrations()\n        const executedMigrations = await this.getExecutedMigrations()\n\n        return allMigrations.filter(\n            (migration) =>\n                !executedMigrations.find(\n                    (executedMigration) =>\n                        executedMigration.name === migration.name,\n                ),\n        )\n    }\n\n    /**\n     * Inserts an executed migration.\n     */\n    public insertMigration(migration: Migration): Promise<void> {\n        return this.withQueryRunner((q) =>\n            this.insertExecutedMigration(q, migration),\n        )\n    }\n\n    /**\n     * Deletes an executed migration.\n     */\n    public deleteMigration(migration: Migration): Promise<void> {\n        return this.withQueryRunner((q) =>\n            this.deleteExecutedMigration(q, migration),\n        )\n    }\n\n    /**\n     * Lists all migrations and whether they have been executed or not\n     * returns true if there are unapplied migrations\n     */\n    async showMigrations(): Promise<boolean> {\n        let hasUnappliedMigrations = false\n        const queryRunner =\n            this.queryRunner || this.connection.createQueryRunner()\n        // create migrations table if its not created yet\n        await this.createMigrationsTableIfNotExist(queryRunner)\n        // get all migrations that are executed and saved in the database\n        const executedMigrations = await this.loadExecutedMigrations(\n            queryRunner,\n        )\n\n        // get all user's migrations in the source code\n        const allMigrations = this.getMigrations()\n\n        for (const migration of allMigrations) {\n            const executedMigration = executedMigrations.find(\n                (executedMigration) =>\n                    executedMigration.name === migration.name,\n            )\n\n            if (executedMigration) {\n                this.connection.logger.logSchemaBuild(`[X] ${migration.name}`)\n            } else {\n                hasUnappliedMigrations = true\n                this.connection.logger.logSchemaBuild(`[ ] ${migration.name}`)\n            }\n        }\n\n        // if query runner was created by us then release it\n        if (!this.queryRunner) {\n            await queryRunner.release()\n        }\n\n        return hasUnappliedMigrations\n    }\n\n    /**\n     * Executes all pending migrations. Pending migrations are migrations that are not yet executed,\n     * thus not saved in the database.\n     */\n    async executePendingMigrations(): Promise<Migration[]> {\n        const queryRunner =\n            this.queryRunner || this.connection.createQueryRunner()\n        // create migrations table if its not created yet\n        await this.createMigrationsTableIfNotExist(queryRunner)\n\n        // create the typeorm_metadata table if necessary\n        const schemaBuilder = this.connection.driver.createSchemaBuilder()\n\n        if (InstanceChecker.isRdbmsSchemaBuilder(schemaBuilder)) {\n            await schemaBuilder.createMetadataTableIfNecessary(queryRunner)\n        }\n\n        // get all migrations that are executed and saved in the database\n        const executedMigrations = await this.loadExecutedMigrations(\n            queryRunner,\n        )\n\n        // get the time when last migration was executed\n        let lastTimeExecutedMigration =\n            this.getLatestTimestampMigration(executedMigrations)\n\n        // get all user's migrations in the source code\n        const allMigrations = this.getMigrations()\n\n        // variable to store all migrations we did successfully\n        const successMigrations: Migration[] = []\n\n        // find all migrations that needs to be executed\n        const pendingMigrations = allMigrations.filter((migration) => {\n            // check if we already have executed migration\n            const executedMigration = executedMigrations.find(\n                (executedMigration) =>\n                    executedMigration.name === migration.name,\n            )\n            if (executedMigration) return false\n\n            // migration is new and not executed. now check if its timestamp is correct\n            // if (lastTimeExecutedMigration && migration.timestamp < lastTimeExecutedMigration.timestamp)\n            //     throw new TypeORMError(`New migration found: ${migration.name}, however this migration's timestamp is not valid. Migration's timestamp should not be older then migrations already executed in the database.`);\n\n            // every check is passed means that migration was not run yet and we need to run it\n            return true\n        })\n\n        // if no migrations are pending then nothing to do here\n        if (!pendingMigrations.length) {\n            this.connection.logger.logSchemaBuild(`No migrations are pending`)\n            // if query runner was created by us then release it\n            if (!this.queryRunner) await queryRunner.release()\n            return []\n        }\n\n        // log information about migration execution\n        this.connection.logger.logSchemaBuild(\n            `${executedMigrations.length} migrations are already loaded in the database.`,\n        )\n        this.connection.logger.logSchemaBuild(\n            `${allMigrations.length} migrations were found in the source code.`,\n        )\n        if (lastTimeExecutedMigration)\n            this.connection.logger.logSchemaBuild(\n                `${\n                    lastTimeExecutedMigration.name\n                } is the last executed migration. It was executed on ${new Date(\n                    lastTimeExecutedMigration.timestamp,\n                ).toString()}.`,\n            )\n        this.connection.logger.logSchemaBuild(\n            `${pendingMigrations.length} migrations are new migrations must be executed.`,\n        )\n\n        // start transaction if its not started yet\n        let transactionStartedByUs = false\n        if (this.transaction === \"all\" && !queryRunner.isTransactionActive) {\n            await queryRunner.startTransaction()\n            transactionStartedByUs = true\n        }\n\n        // run all pending migrations in a sequence\n        try {\n            for (const migration of pendingMigrations) {\n                if (this.fake) {\n                    // directly insert migration record into the database if it is fake\n                    await this.insertExecutedMigration(queryRunner, migration)\n\n                    // nothing else needs to be done, continue to next migration\n                    continue\n                }\n\n                if (\n                    this.transaction === \"each\" &&\n                    !queryRunner.isTransactionActive\n                ) {\n                    await queryRunner.startTransaction()\n                    transactionStartedByUs = true\n                }\n\n                await migration\n                    .instance!.up(queryRunner)\n                    .catch((error) => {\n                        // informative log about migration failure\n                        this.connection.logger.logMigration(\n                            `Migration \"${migration.name}\" failed, error: ${error?.message}`,\n                        )\n                        throw error\n                    })\n                    .then(async () => {\n                        // now when migration is executed we need to insert record about it into the database\n                        await this.insertExecutedMigration(\n                            queryRunner,\n                            migration,\n                        )\n                        // commit transaction if we started it\n                        if (\n                            this.transaction === \"each\" &&\n                            transactionStartedByUs\n                        )\n                            await queryRunner.commitTransaction()\n                    })\n                    .then(() => {\n                        // informative log about migration success\n                        successMigrations.push(migration)\n                        this.connection.logger.logSchemaBuild(\n                            `Migration ${migration.name} has been ${\n                                this.fake ? \"(fake)\" : \"\"\n                            } executed successfully.`,\n                        )\n                    })\n            }\n\n            // commit transaction if we started it\n            if (this.transaction === \"all\" && transactionStartedByUs)\n                await queryRunner.commitTransaction()\n        } catch (err) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    // we throw original error even if rollback thrown an error\n                    await queryRunner.rollbackTransaction()\n                } catch (rollbackError) {}\n            }\n\n            throw err\n        } finally {\n            // if query runner was created by us then release it\n            if (!this.queryRunner) await queryRunner.release()\n        }\n        return successMigrations\n    }\n\n    /**\n     * Reverts last migration that were run.\n     */\n    async undoLastMigration(): Promise<void> {\n        const queryRunner =\n            this.queryRunner || this.connection.createQueryRunner()\n\n        // create migrations table if its not created yet\n        await this.createMigrationsTableIfNotExist(queryRunner)\n\n        // get all migrations that are executed and saved in the database\n        const executedMigrations = await this.loadExecutedMigrations(\n            queryRunner,\n        )\n\n        // get the time when last migration was executed\n        let lastTimeExecutedMigration =\n            this.getLatestExecutedMigration(executedMigrations)\n\n        // if no migrations found in the database then nothing to revert\n        if (!lastTimeExecutedMigration) {\n            this.connection.logger.logSchemaBuild(\n                `No migrations was found in the database. Nothing to revert!`,\n            )\n            return\n        }\n\n        // get all user's migrations in the source code\n        const allMigrations = this.getMigrations()\n\n        // find the instance of the migration we need to remove\n        const migrationToRevert = allMigrations.find(\n            (migration) => migration.name === lastTimeExecutedMigration!.name,\n        )\n\n        // if no migrations found in the database then nothing to revert\n        if (!migrationToRevert)\n            throw new TypeORMError(\n                `No migration ${lastTimeExecutedMigration.name} was found in the source code. Make sure you have this migration in your codebase and its included in the connection options.`,\n            )\n\n        // log information about migration execution\n        this.connection.logger.logSchemaBuild(\n            `${executedMigrations.length} migrations are already loaded in the database.`,\n        )\n        this.connection.logger.logSchemaBuild(\n            `${\n                lastTimeExecutedMigration.name\n            } is the last executed migration. It was executed on ${new Date(\n                lastTimeExecutedMigration.timestamp,\n            ).toString()}.`,\n        )\n        this.connection.logger.logSchemaBuild(`Now reverting it...`)\n\n        // start transaction if its not started yet\n        let transactionStartedByUs = false\n        if (this.transaction !== \"none\" && !queryRunner.isTransactionActive) {\n            await queryRunner.startTransaction()\n            transactionStartedByUs = true\n        }\n\n        try {\n            if (!this.fake) {\n                await queryRunner.beforeMigration()\n                await migrationToRevert.instance!.down(queryRunner)\n                await queryRunner.afterMigration()\n            }\n\n            await this.deleteExecutedMigration(queryRunner, migrationToRevert)\n            this.connection.logger.logSchemaBuild(\n                `Migration ${migrationToRevert.name} has been ${\n                    this.fake ? \"(fake)\" : \"\"\n                } reverted successfully.`,\n            )\n\n            // commit transaction if we started it\n            if (transactionStartedByUs) await queryRunner.commitTransaction()\n        } catch (err) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    // we throw original error even if rollback thrown an error\n                    await queryRunner.rollbackTransaction()\n                } catch (rollbackError) {}\n            }\n\n            throw err\n        } finally {\n            // if query runner was created by us then release it\n            if (!this.queryRunner) await queryRunner.release()\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates table \"migrations\" that will store information about executed migrations.\n     */\n    protected async createMigrationsTableIfNotExist(\n        queryRunner: QueryRunner,\n    ): Promise<void> {\n        // If driver is mongo no need to create\n        if (this.connection.driver.options.type === \"mongodb\") {\n            return\n        }\n        const tableExist = await queryRunner.hasTable(this.migrationsTable) // todo: table name should be configurable\n        if (!tableExist) {\n            await queryRunner.createTable(\n                new Table({\n                    database: this.migrationsDatabase,\n                    schema: this.migrationsSchema,\n                    name: this.migrationsTable,\n                    columns: [\n                        {\n                            name: \"id\",\n                            type: this.connection.driver.normalizeType({\n                                type: this.connection.driver.mappedDataTypes\n                                    .migrationId,\n                            }),\n                            isGenerated: true,\n                            generationStrategy: \"increment\",\n                            isPrimary: true,\n                            isNullable: false,\n                        },\n                        {\n                            name: \"timestamp\",\n                            type: this.connection.driver.normalizeType({\n                                type: this.connection.driver.mappedDataTypes\n                                    .migrationTimestamp,\n                            }),\n                            isPrimary: false,\n                            isNullable: false,\n                        },\n                        {\n                            name: \"name\",\n                            type: this.connection.driver.normalizeType({\n                                type: this.connection.driver.mappedDataTypes\n                                    .migrationName,\n                            }),\n                            isNullable: false,\n                        },\n                    ],\n                }),\n            )\n        }\n    }\n\n    /**\n     * Loads all migrations that were executed and saved into the database (sorts by id).\n     */\n    protected async loadExecutedMigrations(\n        queryRunner: QueryRunner,\n    ): Promise<Migration[]> {\n        if (this.connection.driver.options.type === \"mongodb\") {\n            const mongoRunner = queryRunner as MongoQueryRunner\n            return await mongoRunner.databaseConnection\n                .db(this.connection.driver.database!)\n                .collection(this.migrationsTableName)\n                .find<Migration>()\n                .sort({ _id: -1 })\n                .toArray()\n        } else {\n            const migrationsRaw: ObjectLiteral[] = await this.connection.manager\n                .createQueryBuilder(queryRunner)\n                .select()\n                .orderBy(this.connection.driver.escape(\"id\"), \"DESC\")\n                .from(this.migrationsTable, this.migrationsTableName)\n                .getRawMany()\n            return migrationsRaw.map((migrationRaw) => {\n                return new Migration(\n                    parseInt(migrationRaw[\"id\"]),\n                    parseInt(migrationRaw[\"timestamp\"]),\n                    migrationRaw[\"name\"],\n                )\n            })\n        }\n    }\n\n    /**\n     * Gets all migrations that setup for this connection.\n     */\n    protected getMigrations(): Migration[] {\n        const migrations = this.connection.migrations.map((migration) => {\n            const migrationClassName =\n                migration.name || (migration.constructor as any).name\n            const migrationTimestamp = parseInt(\n                migrationClassName.substr(-13),\n                10,\n            )\n            if (!migrationTimestamp || isNaN(migrationTimestamp)) {\n                throw new TypeORMError(\n                    `${migrationClassName} migration name is wrong. Migration class name should have a JavaScript timestamp appended.`,\n                )\n            }\n\n            return new Migration(\n                undefined,\n                migrationTimestamp,\n                migrationClassName,\n                migration,\n            )\n        })\n\n        this.checkForDuplicateMigrations(migrations)\n\n        // sort them by timestamp\n        return migrations.sort((a, b) => a.timestamp - b.timestamp)\n    }\n\n    protected checkForDuplicateMigrations(migrations: Migration[]) {\n        const migrationNames = migrations.map((migration) => migration.name)\n        const duplicates = Array.from(\n            new Set(\n                migrationNames.filter(\n                    (migrationName, index) =>\n                        migrationNames.indexOf(migrationName) < index,\n                ),\n            ),\n        )\n        if (duplicates.length > 0) {\n            throw Error(`Duplicate migrations: ${duplicates.join(\", \")}`)\n        }\n    }\n\n    /**\n     * Finds the latest migration (sorts by timestamp) in the given array of migrations.\n     */\n    protected getLatestTimestampMigration(\n        migrations: Migration[],\n    ): Migration | undefined {\n        const sortedMigrations = migrations\n            .map((migration) => migration)\n            .sort((a, b) => (a.timestamp - b.timestamp) * -1)\n        return sortedMigrations.length > 0 ? sortedMigrations[0] : undefined\n    }\n\n    /**\n     * Finds the latest migration in the given array of migrations.\n     * PRE: Migration array must be sorted by descending id.\n     */\n    protected getLatestExecutedMigration(\n        sortedMigrations: Migration[],\n    ): Migration | undefined {\n        return sortedMigrations.length > 0 ? sortedMigrations[0] : undefined\n    }\n\n    /**\n     * Inserts new executed migration's data into migrations table.\n     */\n    protected async insertExecutedMigration(\n        queryRunner: QueryRunner,\n        migration: Migration,\n    ): Promise<void> {\n        const values: ObjectLiteral = {}\n        if (this.connection.driver.options.type === \"mssql\") {\n            values[\"timestamp\"] = new MssqlParameter(\n                migration.timestamp,\n                this.connection.driver.normalizeType({\n                    type: this.connection.driver.mappedDataTypes\n                        .migrationTimestamp,\n                }) as any,\n            )\n            values[\"name\"] = new MssqlParameter(\n                migration.name,\n                this.connection.driver.normalizeType({\n                    type: this.connection.driver.mappedDataTypes.migrationName,\n                }) as any,\n            )\n        } else {\n            values[\"timestamp\"] = migration.timestamp\n            values[\"name\"] = migration.name\n        }\n        if (this.connection.driver.options.type === \"mongodb\") {\n            const mongoRunner = queryRunner as MongoQueryRunner\n            await mongoRunner.databaseConnection\n                .db(this.connection.driver.database!)\n                .collection(this.migrationsTableName)\n                .insertOne(values)\n        } else {\n            const qb = queryRunner.manager.createQueryBuilder()\n            await qb\n                .insert()\n                .into(this.migrationsTable)\n                .values(values)\n                .execute()\n        }\n    }\n\n    /**\n     * Delete previously executed migration's data from the migrations table.\n     */\n    protected async deleteExecutedMigration(\n        queryRunner: QueryRunner,\n        migration: Migration,\n    ): Promise<void> {\n        const conditions: ObjectLiteral = {}\n        if (this.connection.driver.options.type === \"mssql\") {\n            conditions[\"timestamp\"] = new MssqlParameter(\n                migration.timestamp,\n                this.connection.driver.normalizeType({\n                    type: this.connection.driver.mappedDataTypes\n                        .migrationTimestamp,\n                }) as any,\n            )\n            conditions[\"name\"] = new MssqlParameter(\n                migration.name,\n                this.connection.driver.normalizeType({\n                    type: this.connection.driver.mappedDataTypes.migrationName,\n                }) as any,\n            )\n        } else {\n            conditions[\"timestamp\"] = migration.timestamp\n            conditions[\"name\"] = migration.name\n        }\n\n        if (this.connection.driver.options.type === \"mongodb\") {\n            const mongoRunner = queryRunner as MongoQueryRunner\n            await mongoRunner.databaseConnection\n                .db(this.connection.driver.database!)\n                .collection(this.migrationsTableName)\n                .deleteOne(conditions)\n        } else {\n            const qb = queryRunner.manager.createQueryBuilder()\n            await qb\n                .delete()\n                .from(this.migrationsTable)\n                .where(`${qb.escape(\"timestamp\")} = :timestamp`)\n                .andWhere(`${qb.escape(\"name\")} = :name`)\n                .setParameters(conditions)\n                .execute()\n        }\n    }\n\n    protected async withQueryRunner<T extends any>(\n        callback: (queryRunner: QueryRunner) => T | Promise<T>,\n    ) {\n        const queryRunner =\n            this.queryRunner || this.connection.createQueryRunner()\n\n        try {\n            return callback(queryRunner)\n        } finally {\n            if (!this.queryRunner) {\n                await queryRunner.release()\n            }\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}