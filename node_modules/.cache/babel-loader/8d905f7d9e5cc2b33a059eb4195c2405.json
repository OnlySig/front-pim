{"ast":null,"code":"import { MssqlParameter } from \"../driver/sqlserver/MssqlParameter\";\nimport { Table } from \"../schema-builder/table/Table\";\nimport { v4 as uuidv4 } from \"uuid\";\n/**\n * Caches query result into current database, into separate table called \"query-result-cache\".\n */\n\nexport class DbQueryResultCache {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection) {\n    this.connection = connection;\n    const {\n      schema\n    } = this.connection.driver.options;\n    const database = this.connection.driver.database;\n    const cacheOptions = typeof this.connection.options.cache === \"object\" ? this.connection.options.cache : {};\n    const cacheTableName = cacheOptions.tableName || \"query-result-cache\";\n    this.queryResultCacheDatabase = database;\n    this.queryResultCacheSchema = schema;\n    this.queryResultCacheTable = this.connection.driver.buildTableName(cacheTableName, schema, database);\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Creates a connection with given cache provider.\n   */\n\n\n  async connect() {}\n  /**\n   * Disconnects with given cache provider.\n   */\n\n\n  async disconnect() {}\n  /**\n   * Creates table for storing cache if it does not exist yet.\n   */\n\n\n  async synchronize(queryRunner) {\n    queryRunner = this.getQueryRunner(queryRunner);\n    const driver = this.connection.driver;\n    const tableExist = await queryRunner.hasTable(this.queryResultCacheTable); // todo: table name should be configurable\n\n    if (tableExist) return;\n    await queryRunner.createTable(new Table({\n      database: this.queryResultCacheDatabase,\n      schema: this.queryResultCacheSchema,\n      name: this.queryResultCacheTable,\n      columns: [{\n        name: \"id\",\n        isPrimary: true,\n        isNullable: false,\n        type: driver.normalizeType({\n          type: driver.mappedDataTypes.cacheId\n        }),\n        generationStrategy: driver.options.type === \"spanner\" ? \"uuid\" : \"increment\",\n        isGenerated: true\n      }, {\n        name: \"identifier\",\n        type: driver.normalizeType({\n          type: driver.mappedDataTypes.cacheIdentifier\n        }),\n        isNullable: true\n      }, {\n        name: \"time\",\n        type: driver.normalizeType({\n          type: driver.mappedDataTypes.cacheTime\n        }),\n        isPrimary: false,\n        isNullable: false\n      }, {\n        name: \"duration\",\n        type: driver.normalizeType({\n          type: driver.mappedDataTypes.cacheDuration\n        }),\n        isPrimary: false,\n        isNullable: false\n      }, {\n        name: \"query\",\n        type: driver.normalizeType({\n          type: driver.mappedDataTypes.cacheQuery\n        }),\n        isPrimary: false,\n        isNullable: false\n      }, {\n        name: \"result\",\n        type: driver.normalizeType({\n          type: driver.mappedDataTypes.cacheResult\n        }),\n        isNullable: false\n      }]\n    }));\n  }\n  /**\n   * Caches given query result.\n   * Returns cache result if found.\n   * Returns undefined if result is not cached.\n   */\n\n\n  getFromCache(options, queryRunner) {\n    queryRunner = this.getQueryRunner(queryRunner);\n    const qb = this.connection.createQueryBuilder(queryRunner).select().from(this.queryResultCacheTable, \"cache\");\n\n    if (options.identifier) {\n      return qb.where(`${qb.escape(\"cache\")}.${qb.escape(\"identifier\")} = :identifier`).setParameters({\n        identifier: this.connection.driver.options.type === \"mssql\" ? new MssqlParameter(options.identifier, \"nvarchar\") : options.identifier\n      }).getRawOne();\n    } else if (options.query) {\n      if (this.connection.driver.options.type === \"oracle\") {\n        return qb.where(`dbms_lob.compare(${qb.escape(\"cache\")}.${qb.escape(\"query\")}, :query) = 0`, {\n          query: options.query\n        }).getRawOne();\n      }\n\n      return qb.where(`${qb.escape(\"cache\")}.${qb.escape(\"query\")} = :query`).setParameters({\n        query: this.connection.driver.options.type === \"mssql\" ? new MssqlParameter(options.query, \"nvarchar\") : options.query\n      }).getRawOne();\n    }\n\n    return Promise.resolve(undefined);\n  }\n  /**\n   * Checks if cache is expired or not.\n   */\n\n\n  isExpired(savedCache) {\n    const duration = typeof savedCache.duration === \"string\" ? parseInt(savedCache.duration) : savedCache.duration;\n    return (typeof savedCache.time === \"string\" ? parseInt(savedCache.time) : savedCache.time) + duration < new Date().getTime();\n  }\n  /**\n   * Stores given query result in the cache.\n   */\n\n\n  async storeInCache(options, savedCache, queryRunner) {\n    const shouldCreateQueryRunner = queryRunner === undefined || (queryRunner === null || queryRunner === void 0 ? void 0 : queryRunner.getReplicationMode()) === \"slave\";\n\n    if (queryRunner === undefined || shouldCreateQueryRunner) {\n      queryRunner = this.connection.createQueryRunner(\"master\");\n    }\n\n    let insertedValues = options;\n\n    if (this.connection.driver.options.type === \"mssql\") {\n      // todo: bad abstraction, re-implement this part, probably better if we create an entity metadata for cache table\n      insertedValues = {\n        identifier: new MssqlParameter(options.identifier, \"nvarchar\"),\n        time: new MssqlParameter(options.time, \"bigint\"),\n        duration: new MssqlParameter(options.duration, \"int\"),\n        query: new MssqlParameter(options.query, \"nvarchar\"),\n        result: new MssqlParameter(options.result, \"nvarchar\")\n      };\n    }\n\n    if (savedCache && savedCache.identifier) {\n      // if exist then update\n      const qb = queryRunner.manager.createQueryBuilder().update(this.queryResultCacheTable).set(insertedValues);\n      qb.where(`${qb.escape(\"identifier\")} = :condition`, {\n        condition: insertedValues.identifier\n      });\n      await qb.execute();\n    } else if (savedCache && savedCache.query) {\n      // if exist then update\n      const qb = queryRunner.manager.createQueryBuilder().update(this.queryResultCacheTable).set(insertedValues);\n\n      if (this.connection.driver.options.type === \"oracle\") {\n        qb.where(`dbms_lob.compare(\"query\", :condition) = 0`, {\n          condition: insertedValues.query\n        });\n      } else {\n        qb.where(`${qb.escape(\"query\")} = :condition`, {\n          condition: insertedValues.query\n        });\n      }\n\n      await qb.execute();\n    } else {\n      // Spanner does not support auto-generated columns\n      if (this.connection.driver.options.type === \"spanner\" && !insertedValues.id) {\n        insertedValues.id = uuidv4();\n      } // otherwise insert\n\n\n      await queryRunner.manager.createQueryBuilder().insert().into(this.queryResultCacheTable).values(insertedValues).execute();\n    }\n\n    if (shouldCreateQueryRunner) {\n      await queryRunner.release();\n    }\n  }\n  /**\n   * Clears everything stored in the cache.\n   */\n\n\n  async clear(queryRunner) {\n    return this.getQueryRunner(queryRunner).clearTable(this.queryResultCacheTable);\n  }\n  /**\n   * Removes all cached results by given identifiers from cache.\n   */\n\n\n  async remove(identifiers, queryRunner) {\n    let _queryRunner = queryRunner || this.getQueryRunner();\n\n    await Promise.all(identifiers.map(identifier => {\n      const qb = _queryRunner.manager.createQueryBuilder();\n\n      return qb.delete().from(this.queryResultCacheTable).where(`${qb.escape(\"identifier\")} = :identifier`, {\n        identifier\n      }).execute();\n    }));\n\n    if (!queryRunner) {\n      await _queryRunner.release();\n    }\n  } // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Gets a query runner to work with.\n   */\n\n\n  getQueryRunner(queryRunner) {\n    if (queryRunner) return queryRunner;\n    return this.connection.createQueryRunner();\n  }\n\n}","map":{"version":3,"mappings":"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","names":["MssqlParameter","Table","v4","uuidv4","DbQueryResultCache","constructor","connection","schema","driver","options","database","cacheOptions","cache","cacheTableName","tableName","queryResultCacheDatabase","queryResultCacheSchema","queryResultCacheTable","buildTableName","connect","disconnect","synchronize","queryRunner","getQueryRunner","tableExist","hasTable","createTable","name","columns","isPrimary","isNullable","type","normalizeType","mappedDataTypes","cacheId","generationStrategy","isGenerated","cacheIdentifier","cacheTime","cacheDuration","cacheQuery","cacheResult","getFromCache","qb","createQueryBuilder","select","from","identifier","where","escape","setParameters","getRawOne","query","Promise","resolve","undefined","isExpired","savedCache","duration","parseInt","time","Date","getTime","storeInCache","shouldCreateQueryRunner","getReplicationMode","createQueryRunner","insertedValues","result","manager","update","set","condition","execute","id","insert","into","values","release","clear","clearTable","remove","identifiers","_queryRunner","all","map","delete"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\cache\\DbQueryResultCache.ts"],"sourcesContent":["import { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { MssqlParameter } from \"../driver/sqlserver/MssqlParameter\"\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\nimport { Table } from \"../schema-builder/table/Table\"\nimport { QueryResultCache } from \"./QueryResultCache\"\nimport { QueryResultCacheOptions } from \"./QueryResultCacheOptions\"\nimport { v4 as uuidv4 } from \"uuid\"\n\n/**\n * Caches query result into current database, into separate table called \"query-result-cache\".\n */\nexport class DbQueryResultCache implements QueryResultCache {\n    // -------------------------------------------------------------------------\n    // Private properties\n    // -------------------------------------------------------------------------\n\n    private queryResultCacheTable: string\n\n    private queryResultCacheDatabase?: string\n\n    private queryResultCacheSchema?: string\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(protected connection: DataSource) {\n        const { schema } = this.connection.driver.options as any\n        const database = this.connection.driver.database\n        const cacheOptions =\n            typeof this.connection.options.cache === \"object\"\n                ? this.connection.options.cache\n                : {}\n        const cacheTableName = cacheOptions.tableName || \"query-result-cache\"\n\n        this.queryResultCacheDatabase = database\n        this.queryResultCacheSchema = schema\n        this.queryResultCacheTable = this.connection.driver.buildTableName(\n            cacheTableName,\n            schema,\n            database,\n        )\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates a connection with given cache provider.\n     */\n    async connect(): Promise<void> {}\n\n    /**\n     * Disconnects with given cache provider.\n     */\n    async disconnect(): Promise<void> {}\n\n    /**\n     * Creates table for storing cache if it does not exist yet.\n     */\n    async synchronize(queryRunner?: QueryRunner): Promise<void> {\n        queryRunner = this.getQueryRunner(queryRunner)\n        const driver = this.connection.driver\n        const tableExist = await queryRunner.hasTable(\n            this.queryResultCacheTable,\n        ) // todo: table name should be configurable\n        if (tableExist) return\n\n        await queryRunner.createTable(\n            new Table({\n                database: this.queryResultCacheDatabase,\n                schema: this.queryResultCacheSchema,\n                name: this.queryResultCacheTable,\n                columns: [\n                    {\n                        name: \"id\",\n                        isPrimary: true,\n                        isNullable: false,\n                        type: driver.normalizeType({\n                            type: driver.mappedDataTypes.cacheId,\n                        }),\n                        generationStrategy:\n                            driver.options.type === \"spanner\"\n                                ? \"uuid\"\n                                : \"increment\",\n                        isGenerated: true,\n                    },\n                    {\n                        name: \"identifier\",\n                        type: driver.normalizeType({\n                            type: driver.mappedDataTypes.cacheIdentifier,\n                        }),\n                        isNullable: true,\n                    },\n                    {\n                        name: \"time\",\n                        type: driver.normalizeType({\n                            type: driver.mappedDataTypes.cacheTime,\n                        }),\n                        isPrimary: false,\n                        isNullable: false,\n                    },\n                    {\n                        name: \"duration\",\n                        type: driver.normalizeType({\n                            type: driver.mappedDataTypes.cacheDuration,\n                        }),\n                        isPrimary: false,\n                        isNullable: false,\n                    },\n                    {\n                        name: \"query\",\n                        type: driver.normalizeType({\n                            type: driver.mappedDataTypes.cacheQuery,\n                        }),\n                        isPrimary: false,\n                        isNullable: false,\n                    },\n                    {\n                        name: \"result\",\n                        type: driver.normalizeType({\n                            type: driver.mappedDataTypes.cacheResult,\n                        }),\n                        isNullable: false,\n                    },\n                ],\n            }),\n        )\n    }\n\n    /**\n     * Caches given query result.\n     * Returns cache result if found.\n     * Returns undefined if result is not cached.\n     */\n    getFromCache(\n        options: QueryResultCacheOptions,\n        queryRunner?: QueryRunner,\n    ): Promise<QueryResultCacheOptions | undefined> {\n        queryRunner = this.getQueryRunner(queryRunner)\n        const qb = this.connection\n            .createQueryBuilder(queryRunner)\n            .select()\n            .from(this.queryResultCacheTable, \"cache\")\n\n        if (options.identifier) {\n            return qb\n                .where(\n                    `${qb.escape(\"cache\")}.${qb.escape(\n                        \"identifier\",\n                    )} = :identifier`,\n                )\n                .setParameters({\n                    identifier:\n                        this.connection.driver.options.type === \"mssql\"\n                            ? new MssqlParameter(options.identifier, \"nvarchar\")\n                            : options.identifier,\n                })\n                .getRawOne()\n        } else if (options.query) {\n            if (this.connection.driver.options.type === \"oracle\") {\n                return qb\n                    .where(\n                        `dbms_lob.compare(${qb.escape(\"cache\")}.${qb.escape(\n                            \"query\",\n                        )}, :query) = 0`,\n                        { query: options.query },\n                    )\n                    .getRawOne()\n            }\n\n            return qb\n                .where(`${qb.escape(\"cache\")}.${qb.escape(\"query\")} = :query`)\n                .setParameters({\n                    query:\n                        this.connection.driver.options.type === \"mssql\"\n                            ? new MssqlParameter(options.query, \"nvarchar\")\n                            : options.query,\n                })\n                .getRawOne()\n        }\n\n        return Promise.resolve(undefined)\n    }\n\n    /**\n     * Checks if cache is expired or not.\n     */\n    isExpired(savedCache: QueryResultCacheOptions): boolean {\n        const duration =\n            typeof savedCache.duration === \"string\"\n                ? parseInt(savedCache.duration)\n                : savedCache.duration\n        return (\n            (typeof savedCache.time === \"string\"\n                ? parseInt(savedCache.time as any)\n                : savedCache.time)! +\n                duration <\n            new Date().getTime()\n        )\n    }\n\n    /**\n     * Stores given query result in the cache.\n     */\n    async storeInCache(\n        options: QueryResultCacheOptions,\n        savedCache: QueryResultCacheOptions | undefined,\n        queryRunner?: QueryRunner,\n    ): Promise<void> {\n        const shouldCreateQueryRunner =\n            queryRunner === undefined ||\n            queryRunner?.getReplicationMode() === \"slave\"\n\n        if (queryRunner === undefined || shouldCreateQueryRunner) {\n            queryRunner = this.connection.createQueryRunner(\"master\")\n        }\n\n        let insertedValues: ObjectLiteral = options\n        if (this.connection.driver.options.type === \"mssql\") {\n            // todo: bad abstraction, re-implement this part, probably better if we create an entity metadata for cache table\n            insertedValues = {\n                identifier: new MssqlParameter(options.identifier, \"nvarchar\"),\n                time: new MssqlParameter(options.time, \"bigint\"),\n                duration: new MssqlParameter(options.duration, \"int\"),\n                query: new MssqlParameter(options.query, \"nvarchar\"),\n                result: new MssqlParameter(options.result, \"nvarchar\"),\n            }\n        }\n\n        if (savedCache && savedCache.identifier) {\n            // if exist then update\n            const qb = queryRunner.manager\n                .createQueryBuilder()\n                .update(this.queryResultCacheTable)\n                .set(insertedValues)\n\n            qb.where(`${qb.escape(\"identifier\")} = :condition`, {\n                condition: insertedValues.identifier,\n            })\n            await qb.execute()\n        } else if (savedCache && savedCache.query) {\n            // if exist then update\n            const qb = queryRunner.manager\n                .createQueryBuilder()\n                .update(this.queryResultCacheTable)\n                .set(insertedValues)\n\n            if (this.connection.driver.options.type === \"oracle\") {\n                qb.where(`dbms_lob.compare(\"query\", :condition) = 0`, {\n                    condition: insertedValues.query,\n                })\n            } else {\n                qb.where(`${qb.escape(\"query\")} = :condition`, {\n                    condition: insertedValues.query,\n                })\n            }\n\n            await qb.execute()\n        } else {\n            // Spanner does not support auto-generated columns\n            if (\n                this.connection.driver.options.type === \"spanner\" &&\n                !insertedValues.id\n            ) {\n                insertedValues.id = uuidv4()\n            }\n\n            // otherwise insert\n            await queryRunner.manager\n                .createQueryBuilder()\n                .insert()\n                .into(this.queryResultCacheTable)\n                .values(insertedValues)\n                .execute()\n        }\n\n        if (shouldCreateQueryRunner) {\n            await queryRunner.release()\n        }\n    }\n\n    /**\n     * Clears everything stored in the cache.\n     */\n    async clear(queryRunner: QueryRunner): Promise<void> {\n        return this.getQueryRunner(queryRunner).clearTable(\n            this.queryResultCacheTable,\n        )\n    }\n\n    /**\n     * Removes all cached results by given identifiers from cache.\n     */\n    async remove(\n        identifiers: string[],\n        queryRunner?: QueryRunner,\n    ): Promise<void> {\n        let _queryRunner: QueryRunner = queryRunner || this.getQueryRunner()\n        await Promise.all(\n            identifiers.map((identifier) => {\n                const qb = _queryRunner.manager.createQueryBuilder()\n                return qb\n                    .delete()\n                    .from(this.queryResultCacheTable)\n                    .where(`${qb.escape(\"identifier\")} = :identifier`, {\n                        identifier,\n                    })\n                    .execute()\n            }),\n        )\n\n        if (!queryRunner) {\n            await _queryRunner.release()\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets a query runner to work with.\n     */\n    protected getQueryRunner(queryRunner?: QueryRunner): QueryRunner {\n        if (queryRunner) return queryRunner\n\n        return this.connection.createQueryRunner()\n    }\n}\n"]},"metadata":{},"sourceType":"module"}