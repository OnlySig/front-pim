{"ast":null,"code":"import { EntityMetadata } from \"./EntityMetadata\";\nimport { TypeORMError } from \"../error\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\nimport { InstanceChecker } from \"../util/InstanceChecker\";\n/**\n * Contains all information about some entity's relation.\n */\n\nexport class RelationMetadata {\n  // ---------------------------------------------------------------------\n  // Constructor\n  // ---------------------------------------------------------------------\n  constructor(options) {\n    /**\n     * Indicates if this is a parent (can be only many-to-one relation) relation in the tree tables.\n     */\n    this.isTreeParent = false;\n    /**\n     * Indicates if this is a children (can be only one-to-many relation) relation in the tree tables.\n     */\n\n    this.isTreeChildren = false;\n    /**\n     * Indicates if this relation's column is a primary key.\n     * Can be used only for many-to-one and owner one-to-one relations.\n     */\n\n    this.isPrimary = false;\n    /**\n     * Indicates if this relation is lazily loaded.\n     */\n\n    this.isLazy = false;\n    /**\n     * Indicates if this relation is eagerly loaded.\n     */\n\n    this.isEager = false;\n    /**\n     * Indicates if persistence is enabled for the relation.\n     * By default its enabled, but if you want to avoid any changes in the relation to be reflected in the database you can disable it.\n     * If its disabled you can only change a relation from inverse side of a relation or using relation query builder functionality.\n     * This is useful for performance optimization since its disabling avoid multiple extra queries during entity save.\n     */\n\n    this.persistenceEnabled = true;\n    /**\n     * If set to true then related objects are allowed to be inserted to the database.\n     */\n\n    this.isCascadeInsert = false;\n    /**\n     * If set to true then related objects are allowed to be updated in the database.\n     */\n\n    this.isCascadeUpdate = false;\n    /**\n     * If set to true then related objects are allowed to be remove from the database.\n     */\n\n    this.isCascadeRemove = false;\n    /**\n     * If set to true then related objects are allowed to be soft-removed from the database.\n     */\n\n    this.isCascadeSoftRemove = false;\n    /**\n     * If set to true then related objects are allowed to be recovered from the database.\n     */\n\n    this.isCascadeRecover = false;\n    /**\n     * Indicates if relation column value can be nullable or not.\n     */\n\n    this.isNullable = true;\n    /**\n     * Indicates whether foreign key constraints will be created for join columns.\n     * Can be used only for many-to-one and owner one-to-one relations.\n     * Defaults to true.\n     */\n\n    this.createForeignKeyConstraints = true;\n    /**\n     * Indicates if this side is an owner of this relation.\n     */\n\n    this.isOwning = false;\n    /**\n     * Checks if this relation's type is \"one-to-one\".\n     */\n\n    this.isOneToOne = false;\n    /**\n     * Checks if this relation is owner side of the \"one-to-one\" relation.\n     * Owner side means this side of relation has a join column in the table.\n     */\n\n    this.isOneToOneOwner = false;\n    /**\n     * Checks if this relation has a join column (e.g. is it many-to-one or one-to-one owner side).\n     */\n\n    this.isWithJoinColumn = false;\n    /**\n     * Checks if this relation is NOT owner side of the \"one-to-one\" relation.\n     * NOT owner side means this side of relation does not have a join column in the table.\n     */\n\n    this.isOneToOneNotOwner = false;\n    /**\n     * Checks if this relation's type is \"one-to-many\".\n     */\n\n    this.isOneToMany = false;\n    /**\n     * Checks if this relation's type is \"many-to-one\".\n     */\n\n    this.isManyToOne = false;\n    /**\n     * Checks if this relation's type is \"many-to-many\".\n     */\n\n    this.isManyToMany = false;\n    /**\n     * Checks if this relation's type is \"many-to-many\", and is owner side of the relationship.\n     * Owner side means this side of relation has a join table.\n     */\n\n    this.isManyToManyOwner = false;\n    /**\n     * Checks if this relation's type is \"many-to-many\", and is NOT owner side of the relationship.\n     * Not owner side means this side of relation does not have a join table.\n     */\n\n    this.isManyToManyNotOwner = false;\n    /**\n     * Foreign keys created for this relation.\n     */\n\n    this.foreignKeys = [];\n    /**\n     * Join table columns.\n     * Join columns can be obtained only from owner side of the relation.\n     * From non-owner side of the relation join columns will be empty.\n     * If this relation is a many-to-one/one-to-one then it takes join columns from the current entity.\n     * If this relation is many-to-many then it takes all owner join columns from the junction entity.\n     */\n\n    this.joinColumns = [];\n    /**\n     * Inverse join table columns.\n     * Inverse join columns are supported only for many-to-many relations\n     * and can be obtained only from owner side of the relation.\n     * From non-owner side of the relation join columns will be undefined.\n     */\n\n    this.inverseJoinColumns = [];\n    this.entityMetadata = options.entityMetadata;\n    this.embeddedMetadata = options.embeddedMetadata;\n    const args = options.args;\n    this.target = args.target;\n    this.propertyName = args.propertyName;\n    this.relationType = args.relationType;\n    if (args.inverseSideProperty) this.givenInverseSidePropertyFactory = args.inverseSideProperty;\n    this.isLazy = args.isLazy || false; // this.isCascadeInsert = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf(\"insert\") !== -1);\n    // this.isCascadeUpdate = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf(\"update\") !== -1);\n    // this.isCascadeRemove = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf(\"remove\") !== -1);\n    // this.isCascadeSoftRemove = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf(\"soft-remove\") !== -1);\n    // this.isCascadeRecover = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf(\"recover\") !== -1);\n\n    this.isCascadeInsert = args.options.cascade === true || Array.isArray(args.options.cascade) && args.options.cascade.indexOf(\"insert\") !== -1;\n    this.isCascadeUpdate = args.options.cascade === true || Array.isArray(args.options.cascade) && args.options.cascade.indexOf(\"update\") !== -1;\n    this.isCascadeRemove = args.options.cascade === true || Array.isArray(args.options.cascade) && args.options.cascade.indexOf(\"remove\") !== -1;\n    this.isCascadeSoftRemove = args.options.cascade === true || Array.isArray(args.options.cascade) && args.options.cascade.indexOf(\"soft-remove\") !== -1;\n    this.isCascadeRecover = args.options.cascade === true || Array.isArray(args.options.cascade) && args.options.cascade.indexOf(\"recover\") !== -1; // this.isPrimary = args.options.primary || false;\n\n    this.isNullable = args.options.nullable === false || this.isPrimary ? false : true;\n    this.onDelete = args.options.onDelete;\n    this.onUpdate = args.options.onUpdate;\n    this.deferrable = args.options.deferrable;\n    this.createForeignKeyConstraints = args.options.createForeignKeyConstraints === false ? false : true;\n    this.isEager = args.options.eager || false;\n    this.persistenceEnabled = args.options.persistence === false ? false : true;\n    this.orphanedRowAction = args.options.orphanedRowAction || \"nullify\";\n    this.isTreeParent = args.isTreeParent || false;\n    this.isTreeChildren = args.isTreeChildren || false;\n\n    if (typeof args.type === \"function\") {\n      this.type = typeof args.type === \"function\" ? args.type() : args.type;\n    } else if (InstanceChecker.isEntitySchema(args.type)) {\n      this.type = args.type.options.name;\n    } else if (ObjectUtils.isObject(args.type) && typeof args.type.name === \"string\") {\n      this.type = args.type.name;\n    } else {\n      this.type = args.type;\n    }\n\n    this.isOneToOne = this.relationType === \"one-to-one\";\n    this.isOneToMany = this.relationType === \"one-to-many\";\n    this.isManyToOne = this.relationType === \"many-to-one\";\n    this.isManyToMany = this.relationType === \"many-to-many\";\n    this.isOneToOneNotOwner = this.isOneToOne ? true : false;\n    this.isManyToManyNotOwner = this.isManyToMany ? true : false;\n  } // ---------------------------------------------------------------------\n  // Public Methods\n  // ---------------------------------------------------------------------\n\n  /**\n   * Creates join column ids map from the given related entity ids array.\n   */\n\n\n  getRelationIdMap(entity) {\n    const joinColumns = this.isOwning ? this.joinColumns : this.inverseRelation.joinColumns;\n    const referencedColumns = joinColumns.map(joinColumn => joinColumn.referencedColumn); // console.log(\"entity\", entity);\n    // console.log(\"referencedColumns\", referencedColumns);\n\n    return EntityMetadata.getValueMap(entity, referencedColumns);\n  }\n  /**\n   * Ensures that given object is an entity id map.\n   * If given id is an object then it means its already id map.\n   * If given id isn't an object then it means its a value of the id column\n   * and it creates a new id map with this value and name of the primary column.\n   */\n\n\n  ensureRelationIdMap(id) {\n    if (ObjectUtils.isObject(id)) return id;\n    const joinColumns = this.isOwning ? this.joinColumns : this.inverseRelation.joinColumns;\n    const referencedColumns = joinColumns.map(joinColumn => joinColumn.referencedColumn);\n    if (referencedColumns.length > 1) throw new TypeORMError(`Cannot create relation id map for a single value because relation contains multiple referenced columns.`);\n    return referencedColumns[0].createValueMap(id);\n  }\n  /**\n   * Extracts column value from the given entity.\n   * If column is in embedded (or recursive embedded) it extracts its value from there.\n   */\n\n\n  getEntityValue(entity) {\n    let getLazyRelationsPromiseValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (entity === null || entity === undefined) return undefined; // extract column value from embeddeds of entity if column is in embedded\n\n    if (this.embeddedMetadata) {\n      // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n      // we need to get value of \"id\" column from the post real entity object\n      // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n      const propertyNames = [...this.embeddedMetadata.parentPropertyNames]; // next we need to access post[data][information][counters][this.propertyName] to get column value from the counters\n      // this recursive function takes array of generated property names and gets the post[data][information][counters] embed\n\n      const extractEmbeddedColumnValue = (propertyNames, value) => {\n        const propertyName = propertyNames.shift();\n\n        if (propertyName) {\n          if (value[propertyName]) {\n            return extractEmbeddedColumnValue(propertyNames, value[propertyName]);\n          }\n\n          return undefined;\n        }\n\n        return value;\n      }; // once we get nested embed object we get its column, e.g. post[data][information][counters][this.propertyName]\n\n\n      const embeddedObject = extractEmbeddedColumnValue(propertyNames, entity);\n\n      if (this.isLazy) {\n        if (embeddedObject[\"__\" + this.propertyName + \"__\"] !== undefined) return embeddedObject[\"__\" + this.propertyName + \"__\"];\n        if (getLazyRelationsPromiseValue === true) return embeddedObject[this.propertyName];\n        return undefined;\n      }\n\n      return embeddedObject ? embeddedObject[this.isLazy ? \"__\" + this.propertyName + \"__\" : this.propertyName] : undefined;\n    } else {\n      // no embeds - no problems. Simply return column name by property name of the entity\n      if (this.isLazy) {\n        if (entity[\"__\" + this.propertyName + \"__\"] !== undefined) return entity[\"__\" + this.propertyName + \"__\"];\n        if (getLazyRelationsPromiseValue === true) return entity[this.propertyName];\n        return undefined;\n      }\n\n      return entity[this.propertyName];\n    }\n  }\n  /**\n   * Sets given entity's relation's value.\n   * Using of this method helps to set entity relation's value of the lazy and non-lazy relations.\n   *\n   * If merge is set to true, it merges given value into currently\n   */\n\n\n  setEntityValue(entity, value) {\n    const propertyName = this.isLazy ? \"__\" + this.propertyName + \"__\" : this.propertyName;\n\n    if (this.embeddedMetadata) {\n      // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n      const extractEmbeddedColumnValue = (embeddedMetadatas, map) => {\n        // if (!object[embeddedMetadata.propertyName])\n        //     object[embeddedMetadata.propertyName] = embeddedMetadata.create();\n        const embeddedMetadata = embeddedMetadatas.shift();\n\n        if (embeddedMetadata) {\n          if (!map[embeddedMetadata.propertyName]) map[embeddedMetadata.propertyName] = embeddedMetadata.create();\n          extractEmbeddedColumnValue(embeddedMetadatas, map[embeddedMetadata.propertyName]);\n          return map;\n        }\n\n        map[propertyName] = value;\n        return map;\n      };\n\n      return extractEmbeddedColumnValue([...this.embeddedMetadata.embeddedMetadataTree], entity);\n    } else {\n      entity[propertyName] = value;\n    }\n  }\n  /**\n   * Creates entity id map from the given entity ids array.\n   */\n\n\n  createValueMap(value) {\n    // extract column value from embeds of entity if column is in embedded\n    if (this.embeddedMetadata) {\n      // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n      // we need to get value of \"id\" column from the post real entity object and return it in a\n      // { data: { information: { counters: { id: ... } } } } format\n      // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n      const propertyNames = [...this.embeddedMetadata.parentPropertyNames]; // now need to access post[data][information][counters] to get column value from the counters\n      // and on each step we need to create complex literal object, e.g. first { data },\n      // then { data: { information } }, then { data: { information: { counters } } },\n      // then { data: { information: { counters: [this.propertyName]: entity[data][information][counters][this.propertyName] } } }\n      // this recursive function helps doing that\n\n      const extractEmbeddedColumnValue = (propertyNames, map) => {\n        const propertyName = propertyNames.shift();\n\n        if (propertyName) {\n          map[propertyName] = {};\n          extractEmbeddedColumnValue(propertyNames, map[propertyName]);\n          return map;\n        }\n\n        map[this.propertyName] = value;\n        return map;\n      };\n\n      return extractEmbeddedColumnValue(propertyNames, {});\n    } else {\n      // no embeds - no problems. Simply return column property name and its value of the entity\n      return {\n        [this.propertyName]: value\n      };\n    }\n  } // ---------------------------------------------------------------------\n  // Builder Methods\n  // ---------------------------------------------------------------------\n\n  /**\n   * Builds some depend relation metadata properties.\n   * This builder method should be used only after embedded metadata tree was build.\n   */\n\n\n  build() {\n    this.propertyPath = this.buildPropertyPath();\n  }\n  /**\n   * Registers given foreign keys in the relation.\n   * This builder method should be used to register foreign key in the relation.\n   */\n\n\n  registerForeignKeys() {\n    this.foreignKeys.push(...arguments);\n  }\n  /**\n   * Registers given join columns in the relation.\n   * This builder method should be used to register join column in the relation.\n   */\n\n\n  registerJoinColumns() {\n    let joinColumns = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let inverseJoinColumns = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    this.joinColumns = joinColumns;\n    this.inverseJoinColumns = inverseJoinColumns;\n    this.isOwning = this.isManyToOne || (this.isManyToMany || this.isOneToOne) && this.joinColumns.length > 0;\n    this.isOneToOneOwner = this.isOneToOne && this.isOwning;\n    this.isOneToOneNotOwner = this.isOneToOne && !this.isOwning;\n    this.isManyToManyOwner = this.isManyToMany && this.isOwning;\n    this.isManyToManyNotOwner = this.isManyToMany && !this.isOwning;\n    this.isWithJoinColumn = this.isManyToOne || this.isOneToOneOwner;\n  }\n  /**\n   * Registers a given junction entity metadata.\n   * This builder method can be called after junction entity metadata for the many-to-many relation was created.\n   */\n\n\n  registerJunctionEntityMetadata(junctionEntityMetadata) {\n    this.junctionEntityMetadata = junctionEntityMetadata;\n    this.joinTableName = junctionEntityMetadata.tableName;\n\n    if (this.inverseRelation) {\n      this.inverseRelation.junctionEntityMetadata = junctionEntityMetadata;\n      this.joinTableName = junctionEntityMetadata.tableName;\n    }\n  }\n  /**\n   * Builds inverse side property path based on given inverse side property factory.\n   * This builder method should be used only after properties map of the inverse entity metadata was build.\n   */\n\n\n  buildInverseSidePropertyPath() {\n    if (this.givenInverseSidePropertyFactory) {\n      const ownerEntityPropertiesMap = this.inverseEntityMetadata.propertiesMap;\n      if (typeof this.givenInverseSidePropertyFactory === \"function\") return this.givenInverseSidePropertyFactory(ownerEntityPropertiesMap);\n      if (typeof this.givenInverseSidePropertyFactory === \"string\") return this.givenInverseSidePropertyFactory;\n    } else if (this.isTreeParent && this.entityMetadata.treeChildrenRelation) {\n      return this.entityMetadata.treeChildrenRelation.propertyName;\n    } else if (this.isTreeChildren && this.entityMetadata.treeParentRelation) {\n      return this.entityMetadata.treeParentRelation.propertyName;\n    }\n\n    return \"\";\n  }\n  /**\n   * Builds relation's property path based on its embedded tree.\n   */\n\n\n  buildPropertyPath() {\n    if (!this.embeddedMetadata || !this.embeddedMetadata.parentPropertyNames.length) return this.propertyName;\n    return this.embeddedMetadata.parentPropertyNames.join(\".\") + \".\" + this.propertyName;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["EntityMetadata","TypeORMError","ObjectUtils","InstanceChecker","RelationMetadata","constructor","options","entityMetadata","embeddedMetadata","args","target","propertyName","relationType","inverseSideProperty","givenInverseSidePropertyFactory","isLazy","isCascadeInsert","cascade","Array","isArray","indexOf","isCascadeUpdate","isCascadeRemove","isCascadeSoftRemove","isCascadeRecover","isNullable","nullable","isPrimary","onDelete","onUpdate","deferrable","createForeignKeyConstraints","isEager","eager","persistenceEnabled","persistence","orphanedRowAction","isTreeParent","isTreeChildren","type","isEntitySchema","name","isObject","isOneToOne","isOneToMany","isManyToOne","isManyToMany","isOneToOneNotOwner","isManyToManyNotOwner","getRelationIdMap","entity","joinColumns","isOwning","inverseRelation","referencedColumns","map","joinColumn","referencedColumn","getValueMap","ensureRelationIdMap","id","length","createValueMap","getEntityValue","getLazyRelationsPromiseValue","undefined","propertyNames","parentPropertyNames","extractEmbeddedColumnValue","value","shift","embeddedObject","setEntityValue","embeddedMetadatas","create","embeddedMetadataTree","build","propertyPath","buildPropertyPath","registerForeignKeys","foreignKeys","push","registerJoinColumns","inverseJoinColumns","isOneToOneOwner","isManyToManyOwner","isWithJoinColumn","registerJunctionEntityMetadata","junctionEntityMetadata","joinTableName","tableName","buildInverseSidePropertyPath","ownerEntityPropertiesMap","inverseEntityMetadata","propertiesMap","treeChildrenRelation","treeParentRelation","join"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\metadata\\RelationMetadata.ts"],"sourcesContent":["import { RelationType } from \"./types/RelationTypes\"\nimport { EntityMetadata } from \"./EntityMetadata\"\nimport { ForeignKeyMetadata } from \"./ForeignKeyMetadata\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { ColumnMetadata } from \"./ColumnMetadata\"\nimport { EmbeddedMetadata } from \"./EmbeddedMetadata\"\nimport { RelationMetadataArgs } from \"../metadata-args/RelationMetadataArgs\"\nimport { DeferrableType } from \"./types/DeferrableType\"\nimport { OnUpdateType } from \"./types/OnUpdateType\"\nimport { OnDeleteType } from \"./types/OnDeleteType\"\nimport { PropertyTypeFactory } from \"./types/PropertyTypeInFunction\"\nimport { TypeORMError } from \"../error\"\nimport { ObjectUtils } from \"../util/ObjectUtils\"\nimport { InstanceChecker } from \"../util/InstanceChecker\"\n\n/**\n * Contains all information about some entity's relation.\n */\nexport class RelationMetadata {\n    // ---------------------------------------------------------------------\n    // Public Properties\n    // ---------------------------------------------------------------------\n\n    /**\n     * Entity metadata of the entity where this relation is placed.\n     *\n     * For example for @ManyToMany(type => Category) in Post, entityMetadata will be metadata of Post entity.\n     */\n    entityMetadata: EntityMetadata\n\n    /**\n     * Entity metadata of the entity that is targeted by this relation.\n     *\n     * For example for @ManyToMany(type => Category) in Post, inverseEntityMetadata will be metadata of Category entity.\n     */\n    inverseEntityMetadata: EntityMetadata\n\n    /**\n     * Entity metadata of the junction table.\n     * Junction tables have their own entity metadata objects.\n     * Defined only for many-to-many relations.\n     */\n    junctionEntityMetadata?: EntityMetadata\n\n    /**\n     * Embedded metadata where this relation is.\n     * If this relation is not in embed then this property value is undefined.\n     */\n    embeddedMetadata?: EmbeddedMetadata\n\n    /**\n     * Relation type, e.g. is it one-to-one, one-to-many, many-to-one or many-to-many.\n     */\n    relationType: RelationType\n\n    /**\n     * Target entity to which this relation is applied.\n     * Target IS NOT equal to entityMetadata.target, because relation\n     *\n     * For example for @ManyToMany(type => Category) in Post, target will be Post.\n     * If @ManyToMany(type => Category) is in Counters which is embedded into Post, target will be Counters.\n     * If @ManyToMany(type => Category) is in abstract class BaseUser which Post extends, target will be BaseUser.\n     * Target can be string if its defined in entity schema instead of class.\n     */\n    target: Function | string\n\n    /**\n     * Target's property name to which relation decorator is applied.\n     */\n    propertyName: string\n\n    /**\n     * Gets full path to this column property (including relation name).\n     * Full path is relevant when column is used in embeds (one or multiple nested).\n     * For example it will return \"counters.subcounters.likes\".\n     * If property is not in embeds then it returns just property name of the column.\n     */\n    propertyPath: string\n\n    /**\n     * Indicates if this is a parent (can be only many-to-one relation) relation in the tree tables.\n     */\n    isTreeParent: boolean = false\n\n    /**\n     * Indicates if this is a children (can be only one-to-many relation) relation in the tree tables.\n     */\n    isTreeChildren: boolean = false\n\n    /**\n     * Indicates if this relation's column is a primary key.\n     * Can be used only for many-to-one and owner one-to-one relations.\n     */\n    isPrimary: boolean = false\n\n    /**\n     * Indicates if this relation is lazily loaded.\n     */\n    isLazy: boolean = false\n\n    /**\n     * Indicates if this relation is eagerly loaded.\n     */\n    isEager: boolean = false\n\n    /**\n     * Indicates if persistence is enabled for the relation.\n     * By default its enabled, but if you want to avoid any changes in the relation to be reflected in the database you can disable it.\n     * If its disabled you can only change a relation from inverse side of a relation or using relation query builder functionality.\n     * This is useful for performance optimization since its disabling avoid multiple extra queries during entity save.\n     */\n    persistenceEnabled: boolean = true\n\n    /**\n     * When a parent is saved (with cascading but) without a child row that still exists in database, this will control what shall happen to them.\n     * delete will remove these rows from database. nullify will remove the relation key.\n     * skip will keep the relation intact. Removal of related item is only possible through its own repo.\n     */\n    orphanedRowAction?: \"nullify\" | \"delete\" | \"soft-delete\" | \"disable\"\n\n    /**\n     * If set to true then related objects are allowed to be inserted to the database.\n     */\n    isCascadeInsert: boolean = false\n\n    /**\n     * If set to true then related objects are allowed to be updated in the database.\n     */\n    isCascadeUpdate: boolean = false\n\n    /**\n     * If set to true then related objects are allowed to be remove from the database.\n     */\n    isCascadeRemove: boolean = false\n\n    /**\n     * If set to true then related objects are allowed to be soft-removed from the database.\n     */\n    isCascadeSoftRemove: boolean = false\n\n    /**\n     * If set to true then related objects are allowed to be recovered from the database.\n     */\n    isCascadeRecover: boolean = false\n\n    /**\n     * Indicates if relation column value can be nullable or not.\n     */\n    isNullable: boolean = true\n\n    /**\n     * What to do with a relation on deletion of the row containing a foreign key.\n     */\n    onDelete?: OnDeleteType\n\n    /**\n     * What to do with a relation on update of the row containing a foreign key.\n     */\n    onUpdate?: OnUpdateType\n\n    /**\n     * What to do with a relation on update of the row containing a foreign key.\n     */\n    deferrable?: DeferrableType\n\n    /**\n     * Indicates whether foreign key constraints will be created for join columns.\n     * Can be used only for many-to-one and owner one-to-one relations.\n     * Defaults to true.\n     */\n    createForeignKeyConstraints: boolean = true\n\n    /**\n     * Gets the property's type to which this relation is applied.\n     *\n     * For example for @ManyToMany(type => Category) in Post, target will be Category.\n     */\n    type: Function | string\n\n    /**\n     * Indicates if this side is an owner of this relation.\n     */\n    isOwning: boolean = false\n\n    /**\n     * Checks if this relation's type is \"one-to-one\".\n     */\n    isOneToOne: boolean = false\n\n    /**\n     * Checks if this relation is owner side of the \"one-to-one\" relation.\n     * Owner side means this side of relation has a join column in the table.\n     */\n    isOneToOneOwner: boolean = false\n\n    /**\n     * Checks if this relation has a join column (e.g. is it many-to-one or one-to-one owner side).\n     */\n    isWithJoinColumn: boolean = false\n\n    /**\n     * Checks if this relation is NOT owner side of the \"one-to-one\" relation.\n     * NOT owner side means this side of relation does not have a join column in the table.\n     */\n    isOneToOneNotOwner: boolean = false\n\n    /**\n     * Checks if this relation's type is \"one-to-many\".\n     */\n    isOneToMany: boolean = false\n\n    /**\n     * Checks if this relation's type is \"many-to-one\".\n     */\n    isManyToOne: boolean = false\n\n    /**\n     * Checks if this relation's type is \"many-to-many\".\n     */\n    isManyToMany: boolean = false\n\n    /**\n     * Checks if this relation's type is \"many-to-many\", and is owner side of the relationship.\n     * Owner side means this side of relation has a join table.\n     */\n    isManyToManyOwner: boolean = false\n\n    /**\n     * Checks if this relation's type is \"many-to-many\", and is NOT owner side of the relationship.\n     * Not owner side means this side of relation does not have a join table.\n     */\n    isManyToManyNotOwner: boolean = false\n\n    /**\n     * Gets the property path of the inverse side of the relation.\n     */\n    inverseSidePropertyPath: string\n\n    /**\n     * Inverse side of the relation set by user.\n     *\n     * Inverse side set in the relation can be either string - property name of the column on inverse side,\n     * either can be a function that accepts a map of properties with the object and returns one of them.\n     * Second approach is used to achieve type-safety.\n     */\n    givenInverseSidePropertyFactory: PropertyTypeFactory<any>\n\n    /**\n     * Gets the relation metadata of the inverse side of this relation.\n     */\n    inverseRelation?: RelationMetadata\n\n    /**\n     * Join table name.\n     */\n    joinTableName: string\n\n    /**\n     * Foreign keys created for this relation.\n     */\n    foreignKeys: ForeignKeyMetadata[] = []\n\n    /**\n     * Join table columns.\n     * Join columns can be obtained only from owner side of the relation.\n     * From non-owner side of the relation join columns will be empty.\n     * If this relation is a many-to-one/one-to-one then it takes join columns from the current entity.\n     * If this relation is many-to-many then it takes all owner join columns from the junction entity.\n     */\n    joinColumns: ColumnMetadata[] = []\n\n    /**\n     * Inverse join table columns.\n     * Inverse join columns are supported only for many-to-many relations\n     * and can be obtained only from owner side of the relation.\n     * From non-owner side of the relation join columns will be undefined.\n     */\n    inverseJoinColumns: ColumnMetadata[] = []\n\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(options: {\n        entityMetadata: EntityMetadata\n        embeddedMetadata?: EmbeddedMetadata\n        args: RelationMetadataArgs\n    }) {\n        this.entityMetadata = options.entityMetadata\n        this.embeddedMetadata = options.embeddedMetadata!\n        const args = options.args\n        this.target = args.target\n        this.propertyName = args.propertyName\n        this.relationType = args.relationType\n\n        if (args.inverseSideProperty)\n            this.givenInverseSidePropertyFactory = args.inverseSideProperty\n\n        this.isLazy = args.isLazy || false\n        // this.isCascadeInsert = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf(\"insert\") !== -1);\n        // this.isCascadeUpdate = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf(\"update\") !== -1);\n        // this.isCascadeRemove = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf(\"remove\") !== -1);\n        // this.isCascadeSoftRemove = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf(\"soft-remove\") !== -1);\n        // this.isCascadeRecover = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf(\"recover\") !== -1);\n        this.isCascadeInsert =\n            args.options.cascade === true ||\n            (Array.isArray(args.options.cascade) &&\n                args.options.cascade.indexOf(\"insert\") !== -1)\n        this.isCascadeUpdate =\n            args.options.cascade === true ||\n            (Array.isArray(args.options.cascade) &&\n                args.options.cascade.indexOf(\"update\") !== -1)\n        this.isCascadeRemove =\n            args.options.cascade === true ||\n            (Array.isArray(args.options.cascade) &&\n                args.options.cascade.indexOf(\"remove\") !== -1)\n        this.isCascadeSoftRemove =\n            args.options.cascade === true ||\n            (Array.isArray(args.options.cascade) &&\n                args.options.cascade.indexOf(\"soft-remove\") !== -1)\n        this.isCascadeRecover =\n            args.options.cascade === true ||\n            (Array.isArray(args.options.cascade) &&\n                args.options.cascade.indexOf(\"recover\") !== -1)\n        // this.isPrimary = args.options.primary || false;\n        this.isNullable =\n            args.options.nullable === false || this.isPrimary ? false : true\n        this.onDelete = args.options.onDelete\n        this.onUpdate = args.options.onUpdate\n        this.deferrable = args.options.deferrable\n        this.createForeignKeyConstraints =\n            args.options.createForeignKeyConstraints === false ? false : true\n        this.isEager = args.options.eager || false\n        this.persistenceEnabled =\n            args.options.persistence === false ? false : true\n        this.orphanedRowAction = args.options.orphanedRowAction || \"nullify\"\n        this.isTreeParent = args.isTreeParent || false\n        this.isTreeChildren = args.isTreeChildren || false\n\n        if (typeof args.type === \"function\") {\n            this.type =\n                typeof args.type === \"function\"\n                    ? (args.type as () => any)()\n                    : args.type\n        } else if (InstanceChecker.isEntitySchema(args.type)) {\n            this.type = args.type.options.name\n        } else if (\n            ObjectUtils.isObject(args.type) &&\n            typeof (args.type as any).name === \"string\"\n        ) {\n            this.type = (args.type as any).name\n        } else {\n            this.type = args.type as string | Function\n        }\n\n        this.isOneToOne = this.relationType === \"one-to-one\"\n        this.isOneToMany = this.relationType === \"one-to-many\"\n        this.isManyToOne = this.relationType === \"many-to-one\"\n        this.isManyToMany = this.relationType === \"many-to-many\"\n        this.isOneToOneNotOwner = this.isOneToOne ? true : false\n        this.isManyToManyNotOwner = this.isManyToMany ? true : false\n    }\n\n    // ---------------------------------------------------------------------\n    // Public Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Creates join column ids map from the given related entity ids array.\n     */\n    getRelationIdMap(entity: ObjectLiteral): ObjectLiteral | undefined {\n        const joinColumns = this.isOwning\n            ? this.joinColumns\n            : this.inverseRelation!.joinColumns\n        const referencedColumns = joinColumns.map(\n            (joinColumn) => joinColumn.referencedColumn!,\n        )\n        // console.log(\"entity\", entity);\n        // console.log(\"referencedColumns\", referencedColumns);\n        return EntityMetadata.getValueMap(entity, referencedColumns)\n    }\n\n    /**\n     * Ensures that given object is an entity id map.\n     * If given id is an object then it means its already id map.\n     * If given id isn't an object then it means its a value of the id column\n     * and it creates a new id map with this value and name of the primary column.\n     */\n    ensureRelationIdMap(id: any): ObjectLiteral {\n        if (ObjectUtils.isObject(id)) return id\n\n        const joinColumns = this.isOwning\n            ? this.joinColumns\n            : this.inverseRelation!.joinColumns\n        const referencedColumns = joinColumns.map(\n            (joinColumn) => joinColumn.referencedColumn!,\n        )\n\n        if (referencedColumns.length > 1)\n            throw new TypeORMError(\n                `Cannot create relation id map for a single value because relation contains multiple referenced columns.`,\n            )\n\n        return referencedColumns[0].createValueMap(id)\n    }\n\n    /**\n     * Extracts column value from the given entity.\n     * If column is in embedded (or recursive embedded) it extracts its value from there.\n     */\n    getEntityValue(\n        entity: ObjectLiteral,\n        getLazyRelationsPromiseValue: boolean = false,\n    ): any | undefined {\n        if (entity === null || entity === undefined) return undefined\n        // extract column value from embeddeds of entity if column is in embedded\n        if (this.embeddedMetadata) {\n            // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n            // we need to get value of \"id\" column from the post real entity object\n\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n            const propertyNames = [...this.embeddedMetadata.parentPropertyNames]\n\n            // next we need to access post[data][information][counters][this.propertyName] to get column value from the counters\n            // this recursive function takes array of generated property names and gets the post[data][information][counters] embed\n            const extractEmbeddedColumnValue = (\n                propertyNames: string[],\n                value: ObjectLiteral,\n            ): any => {\n                const propertyName = propertyNames.shift()\n                if (propertyName) {\n                    if (value[propertyName]) {\n                        return extractEmbeddedColumnValue(\n                            propertyNames,\n                            value[propertyName],\n                        )\n                    }\n                    return undefined\n                }\n                return value\n            }\n\n            // once we get nested embed object we get its column, e.g. post[data][information][counters][this.propertyName]\n            const embeddedObject = extractEmbeddedColumnValue(\n                propertyNames,\n                entity,\n            )\n\n            if (this.isLazy) {\n                if (\n                    embeddedObject[\"__\" + this.propertyName + \"__\"] !==\n                    undefined\n                )\n                    return embeddedObject[\"__\" + this.propertyName + \"__\"]\n\n                if (getLazyRelationsPromiseValue === true)\n                    return embeddedObject[this.propertyName]\n\n                return undefined\n            }\n            return embeddedObject\n                ? embeddedObject[\n                      this.isLazy\n                          ? \"__\" + this.propertyName + \"__\"\n                          : this.propertyName\n                  ]\n                : undefined\n        } else {\n            // no embeds - no problems. Simply return column name by property name of the entity\n            if (this.isLazy) {\n                if (entity[\"__\" + this.propertyName + \"__\"] !== undefined)\n                    return entity[\"__\" + this.propertyName + \"__\"]\n\n                if (getLazyRelationsPromiseValue === true)\n                    return entity[this.propertyName]\n\n                return undefined\n            }\n            return entity[this.propertyName]\n        }\n    }\n\n    /**\n     * Sets given entity's relation's value.\n     * Using of this method helps to set entity relation's value of the lazy and non-lazy relations.\n     *\n     * If merge is set to true, it merges given value into currently\n     */\n    setEntityValue(entity: ObjectLiteral, value: any): void {\n        const propertyName = this.isLazy\n            ? \"__\" + this.propertyName + \"__\"\n            : this.propertyName\n\n        if (this.embeddedMetadata) {\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n            const extractEmbeddedColumnValue = (\n                embeddedMetadatas: EmbeddedMetadata[],\n                map: ObjectLiteral,\n            ): any => {\n                // if (!object[embeddedMetadata.propertyName])\n                //     object[embeddedMetadata.propertyName] = embeddedMetadata.create();\n\n                const embeddedMetadata = embeddedMetadatas.shift()\n                if (embeddedMetadata) {\n                    if (!map[embeddedMetadata.propertyName])\n                        map[embeddedMetadata.propertyName] =\n                            embeddedMetadata.create()\n\n                    extractEmbeddedColumnValue(\n                        embeddedMetadatas,\n                        map[embeddedMetadata.propertyName],\n                    )\n                    return map\n                }\n                map[propertyName] = value\n                return map\n            }\n            return extractEmbeddedColumnValue(\n                [...this.embeddedMetadata.embeddedMetadataTree],\n                entity,\n            )\n        } else {\n            entity[propertyName] = value\n        }\n    }\n\n    /**\n     * Creates entity id map from the given entity ids array.\n     */\n    createValueMap(value: any) {\n        // extract column value from embeds of entity if column is in embedded\n        if (this.embeddedMetadata) {\n            // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n            // we need to get value of \"id\" column from the post real entity object and return it in a\n            // { data: { information: { counters: { id: ... } } } } format\n\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n            const propertyNames = [...this.embeddedMetadata.parentPropertyNames]\n\n            // now need to access post[data][information][counters] to get column value from the counters\n            // and on each step we need to create complex literal object, e.g. first { data },\n            // then { data: { information } }, then { data: { information: { counters } } },\n            // then { data: { information: { counters: [this.propertyName]: entity[data][information][counters][this.propertyName] } } }\n            // this recursive function helps doing that\n            const extractEmbeddedColumnValue = (\n                propertyNames: string[],\n                map: ObjectLiteral,\n            ): any => {\n                const propertyName = propertyNames.shift()\n                if (propertyName) {\n                    map[propertyName] = {}\n                    extractEmbeddedColumnValue(propertyNames, map[propertyName])\n                    return map\n                }\n                map[this.propertyName] = value\n                return map\n            }\n            return extractEmbeddedColumnValue(propertyNames, {})\n        } else {\n            // no embeds - no problems. Simply return column property name and its value of the entity\n            return { [this.propertyName]: value }\n        }\n    }\n\n    // ---------------------------------------------------------------------\n    // Builder Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Builds some depend relation metadata properties.\n     * This builder method should be used only after embedded metadata tree was build.\n     */\n    build() {\n        this.propertyPath = this.buildPropertyPath()\n    }\n\n    /**\n     * Registers given foreign keys in the relation.\n     * This builder method should be used to register foreign key in the relation.\n     */\n    registerForeignKeys(...foreignKeys: ForeignKeyMetadata[]) {\n        this.foreignKeys.push(...foreignKeys)\n    }\n\n    /**\n     * Registers given join columns in the relation.\n     * This builder method should be used to register join column in the relation.\n     */\n    registerJoinColumns(\n        joinColumns: ColumnMetadata[] = [],\n        inverseJoinColumns: ColumnMetadata[] = [],\n    ) {\n        this.joinColumns = joinColumns\n        this.inverseJoinColumns = inverseJoinColumns\n        this.isOwning =\n            this.isManyToOne ||\n            ((this.isManyToMany || this.isOneToOne) &&\n                this.joinColumns.length > 0)\n        this.isOneToOneOwner = this.isOneToOne && this.isOwning\n        this.isOneToOneNotOwner = this.isOneToOne && !this.isOwning\n        this.isManyToManyOwner = this.isManyToMany && this.isOwning\n        this.isManyToManyNotOwner = this.isManyToMany && !this.isOwning\n        this.isWithJoinColumn = this.isManyToOne || this.isOneToOneOwner\n    }\n\n    /**\n     * Registers a given junction entity metadata.\n     * This builder method can be called after junction entity metadata for the many-to-many relation was created.\n     */\n    registerJunctionEntityMetadata(junctionEntityMetadata: EntityMetadata) {\n        this.junctionEntityMetadata = junctionEntityMetadata\n        this.joinTableName = junctionEntityMetadata.tableName\n        if (this.inverseRelation) {\n            this.inverseRelation.junctionEntityMetadata = junctionEntityMetadata\n            this.joinTableName = junctionEntityMetadata.tableName\n        }\n    }\n\n    /**\n     * Builds inverse side property path based on given inverse side property factory.\n     * This builder method should be used only after properties map of the inverse entity metadata was build.\n     */\n    buildInverseSidePropertyPath(): string {\n        if (this.givenInverseSidePropertyFactory) {\n            const ownerEntityPropertiesMap =\n                this.inverseEntityMetadata.propertiesMap\n            if (typeof this.givenInverseSidePropertyFactory === \"function\")\n                return this.givenInverseSidePropertyFactory(\n                    ownerEntityPropertiesMap,\n                )\n\n            if (typeof this.givenInverseSidePropertyFactory === \"string\")\n                return this.givenInverseSidePropertyFactory\n        } else if (\n            this.isTreeParent &&\n            this.entityMetadata.treeChildrenRelation\n        ) {\n            return this.entityMetadata.treeChildrenRelation.propertyName\n        } else if (\n            this.isTreeChildren &&\n            this.entityMetadata.treeParentRelation\n        ) {\n            return this.entityMetadata.treeParentRelation.propertyName\n        }\n\n        return \"\"\n    }\n\n    /**\n     * Builds relation's property path based on its embedded tree.\n     */\n    buildPropertyPath(): string {\n        if (\n            !this.embeddedMetadata ||\n            !this.embeddedMetadata.parentPropertyNames.length\n        )\n            return this.propertyName\n\n        return (\n            this.embeddedMetadata.parentPropertyNames.join(\".\") +\n            \".\" +\n            this.propertyName\n        )\n    }\n}\n"]},"metadata":{},"sourceType":"module"}