{"ast":null,"code":"import { TypeORMError } from \"../error\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\n/**\n * Allows to work with entity relations and perform specific operations with those relations.\n *\n * todo: add transactions everywhere\n */\n\nexport class RelationUpdater {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(queryBuilder, expressionMap) {\n    this.queryBuilder = queryBuilder;\n    this.expressionMap = expressionMap;\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Performs set or add operation on a relation.\n   */\n\n\n  async update(value) {\n    const relation = this.expressionMap.relationMetadata;\n\n    if (relation.isManyToOne || relation.isOneToOneOwner) {\n      const updateSet = relation.joinColumns.reduce((updateSet, joinColumn) => {\n        const relationValue = ObjectUtils.isObject(value) ? joinColumn.referencedColumn.getEntityValue(value) : value;\n        joinColumn.setEntityValue(updateSet, relationValue);\n        return updateSet;\n      }, {});\n      if (!this.expressionMap.of || Array.isArray(this.expressionMap.of) && !this.expressionMap.of.length) return;\n      await this.queryBuilder.createQueryBuilder().update(relation.entityMetadata.target).set(updateSet).whereInIds(this.expressionMap.of).execute();\n    } else if ((relation.isOneToOneNotOwner || relation.isOneToMany) && value === null) {\n      // we handle null a bit different way\n      const updateSet = {};\n      relation.inverseRelation.joinColumns.forEach(column => {\n        updateSet[column.propertyName] = null;\n      });\n      const ofs = Array.isArray(this.expressionMap.of) ? this.expressionMap.of : [this.expressionMap.of];\n      const parameters = {};\n      const conditions = [];\n      ofs.forEach((of, ofIndex) => {\n        relation.inverseRelation.joinColumns.map((column, columnIndex) => {\n          const parameterName = \"joinColumn_\" + ofIndex + \"_\" + columnIndex;\n          parameters[parameterName] = ObjectUtils.isObject(of) ? column.referencedColumn.getEntityValue(of) : of;\n          conditions.push(`${column.propertyPath} = :${parameterName}`);\n        });\n      });\n      const condition = conditions.map(str => \"(\" + str + \")\").join(\" OR \");\n      if (!condition) return;\n      await this.queryBuilder.createQueryBuilder().update(relation.inverseEntityMetadata.target).set(updateSet).where(condition).setParameters(parameters).execute();\n    } else if (relation.isOneToOneNotOwner || relation.isOneToMany) {\n      if (Array.isArray(this.expressionMap.of)) throw new TypeORMError(`You cannot update relations of multiple entities with the same related object. Provide a single entity into .of method.`);\n      const of = this.expressionMap.of;\n      const updateSet = relation.inverseRelation.joinColumns.reduce((updateSet, joinColumn) => {\n        const relationValue = ObjectUtils.isObject(of) ? joinColumn.referencedColumn.getEntityValue(of) : of;\n        joinColumn.setEntityValue(updateSet, relationValue);\n        return updateSet;\n      }, {});\n      if (!value || Array.isArray(value) && !value.length) return;\n      await this.queryBuilder.createQueryBuilder().update(relation.inverseEntityMetadata.target).set(updateSet).whereInIds(value).execute();\n    } else {\n      // many to many\n      const junctionMetadata = relation.junctionEntityMetadata;\n      const ofs = Array.isArray(this.expressionMap.of) ? this.expressionMap.of : [this.expressionMap.of];\n      const values = Array.isArray(value) ? value : [value];\n      const firstColumnValues = relation.isManyToManyOwner ? ofs : values;\n      const secondColumnValues = relation.isManyToManyOwner ? values : ofs;\n      const bulkInserted = [];\n      firstColumnValues.forEach(firstColumnVal => {\n        secondColumnValues.forEach(secondColumnVal => {\n          const inserted = {};\n          junctionMetadata.ownerColumns.forEach(column => {\n            inserted[column.databaseName] = ObjectUtils.isObject(firstColumnVal) ? column.referencedColumn.getEntityValue(firstColumnVal) : firstColumnVal;\n          });\n          junctionMetadata.inverseColumns.forEach(column => {\n            inserted[column.databaseName] = ObjectUtils.isObject(secondColumnVal) ? column.referencedColumn.getEntityValue(secondColumnVal) : secondColumnVal;\n          });\n          bulkInserted.push(inserted);\n        });\n      });\n      if (!bulkInserted.length) return;\n\n      if (this.queryBuilder.connection.driver.options.type === \"oracle\" || this.queryBuilder.connection.driver.options.type === \"sap\") {\n        await Promise.all(bulkInserted.map(value => {\n          return this.queryBuilder.createQueryBuilder().insert().into(junctionMetadata.tableName).values(value).execute();\n        }));\n      } else {\n        await this.queryBuilder.createQueryBuilder().insert().into(junctionMetadata.tableName).values(bulkInserted).execute();\n      }\n    }\n  }\n\n}","map":{"version":3,"mappings":"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","names":["TypeORMError","ObjectUtils","RelationUpdater","constructor","queryBuilder","expressionMap","update","value","relation","relationMetadata","isManyToOne","isOneToOneOwner","updateSet","joinColumns","reduce","joinColumn","relationValue","isObject","referencedColumn","getEntityValue","setEntityValue","of","Array","isArray","length","createQueryBuilder","entityMetadata","target","set","whereInIds","execute","isOneToOneNotOwner","isOneToMany","inverseRelation","forEach","column","propertyName","ofs","parameters","conditions","ofIndex","map","columnIndex","parameterName","push","propertyPath","condition","str","join","inverseEntityMetadata","where","setParameters","junctionMetadata","junctionEntityMetadata","values","firstColumnValues","isManyToManyOwner","secondColumnValues","bulkInserted","firstColumnVal","secondColumnVal","inserted","ownerColumns","databaseName","inverseColumns","connection","driver","options","type","Promise","all","insert","into","tableName"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\query-builder\\RelationUpdater.ts"],"sourcesContent":["import { QueryBuilder } from \"./QueryBuilder\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { QueryExpressionMap } from \"./QueryExpressionMap\"\nimport { TypeORMError } from \"../error\"\nimport { ObjectUtils } from \"../util/ObjectUtils\"\n\n/**\n * Allows to work with entity relations and perform specific operations with those relations.\n *\n * todo: add transactions everywhere\n */\nexport class RelationUpdater {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        protected queryBuilder: QueryBuilder<any>,\n        protected expressionMap: QueryExpressionMap,\n    ) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Performs set or add operation on a relation.\n     */\n    async update(value: any | any[]): Promise<void> {\n        const relation = this.expressionMap.relationMetadata\n\n        if (relation.isManyToOne || relation.isOneToOneOwner) {\n            const updateSet = relation.joinColumns.reduce(\n                (updateSet, joinColumn) => {\n                    const relationValue = ObjectUtils.isObject(value)\n                        ? joinColumn.referencedColumn!.getEntityValue(value)\n                        : value\n                    joinColumn.setEntityValue(updateSet, relationValue)\n                    return updateSet\n                },\n                {} as any,\n            )\n\n            if (\n                !this.expressionMap.of ||\n                (Array.isArray(this.expressionMap.of) &&\n                    !this.expressionMap.of.length)\n            )\n                return\n\n            await this.queryBuilder\n                .createQueryBuilder()\n                .update(relation.entityMetadata.target)\n                .set(updateSet)\n                .whereInIds(this.expressionMap.of)\n                .execute()\n        } else if (\n            (relation.isOneToOneNotOwner || relation.isOneToMany) &&\n            value === null\n        ) {\n            // we handle null a bit different way\n\n            const updateSet: ObjectLiteral = {}\n            relation.inverseRelation!.joinColumns.forEach((column) => {\n                updateSet[column.propertyName] = null\n            })\n\n            const ofs = Array.isArray(this.expressionMap.of)\n                ? this.expressionMap.of\n                : [this.expressionMap.of]\n            const parameters: ObjectLiteral = {}\n            const conditions: string[] = []\n            ofs.forEach((of, ofIndex) => {\n                relation.inverseRelation!.joinColumns.map(\n                    (column, columnIndex) => {\n                        const parameterName =\n                            \"joinColumn_\" + ofIndex + \"_\" + columnIndex\n                        parameters[parameterName] = ObjectUtils.isObject(of)\n                            ? column.referencedColumn!.getEntityValue(of)\n                            : of\n                        conditions.push(\n                            `${column.propertyPath} = :${parameterName}`,\n                        )\n                    },\n                )\n            })\n            const condition = conditions\n                .map((str) => \"(\" + str + \")\")\n                .join(\" OR \")\n            if (!condition) return\n\n            await this.queryBuilder\n                .createQueryBuilder()\n                .update(relation.inverseEntityMetadata.target)\n                .set(updateSet)\n                .where(condition)\n                .setParameters(parameters)\n                .execute()\n        } else if (relation.isOneToOneNotOwner || relation.isOneToMany) {\n            if (Array.isArray(this.expressionMap.of))\n                throw new TypeORMError(\n                    `You cannot update relations of multiple entities with the same related object. Provide a single entity into .of method.`,\n                )\n\n            const of = this.expressionMap.of\n            const updateSet = relation.inverseRelation!.joinColumns.reduce(\n                (updateSet, joinColumn) => {\n                    const relationValue = ObjectUtils.isObject(of)\n                        ? joinColumn.referencedColumn!.getEntityValue(of)\n                        : of\n                    joinColumn.setEntityValue(updateSet, relationValue)\n                    return updateSet\n                },\n                {} as any,\n            )\n\n            if (!value || (Array.isArray(value) && !value.length)) return\n\n            await this.queryBuilder\n                .createQueryBuilder()\n                .update(relation.inverseEntityMetadata.target)\n                .set(updateSet)\n                .whereInIds(value)\n                .execute()\n        } else {\n            // many to many\n            const junctionMetadata = relation.junctionEntityMetadata!\n            const ofs = Array.isArray(this.expressionMap.of)\n                ? this.expressionMap.of\n                : [this.expressionMap.of]\n            const values = Array.isArray(value) ? value : [value]\n            const firstColumnValues = relation.isManyToManyOwner ? ofs : values\n            const secondColumnValues = relation.isManyToManyOwner ? values : ofs\n\n            const bulkInserted: ObjectLiteral[] = []\n            firstColumnValues.forEach((firstColumnVal) => {\n                secondColumnValues.forEach((secondColumnVal) => {\n                    const inserted: ObjectLiteral = {}\n                    junctionMetadata.ownerColumns.forEach((column) => {\n                        inserted[column.databaseName] = ObjectUtils.isObject(\n                            firstColumnVal,\n                        )\n                            ? column.referencedColumn!.getEntityValue(\n                                  firstColumnVal,\n                              )\n                            : firstColumnVal\n                    })\n                    junctionMetadata.inverseColumns.forEach((column) => {\n                        inserted[column.databaseName] = ObjectUtils.isObject(\n                            secondColumnVal,\n                        )\n                            ? column.referencedColumn!.getEntityValue(\n                                  secondColumnVal,\n                              )\n                            : secondColumnVal\n                    })\n                    bulkInserted.push(inserted)\n                })\n            })\n\n            if (!bulkInserted.length) return\n\n            if (\n                this.queryBuilder.connection.driver.options.type === \"oracle\" ||\n                this.queryBuilder.connection.driver.options.type === \"sap\"\n            ) {\n                await Promise.all(\n                    bulkInserted.map((value) => {\n                        return this.queryBuilder\n                            .createQueryBuilder()\n                            .insert()\n                            .into(junctionMetadata.tableName)\n                            .values(value)\n                            .execute()\n                    }),\n                )\n            } else {\n                await this.queryBuilder\n                    .createQueryBuilder()\n                    .insert()\n                    .into(junctionMetadata.tableName)\n                    .values(bulkInserted)\n                    .execute()\n            }\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}