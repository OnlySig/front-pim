{"ast":null,"code":"import { getMetadataArgsStorage } from \"../../globals\";\nimport { ColumnTypeUndefinedError } from \"../../error/ColumnTypeUndefinedError\";\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n */\n\nexport function Column(typeOrOptions, options) {\n  return function (object, propertyName) {\n    // normalize parameters\n    let type;\n\n    if (typeof typeOrOptions === \"string\" || typeof typeOrOptions === \"function\") {\n      type = typeOrOptions;\n    } else if (typeOrOptions) {\n      options = typeOrOptions;\n      type = typeOrOptions.type;\n    }\n\n    if (!options) options = {}; // if type is not given explicitly then try to guess it\n\n    const reflectMetadataType = Reflect && Reflect.getMetadata ? Reflect.getMetadata(\"design:type\", object, propertyName) : undefined;\n    if (!type && reflectMetadataType) // if type is not given explicitly then try to guess it\n      type = reflectMetadataType; // check if there is no type in column options then set type from first function argument, or guessed one\n\n    if (!options.type && type) options.type = type; // specify HSTORE type if column is HSTORE\n\n    if (options.type === \"hstore\" && !options.hstoreType) options.hstoreType = reflectMetadataType === Object ? \"object\" : \"string\";\n\n    if (typeof typeOrOptions === \"function\") {\n      // register an embedded\n      getMetadataArgsStorage().embeddeds.push({\n        target: object.constructor,\n        propertyName: propertyName,\n        isArray: reflectMetadataType === Array || options.array === true,\n        prefix: options.prefix !== undefined ? options.prefix : undefined,\n        type: typeOrOptions\n      });\n    } else {\n      // register a regular column\n      // if we still don't have a type then we need to give error to user that type is required\n      if (!options.type) throw new ColumnTypeUndefinedError(object, propertyName); // create unique\n\n      if (options.unique === true) getMetadataArgsStorage().uniques.push({\n        target: object.constructor,\n        columns: [propertyName]\n      });\n      getMetadataArgsStorage().columns.push({\n        target: object.constructor,\n        propertyName: propertyName,\n        mode: \"regular\",\n        options: options\n      });\n\n      if (options.generated) {\n        getMetadataArgsStorage().generations.push({\n          target: object.constructor,\n          propertyName: propertyName,\n          strategy: typeof options.generated === \"string\" ? options.generated : \"increment\"\n        });\n      }\n    }\n  };\n}","map":{"version":3,"mappings":"AAAA,SAASA,sBAAT,QAAuC,eAAvC;AAiBA,SAASC,wBAAT,QAAyC,sCAAzC;AAgHA;;;;;AAIA,OAAM,SAAUC,MAAV,CACFC,aADE,EAKFC,OALE,EAK6C;EAE/C,OAAO,UAAUC,MAAV,EAA0BC,YAA1B,EAA8C;IACjD;IACA,IAAIC,IAAJ;;IACA,IACI,OAAOJ,aAAP,KAAyB,QAAzB,IACA,OAAOA,aAAP,KAAyB,UAF7B,EAGE;MACEI,IAAI,GAAeJ,aAAnB;IACH,CALD,MAKO,IAAIA,aAAJ,EAAmB;MACtBC,OAAO,GAAkBD,aAAzB;MACAI,IAAI,GAAGJ,aAAa,CAACI,IAArB;IACH;;IACD,IAAI,CAACH,OAAL,EAAcA,OAAO,GAAG,EAAV,CAZmC,CAcjD;;IACA,MAAMI,mBAAmB,GACrBC,OAAO,IAAKA,OAAe,CAACC,WAA5B,GACOD,OAAe,CAACC,WAAhB,CACG,aADH,EAEGL,MAFH,EAGGC,YAHH,CADP,GAMMK,SAPV;IAQA,IAAI,CAACJ,IAAD,IAASC,mBAAb,EACI;MACAD,IAAI,GAAGC,mBAAP,CAzB6C,CA2BjD;;IACA,IAAI,CAACJ,OAAO,CAACG,IAAT,IAAiBA,IAArB,EAA2BH,OAAO,CAACG,IAAR,GAAeA,IAAf,CA5BsB,CA8BjD;;IACA,IAAIH,OAAO,CAACG,IAAR,KAAiB,QAAjB,IAA6B,CAACH,OAAO,CAACQ,UAA1C,EACIR,OAAO,CAACQ,UAAR,GACIJ,mBAAmB,KAAKK,MAAxB,GAAiC,QAAjC,GAA4C,QADhD;;IAGJ,IAAI,OAAOV,aAAP,KAAyB,UAA7B,EAAyC;MACrC;MACAH,sBAAsB,GAAGc,SAAzB,CAAmCC,IAAnC,CAAwC;QACpCC,MAAM,EAAEX,MAAM,CAACY,WADqB;QAEpCX,YAAY,EAAEA,YAFsB;QAGpCY,OAAO,EACHV,mBAAmB,KAAKW,KAAxB,IAAiCf,OAAO,CAACgB,KAAR,KAAkB,IAJnB;QAKpCC,MAAM,EACFjB,OAAO,CAACiB,MAAR,KAAmBV,SAAnB,GAA+BP,OAAO,CAACiB,MAAvC,GAAgDV,SANhB;QAOpCJ,IAAI,EAAEJ;MAP8B,CAAxC;IASH,CAXD,MAWO;MACH;MAEA;MACA,IAAI,CAACC,OAAO,CAACG,IAAb,EACI,MAAM,IAAIN,wBAAJ,CAA6BI,MAA7B,EAAqCC,YAArC,CAAN,CALD,CAOH;;MACA,IAAIF,OAAO,CAACkB,MAAR,KAAmB,IAAvB,EACItB,sBAAsB,GAAGuB,OAAzB,CAAiCR,IAAjC,CAAsC;QAClCC,MAAM,EAAEX,MAAM,CAACY,WADmB;QAElCO,OAAO,EAAE,CAAClB,YAAD;MAFyB,CAAtC;MAKJN,sBAAsB,GAAGwB,OAAzB,CAAiCT,IAAjC,CAAsC;QAClCC,MAAM,EAAEX,MAAM,CAACY,WADmB;QAElCX,YAAY,EAAEA,YAFoB;QAGlCmB,IAAI,EAAE,SAH4B;QAIlCrB,OAAO,EAAEA;MAJyB,CAAtC;;MAOA,IAAIA,OAAO,CAACsB,SAAZ,EAAuB;QACnB1B,sBAAsB,GAAG2B,WAAzB,CAAqCZ,IAArC,CAA0C;UACtCC,MAAM,EAAEX,MAAM,CAACY,WADuB;UAEtCX,YAAY,EAAEA,YAFwB;UAGtCsB,QAAQ,EACJ,OAAOxB,OAAO,CAACsB,SAAf,KAA6B,QAA7B,GACMtB,OAAO,CAACsB,SADd,GAEM;QAN4B,CAA1C;MAQH;IACJ;EACJ,CA9ED;AA+EH","names":["getMetadataArgsStorage","ColumnTypeUndefinedError","Column","typeOrOptions","options","object","propertyName","type","reflectMetadataType","Reflect","getMetadata","undefined","hstoreType","Object","embeddeds","push","target","constructor","isArray","Array","array","prefix","unique","uniques","columns","mode","generated","generations","strategy"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\decorator\\columns\\Column.ts"],"sourcesContent":["import { getMetadataArgsStorage } from \"../../globals\"\nimport {\n    ColumnType,\n    SimpleColumnType,\n    SpatialColumnType,\n    WithLengthColumnType,\n    WithPrecisionColumnType,\n    WithWidthColumnType,\n} from \"../../driver/types/ColumnTypes\"\nimport { ColumnMetadataArgs } from \"../../metadata-args/ColumnMetadataArgs\"\nimport { ColumnCommonOptions } from \"../options/ColumnCommonOptions\"\nimport { SpatialColumnOptions } from \"../options/SpatialColumnOptions\"\nimport { ColumnWithLengthOptions } from \"../options/ColumnWithLengthOptions\"\nimport { ColumnNumericOptions } from \"../options/ColumnNumericOptions\"\nimport { ColumnEnumOptions } from \"../options/ColumnEnumOptions\"\nimport { ColumnEmbeddedOptions } from \"../options/ColumnEmbeddedOptions\"\nimport { EmbeddedMetadataArgs } from \"../../metadata-args/EmbeddedMetadataArgs\"\nimport { ColumnTypeUndefinedError } from \"../../error/ColumnTypeUndefinedError\"\nimport { ColumnHstoreOptions } from \"../options/ColumnHstoreOptions\"\nimport { ColumnWithWidthOptions } from \"../options/ColumnWithWidthOptions\"\nimport { GeneratedMetadataArgs } from \"../../metadata-args/GeneratedMetadataArgs\"\nimport { ColumnOptions } from \"../options/ColumnOptions\"\n\n/**\n * Column decorator is used to mark a specific class property as a table column. Only properties decorated with this\n * decorator will be persisted to the database when entity be saved.\n */\nexport function Column(): PropertyDecorator\n\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n */\nexport function Column(options: ColumnOptions): PropertyDecorator\n\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n */\nexport function Column(\n    type: SimpleColumnType,\n    options?: ColumnCommonOptions,\n): PropertyDecorator\n\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n */\nexport function Column(\n    type: SpatialColumnType,\n    options?: ColumnCommonOptions & SpatialColumnOptions,\n): PropertyDecorator\n\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n */\nexport function Column(\n    type: WithLengthColumnType,\n    options?: ColumnCommonOptions & ColumnWithLengthOptions,\n): PropertyDecorator\n\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n */\nexport function Column(\n    type: WithWidthColumnType,\n    options?: ColumnCommonOptions & ColumnWithWidthOptions,\n): PropertyDecorator\n\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n */\nexport function Column(\n    type: WithPrecisionColumnType,\n    options?: ColumnCommonOptions & ColumnNumericOptions,\n): PropertyDecorator\n\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n */\nexport function Column(\n    type: \"enum\",\n    options?: ColumnCommonOptions & ColumnEnumOptions,\n): PropertyDecorator\n\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n */\nexport function Column(\n    type: \"simple-enum\",\n    options?: ColumnCommonOptions & ColumnEnumOptions,\n): PropertyDecorator\n\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n */\nexport function Column(\n    type: \"set\",\n    options?: ColumnCommonOptions & ColumnEnumOptions,\n): PropertyDecorator\n\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n */\nexport function Column(\n    type: \"hstore\",\n    options?: ColumnCommonOptions & ColumnHstoreOptions,\n): PropertyDecorator\n\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n *\n * Property in entity can be marked as Embedded, and on persist all columns from the embedded are mapped to the\n * single table of the entity where Embedded is used. And on hydration all columns which supposed to be in the\n * embedded will be mapped to it from the single table.\n */\nexport function Column(\n    type: (type?: any) => Function,\n    options?: ColumnEmbeddedOptions,\n): PropertyDecorator\n\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n */\nexport function Column(\n    typeOrOptions?:\n        | ((type?: any) => Function)\n        | ColumnType\n        | (ColumnOptions & ColumnEmbeddedOptions),\n    options?: ColumnOptions & ColumnEmbeddedOptions,\n): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        // normalize parameters\n        let type: ColumnType | undefined\n        if (\n            typeof typeOrOptions === \"string\" ||\n            typeof typeOrOptions === \"function\"\n        ) {\n            type = <ColumnType>typeOrOptions\n        } else if (typeOrOptions) {\n            options = <ColumnOptions>typeOrOptions\n            type = typeOrOptions.type\n        }\n        if (!options) options = {} as ColumnOptions\n\n        // if type is not given explicitly then try to guess it\n        const reflectMetadataType =\n            Reflect && (Reflect as any).getMetadata\n                ? (Reflect as any).getMetadata(\n                      \"design:type\",\n                      object,\n                      propertyName,\n                  )\n                : undefined\n        if (!type && reflectMetadataType)\n            // if type is not given explicitly then try to guess it\n            type = reflectMetadataType\n\n        // check if there is no type in column options then set type from first function argument, or guessed one\n        if (!options.type && type) options.type = type\n\n        // specify HSTORE type if column is HSTORE\n        if (options.type === \"hstore\" && !options.hstoreType)\n            options.hstoreType =\n                reflectMetadataType === Object ? \"object\" : \"string\"\n\n        if (typeof typeOrOptions === \"function\") {\n            // register an embedded\n            getMetadataArgsStorage().embeddeds.push({\n                target: object.constructor,\n                propertyName: propertyName,\n                isArray:\n                    reflectMetadataType === Array || options.array === true,\n                prefix:\n                    options.prefix !== undefined ? options.prefix : undefined,\n                type: typeOrOptions as (type?: any) => Function,\n            } as EmbeddedMetadataArgs)\n        } else {\n            // register a regular column\n\n            // if we still don't have a type then we need to give error to user that type is required\n            if (!options.type)\n                throw new ColumnTypeUndefinedError(object, propertyName)\n\n            // create unique\n            if (options.unique === true)\n                getMetadataArgsStorage().uniques.push({\n                    target: object.constructor,\n                    columns: [propertyName],\n                })\n\n            getMetadataArgsStorage().columns.push({\n                target: object.constructor,\n                propertyName: propertyName,\n                mode: \"regular\",\n                options: options,\n            } as ColumnMetadataArgs)\n\n            if (options.generated) {\n                getMetadataArgsStorage().generations.push({\n                    target: object.constructor,\n                    propertyName: propertyName,\n                    strategy:\n                        typeof options.generated === \"string\"\n                            ? options.generated\n                            : \"increment\",\n                } as GeneratedMetadataArgs)\n            }\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}