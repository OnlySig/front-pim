{"ast":null,"code":"import { DriverUtils } from \"../DriverUtils\";\nimport { AuroraMysqlQueryRunner } from \"./AuroraMysqlQueryRunner\";\nimport { DateUtils } from \"../../util/DateUtils\";\nimport { PlatformTools } from \"../../platform/PlatformTools\";\nimport { RdbmsSchemaBuilder } from \"../../schema-builder/RdbmsSchemaBuilder\";\nimport { OrmUtils } from \"../../util/OrmUtils\";\nimport { ApplyValueTransformers } from \"../../util/ApplyValueTransformers\";\nimport { TypeORMError } from \"../../error\";\nimport { InstanceChecker } from \"../../util/InstanceChecker\";\n/**\n * Organizes communication with MySQL DBMS.\n */\n\nexport class AuroraMysqlDriver {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection) {\n    /**\n     * Indicates if replication is enabled.\n     */\n    this.isReplicated = false;\n    /**\n     * Indicates if tree tables are supported by this driver.\n     */\n\n    this.treeSupport = true;\n    /**\n     * Represent transaction support by this driver\n     */\n\n    this.transactionSupport = \"nested\";\n    /**\n     * Gets list of supported column data types by a driver.\n     *\n     * @see https://www.tutorialspoint.com/mysql/mysql-data-types.htm\n     * @see https://dev.mysql.com/doc/refman/8.0/en/data-types.html\n     */\n\n    this.supportedDataTypes = [// numeric types\n    \"bit\", \"int\", \"integer\", \"tinyint\", \"smallint\", \"mediumint\", \"bigint\", \"float\", \"double\", \"double precision\", \"real\", \"decimal\", \"dec\", \"numeric\", \"fixed\", \"bool\", \"boolean\", // date and time types\n    \"date\", \"datetime\", \"timestamp\", \"time\", \"year\", // string types\n    \"char\", \"nchar\", \"national char\", \"varchar\", \"nvarchar\", \"national varchar\", \"blob\", \"text\", \"tinyblob\", \"tinytext\", \"mediumblob\", \"mediumtext\", \"longblob\", \"longtext\", \"enum\", \"set\", \"binary\", \"varbinary\", // json data type\n    \"json\", // spatial data types\n    \"geometry\", \"point\", \"linestring\", \"polygon\", \"multipoint\", \"multilinestring\", \"multipolygon\", \"geometrycollection\"];\n    /**\n     * Returns type of upsert supported by driver if any\n     */\n\n    this.supportedUpsertType = \"on-duplicate-key-update\";\n    /**\n     * Gets list of spatial column data types.\n     */\n\n    this.spatialTypes = [\"geometry\", \"point\", \"linestring\", \"polygon\", \"multipoint\", \"multilinestring\", \"multipolygon\", \"geometrycollection\"];\n    /**\n     * Gets list of column data types that support length by a driver.\n     */\n\n    this.withLengthColumnTypes = [\"char\", \"varchar\", \"nvarchar\", \"binary\", \"varbinary\"];\n    /**\n     * Gets list of column data types that support length by a driver.\n     */\n\n    this.withWidthColumnTypes = [\"bit\", \"tinyint\", \"smallint\", \"mediumint\", \"int\", \"integer\", \"bigint\"];\n    /**\n     * Gets list of column data types that support precision by a driver.\n     */\n\n    this.withPrecisionColumnTypes = [\"decimal\", \"dec\", \"numeric\", \"fixed\", \"float\", \"double\", \"double precision\", \"real\", \"time\", \"datetime\", \"timestamp\"];\n    /**\n     * Gets list of column data types that supports scale by a driver.\n     */\n\n    this.withScaleColumnTypes = [\"decimal\", \"dec\", \"numeric\", \"fixed\", \"float\", \"double\", \"double precision\", \"real\"];\n    /**\n     * Gets list of column data types that supports UNSIGNED and ZEROFILL attributes.\n     */\n\n    this.unsignedAndZerofillTypes = [\"int\", \"integer\", \"smallint\", \"tinyint\", \"mediumint\", \"bigint\", \"decimal\", \"dec\", \"numeric\", \"fixed\", \"float\", \"double\", \"double precision\", \"real\"];\n    /**\n     * ORM has special columns and we need to know what database column types should be for those columns.\n     * Column types are driver dependant.\n     */\n\n    this.mappedDataTypes = {\n      createDate: \"datetime\",\n      createDatePrecision: 6,\n      createDateDefault: \"CURRENT_TIMESTAMP(6)\",\n      updateDate: \"datetime\",\n      updateDatePrecision: 6,\n      updateDateDefault: \"CURRENT_TIMESTAMP(6)\",\n      deleteDate: \"datetime\",\n      deleteDatePrecision: 6,\n      deleteDateNullable: true,\n      version: \"int\",\n      treeLevel: \"int\",\n      migrationId: \"int\",\n      migrationName: \"varchar\",\n      migrationTimestamp: \"bigint\",\n      cacheId: \"int\",\n      cacheIdentifier: \"varchar\",\n      cacheTime: \"bigint\",\n      cacheDuration: \"int\",\n      cacheQuery: \"text\",\n      cacheResult: \"text\",\n      metadataType: \"varchar\",\n      metadataDatabase: \"varchar\",\n      metadataSchema: \"varchar\",\n      metadataTable: \"varchar\",\n      metadataName: \"varchar\",\n      metadataValue: \"text\"\n    };\n    /**\n     * Default values of length, precision and scale depends on column data type.\n     * Used in the cases when length/precision/scale is not specified by user.\n     */\n\n    this.dataTypeDefaults = {\n      varchar: {\n        length: 255\n      },\n      nvarchar: {\n        length: 255\n      },\n      \"national varchar\": {\n        length: 255\n      },\n      char: {\n        length: 1\n      },\n      binary: {\n        length: 1\n      },\n      varbinary: {\n        length: 255\n      },\n      decimal: {\n        precision: 10,\n        scale: 0\n      },\n      dec: {\n        precision: 10,\n        scale: 0\n      },\n      numeric: {\n        precision: 10,\n        scale: 0\n      },\n      fixed: {\n        precision: 10,\n        scale: 0\n      },\n      float: {\n        precision: 12\n      },\n      double: {\n        precision: 22\n      },\n      time: {\n        precision: 0\n      },\n      datetime: {\n        precision: 0\n      },\n      timestamp: {\n        precision: 0\n      },\n      bit: {\n        width: 1\n      },\n      int: {\n        width: 11\n      },\n      integer: {\n        width: 11\n      },\n      tinyint: {\n        width: 4\n      },\n      smallint: {\n        width: 6\n      },\n      mediumint: {\n        width: 9\n      },\n      bigint: {\n        width: 20\n      }\n    };\n    /**\n     * Max length allowed by MySQL for aliases.\n     * @see https://dev.mysql.com/doc/refman/5.5/en/identifiers.html\n     */\n\n    this.maxAliasLength = 63;\n    this.cteCapabilities = {\n      enabled: false\n    };\n    this.connection = connection;\n    this.options = connection.options; // load mysql package\n\n    this.loadDependencies();\n    this.client = new this.DataApiDriver(this.options.region, this.options.secretArn, this.options.resourceArn, this.options.database, (query, parameters) => this.connection.logger.logQuery(query, parameters), this.options.serviceConfigOptions, this.options.formatOptions);\n    this.database = DriverUtils.buildDriverOptions(this.options).database; // validate options to make sure everything is set\n    // todo: revisit validation with replication in mind\n    // if (!(this.options.host || (this.options.extra && this.options.extra.socketPath)) && !this.options.socketPath)\n    //     throw new DriverOptionNotSetError(\"socketPath and host\");\n    // if (!this.options.username)\n    //     throw new DriverOptionNotSetError(\"username\");\n    // if (!this.options.database)\n    //     throw new DriverOptionNotSetError(\"database\");\n    // todo: check what is going on when connection is setup without database and how to connect to a database then?\n    // todo: provide options to auto-create a database if it does not exist yet\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Performs connection to the database.\n   */\n\n\n  async connect() {\n    if (!this.database) {\n      const queryRunner = await this.createQueryRunner(\"master\");\n      this.database = await queryRunner.getCurrentDatabase();\n      await queryRunner.release();\n    }\n  }\n  /**\n   * Makes any action after connection (e.g. create extensions in Postgres driver).\n   */\n\n\n  afterConnect() {\n    return Promise.resolve();\n  }\n  /**\n   * Closes connection with the database.\n   */\n\n\n  async disconnect() {}\n  /**\n   * Creates a schema builder used to build and sync a schema.\n   */\n\n\n  createSchemaBuilder() {\n    return new RdbmsSchemaBuilder(this.connection);\n  }\n  /**\n   * Creates a query runner used to execute database queries.\n   */\n\n\n  createQueryRunner(mode) {\n    return new AuroraMysqlQueryRunner(this, new this.DataApiDriver(this.options.region, this.options.secretArn, this.options.resourceArn, this.options.database, (query, parameters) => this.connection.logger.logQuery(query, parameters), this.options.serviceConfigOptions, this.options.formatOptions));\n  }\n  /**\n   * Replaces parameters in the given sql with special escaping character\n   * and an array of parameter names to be passed to a query.\n   */\n\n\n  escapeQueryWithParameters(sql, parameters, nativeParameters) {\n    const escapedParameters = Object.keys(nativeParameters).map(key => nativeParameters[key]);\n    if (!parameters || !Object.keys(parameters).length) return [sql, escapedParameters];\n    sql = sql.replace(/:(\\.\\.\\.)?([A-Za-z0-9_.]+)/g, (full, isArray, key) => {\n      if (!parameters.hasOwnProperty(key)) {\n        return full;\n      }\n\n      let value = parameters[key];\n\n      if (isArray) {\n        return value.map(v => {\n          escapedParameters.push(v);\n          return this.createParameter(key, escapedParameters.length - 1);\n        }).join(\", \");\n      }\n\n      if (typeof value === \"function\") {\n        return value();\n      }\n\n      escapedParameters.push(value);\n      return this.createParameter(key, escapedParameters.length - 1);\n    }); // todo: make replace only in value statements, otherwise problems\n\n    return [sql, escapedParameters];\n  }\n  /**\n   * Escapes a column name.\n   */\n\n\n  escape(columnName) {\n    return \"`\" + columnName + \"`\";\n  }\n  /**\n   * Build full table name with database name, schema name and table name.\n   * E.g. myDB.mySchema.myTable\n   */\n\n\n  buildTableName(tableName, schema, database) {\n    let tablePath = [tableName];\n\n    if (database) {\n      tablePath.unshift(database);\n    }\n\n    return tablePath.join(\".\");\n  }\n  /**\n   * Parse a target table name or other types and return a normalized table definition.\n   */\n\n\n  parseTableName(target) {\n    const driverDatabase = this.database;\n    const driverSchema = undefined;\n\n    if (InstanceChecker.isTable(target) || InstanceChecker.isView(target)) {\n      const parsed = this.parseTableName(target.name);\n      return {\n        database: target.database || parsed.database || driverDatabase,\n        schema: target.schema || parsed.schema || driverSchema,\n        tableName: parsed.tableName\n      };\n    }\n\n    if (InstanceChecker.isTableForeignKey(target)) {\n      const parsed = this.parseTableName(target.referencedTableName);\n      return {\n        database: target.referencedDatabase || parsed.database || driverDatabase,\n        schema: target.referencedSchema || parsed.schema || driverSchema,\n        tableName: parsed.tableName\n      };\n    }\n\n    if (InstanceChecker.isEntityMetadata(target)) {\n      // EntityMetadata tableName is never a path\n      return {\n        database: target.database || driverDatabase,\n        schema: target.schema || driverSchema,\n        tableName: target.tableName\n      };\n    }\n\n    const parts = target.split(\".\");\n    return {\n      database: (parts.length > 1 ? parts[0] : undefined) || driverDatabase,\n      schema: driverSchema,\n      tableName: parts.length > 1 ? parts[1] : parts[0]\n    };\n  }\n  /**\n   * Prepares given value to a value to be persisted, based on its column type and metadata.\n   */\n\n\n  preparePersistentValue(value, columnMetadata) {\n    if (columnMetadata.transformer) value = ApplyValueTransformers.transformTo(columnMetadata.transformer, value);\n\n    if (!this.options.formatOptions || this.options.formatOptions.castParameters !== false) {\n      return this.client.preparePersistentValue(value, columnMetadata);\n    }\n\n    if (value === null || value === undefined) return value;\n\n    if (columnMetadata.type === Boolean) {\n      return value === true ? 1 : 0;\n    } else if (columnMetadata.type === \"date\") {\n      return DateUtils.mixedDateToDateString(value);\n    } else if (columnMetadata.type === \"time\") {\n      return DateUtils.mixedDateToTimeString(value);\n    } else if (columnMetadata.type === \"json\") {\n      return JSON.stringify(value);\n    } else if (columnMetadata.type === \"timestamp\" || columnMetadata.type === \"datetime\" || columnMetadata.type === Date) {\n      return DateUtils.mixedDateToDate(value);\n    } else if (columnMetadata.type === \"simple-array\" || columnMetadata.type === \"set\") {\n      return DateUtils.simpleArrayToString(value);\n    } else if (columnMetadata.type === \"simple-json\") {\n      return DateUtils.simpleJsonToString(value);\n    } else if (columnMetadata.type === \"enum\" || columnMetadata.type === \"simple-enum\") {\n      return \"\" + value;\n    }\n\n    return value;\n  }\n  /**\n   * Prepares given value to a value to be persisted, based on its column type or metadata.\n   */\n\n\n  prepareHydratedValue(value, columnMetadata) {\n    if (value === null || value === undefined) return columnMetadata.transformer ? ApplyValueTransformers.transformFrom(columnMetadata.transformer, value) : value;\n\n    if (!this.options.formatOptions || this.options.formatOptions.castParameters !== false) {\n      return this.client.prepareHydratedValue(value, columnMetadata);\n    }\n\n    if (columnMetadata.type === Boolean || columnMetadata.type === \"bool\" || columnMetadata.type === \"boolean\") {\n      value = value ? true : false;\n    } else if (columnMetadata.type === \"datetime\" || columnMetadata.type === Date) {\n      value = DateUtils.normalizeHydratedDate(value);\n    } else if (columnMetadata.type === \"date\") {\n      value = DateUtils.mixedDateToDateString(value);\n    } else if (columnMetadata.type === \"json\") {\n      value = typeof value === \"string\" ? JSON.parse(value) : value;\n    } else if (columnMetadata.type === \"time\") {\n      value = DateUtils.mixedTimeToString(value);\n    } else if (columnMetadata.type === \"simple-array\" || columnMetadata.type === \"set\") {\n      value = DateUtils.stringToSimpleArray(value);\n    } else if (columnMetadata.type === \"simple-json\") {\n      value = DateUtils.stringToSimpleJson(value);\n    } else if ((columnMetadata.type === \"enum\" || columnMetadata.type === \"simple-enum\") && columnMetadata.enum && !isNaN(value) && columnMetadata.enum.indexOf(parseInt(value)) >= 0) {\n      // convert to number if that exists in possible enum options\n      value = parseInt(value);\n    }\n\n    if (columnMetadata.transformer) value = ApplyValueTransformers.transformFrom(columnMetadata.transformer, value);\n    return value;\n  }\n  /**\n   * Creates a database type from a given column metadata.\n   */\n\n\n  normalizeType(column) {\n    if (column.type === Number || column.type === \"integer\") {\n      return \"int\";\n    } else if (column.type === String) {\n      return \"varchar\";\n    } else if (column.type === Date) {\n      return \"datetime\";\n    } else if (column.type === Buffer) {\n      return \"blob\";\n    } else if (column.type === Boolean) {\n      return \"tinyint\";\n    } else if (column.type === \"uuid\") {\n      return \"varchar\";\n    } else if (column.type === \"simple-array\" || column.type === \"simple-json\") {\n      return \"text\";\n    } else if (column.type === \"simple-enum\") {\n      return \"enum\";\n    } else if (column.type === \"double precision\" || column.type === \"real\") {\n      return \"double\";\n    } else if (column.type === \"dec\" || column.type === \"numeric\" || column.type === \"fixed\") {\n      return \"decimal\";\n    } else if (column.type === \"bool\" || column.type === \"boolean\") {\n      return \"tinyint\";\n    } else if (column.type === \"nvarchar\" || column.type === \"national varchar\") {\n      return \"varchar\";\n    } else if (column.type === \"nchar\" || column.type === \"national char\") {\n      return \"char\";\n    } else {\n      return column.type || \"\";\n    }\n  }\n  /**\n   * Normalizes \"default\" value of the column.\n   */\n\n\n  normalizeDefault(columnMetadata) {\n    const defaultValue = columnMetadata.default;\n\n    if (defaultValue === null) {\n      return undefined;\n    }\n\n    if ((columnMetadata.type === \"enum\" || columnMetadata.type === \"simple-enum\") && defaultValue !== undefined) {\n      return `'${defaultValue}'`;\n    }\n\n    if (columnMetadata.type === \"set\" && defaultValue !== undefined) {\n      return `'${DateUtils.simpleArrayToString(defaultValue)}'`;\n    }\n\n    if (typeof defaultValue === \"number\") {\n      return `${defaultValue}`;\n    }\n\n    if (typeof defaultValue === \"boolean\") {\n      return defaultValue ? \"1\" : \"0\";\n    }\n\n    if (typeof defaultValue === \"function\") {\n      return defaultValue();\n    }\n\n    if (typeof defaultValue === \"string\") {\n      return `'${defaultValue}'`;\n    }\n\n    if (defaultValue === undefined) {\n      return undefined;\n    }\n\n    return `${defaultValue}`;\n  }\n  /**\n   * Normalizes \"isUnique\" value of the column.\n   */\n\n\n  normalizeIsUnique(column) {\n    return column.entityMetadata.indices.some(idx => idx.isUnique && idx.columns.length === 1 && idx.columns[0] === column);\n  }\n  /**\n   * Returns default column lengths, which is required on column creation.\n   */\n\n\n  getColumnLength(column) {\n    if (column.length) return column.length.toString();\n    /**\n     * fix https://github.com/typeorm/typeorm/issues/1139\n     */\n\n    if (column.generationStrategy === \"uuid\") return \"36\";\n\n    switch (column.type) {\n      case String:\n      case \"varchar\":\n      case \"nvarchar\":\n      case \"national varchar\":\n        return \"255\";\n\n      case \"varbinary\":\n        return \"255\";\n\n      default:\n        return \"\";\n    }\n  }\n  /**\n   * Creates column type definition including length, precision and scale\n   */\n\n\n  createFullType(column) {\n    let type = column.type; // used 'getColumnLength()' method, because MySQL requires column length for `varchar`, `nvarchar` and `varbinary` data types\n\n    if (this.getColumnLength(column)) {\n      type += `(${this.getColumnLength(column)})`;\n    } else if (column.width) {\n      type += `(${column.width})`;\n    } else if (column.precision !== null && column.precision !== undefined && column.scale !== null && column.scale !== undefined) {\n      type += `(${column.precision},${column.scale})`;\n    } else if (column.precision !== null && column.precision !== undefined) {\n      type += `(${column.precision})`;\n    }\n\n    if (column.isArray) type += \" array\";\n    return type;\n  }\n  /**\n   * Obtains a new database connection to a master server.\n   * Used for replication.\n   * If replication is not setup then returns default connection's database connection.\n   */\n\n\n  obtainMasterConnection() {\n    return new Promise((ok, fail) => {\n      if (this.poolCluster) {\n        this.poolCluster.getConnection(\"MASTER\", (err, dbConnection) => {\n          err ? fail(err) : ok(this.prepareDbConnection(dbConnection));\n        });\n      } else if (this.pool) {\n        this.pool.getConnection((err, dbConnection) => {\n          err ? fail(err) : ok(this.prepareDbConnection(dbConnection));\n        });\n      } else {\n        fail(new TypeORMError(`Connection is not established with mysql database`));\n      }\n    });\n  }\n  /**\n   * Obtains a new database connection to a slave server.\n   * Used for replication.\n   * If replication is not setup then returns master (default) connection's database connection.\n   */\n\n\n  obtainSlaveConnection() {\n    if (!this.poolCluster) return this.obtainMasterConnection();\n    return new Promise((ok, fail) => {\n      this.poolCluster.getConnection(\"SLAVE*\", (err, dbConnection) => {\n        err ? fail(err) : ok(this.prepareDbConnection(dbConnection));\n      });\n    });\n  }\n  /**\n   * Creates generated map of values generated or returned by database after INSERT query.\n   */\n\n\n  createGeneratedMap(metadata, insertResult, entityIndex) {\n    const generatedMap = metadata.generatedColumns.reduce((map, generatedColumn) => {\n      let value;\n\n      if (generatedColumn.generationStrategy === \"increment\" && insertResult.insertId) {\n        // NOTE: When multiple rows is inserted by a single INSERT statement,\n        // `insertId` is the value generated for the first inserted row only.\n        value = insertResult.insertId + entityIndex; // } else if (generatedColumn.generationStrategy === \"uuid\") {\n        //     console.log(\"getting db value:\", generatedColumn.databaseName);\n        //     value = generatedColumn.getEntityValue(uuidMap);\n      }\n\n      return OrmUtils.mergeDeep(map, generatedColumn.createValueMap(value));\n    }, {});\n    return Object.keys(generatedMap).length > 0 ? generatedMap : undefined;\n  }\n  /**\n   * Differentiate columns of this table and columns from the given column metadatas columns\n   * and returns only changed.\n   */\n\n\n  findChangedColumns(tableColumns, columnMetadatas) {\n    return columnMetadatas.filter(columnMetadata => {\n      const tableColumn = tableColumns.find(c => c.name === columnMetadata.databaseName);\n      if (!tableColumn) return false; // we don't need new columns, we only need exist and changed\n      // console.log(\"table:\", columnMetadata.entityMetadata.tableName);\n      // console.log(\"name:\", tableColumn.name, columnMetadata.databaseName);\n      // console.log(\"type:\", tableColumn.type, this.normalizeType(columnMetadata));\n      // console.log(\"length:\", tableColumn.length, columnMetadata.length);\n      // console.log(\"width:\", tableColumn.width, columnMetadata.width);\n      // console.log(\"precision:\", tableColumn.precision, columnMetadata.precision);\n      // console.log(\"scale:\", tableColumn.scale, columnMetadata.scale);\n      // console.log(\"zerofill:\", tableColumn.zerofill, columnMetadata.zerofill);\n      // console.log(\"unsigned:\", tableColumn.unsigned, columnMetadata.unsigned);\n      // console.log(\"asExpression:\", tableColumn.asExpression, columnMetadata.asExpression);\n      // console.log(\"generatedType:\", tableColumn.generatedType, columnMetadata.generatedType);\n      // console.log(\"comment:\", tableColumn.comment, this.escapeComment(columnMetadata.comment));\n      // console.log(\"default:\", tableColumn.default, columnMetadata.default);\n      // console.log(\"enum:\", tableColumn.enum, columnMetadata.enum);\n      // console.log(\"default changed:\", !this.compareDefaultValues(this.normalizeDefault(columnMetadata), tableColumn.default));\n      // console.log(\"onUpdate:\", tableColumn.onUpdate, columnMetadata.onUpdate);\n      // console.log(\"isPrimary:\", tableColumn.isPrimary, columnMetadata.isPrimary);\n      // console.log(\"isNullable:\", tableColumn.isNullable, columnMetadata.isNullable);\n      // console.log(\"isUnique:\", tableColumn.isUnique, this.normalizeIsUnique(columnMetadata));\n      // console.log(\"isGenerated:\", tableColumn.isGenerated, columnMetadata.isGenerated);\n      // console.log((columnMetadata.generationStrategy !== \"uuid\" && tableColumn.isGenerated !== columnMetadata.isGenerated));\n      // console.log(\"==========================================\");\n\n      let columnMetadataLength = columnMetadata.length;\n\n      if (!columnMetadataLength && columnMetadata.generationStrategy === \"uuid\") {\n        // fixing #3374\n        columnMetadataLength = this.getColumnLength(columnMetadata);\n      }\n\n      return tableColumn.name !== columnMetadata.databaseName || tableColumn.type !== this.normalizeType(columnMetadata) || tableColumn.length !== columnMetadataLength || tableColumn.width !== columnMetadata.width || tableColumn.precision !== columnMetadata.precision || tableColumn.scale !== columnMetadata.scale || tableColumn.zerofill !== columnMetadata.zerofill || tableColumn.unsigned !== columnMetadata.unsigned || tableColumn.asExpression !== columnMetadata.asExpression || tableColumn.generatedType !== columnMetadata.generatedType || tableColumn.comment !== this.escapeComment(columnMetadata.comment) || !this.compareDefaultValues(this.normalizeDefault(columnMetadata), tableColumn.default) || tableColumn.enum && columnMetadata.enum && !OrmUtils.isArraysEqual(tableColumn.enum, columnMetadata.enum.map(val => val + \"\")) || tableColumn.onUpdate !== columnMetadata.onUpdate || tableColumn.isPrimary !== columnMetadata.isPrimary || tableColumn.isNullable !== columnMetadata.isNullable || tableColumn.isUnique !== this.normalizeIsUnique(columnMetadata) || columnMetadata.generationStrategy !== \"uuid\" && tableColumn.isGenerated !== columnMetadata.isGenerated;\n    });\n  }\n  /**\n   * Returns true if driver supports RETURNING / OUTPUT statement.\n   */\n\n\n  isReturningSqlSupported() {\n    return false;\n  }\n  /**\n   * Returns true if driver supports uuid values generation on its own.\n   */\n\n\n  isUUIDGenerationSupported() {\n    return false;\n  }\n  /**\n   * Returns true if driver supports fulltext indices.\n   */\n\n\n  isFullTextColumnTypeSupported() {\n    return true;\n  }\n  /**\n   * Creates an escaped parameter.\n   */\n\n\n  createParameter(parameterName, index) {\n    return \"?\";\n  } // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Loads all driver dependencies.\n   */\n\n\n  loadDependencies() {\n    const DataApiDriver = this.options.driver || PlatformTools.load(\"typeorm-aurora-data-api-driver\");\n    this.DataApiDriver = DataApiDriver; // Driver uses rollup for publishing, which has issues when using typeorm in combination with webpack\n    // See https://github.com/webpack/webpack/issues/4742#issuecomment-295556787\n\n    this.DataApiDriver = this.DataApiDriver.default || this.DataApiDriver;\n  }\n  /**\n   * Creates a new connection pool for a given database credentials.\n   */\n\n\n  createConnectionOptions(options, credentials) {\n    credentials = Object.assign({}, credentials, DriverUtils.buildDriverOptions(credentials)); // todo: do it better way\n    // build connection options for the driver\n\n    return Object.assign({}, {\n      resourceArn: options.resourceArn,\n      secretArn: options.secretArn,\n      database: options.database,\n      region: options.region,\n      type: options.type\n    }, {\n      host: credentials.host,\n      user: credentials.username,\n      password: credentials.password,\n      database: credentials.database,\n      port: credentials.port,\n      ssl: options.ssl\n    }, options.extra || {});\n  }\n  /**\n   * Creates a new connection pool for a given database credentials.\n   */\n\n\n  async createPool(connectionOptions) {\n    return {};\n  }\n  /**\n   * Attaches all required base handlers to a database connection, such as the unhandled error handler.\n   */\n\n\n  prepareDbConnection(connection) {\n    const {\n      logger\n    } = this.connection;\n    /**\n     * Attaching an error handler to connection errors is essential, as, otherwise, errors raised will go unhandled and\n     * cause the hosting app to crash.\n     */\n\n    if (connection.listeners(\"error\").length === 0) {\n      connection.on(\"error\", error => logger.log(\"warn\", `MySQL connection raised an error. ${error}`));\n    }\n\n    return connection;\n  }\n  /**\n   * Checks if \"DEFAULT\" values in the column metadata and in the database are equal.\n   */\n\n\n  compareDefaultValues(columnMetadataValue, databaseValue) {\n    if (typeof columnMetadataValue === \"string\" && typeof databaseValue === \"string\") {\n      // we need to cut out \"'\" because in mysql we can understand returned value is a string or a function\n      // as result compare cannot understand if default is really changed or not\n      columnMetadataValue = columnMetadataValue.replace(/^'+|'+$/g, \"\");\n      databaseValue = databaseValue.replace(/^'+|'+$/g, \"\");\n    }\n\n    return columnMetadataValue === databaseValue;\n  }\n  /**\n   * Escapes a given comment.\n   */\n\n\n  escapeComment(comment) {\n    if (!comment) return comment;\n    comment = comment.replace(/\\u0000/g, \"\"); // Null bytes aren't allowed in comments\n\n    return comment;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["DriverUtils","AuroraMysqlQueryRunner","DateUtils","PlatformTools","RdbmsSchemaBuilder","OrmUtils","ApplyValueTransformers","TypeORMError","InstanceChecker","AuroraMysqlDriver","constructor","connection","createDate","createDatePrecision","createDateDefault","updateDate","updateDatePrecision","updateDateDefault","deleteDate","deleteDatePrecision","deleteDateNullable","version","treeLevel","migrationId","migrationName","migrationTimestamp","cacheId","cacheIdentifier","cacheTime","cacheDuration","cacheQuery","cacheResult","metadataType","metadataDatabase","metadataSchema","metadataTable","metadataName","metadataValue","varchar","length","nvarchar","char","binary","varbinary","decimal","precision","scale","dec","numeric","fixed","float","double","time","datetime","timestamp","bit","width","int","integer","tinyint","smallint","mediumint","bigint","enabled","options","loadDependencies","client","DataApiDriver","region","secretArn","resourceArn","database","query","parameters","logger","logQuery","serviceConfigOptions","formatOptions","buildDriverOptions","connect","queryRunner","createQueryRunner","getCurrentDatabase","release","afterConnect","Promise","resolve","disconnect","createSchemaBuilder","mode","escapeQueryWithParameters","sql","nativeParameters","escapedParameters","Object","keys","map","key","replace","full","isArray","hasOwnProperty","value","v","push","createParameter","join","escape","columnName","buildTableName","tableName","schema","tablePath","unshift","parseTableName","target","driverDatabase","driverSchema","undefined","isTable","isView","parsed","name","isTableForeignKey","referencedTableName","referencedDatabase","referencedSchema","isEntityMetadata","parts","split","preparePersistentValue","columnMetadata","transformer","transformTo","castParameters","type","Boolean","mixedDateToDateString","mixedDateToTimeString","JSON","stringify","Date","mixedDateToDate","simpleArrayToString","simpleJsonToString","prepareHydratedValue","transformFrom","normalizeHydratedDate","parse","mixedTimeToString","stringToSimpleArray","stringToSimpleJson","enum","isNaN","indexOf","parseInt","normalizeType","column","Number","String","Buffer","normalizeDefault","defaultValue","default","normalizeIsUnique","entityMetadata","indices","some","idx","isUnique","columns","getColumnLength","toString","generationStrategy","createFullType","obtainMasterConnection","ok","fail","poolCluster","getConnection","err","dbConnection","prepareDbConnection","pool","obtainSlaveConnection","createGeneratedMap","metadata","insertResult","entityIndex","generatedMap","generatedColumns","reduce","generatedColumn","insertId","mergeDeep","createValueMap","findChangedColumns","tableColumns","columnMetadatas","filter","tableColumn","find","c","databaseName","columnMetadataLength","zerofill","unsigned","asExpression","generatedType","comment","escapeComment","compareDefaultValues","isArraysEqual","val","onUpdate","isPrimary","isNullable","isGenerated","isReturningSqlSupported","isUUIDGenerationSupported","isFullTextColumnTypeSupported","parameterName","index","driver","load","createConnectionOptions","credentials","assign","host","user","username","password","port","ssl","extra","createPool","connectionOptions","listeners","on","error","log","columnMetadataValue","databaseValue"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\driver\\aurora-mysql\\AuroraMysqlDriver.ts"],"sourcesContent":["import { Driver } from \"../Driver\"\nimport { DriverUtils } from \"../DriverUtils\"\nimport { CteCapabilities } from \"../types/CteCapabilities\"\nimport { AuroraMysqlQueryRunner } from \"./AuroraMysqlQueryRunner\"\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { ColumnMetadata } from \"../../metadata/ColumnMetadata\"\nimport { DateUtils } from \"../../util/DateUtils\"\nimport { PlatformTools } from \"../../platform/PlatformTools\"\nimport { DataSource } from \"../../data-source\"\nimport { RdbmsSchemaBuilder } from \"../../schema-builder/RdbmsSchemaBuilder\"\nimport { AuroraMysqlConnectionOptions } from \"./AuroraMysqlConnectionOptions\"\nimport { MappedColumnTypes } from \"../types/MappedColumnTypes\"\nimport { ColumnType } from \"../types/ColumnTypes\"\nimport { DataTypeDefaults } from \"../types/DataTypeDefaults\"\nimport { TableColumn } from \"../../schema-builder/table/TableColumn\"\nimport { AuroraMysqlConnectionCredentialsOptions } from \"./AuroraMysqlConnectionCredentialsOptions\"\nimport { EntityMetadata } from \"../../metadata/EntityMetadata\"\nimport { OrmUtils } from \"../../util/OrmUtils\"\nimport { ApplyValueTransformers } from \"../../util/ApplyValueTransformers\"\nimport { ReplicationMode } from \"../types/ReplicationMode\"\nimport { TypeORMError } from \"../../error\"\nimport { Table } from \"../../schema-builder/table/Table\"\nimport { View } from \"../../schema-builder/view/View\"\nimport { TableForeignKey } from \"../../schema-builder/table/TableForeignKey\"\nimport { InstanceChecker } from \"../../util/InstanceChecker\"\n\n/**\n * Organizes communication with MySQL DBMS.\n */\nexport class AuroraMysqlDriver implements Driver {\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    connection: DataSource\n\n    /**\n     * Aurora Data API underlying library.\n     */\n    DataApiDriver: any\n\n    client: any\n\n    /**\n     * Connection pool.\n     * Used in non-replication mode.\n     */\n    pool: any\n\n    /**\n     * Pool cluster used in replication mode.\n     */\n    poolCluster: any\n\n    // -------------------------------------------------------------------------\n    // Public Implemented Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Connection options.\n     */\n    options: AuroraMysqlConnectionOptions\n\n    /**\n     * Database name used to perform all write queries.\n     */\n    database?: string\n\n    /**\n     * Schema name used to perform all write queries.\n     */\n    schema?: string\n\n    /**\n     * Indicates if replication is enabled.\n     */\n    isReplicated: boolean = false\n\n    /**\n     * Indicates if tree tables are supported by this driver.\n     */\n    treeSupport = true\n\n    /**\n     * Represent transaction support by this driver\n     */\n    transactionSupport = \"nested\" as const\n\n    /**\n     * Gets list of supported column data types by a driver.\n     *\n     * @see https://www.tutorialspoint.com/mysql/mysql-data-types.htm\n     * @see https://dev.mysql.com/doc/refman/8.0/en/data-types.html\n     */\n    supportedDataTypes: ColumnType[] = [\n        // numeric types\n        \"bit\",\n        \"int\",\n        \"integer\", // synonym for int\n        \"tinyint\",\n        \"smallint\",\n        \"mediumint\",\n        \"bigint\",\n        \"float\",\n        \"double\",\n        \"double precision\", // synonym for double\n        \"real\", // synonym for double\n        \"decimal\",\n        \"dec\", // synonym for decimal\n        \"numeric\", // synonym for decimal\n        \"fixed\", // synonym for decimal\n        \"bool\", // synonym for tinyint\n        \"boolean\", // synonym for tinyint\n        // date and time types\n        \"date\",\n        \"datetime\",\n        \"timestamp\",\n        \"time\",\n        \"year\",\n        // string types\n        \"char\",\n        \"nchar\", // synonym for national char\n        \"national char\",\n        \"varchar\",\n        \"nvarchar\", // synonym for national varchar\n        \"national varchar\",\n        \"blob\",\n        \"text\",\n        \"tinyblob\",\n        \"tinytext\",\n        \"mediumblob\",\n        \"mediumtext\",\n        \"longblob\",\n        \"longtext\",\n        \"enum\",\n        \"set\",\n        \"binary\",\n        \"varbinary\",\n        // json data type\n        \"json\",\n        // spatial data types\n        \"geometry\",\n        \"point\",\n        \"linestring\",\n        \"polygon\",\n        \"multipoint\",\n        \"multilinestring\",\n        \"multipolygon\",\n        \"geometrycollection\",\n    ]\n\n    /**\n     * Returns type of upsert supported by driver if any\n     */\n    readonly supportedUpsertType = \"on-duplicate-key-update\"\n\n    /**\n     * Gets list of spatial column data types.\n     */\n    spatialTypes: ColumnType[] = [\n        \"geometry\",\n        \"point\",\n        \"linestring\",\n        \"polygon\",\n        \"multipoint\",\n        \"multilinestring\",\n        \"multipolygon\",\n        \"geometrycollection\",\n    ]\n\n    /**\n     * Gets list of column data types that support length by a driver.\n     */\n    withLengthColumnTypes: ColumnType[] = [\n        \"char\",\n        \"varchar\",\n        \"nvarchar\",\n        \"binary\",\n        \"varbinary\",\n    ]\n\n    /**\n     * Gets list of column data types that support length by a driver.\n     */\n    withWidthColumnTypes: ColumnType[] = [\n        \"bit\",\n        \"tinyint\",\n        \"smallint\",\n        \"mediumint\",\n        \"int\",\n        \"integer\",\n        \"bigint\",\n    ]\n\n    /**\n     * Gets list of column data types that support precision by a driver.\n     */\n    withPrecisionColumnTypes: ColumnType[] = [\n        \"decimal\",\n        \"dec\",\n        \"numeric\",\n        \"fixed\",\n        \"float\",\n        \"double\",\n        \"double precision\",\n        \"real\",\n        \"time\",\n        \"datetime\",\n        \"timestamp\",\n    ]\n\n    /**\n     * Gets list of column data types that supports scale by a driver.\n     */\n    withScaleColumnTypes: ColumnType[] = [\n        \"decimal\",\n        \"dec\",\n        \"numeric\",\n        \"fixed\",\n        \"float\",\n        \"double\",\n        \"double precision\",\n        \"real\",\n    ]\n\n    /**\n     * Gets list of column data types that supports UNSIGNED and ZEROFILL attributes.\n     */\n    unsignedAndZerofillTypes: ColumnType[] = [\n        \"int\",\n        \"integer\",\n        \"smallint\",\n        \"tinyint\",\n        \"mediumint\",\n        \"bigint\",\n        \"decimal\",\n        \"dec\",\n        \"numeric\",\n        \"fixed\",\n        \"float\",\n        \"double\",\n        \"double precision\",\n        \"real\",\n    ]\n\n    /**\n     * ORM has special columns and we need to know what database column types should be for those columns.\n     * Column types are driver dependant.\n     */\n    mappedDataTypes: MappedColumnTypes = {\n        createDate: \"datetime\",\n        createDatePrecision: 6,\n        createDateDefault: \"CURRENT_TIMESTAMP(6)\",\n        updateDate: \"datetime\",\n        updateDatePrecision: 6,\n        updateDateDefault: \"CURRENT_TIMESTAMP(6)\",\n        deleteDate: \"datetime\",\n        deleteDatePrecision: 6,\n        deleteDateNullable: true,\n        version: \"int\",\n        treeLevel: \"int\",\n        migrationId: \"int\",\n        migrationName: \"varchar\",\n        migrationTimestamp: \"bigint\",\n        cacheId: \"int\",\n        cacheIdentifier: \"varchar\",\n        cacheTime: \"bigint\",\n        cacheDuration: \"int\",\n        cacheQuery: \"text\",\n        cacheResult: \"text\",\n        metadataType: \"varchar\",\n        metadataDatabase: \"varchar\",\n        metadataSchema: \"varchar\",\n        metadataTable: \"varchar\",\n        metadataName: \"varchar\",\n        metadataValue: \"text\",\n    }\n\n    /**\n     * Default values of length, precision and scale depends on column data type.\n     * Used in the cases when length/precision/scale is not specified by user.\n     */\n    dataTypeDefaults: DataTypeDefaults = {\n        varchar: { length: 255 },\n        nvarchar: { length: 255 },\n        \"national varchar\": { length: 255 },\n        char: { length: 1 },\n        binary: { length: 1 },\n        varbinary: { length: 255 },\n        decimal: { precision: 10, scale: 0 },\n        dec: { precision: 10, scale: 0 },\n        numeric: { precision: 10, scale: 0 },\n        fixed: { precision: 10, scale: 0 },\n        float: { precision: 12 },\n        double: { precision: 22 },\n        time: { precision: 0 },\n        datetime: { precision: 0 },\n        timestamp: { precision: 0 },\n        bit: { width: 1 },\n        int: { width: 11 },\n        integer: { width: 11 },\n        tinyint: { width: 4 },\n        smallint: { width: 6 },\n        mediumint: { width: 9 },\n        bigint: { width: 20 },\n    }\n\n    /**\n     * Max length allowed by MySQL for aliases.\n     * @see https://dev.mysql.com/doc/refman/5.5/en/identifiers.html\n     */\n    maxAliasLength = 63\n\n    cteCapabilities: CteCapabilities = {\n        enabled: false,\n    }\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(connection: DataSource) {\n        this.connection = connection\n        this.options = connection.options as AuroraMysqlConnectionOptions\n\n        // load mysql package\n        this.loadDependencies()\n\n        this.client = new this.DataApiDriver(\n            this.options.region,\n            this.options.secretArn,\n            this.options.resourceArn,\n            this.options.database,\n            (query: string, parameters?: any[]) =>\n                this.connection.logger.logQuery(query, parameters),\n            this.options.serviceConfigOptions,\n            this.options.formatOptions,\n        )\n\n        this.database = DriverUtils.buildDriverOptions(this.options).database\n\n        // validate options to make sure everything is set\n        // todo: revisit validation with replication in mind\n        // if (!(this.options.host || (this.options.extra && this.options.extra.socketPath)) && !this.options.socketPath)\n        //     throw new DriverOptionNotSetError(\"socketPath and host\");\n        // if (!this.options.username)\n        //     throw new DriverOptionNotSetError(\"username\");\n        // if (!this.options.database)\n        //     throw new DriverOptionNotSetError(\"database\");\n        // todo: check what is going on when connection is setup without database and how to connect to a database then?\n        // todo: provide options to auto-create a database if it does not exist yet\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Performs connection to the database.\n     */\n    async connect(): Promise<void> {\n        if (!this.database) {\n            const queryRunner = await this.createQueryRunner(\"master\")\n\n            this.database = await queryRunner.getCurrentDatabase()\n\n            await queryRunner.release()\n        }\n    }\n\n    /**\n     * Makes any action after connection (e.g. create extensions in Postgres driver).\n     */\n    afterConnect(): Promise<void> {\n        return Promise.resolve()\n    }\n\n    /**\n     * Closes connection with the database.\n     */\n    async disconnect(): Promise<void> {}\n\n    /**\n     * Creates a schema builder used to build and sync a schema.\n     */\n    createSchemaBuilder() {\n        return new RdbmsSchemaBuilder(this.connection)\n    }\n\n    /**\n     * Creates a query runner used to execute database queries.\n     */\n    createQueryRunner(mode: ReplicationMode) {\n        return new AuroraMysqlQueryRunner(\n            this,\n            new this.DataApiDriver(\n                this.options.region,\n                this.options.secretArn,\n                this.options.resourceArn,\n                this.options.database,\n                (query: string, parameters?: any[]) =>\n                    this.connection.logger.logQuery(query, parameters),\n                this.options.serviceConfigOptions,\n                this.options.formatOptions,\n            ),\n        )\n    }\n\n    /**\n     * Replaces parameters in the given sql with special escaping character\n     * and an array of parameter names to be passed to a query.\n     */\n    escapeQueryWithParameters(\n        sql: string,\n        parameters: ObjectLiteral,\n        nativeParameters: ObjectLiteral,\n    ): [string, any[]] {\n        const escapedParameters: any[] = Object.keys(nativeParameters).map(\n            (key) => nativeParameters[key],\n        )\n        if (!parameters || !Object.keys(parameters).length)\n            return [sql, escapedParameters]\n\n        sql = sql.replace(\n            /:(\\.\\.\\.)?([A-Za-z0-9_.]+)/g,\n            (full, isArray: string, key: string): string => {\n                if (!parameters.hasOwnProperty(key)) {\n                    return full\n                }\n\n                let value: any = parameters[key]\n\n                if (isArray) {\n                    return value\n                        .map((v: any) => {\n                            escapedParameters.push(v)\n                            return this.createParameter(\n                                key,\n                                escapedParameters.length - 1,\n                            )\n                        })\n                        .join(\", \")\n                }\n\n                if (typeof value === \"function\") {\n                    return value()\n                }\n\n                escapedParameters.push(value)\n                return this.createParameter(key, escapedParameters.length - 1)\n            },\n        ) // todo: make replace only in value statements, otherwise problems\n        return [sql, escapedParameters]\n    }\n\n    /**\n     * Escapes a column name.\n     */\n    escape(columnName: string): string {\n        return \"`\" + columnName + \"`\"\n    }\n\n    /**\n     * Build full table name with database name, schema name and table name.\n     * E.g. myDB.mySchema.myTable\n     */\n    buildTableName(\n        tableName: string,\n        schema?: string,\n        database?: string,\n    ): string {\n        let tablePath = [tableName]\n\n        if (database) {\n            tablePath.unshift(database)\n        }\n\n        return tablePath.join(\".\")\n    }\n\n    /**\n     * Parse a target table name or other types and return a normalized table definition.\n     */\n    parseTableName(\n        target: EntityMetadata | Table | View | TableForeignKey | string,\n    ): { database?: string; schema?: string; tableName: string } {\n        const driverDatabase = this.database\n        const driverSchema = undefined\n\n        if (InstanceChecker.isTable(target) || InstanceChecker.isView(target)) {\n            const parsed = this.parseTableName(target.name)\n\n            return {\n                database: target.database || parsed.database || driverDatabase,\n                schema: target.schema || parsed.schema || driverSchema,\n                tableName: parsed.tableName,\n            }\n        }\n\n        if (InstanceChecker.isTableForeignKey(target)) {\n            const parsed = this.parseTableName(target.referencedTableName)\n\n            return {\n                database:\n                    target.referencedDatabase ||\n                    parsed.database ||\n                    driverDatabase,\n                schema:\n                    target.referencedSchema || parsed.schema || driverSchema,\n                tableName: parsed.tableName,\n            }\n        }\n\n        if (InstanceChecker.isEntityMetadata(target)) {\n            // EntityMetadata tableName is never a path\n\n            return {\n                database: target.database || driverDatabase,\n                schema: target.schema || driverSchema,\n                tableName: target.tableName,\n            }\n        }\n\n        const parts = target.split(\".\")\n\n        return {\n            database:\n                (parts.length > 1 ? parts[0] : undefined) || driverDatabase,\n            schema: driverSchema,\n            tableName: parts.length > 1 ? parts[1] : parts[0],\n        }\n    }\n\n    /**\n     * Prepares given value to a value to be persisted, based on its column type and metadata.\n     */\n    preparePersistentValue(value: any, columnMetadata: ColumnMetadata): any {\n        if (columnMetadata.transformer)\n            value = ApplyValueTransformers.transformTo(\n                columnMetadata.transformer,\n                value,\n            )\n\n        if (\n            !this.options.formatOptions ||\n            this.options.formatOptions.castParameters !== false\n        ) {\n            return this.client.preparePersistentValue(value, columnMetadata)\n        }\n\n        if (value === null || value === undefined) return value\n\n        if (columnMetadata.type === Boolean) {\n            return value === true ? 1 : 0\n        } else if (columnMetadata.type === \"date\") {\n            return DateUtils.mixedDateToDateString(value)\n        } else if (columnMetadata.type === \"time\") {\n            return DateUtils.mixedDateToTimeString(value)\n        } else if (columnMetadata.type === \"json\") {\n            return JSON.stringify(value)\n        } else if (\n            columnMetadata.type === \"timestamp\" ||\n            columnMetadata.type === \"datetime\" ||\n            columnMetadata.type === Date\n        ) {\n            return DateUtils.mixedDateToDate(value)\n        } else if (\n            columnMetadata.type === \"simple-array\" ||\n            columnMetadata.type === \"set\"\n        ) {\n            return DateUtils.simpleArrayToString(value)\n        } else if (columnMetadata.type === \"simple-json\") {\n            return DateUtils.simpleJsonToString(value)\n        } else if (\n            columnMetadata.type === \"enum\" ||\n            columnMetadata.type === \"simple-enum\"\n        ) {\n            return \"\" + value\n        }\n\n        return value\n    }\n\n    /**\n     * Prepares given value to a value to be persisted, based on its column type or metadata.\n     */\n    prepareHydratedValue(value: any, columnMetadata: ColumnMetadata): any {\n        if (value === null || value === undefined)\n            return columnMetadata.transformer\n                ? ApplyValueTransformers.transformFrom(\n                      columnMetadata.transformer,\n                      value,\n                  )\n                : value\n\n        if (\n            !this.options.formatOptions ||\n            this.options.formatOptions.castParameters !== false\n        ) {\n            return this.client.prepareHydratedValue(value, columnMetadata)\n        }\n\n        if (\n            columnMetadata.type === Boolean ||\n            columnMetadata.type === \"bool\" ||\n            columnMetadata.type === \"boolean\"\n        ) {\n            value = value ? true : false\n        } else if (\n            columnMetadata.type === \"datetime\" ||\n            columnMetadata.type === Date\n        ) {\n            value = DateUtils.normalizeHydratedDate(value)\n        } else if (columnMetadata.type === \"date\") {\n            value = DateUtils.mixedDateToDateString(value)\n        } else if (columnMetadata.type === \"json\") {\n            value = typeof value === \"string\" ? JSON.parse(value) : value\n        } else if (columnMetadata.type === \"time\") {\n            value = DateUtils.mixedTimeToString(value)\n        } else if (\n            columnMetadata.type === \"simple-array\" ||\n            columnMetadata.type === \"set\"\n        ) {\n            value = DateUtils.stringToSimpleArray(value)\n        } else if (columnMetadata.type === \"simple-json\") {\n            value = DateUtils.stringToSimpleJson(value)\n        } else if (\n            (columnMetadata.type === \"enum\" ||\n                columnMetadata.type === \"simple-enum\") &&\n            columnMetadata.enum &&\n            !isNaN(value) &&\n            columnMetadata.enum.indexOf(parseInt(value)) >= 0\n        ) {\n            // convert to number if that exists in possible enum options\n            value = parseInt(value)\n        }\n\n        if (columnMetadata.transformer)\n            value = ApplyValueTransformers.transformFrom(\n                columnMetadata.transformer,\n                value,\n            )\n\n        return value\n    }\n\n    /**\n     * Creates a database type from a given column metadata.\n     */\n    normalizeType(column: {\n        type: ColumnType\n        length?: number | string\n        precision?: number | null\n        scale?: number\n    }): string {\n        if (column.type === Number || column.type === \"integer\") {\n            return \"int\"\n        } else if (column.type === String) {\n            return \"varchar\"\n        } else if (column.type === Date) {\n            return \"datetime\"\n        } else if ((column.type as any) === Buffer) {\n            return \"blob\"\n        } else if (column.type === Boolean) {\n            return \"tinyint\"\n        } else if (column.type === \"uuid\") {\n            return \"varchar\"\n        } else if (\n            column.type === \"simple-array\" ||\n            column.type === \"simple-json\"\n        ) {\n            return \"text\"\n        } else if (column.type === \"simple-enum\") {\n            return \"enum\"\n        } else if (\n            column.type === \"double precision\" ||\n            column.type === \"real\"\n        ) {\n            return \"double\"\n        } else if (\n            column.type === \"dec\" ||\n            column.type === \"numeric\" ||\n            column.type === \"fixed\"\n        ) {\n            return \"decimal\"\n        } else if (column.type === \"bool\" || column.type === \"boolean\") {\n            return \"tinyint\"\n        } else if (\n            column.type === \"nvarchar\" ||\n            column.type === \"national varchar\"\n        ) {\n            return \"varchar\"\n        } else if (column.type === \"nchar\" || column.type === \"national char\") {\n            return \"char\"\n        } else {\n            return (column.type as string) || \"\"\n        }\n    }\n\n    /**\n     * Normalizes \"default\" value of the column.\n     */\n    normalizeDefault(columnMetadata: ColumnMetadata): string | undefined {\n        const defaultValue = columnMetadata.default\n\n        if (defaultValue === null) {\n            return undefined\n        }\n\n        if (\n            (columnMetadata.type === \"enum\" ||\n                columnMetadata.type === \"simple-enum\") &&\n            defaultValue !== undefined\n        ) {\n            return `'${defaultValue}'`\n        }\n\n        if (columnMetadata.type === \"set\" && defaultValue !== undefined) {\n            return `'${DateUtils.simpleArrayToString(defaultValue)}'`\n        }\n\n        if (typeof defaultValue === \"number\") {\n            return `${defaultValue}`\n        }\n\n        if (typeof defaultValue === \"boolean\") {\n            return defaultValue ? \"1\" : \"0\"\n        }\n\n        if (typeof defaultValue === \"function\") {\n            return defaultValue()\n        }\n\n        if (typeof defaultValue === \"string\") {\n            return `'${defaultValue}'`\n        }\n\n        if (defaultValue === undefined) {\n            return undefined\n        }\n\n        return `${defaultValue}`\n    }\n\n    /**\n     * Normalizes \"isUnique\" value of the column.\n     */\n    normalizeIsUnique(column: ColumnMetadata): boolean {\n        return column.entityMetadata.indices.some(\n            (idx) =>\n                idx.isUnique &&\n                idx.columns.length === 1 &&\n                idx.columns[0] === column,\n        )\n    }\n\n    /**\n     * Returns default column lengths, which is required on column creation.\n     */\n    getColumnLength(column: ColumnMetadata | TableColumn): string {\n        if (column.length) return column.length.toString()\n\n        /**\n         * fix https://github.com/typeorm/typeorm/issues/1139\n         */\n        if (column.generationStrategy === \"uuid\") return \"36\"\n\n        switch (column.type) {\n            case String:\n            case \"varchar\":\n            case \"nvarchar\":\n            case \"national varchar\":\n                return \"255\"\n            case \"varbinary\":\n                return \"255\"\n            default:\n                return \"\"\n        }\n    }\n\n    /**\n     * Creates column type definition including length, precision and scale\n     */\n    createFullType(column: TableColumn): string {\n        let type = column.type\n\n        // used 'getColumnLength()' method, because MySQL requires column length for `varchar`, `nvarchar` and `varbinary` data types\n        if (this.getColumnLength(column)) {\n            type += `(${this.getColumnLength(column)})`\n        } else if (column.width) {\n            type += `(${column.width})`\n        } else if (\n            column.precision !== null &&\n            column.precision !== undefined &&\n            column.scale !== null &&\n            column.scale !== undefined\n        ) {\n            type += `(${column.precision},${column.scale})`\n        } else if (\n            column.precision !== null &&\n            column.precision !== undefined\n        ) {\n            type += `(${column.precision})`\n        }\n\n        if (column.isArray) type += \" array\"\n\n        return type\n    }\n\n    /**\n     * Obtains a new database connection to a master server.\n     * Used for replication.\n     * If replication is not setup then returns default connection's database connection.\n     */\n    obtainMasterConnection(): Promise<any> {\n        return new Promise<any>((ok, fail) => {\n            if (this.poolCluster) {\n                this.poolCluster.getConnection(\n                    \"MASTER\",\n                    (err: any, dbConnection: any) => {\n                        err\n                            ? fail(err)\n                            : ok(this.prepareDbConnection(dbConnection))\n                    },\n                )\n            } else if (this.pool) {\n                this.pool.getConnection((err: any, dbConnection: any) => {\n                    err ? fail(err) : ok(this.prepareDbConnection(dbConnection))\n                })\n            } else {\n                fail(\n                    new TypeORMError(\n                        `Connection is not established with mysql database`,\n                    ),\n                )\n            }\n        })\n    }\n\n    /**\n     * Obtains a new database connection to a slave server.\n     * Used for replication.\n     * If replication is not setup then returns master (default) connection's database connection.\n     */\n    obtainSlaveConnection(): Promise<any> {\n        if (!this.poolCluster) return this.obtainMasterConnection()\n\n        return new Promise<any>((ok, fail) => {\n            this.poolCluster.getConnection(\n                \"SLAVE*\",\n                (err: any, dbConnection: any) => {\n                    err ? fail(err) : ok(this.prepareDbConnection(dbConnection))\n                },\n            )\n        })\n    }\n\n    /**\n     * Creates generated map of values generated or returned by database after INSERT query.\n     */\n    createGeneratedMap(\n        metadata: EntityMetadata,\n        insertResult: any,\n        entityIndex: number,\n    ) {\n        const generatedMap = metadata.generatedColumns.reduce(\n            (map, generatedColumn) => {\n                let value: any\n                if (\n                    generatedColumn.generationStrategy === \"increment\" &&\n                    insertResult.insertId\n                ) {\n                    // NOTE: When multiple rows is inserted by a single INSERT statement,\n                    // `insertId` is the value generated for the first inserted row only.\n                    value = insertResult.insertId + entityIndex\n                    // } else if (generatedColumn.generationStrategy === \"uuid\") {\n                    //     console.log(\"getting db value:\", generatedColumn.databaseName);\n                    //     value = generatedColumn.getEntityValue(uuidMap);\n                }\n\n                return OrmUtils.mergeDeep(\n                    map,\n                    generatedColumn.createValueMap(value),\n                )\n            },\n            {} as ObjectLiteral,\n        )\n\n        return Object.keys(generatedMap).length > 0 ? generatedMap : undefined\n    }\n\n    /**\n     * Differentiate columns of this table and columns from the given column metadatas columns\n     * and returns only changed.\n     */\n    findChangedColumns(\n        tableColumns: TableColumn[],\n        columnMetadatas: ColumnMetadata[],\n    ): ColumnMetadata[] {\n        return columnMetadatas.filter((columnMetadata) => {\n            const tableColumn = tableColumns.find(\n                (c) => c.name === columnMetadata.databaseName,\n            )\n            if (!tableColumn) return false // we don't need new columns, we only need exist and changed\n\n            // console.log(\"table:\", columnMetadata.entityMetadata.tableName);\n            // console.log(\"name:\", tableColumn.name, columnMetadata.databaseName);\n            // console.log(\"type:\", tableColumn.type, this.normalizeType(columnMetadata));\n            // console.log(\"length:\", tableColumn.length, columnMetadata.length);\n            // console.log(\"width:\", tableColumn.width, columnMetadata.width);\n            // console.log(\"precision:\", tableColumn.precision, columnMetadata.precision);\n            // console.log(\"scale:\", tableColumn.scale, columnMetadata.scale);\n            // console.log(\"zerofill:\", tableColumn.zerofill, columnMetadata.zerofill);\n            // console.log(\"unsigned:\", tableColumn.unsigned, columnMetadata.unsigned);\n            // console.log(\"asExpression:\", tableColumn.asExpression, columnMetadata.asExpression);\n            // console.log(\"generatedType:\", tableColumn.generatedType, columnMetadata.generatedType);\n            // console.log(\"comment:\", tableColumn.comment, this.escapeComment(columnMetadata.comment));\n            // console.log(\"default:\", tableColumn.default, columnMetadata.default);\n            // console.log(\"enum:\", tableColumn.enum, columnMetadata.enum);\n            // console.log(\"default changed:\", !this.compareDefaultValues(this.normalizeDefault(columnMetadata), tableColumn.default));\n            // console.log(\"onUpdate:\", tableColumn.onUpdate, columnMetadata.onUpdate);\n            // console.log(\"isPrimary:\", tableColumn.isPrimary, columnMetadata.isPrimary);\n            // console.log(\"isNullable:\", tableColumn.isNullable, columnMetadata.isNullable);\n            // console.log(\"isUnique:\", tableColumn.isUnique, this.normalizeIsUnique(columnMetadata));\n            // console.log(\"isGenerated:\", tableColumn.isGenerated, columnMetadata.isGenerated);\n            // console.log((columnMetadata.generationStrategy !== \"uuid\" && tableColumn.isGenerated !== columnMetadata.isGenerated));\n            // console.log(\"==========================================\");\n\n            let columnMetadataLength = columnMetadata.length\n            if (\n                !columnMetadataLength &&\n                columnMetadata.generationStrategy === \"uuid\"\n            ) {\n                // fixing #3374\n                columnMetadataLength = this.getColumnLength(columnMetadata)\n            }\n\n            return (\n                tableColumn.name !== columnMetadata.databaseName ||\n                tableColumn.type !== this.normalizeType(columnMetadata) ||\n                tableColumn.length !== columnMetadataLength ||\n                tableColumn.width !== columnMetadata.width ||\n                tableColumn.precision !== columnMetadata.precision ||\n                tableColumn.scale !== columnMetadata.scale ||\n                tableColumn.zerofill !== columnMetadata.zerofill ||\n                tableColumn.unsigned !== columnMetadata.unsigned ||\n                tableColumn.asExpression !== columnMetadata.asExpression ||\n                tableColumn.generatedType !== columnMetadata.generatedType ||\n                tableColumn.comment !==\n                    this.escapeComment(columnMetadata.comment) ||\n                !this.compareDefaultValues(\n                    this.normalizeDefault(columnMetadata),\n                    tableColumn.default,\n                ) ||\n                (tableColumn.enum &&\n                    columnMetadata.enum &&\n                    !OrmUtils.isArraysEqual(\n                        tableColumn.enum,\n                        columnMetadata.enum.map((val) => val + \"\"),\n                    )) ||\n                tableColumn.onUpdate !== columnMetadata.onUpdate ||\n                tableColumn.isPrimary !== columnMetadata.isPrimary ||\n                tableColumn.isNullable !== columnMetadata.isNullable ||\n                tableColumn.isUnique !==\n                    this.normalizeIsUnique(columnMetadata) ||\n                (columnMetadata.generationStrategy !== \"uuid\" &&\n                    tableColumn.isGenerated !== columnMetadata.isGenerated)\n            )\n        })\n    }\n\n    /**\n     * Returns true if driver supports RETURNING / OUTPUT statement.\n     */\n    isReturningSqlSupported(): boolean {\n        return false\n    }\n\n    /**\n     * Returns true if driver supports uuid values generation on its own.\n     */\n    isUUIDGenerationSupported(): boolean {\n        return false\n    }\n\n    /**\n     * Returns true if driver supports fulltext indices.\n     */\n    isFullTextColumnTypeSupported(): boolean {\n        return true\n    }\n\n    /**\n     * Creates an escaped parameter.\n     */\n    createParameter(parameterName: string, index: number): string {\n        return \"?\"\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Loads all driver dependencies.\n     */\n    protected loadDependencies(): void {\n        const DataApiDriver =\n            this.options.driver ||\n            PlatformTools.load(\"typeorm-aurora-data-api-driver\")\n        this.DataApiDriver = DataApiDriver\n\n        // Driver uses rollup for publishing, which has issues when using typeorm in combination with webpack\n        // See https://github.com/webpack/webpack/issues/4742#issuecomment-295556787\n        this.DataApiDriver = this.DataApiDriver.default || this.DataApiDriver\n    }\n\n    /**\n     * Creates a new connection pool for a given database credentials.\n     */\n    protected createConnectionOptions(\n        options: AuroraMysqlConnectionOptions,\n        credentials: AuroraMysqlConnectionCredentialsOptions,\n    ): Promise<any> {\n        credentials = Object.assign(\n            {},\n            credentials,\n            DriverUtils.buildDriverOptions(credentials),\n        ) // todo: do it better way\n\n        // build connection options for the driver\n        return Object.assign(\n            {},\n            {\n                resourceArn: options.resourceArn,\n                secretArn: options.secretArn,\n                database: options.database,\n                region: options.region,\n                type: options.type,\n            },\n            {\n                host: credentials.host,\n                user: credentials.username,\n                password: credentials.password,\n                database: credentials.database,\n                port: credentials.port,\n                ssl: options.ssl,\n            },\n\n            options.extra || {},\n        )\n    }\n\n    /**\n     * Creates a new connection pool for a given database credentials.\n     */\n    protected async createPool(connectionOptions: any): Promise<any> {\n        return {}\n    }\n\n    /**\n     * Attaches all required base handlers to a database connection, such as the unhandled error handler.\n     */\n    private prepareDbConnection(connection: any): any {\n        const { logger } = this.connection\n        /**\n         * Attaching an error handler to connection errors is essential, as, otherwise, errors raised will go unhandled and\n         * cause the hosting app to crash.\n         */\n        if (connection.listeners(\"error\").length === 0) {\n            connection.on(\"error\", (error: any) =>\n                logger.log(\n                    \"warn\",\n                    `MySQL connection raised an error. ${error}`,\n                ),\n            )\n        }\n        return connection\n    }\n\n    /**\n     * Checks if \"DEFAULT\" values in the column metadata and in the database are equal.\n     */\n    protected compareDefaultValues(\n        columnMetadataValue: string | undefined,\n        databaseValue: string | undefined,\n    ): boolean {\n        if (\n            typeof columnMetadataValue === \"string\" &&\n            typeof databaseValue === \"string\"\n        ) {\n            // we need to cut out \"'\" because in mysql we can understand returned value is a string or a function\n            // as result compare cannot understand if default is really changed or not\n            columnMetadataValue = columnMetadataValue.replace(/^'+|'+$/g, \"\")\n            databaseValue = databaseValue.replace(/^'+|'+$/g, \"\")\n        }\n\n        return columnMetadataValue === databaseValue\n    }\n\n    /**\n     * Escapes a given comment.\n     */\n    protected escapeComment(comment?: string) {\n        if (!comment) return comment\n\n        comment = comment.replace(/\\u0000/g, \"\") // Null bytes aren't allowed in comments\n\n        return comment\n    }\n}\n"]},"metadata":{},"sourceType":"module"}