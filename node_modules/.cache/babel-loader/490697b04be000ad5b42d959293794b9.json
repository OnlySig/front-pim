{"ast":null,"code":"import { ObjectUtils } from \"../util/ObjectUtils\";\n/**\n * Base abstract entity for all entities, used in ActiveRecord patterns.\n */\n\nexport class BaseEntity {\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Checks if entity has an id.\n   * If entity composite compose ids, it will check them all.\n   */\n  hasId() {\n    const baseEntity = this.constructor;\n    return baseEntity.getRepository().hasId(this);\n  }\n  /**\n   * Saves current entity in the database.\n   * If entity does not exist in the database then inserts, otherwise updates.\n   */\n\n\n  save(options) {\n    const baseEntity = this.constructor;\n    return baseEntity.getRepository().save(this, options);\n  }\n  /**\n   * Removes current entity from the database.\n   */\n\n\n  remove(options) {\n    const baseEntity = this.constructor;\n    return baseEntity.getRepository().remove(this, options);\n  }\n  /**\n   * Records the delete date of current entity.\n   */\n\n\n  softRemove(options) {\n    const baseEntity = this.constructor;\n    return baseEntity.getRepository().softRemove(this, options);\n  }\n  /**\n   * Recovers a given entity in the database.\n   */\n\n\n  recover(options) {\n    const baseEntity = this.constructor;\n    return baseEntity.getRepository().recover(this, options);\n  }\n  /**\n   * Reloads entity data from the database.\n   */\n\n\n  async reload() {\n    const baseEntity = this.constructor;\n    const id = baseEntity.getRepository().metadata.getEntityIdMap(this);\n\n    if (!id) {\n      throw new Error(`Entity doesn't have id-s set, cannot reload entity`);\n    }\n\n    const reloadedEntity = await baseEntity.getRepository().findOneByOrFail(id);\n    ObjectUtils.assign(this, reloadedEntity);\n  } // -------------------------------------------------------------------------\n  // Public Static Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Sets DataSource to be used by entity.\n   */\n\n\n  static useDataSource(dataSource) {\n    this.dataSource = dataSource;\n  }\n  /**\n   * Gets current entity's Repository.\n   */\n\n\n  static getRepository() {\n    const dataSource = this.dataSource;\n    if (!dataSource) throw new Error(`DataSource is not set for this entity.`);\n    return dataSource.getRepository(this);\n  }\n  /**\n   * Returns object that is managed by this repository.\n   * If this repository manages entity from schema,\n   * then it returns a name of that schema instead.\n   */\n\n\n  static get target() {\n    return this.getRepository().target;\n  }\n  /**\n   * Checks entity has an id.\n   * If entity composite compose ids, it will check them all.\n   */\n\n\n  static hasId(entity) {\n    return this.getRepository().hasId(entity);\n  }\n  /**\n   * Gets entity mixed id.\n   */\n\n\n  static getId(entity) {\n    return this.getRepository().getId(entity);\n  }\n  /**\n   * Creates a new query builder that can be used to build a SQL query.\n   */\n\n\n  static createQueryBuilder(alias) {\n    return this.getRepository().createQueryBuilder(alias);\n  }\n  /**\n   * Creates a new entity instance and copies all entity properties from this object into a new entity.\n   * Note that it copies only properties that present in entity schema.\n   */\n\n\n  static create(entityOrEntities) {\n    return this.getRepository().create(entityOrEntities);\n  }\n  /**\n   * Merges multiple entities (or entity-like objects) into a given entity.\n   */\n\n\n  static merge(mergeIntoEntity) {\n    for (var _len = arguments.length, entityLikes = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      entityLikes[_key - 1] = arguments[_key];\n    }\n\n    return this.getRepository().merge(mergeIntoEntity, ...entityLikes);\n  }\n  /**\n   * Creates a new entity from the given plain javascript object. If entity already exist in the database, then\n   * it loads it (and everything related to it), replaces all values with the new ones from the given object\n   * and returns this new entity. This new entity is actually a loaded from the db entity with all properties\n   * replaced from the new object.\n   *\n   * Note that given entity-like object must have an entity id / primary key to find entity by.\n   * Returns undefined if entity with given id was not found.\n   */\n\n\n  static preload(entityLike) {\n    const thisRepository = this.getRepository();\n    return thisRepository.preload(entityLike);\n  }\n  /**\n   * Saves one or many given entities.\n   */\n\n\n  static save(entityOrEntities, options) {\n    return this.getRepository().save(entityOrEntities, options);\n  }\n  /**\n   * Removes one or many given entities.\n   */\n\n\n  static remove(entityOrEntities, options) {\n    return this.getRepository().remove(entityOrEntities, options);\n  }\n  /**\n   * Records the delete date of one or many given entities.\n   */\n\n\n  static softRemove(entityOrEntities, options) {\n    return this.getRepository().softRemove(entityOrEntities, options);\n  }\n  /**\n   * Inserts a given entity into the database.\n   * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n   * Executes fast and efficient INSERT query.\n   * Does not check if entity exist in the database, so query will fail if duplicate entity is being inserted.\n   */\n\n\n  static insert(entity) {\n    return this.getRepository().insert(entity);\n  }\n  /**\n   * Updates entity partially. Entity can be found by a given conditions.\n   * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n   * Executes fast and efficient UPDATE query.\n   * Does not check if entity exist in the database.\n   */\n\n\n  static update(criteria, partialEntity) {\n    return this.getRepository().update(criteria, partialEntity);\n  }\n  /**\n   * Inserts a given entity into the database, unless a unique constraint conflicts then updates the entity\n   * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n   * Executes fast and efficient INSERT ... ON CONFLICT DO UPDATE/ON DUPLICATE KEY UPDATE query.\n   */\n\n\n  static upsert(entityOrEntities, conflictPathsOrOptions) {\n    return this.getRepository().upsert(entityOrEntities, conflictPathsOrOptions);\n  }\n  /**\n   * Deletes entities by a given criteria.\n   * Unlike remove method executes a primitive operation without cascades, relations and other operations included.\n   * Executes fast and efficient DELETE query.\n   * Does not check if entity exist in the database.\n   */\n\n\n  static delete(criteria) {\n    return this.getRepository().delete(criteria);\n  }\n  /**\n   * Counts entities that match given options.\n   */\n\n\n  static count(options) {\n    return this.getRepository().count(options);\n  }\n  /**\n   * Counts entities that match given WHERE conditions.\n   */\n\n\n  static countBy(where) {\n    return this.getRepository().countBy(where);\n  }\n  /**\n   * Finds entities that match given options.\n   */\n\n\n  static find(options) {\n    return this.getRepository().find(options);\n  }\n  /**\n   * Finds entities that match given WHERE conditions.\n   */\n\n\n  static findBy(where) {\n    return this.getRepository().findBy(where);\n  }\n  /**\n   * Finds entities that match given find options.\n   * Also counts all entities that match given conditions,\n   * but ignores pagination settings (from and take options).\n   */\n\n\n  static findAndCount(options) {\n    return this.getRepository().findAndCount(options);\n  }\n  /**\n   * Finds entities that match given WHERE conditions.\n   * Also counts all entities that match given conditions,\n   * but ignores pagination settings (from and take options).\n   */\n\n\n  static findAndCountBy(where) {\n    return this.getRepository().findAndCountBy(where);\n  }\n  /**\n   * Finds entities by ids.\n   * Optionally find options can be applied.\n   *\n   * @deprecated use `findBy` method instead in conjunction with `In` operator, for example:\n   *\n   * .findBy({\n   *     id: In([1, 2, 3])\n   * })\n   */\n\n\n  static findByIds(ids) {\n    return this.getRepository().findByIds(ids);\n  }\n  /**\n   * Finds first entity that matches given conditions.\n   */\n\n\n  static findOne(options) {\n    return this.getRepository().findOne(options);\n  }\n  /**\n   * Finds first entity that matches given conditions.\n   */\n\n\n  static findOneBy(where) {\n    return this.getRepository().findOneBy(where);\n  }\n  /**\n   * Finds first entity that matches given options.\n   *\n   * @deprecated use `findOneBy` method instead in conjunction with `In` operator, for example:\n   *\n   * .findOneBy({\n   *     id: 1 // where \"id\" is your primary column name\n   * })\n   */\n\n\n  static findOneById(id) {\n    return this.getRepository().findOneById(id);\n  }\n  /**\n   * Finds first entity that matches given conditions.\n   */\n\n\n  static findOneOrFail(options) {\n    return this.getRepository().findOneOrFail(options);\n  }\n  /**\n   * Finds first entity that matches given conditions.\n   */\n\n\n  static findOneByOrFail(where) {\n    return this.getRepository().findOneByOrFail(where);\n  }\n  /**\n   * Executes a raw SQL query and returns a raw database results.\n   * Raw query execution is supported only by relational databases (MongoDB is not supported).\n   */\n\n\n  static query(query, parameters) {\n    return this.getRepository().query(query, parameters);\n  }\n  /**\n   * Clears all the data from the given table/collection (truncates/drops it).\n   */\n\n\n  static clear() {\n    return this.getRepository().clear();\n  }\n\n}","map":{"version":3,"mappings":"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","names":["ObjectUtils","BaseEntity","hasId","baseEntity","constructor","getRepository","save","options","remove","softRemove","recover","reload","id","metadata","getEntityIdMap","Error","reloadedEntity","findOneByOrFail","assign","useDataSource","dataSource","target","entity","getId","createQueryBuilder","alias","create","entityOrEntities","merge","mergeIntoEntity","entityLikes","preload","entityLike","thisRepository","insert","update","criteria","partialEntity","upsert","conflictPathsOrOptions","delete","count","countBy","where","find","findBy","findAndCount","findAndCountBy","findByIds","ids","findOne","findOneBy","findOneById","findOneOrFail","query","parameters","clear"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\repository\\BaseEntity.ts"],"sourcesContent":["import { Repository } from \"./Repository\"\nimport { FindOptionsWhere } from \"../find-options/FindOptionsWhere\"\nimport { DeepPartial } from \"../common/DeepPartial\"\nimport { SaveOptions } from \"./SaveOptions\"\nimport { FindOneOptions } from \"../find-options/FindOneOptions\"\nimport { RemoveOptions } from \"./RemoveOptions\"\nimport { FindManyOptions } from \"../find-options/FindManyOptions\"\nimport { DataSource } from \"../data-source\"\nimport { SelectQueryBuilder } from \"../query-builder/SelectQueryBuilder\"\nimport { InsertResult } from \"../query-builder/result/InsertResult\"\nimport { UpdateResult } from \"../query-builder/result/UpdateResult\"\nimport { DeleteResult } from \"../query-builder/result/DeleteResult\"\nimport { ObjectID } from \"../driver/mongodb/typings\"\nimport { ObjectUtils } from \"../util/ObjectUtils\"\nimport { QueryDeepPartialEntity } from \"../query-builder/QueryPartialEntity\"\nimport { UpsertOptions } from \"./UpsertOptions\"\nimport { EntityTarget } from \"../common/EntityTarget\"\n\n/**\n * Base abstract entity for all entities, used in ActiveRecord patterns.\n */\nexport class BaseEntity {\n    // -------------------------------------------------------------------------\n    // Private Static Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * DataSource used in all static methods of the BaseEntity.\n     */\n    private static dataSource: DataSource | null\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Checks if entity has an id.\n     * If entity composite compose ids, it will check them all.\n     */\n    hasId(): boolean {\n        const baseEntity = this.constructor as typeof BaseEntity\n        return baseEntity.getRepository().hasId(this)\n    }\n\n    /**\n     * Saves current entity in the database.\n     * If entity does not exist in the database then inserts, otherwise updates.\n     */\n    save(options?: SaveOptions): Promise<this> {\n        const baseEntity = this.constructor as typeof BaseEntity\n        return baseEntity.getRepository().save(this, options)\n    }\n\n    /**\n     * Removes current entity from the database.\n     */\n    remove(options?: RemoveOptions): Promise<this> {\n        const baseEntity = this.constructor as typeof BaseEntity\n        return baseEntity.getRepository().remove(this, options) as Promise<this>\n    }\n\n    /**\n     * Records the delete date of current entity.\n     */\n    softRemove(options?: SaveOptions): Promise<this> {\n        const baseEntity = this.constructor as typeof BaseEntity\n        return baseEntity.getRepository().softRemove(this, options)\n    }\n\n    /**\n     * Recovers a given entity in the database.\n     */\n    recover(options?: SaveOptions): Promise<this> {\n        const baseEntity = this.constructor as typeof BaseEntity\n        return baseEntity.getRepository().recover(this, options)\n    }\n\n    /**\n     * Reloads entity data from the database.\n     */\n    async reload(): Promise<void> {\n        const baseEntity = this.constructor as typeof BaseEntity\n        const id = baseEntity.getRepository().metadata.getEntityIdMap(this)\n        if (!id) {\n            throw new Error(\n                `Entity doesn't have id-s set, cannot reload entity`,\n            )\n        }\n        const reloadedEntity: BaseEntity = await baseEntity\n            .getRepository()\n            .findOneByOrFail(id)\n\n        ObjectUtils.assign(this, reloadedEntity)\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Static Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Sets DataSource to be used by entity.\n     */\n    static useDataSource(dataSource: DataSource | null) {\n        this.dataSource = dataSource\n    }\n\n    /**\n     * Gets current entity's Repository.\n     */\n    static getRepository<T extends BaseEntity>(\n        this: { new (): T } & typeof BaseEntity,\n    ): Repository<T> {\n        const dataSource = (this as typeof BaseEntity).dataSource\n        if (!dataSource)\n            throw new Error(`DataSource is not set for this entity.`)\n        return dataSource.getRepository<T>(this)\n    }\n\n    /**\n     * Returns object that is managed by this repository.\n     * If this repository manages entity from schema,\n     * then it returns a name of that schema instead.\n     */\n    static get target(): EntityTarget<any> {\n        return this.getRepository().target\n    }\n\n    /**\n     * Checks entity has an id.\n     * If entity composite compose ids, it will check them all.\n     */\n    static hasId(entity: BaseEntity): boolean {\n        return this.getRepository().hasId(entity)\n    }\n\n    /**\n     * Gets entity mixed id.\n     */\n    static getId<T extends BaseEntity>(\n        this: { new (): T } & typeof BaseEntity,\n        entity: T,\n    ): any {\n        return this.getRepository<T>().getId(entity)\n    }\n\n    /**\n     * Creates a new query builder that can be used to build a SQL query.\n     */\n    static createQueryBuilder<T extends BaseEntity>(\n        this: { new (): T } & typeof BaseEntity,\n        alias?: string,\n    ): SelectQueryBuilder<T> {\n        return this.getRepository<T>().createQueryBuilder(alias)\n    }\n\n    /**\n     * Creates a new entity instance.\n     */\n    static create<T extends BaseEntity>(\n        this: { new (): T } & typeof BaseEntity,\n    ): T\n\n    /**\n     * Creates a new entities and copies all entity properties from given objects into their new entities.\n     * Note that it copies only properties that present in entity schema.\n     */\n    static create<T extends BaseEntity>(\n        this: { new (): T } & typeof BaseEntity,\n        entityLikeArray: DeepPartial<T>[],\n    ): T[]\n\n    /**\n     * Creates a new entity instance and copies all entity properties from this object into a new entity.\n     * Note that it copies only properties that present in entity schema.\n     */\n    static create<T extends BaseEntity>(\n        this: { new (): T } & typeof BaseEntity,\n        entityLike: DeepPartial<T>,\n    ): T\n\n    /**\n     * Creates a new entity instance and copies all entity properties from this object into a new entity.\n     * Note that it copies only properties that present in entity schema.\n     */\n    static create<T extends BaseEntity>(\n        this: { new (): T } & typeof BaseEntity,\n        entityOrEntities?: any,\n    ) {\n        return this.getRepository<T>().create(entityOrEntities)\n    }\n\n    /**\n     * Merges multiple entities (or entity-like objects) into a given entity.\n     */\n    static merge<T extends BaseEntity>(\n        this: { new (): T } & typeof BaseEntity,\n        mergeIntoEntity: T,\n        ...entityLikes: DeepPartial<T>[]\n    ): T {\n        return this.getRepository<T>().merge(\n            mergeIntoEntity,\n            ...entityLikes,\n        ) as T\n    }\n\n    /**\n     * Creates a new entity from the given plain javascript object. If entity already exist in the database, then\n     * it loads it (and everything related to it), replaces all values with the new ones from the given object\n     * and returns this new entity. This new entity is actually a loaded from the db entity with all properties\n     * replaced from the new object.\n     *\n     * Note that given entity-like object must have an entity id / primary key to find entity by.\n     * Returns undefined if entity with given id was not found.\n     */\n    static preload<T extends BaseEntity>(\n        this: { new (): T } & typeof BaseEntity,\n        entityLike: DeepPartial<T>,\n    ): Promise<T | undefined> {\n        const thisRepository = this.getRepository<T>()\n        return thisRepository.preload(entityLike)\n    }\n\n    /**\n     * Saves all given entities in the database.\n     * If entities do not exist in the database then inserts, otherwise updates.\n     */\n    static save<T extends BaseEntity>(\n        this: { new (): T } & typeof BaseEntity,\n        entities: DeepPartial<T>[],\n        options?: SaveOptions,\n    ): Promise<T[]>\n\n    /**\n     * Saves a given entity in the database.\n     * If entity does not exist in the database then inserts, otherwise updates.\n     */\n    static save<T extends BaseEntity>(\n        this: { new (): T } & typeof BaseEntity,\n        entity: DeepPartial<T>,\n        options?: SaveOptions,\n    ): Promise<T>\n\n    /**\n     * Saves one or many given entities.\n     */\n    static save<T extends BaseEntity>(\n        this: { new (): T } & typeof BaseEntity,\n        entityOrEntities: DeepPartial<T> | DeepPartial<T>[],\n        options?: SaveOptions,\n    ) {\n        return this.getRepository<T>().save(entityOrEntities as any, options)\n    }\n\n    /**\n     * Removes a given entities from the database.\n     */\n    static remove<T extends BaseEntity>(\n        this: { new (): T } & typeof BaseEntity,\n        entities: T[],\n        options?: RemoveOptions,\n    ): Promise<T[]>\n\n    /**\n     * Removes a given entity from the database.\n     */\n    static remove<T extends BaseEntity>(\n        this: { new (): T } & typeof BaseEntity,\n        entity: T,\n        options?: RemoveOptions,\n    ): Promise<T>\n\n    /**\n     * Removes one or many given entities.\n     */\n    static remove<T extends BaseEntity>(\n        this: { new (): T } & typeof BaseEntity,\n        entityOrEntities: T | T[],\n        options?: RemoveOptions,\n    ) {\n        return this.getRepository<T>().remove(entityOrEntities as any, options)\n    }\n\n    /**\n     * Records the delete date of all given entities.\n     */\n    static softRemove<T extends BaseEntity>(\n        this: { new (): T } & typeof BaseEntity,\n        entities: T[],\n        options?: SaveOptions,\n    ): Promise<T[]>\n\n    /**\n     * Records the delete date of a given entity.\n     */\n    static softRemove<T extends BaseEntity>(\n        this: { new (): T } & typeof BaseEntity,\n        entity: T,\n        options?: SaveOptions,\n    ): Promise<T>\n\n    /**\n     * Records the delete date of one or many given entities.\n     */\n    static softRemove<T extends BaseEntity>(\n        this: { new (): T } & typeof BaseEntity,\n        entityOrEntities: T | T[],\n        options?: SaveOptions,\n    ) {\n        return this.getRepository<T>().softRemove(\n            entityOrEntities as any,\n            options,\n        )\n    }\n\n    /**\n     * Inserts a given entity into the database.\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient INSERT query.\n     * Does not check if entity exist in the database, so query will fail if duplicate entity is being inserted.\n     */\n    static insert<T extends BaseEntity>(\n        this: { new (): T } & typeof BaseEntity,\n        entity: QueryDeepPartialEntity<T> | QueryDeepPartialEntity<T>[],\n    ): Promise<InsertResult> {\n        return this.getRepository<T>().insert(entity)\n    }\n\n    /**\n     * Updates entity partially. Entity can be found by a given conditions.\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient UPDATE query.\n     * Does not check if entity exist in the database.\n     */\n    static update<T extends BaseEntity>(\n        this: { new (): T } & typeof BaseEntity,\n        criteria:\n            | string\n            | string[]\n            | number\n            | number[]\n            | Date\n            | Date[]\n            | ObjectID\n            | ObjectID[]\n            | FindOptionsWhere<T>,\n        partialEntity: QueryDeepPartialEntity<T>,\n    ): Promise<UpdateResult> {\n        return this.getRepository<T>().update(criteria, partialEntity)\n    }\n\n    /**\n     * Inserts a given entity into the database, unless a unique constraint conflicts then updates the entity\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient INSERT ... ON CONFLICT DO UPDATE/ON DUPLICATE KEY UPDATE query.\n     */\n    static upsert<T extends BaseEntity>(\n        this: { new (): T } & typeof BaseEntity,\n        entityOrEntities:\n            | QueryDeepPartialEntity<T>\n            | QueryDeepPartialEntity<T>[],\n        conflictPathsOrOptions: string[] | UpsertOptions<T>,\n    ): Promise<InsertResult> {\n        return this.getRepository<T>().upsert(\n            entityOrEntities,\n            conflictPathsOrOptions,\n        )\n    }\n\n    /**\n     * Deletes entities by a given criteria.\n     * Unlike remove method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient DELETE query.\n     * Does not check if entity exist in the database.\n     */\n    static delete<T extends BaseEntity>(\n        this: { new (): T } & typeof BaseEntity,\n        criteria:\n            | string\n            | string[]\n            | number\n            | number[]\n            | Date\n            | Date[]\n            | ObjectID\n            | ObjectID[]\n            | FindOptionsWhere<T>,\n    ): Promise<DeleteResult> {\n        return this.getRepository<T>().delete(criteria)\n    }\n\n    /**\n     * Counts entities that match given options.\n     */\n    static count<T extends BaseEntity>(\n        this: { new (): T } & typeof BaseEntity,\n        options?: FindManyOptions<T>,\n    ): Promise<number> {\n        return this.getRepository<T>().count(options)\n    }\n\n    /**\n     * Counts entities that match given WHERE conditions.\n     */\n    static countBy<T extends BaseEntity>(\n        this: { new (): T } & typeof BaseEntity,\n        where: FindOptionsWhere<T>,\n    ): Promise<number> {\n        return this.getRepository<T>().countBy(where)\n    }\n\n    /**\n     * Finds entities that match given options.\n     */\n    static find<T extends BaseEntity>(\n        this: { new (): T } & typeof BaseEntity,\n        options?: FindManyOptions<T>,\n    ): Promise<T[]> {\n        return this.getRepository<T>().find(options)\n    }\n\n    /**\n     * Finds entities that match given WHERE conditions.\n     */\n    static findBy<T extends BaseEntity>(\n        this: { new (): T } & typeof BaseEntity,\n        where: FindOptionsWhere<T>,\n    ): Promise<T[]> {\n        return this.getRepository<T>().findBy(where)\n    }\n\n    /**\n     * Finds entities that match given find options.\n     * Also counts all entities that match given conditions,\n     * but ignores pagination settings (from and take options).\n     */\n    static findAndCount<T extends BaseEntity>(\n        this: { new (): T } & typeof BaseEntity,\n        options?: FindManyOptions<T>,\n    ): Promise<[T[], number]> {\n        return this.getRepository<T>().findAndCount(options)\n    }\n\n    /**\n     * Finds entities that match given WHERE conditions.\n     * Also counts all entities that match given conditions,\n     * but ignores pagination settings (from and take options).\n     */\n    static findAndCountBy<T extends BaseEntity>(\n        this: { new (): T } & typeof BaseEntity,\n        where: FindOptionsWhere<T>,\n    ): Promise<[T[], number]> {\n        return this.getRepository<T>().findAndCountBy(where)\n    }\n\n    /**\n     * Finds entities by ids.\n     * Optionally find options can be applied.\n     *\n     * @deprecated use `findBy` method instead in conjunction with `In` operator, for example:\n     *\n     * .findBy({\n     *     id: In([1, 2, 3])\n     * })\n     */\n    static findByIds<T extends BaseEntity>(\n        this: { new (): T } & typeof BaseEntity,\n        ids: any[],\n    ): Promise<T[]> {\n        return this.getRepository<T>().findByIds(ids)\n    }\n\n    /**\n     * Finds first entity that matches given conditions.\n     */\n    static findOne<T extends BaseEntity>(\n        this: { new (): T } & typeof BaseEntity,\n        options: FindOneOptions<T>,\n    ): Promise<T | null> {\n        return this.getRepository<T>().findOne(options)\n    }\n\n    /**\n     * Finds first entity that matches given conditions.\n     */\n    static findOneBy<T extends BaseEntity>(\n        this: { new (): T } & typeof BaseEntity,\n        where: FindOptionsWhere<T>,\n    ): Promise<T | null> {\n        return this.getRepository<T>().findOneBy(where)\n    }\n\n    /**\n     * Finds first entity that matches given options.\n     *\n     * @deprecated use `findOneBy` method instead in conjunction with `In` operator, for example:\n     *\n     * .findOneBy({\n     *     id: 1 // where \"id\" is your primary column name\n     * })\n     */\n    static findOneById<T extends BaseEntity>(\n        this: { new (): T } & typeof BaseEntity,\n        id: string | number | Date | ObjectID,\n    ): Promise<T | null> {\n        return this.getRepository<T>().findOneById(id)\n    }\n\n    /**\n     * Finds first entity that matches given conditions.\n     */\n    static findOneOrFail<T extends BaseEntity>(\n        this: { new (): T } & typeof BaseEntity,\n        options: FindOneOptions<T>,\n    ): Promise<T> {\n        return this.getRepository<T>().findOneOrFail(options)\n    }\n\n    /**\n     * Finds first entity that matches given conditions.\n     */\n    static findOneByOrFail<T extends BaseEntity>(\n        this: { new (): T } & typeof BaseEntity,\n        where: FindOptionsWhere<T>,\n    ): Promise<T> {\n        return this.getRepository<T>().findOneByOrFail(where)\n    }\n\n    /**\n     * Executes a raw SQL query and returns a raw database results.\n     * Raw query execution is supported only by relational databases (MongoDB is not supported).\n     */\n    static query<T extends BaseEntity>(\n        this: { new (): T } & typeof BaseEntity,\n        query: string,\n        parameters?: any[],\n    ): Promise<any> {\n        return this.getRepository<T>().query(query, parameters)\n    }\n\n    /**\n     * Clears all the data from the given table/collection (truncates/drops it).\n     */\n    static clear<T extends BaseEntity>(\n        this: { new (): T } & typeof BaseEntity,\n    ): Promise<void> {\n        return this.getRepository<T>().clear()\n    }\n}\n"]},"metadata":{},"sourceType":"module"}