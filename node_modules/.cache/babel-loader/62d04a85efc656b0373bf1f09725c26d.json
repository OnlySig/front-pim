{"ast":null,"code":"import { QueryBuilder } from \"./QueryBuilder\";\nimport { UpdateResult } from \"./result/UpdateResult\";\nimport { ReturningStatementNotSupportedError } from \"../error/ReturningStatementNotSupportedError\";\nimport { ReturningResultsEntityUpdator } from \"./ReturningResultsEntityUpdator\";\nimport { LimitOnUpdateNotSupportedError } from \"../error/LimitOnUpdateNotSupportedError\";\nimport { UpdateValuesMissingError } from \"../error/UpdateValuesMissingError\";\nimport { TypeORMError } from \"../error\";\nimport { EntityPropertyNotFoundError } from \"../error/EntityPropertyNotFoundError\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n */\n\nexport class UpdateQueryBuilder extends QueryBuilder {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connectionOrQueryBuilder, queryRunner) {\n    super(connectionOrQueryBuilder, queryRunner);\n    this[\"@instanceof\"] = Symbol.for(\"UpdateQueryBuilder\");\n    this.expressionMap.aliasNamePrefixingEnabled = false;\n  } // -------------------------------------------------------------------------\n  // Public Implemented Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Gets generated SQL query without parameters being replaced.\n   */\n\n\n  getQuery() {\n    let sql = this.createComment();\n    sql += this.createCteExpression();\n    sql += this.createUpdateExpression();\n    sql += this.createOrderByExpression();\n    sql += this.createLimitExpression();\n    return sql.trim();\n  }\n  /**\n   * Executes sql generated by query builder and returns raw database results.\n   */\n\n\n  async execute() {\n    const queryRunner = this.obtainQueryRunner();\n    let transactionStartedByUs = false;\n\n    try {\n      // start transaction if it was enabled\n      if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {\n        await queryRunner.startTransaction();\n        transactionStartedByUs = true;\n      } // call before updation methods in listeners and subscribers\n\n\n      if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata) {\n        await queryRunner.broadcaster.broadcast(\"BeforeUpdate\", this.expressionMap.mainAlias.metadata, this.expressionMap.valuesSet);\n      }\n\n      let declareSql = null;\n      let selectOutputSql = null; // if update entity mode is enabled we may need extra columns for the returning statement\n\n      const returningResultsEntityUpdator = new ReturningResultsEntityUpdator(queryRunner, this.expressionMap);\n      const returningColumns = [];\n\n      if (Array.isArray(this.expressionMap.returning) && this.expressionMap.mainAlias.hasMetadata) {\n        for (const columnPath of this.expressionMap.returning) {\n          returningColumns.push(...this.expressionMap.mainAlias.metadata.findColumnsWithPropertyPath(columnPath));\n        }\n      }\n\n      if (this.expressionMap.updateEntity === true && this.expressionMap.mainAlias.hasMetadata && this.expressionMap.whereEntities.length > 0) {\n        this.expressionMap.extraReturningColumns = returningResultsEntityUpdator.getUpdationReturningColumns();\n        returningColumns.push(...this.expressionMap.extraReturningColumns.filter(c => !returningColumns.includes(c)));\n      }\n\n      if (returningColumns.length > 0 && this.connection.driver.options.type === \"mssql\") {\n        declareSql = this.connection.driver.buildTableVariableDeclaration(\"@OutputTable\", returningColumns);\n        selectOutputSql = `SELECT * FROM @OutputTable`;\n      } // execute update query\n\n\n      const [updateSql, parameters] = this.getQueryAndParameters();\n      const statements = [declareSql, updateSql, selectOutputSql];\n      const queryResult = await queryRunner.query(statements.filter(sql => sql != null).join(\";\\n\\n\"), parameters, true);\n      const updateResult = UpdateResult.from(queryResult); // if we are updating entities and entity updation is enabled we must update some of entity columns (like version, update date, etc.)\n\n      if (this.expressionMap.updateEntity === true && this.expressionMap.mainAlias.hasMetadata && this.expressionMap.whereEntities.length > 0) {\n        await returningResultsEntityUpdator.update(updateResult, this.expressionMap.whereEntities);\n      } // call after updation methods in listeners and subscribers\n\n\n      if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata) {\n        await queryRunner.broadcaster.broadcast(\"AfterUpdate\", this.expressionMap.mainAlias.metadata, this.expressionMap.valuesSet);\n      } // close transaction if we started it\n\n\n      if (transactionStartedByUs) await queryRunner.commitTransaction();\n      return updateResult;\n    } catch (error) {\n      // rollback transaction if we started it\n      if (transactionStartedByUs) {\n        try {\n          await queryRunner.rollbackTransaction();\n        } catch (rollbackError) {}\n      }\n\n      throw error;\n    } finally {\n      if (queryRunner !== this.queryRunner) {\n        // means we created our own query runner\n        await queryRunner.release();\n      }\n    }\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Values needs to be updated.\n   */\n\n\n  set(values) {\n    this.expressionMap.valuesSet = values;\n    return this;\n  }\n  /**\n   * Sets WHERE condition in the query builder.\n   * If you had previously WHERE expression defined,\n   * calling this function will override previously set WHERE conditions.\n   * Additionally you can add parameters used in where expression.\n   */\n\n\n  where(where, parameters) {\n    this.expressionMap.wheres = []; // don't move this block below since computeWhereParameter can add where expressions\n\n    const condition = this.getWhereCondition(where);\n    if (condition) this.expressionMap.wheres = [{\n      type: \"simple\",\n      condition: condition\n    }];\n    if (parameters) this.setParameters(parameters);\n    return this;\n  }\n  /**\n   * Adds new AND WHERE condition in the query builder.\n   * Additionally you can add parameters used in where expression.\n   */\n\n\n  andWhere(where, parameters) {\n    this.expressionMap.wheres.push({\n      type: \"and\",\n      condition: this.getWhereCondition(where)\n    });\n    if (parameters) this.setParameters(parameters);\n    return this;\n  }\n  /**\n   * Adds new OR WHERE condition in the query builder.\n   * Additionally you can add parameters used in where expression.\n   */\n\n\n  orWhere(where, parameters) {\n    this.expressionMap.wheres.push({\n      type: \"or\",\n      condition: this.getWhereCondition(where)\n    });\n    if (parameters) this.setParameters(parameters);\n    return this;\n  }\n  /**\n   * Sets WHERE condition in the query builder with a condition for the given ids.\n   * If you had previously WHERE expression defined,\n   * calling this function will override previously set WHERE conditions.\n   */\n\n\n  whereInIds(ids) {\n    return this.where(this.getWhereInIdsCondition(ids));\n  }\n  /**\n   * Adds new AND WHERE with conditions for the given ids.\n   */\n\n\n  andWhereInIds(ids) {\n    return this.andWhere(this.getWhereInIdsCondition(ids));\n  }\n  /**\n   * Adds new OR WHERE with conditions for the given ids.\n   */\n\n\n  orWhereInIds(ids) {\n    return this.orWhere(this.getWhereInIdsCondition(ids));\n  }\n  /**\n   * Optional returning/output clause.\n   */\n\n\n  output(output) {\n    return this.returning(output);\n  }\n  /**\n   * Optional returning/output clause.\n   */\n\n\n  returning(returning) {\n    // not all databases support returning/output cause\n    if (!this.connection.driver.isReturningSqlSupported(\"update\")) {\n      throw new ReturningStatementNotSupportedError();\n    }\n\n    this.expressionMap.returning = returning;\n    return this;\n  }\n  /**\n   * Sets ORDER BY condition in the query builder.\n   * If you had previously ORDER BY expression defined,\n   * calling this function will override previously set ORDER BY conditions.\n   */\n\n\n  orderBy(sort) {\n    let order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"ASC\";\n    let nulls = arguments.length > 2 ? arguments[2] : undefined;\n\n    if (sort) {\n      if (typeof sort === \"object\") {\n        this.expressionMap.orderBys = sort;\n      } else {\n        if (nulls) {\n          this.expressionMap.orderBys = {\n            [sort]: {\n              order,\n              nulls\n            }\n          };\n        } else {\n          this.expressionMap.orderBys = {\n            [sort]: order\n          };\n        }\n      }\n    } else {\n      this.expressionMap.orderBys = {};\n    }\n\n    return this;\n  }\n  /**\n   * Adds ORDER BY condition in the query builder.\n   */\n\n\n  addOrderBy(sort) {\n    let order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"ASC\";\n    let nulls = arguments.length > 2 ? arguments[2] : undefined;\n\n    if (nulls) {\n      this.expressionMap.orderBys[sort] = {\n        order,\n        nulls\n      };\n    } else {\n      this.expressionMap.orderBys[sort] = order;\n    }\n\n    return this;\n  }\n  /**\n   * Sets LIMIT - maximum number of rows to be selected.\n   */\n\n\n  limit(limit) {\n    this.expressionMap.limit = limit;\n    return this;\n  }\n  /**\n   * Indicates if entity must be updated after update operation.\n   * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).\n   * Enabled by default.\n   */\n\n\n  whereEntity(entity) {\n    if (!this.expressionMap.mainAlias.hasMetadata) throw new TypeORMError(`.whereEntity method can only be used on queries which update real entity table.`);\n    this.expressionMap.wheres = [];\n    const entities = Array.isArray(entity) ? entity : [entity];\n    entities.forEach(entity => {\n      const entityIdMap = this.expressionMap.mainAlias.metadata.getEntityIdMap(entity);\n      if (!entityIdMap) throw new TypeORMError(`Provided entity does not have ids set, cannot perform operation.`);\n      this.orWhereInIds(entityIdMap);\n    });\n    this.expressionMap.whereEntities = entities;\n    return this;\n  }\n  /**\n   * Indicates if entity must be updated after update operation.\n   * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).\n   * Enabled by default.\n   */\n\n\n  updateEntity(enabled) {\n    this.expressionMap.updateEntity = enabled;\n    return this;\n  } // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Creates UPDATE express used to perform insert query.\n   */\n\n\n  createUpdateExpression() {\n    const valuesSet = this.getValueSet();\n    const metadata = this.expressionMap.mainAlias.hasMetadata ? this.expressionMap.mainAlias.metadata : undefined; // it doesn't make sense to update undefined properties, so just skip them\n\n    const valuesSetNormalized = {};\n\n    for (let key in valuesSet) {\n      if (valuesSet[key] !== undefined) {\n        valuesSetNormalized[key] = valuesSet[key];\n      }\n    } // prepare columns and values to be updated\n\n\n    const updateColumnAndValues = [];\n    const updatedColumns = [];\n\n    if (metadata) {\n      this.createPropertyPath(metadata, valuesSetNormalized).forEach(propertyPath => {\n        // todo: make this and other query builder to work with properly with tables without metadata\n        const columns = metadata.findColumnsWithPropertyPath(propertyPath);\n\n        if (columns.length <= 0) {\n          throw new EntityPropertyNotFoundError(propertyPath, metadata);\n        }\n\n        columns.forEach(column => {\n          if (!column.isUpdate || updatedColumns.includes(column)) {\n            return;\n          }\n\n          updatedColumns.push(column); //\n\n          let value = column.getEntityValue(valuesSetNormalized);\n\n          if (column.referencedColumn && typeof value === \"object\" && !(value instanceof Date) && value !== null && !Buffer.isBuffer(value)) {\n            value = column.referencedColumn.getEntityValue(value);\n          } else if (!(typeof value === \"function\")) {\n            value = this.connection.driver.preparePersistentValue(value, column);\n          } // todo: duplication zone\n\n\n          if (typeof value === \"function\") {\n            // support for SQL expressions in update query\n            updateColumnAndValues.push(this.escape(column.databaseName) + \" = \" + value());\n          } else if ((this.connection.driver.options.type === \"sap\" || this.connection.driver.options.type === \"spanner\") && value === null) {\n            updateColumnAndValues.push(this.escape(column.databaseName) + \" = NULL\");\n          } else {\n            if (this.connection.driver.options.type === \"mssql\") {\n              value = this.connection.driver.parametrizeValue(column, value);\n            }\n\n            const paramName = this.createParameter(value);\n            let expression = null;\n\n            if ((DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === \"aurora-mysql\") && this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {\n              const useLegacy = this.connection.driver.options.legacySpatialSupport;\n              const geomFromText = useLegacy ? \"GeomFromText\" : \"ST_GeomFromText\";\n\n              if (column.srid != null) {\n                expression = `${geomFromText}(${paramName}, ${column.srid})`;\n              } else {\n                expression = `${geomFromText}(${paramName})`;\n              }\n            } else if (this.connection.driver.options.type === \"postgres\" && this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {\n              if (column.srid != null) {\n                expression = `ST_SetSRID(ST_GeomFromGeoJSON(${paramName}), ${column.srid})::${column.type}`;\n              } else {\n                expression = `ST_GeomFromGeoJSON(${paramName})::${column.type}`;\n              }\n            } else if (this.connection.driver.options.type === \"mssql\" && this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {\n              expression = column.type + \"::STGeomFromText(\" + paramName + \", \" + (column.srid || \"0\") + \")\";\n            } else {\n              expression = paramName;\n            }\n\n            updateColumnAndValues.push(this.escape(column.databaseName) + \" = \" + expression);\n          }\n        });\n      }); // Don't allow calling update only with columns that are `update: false`\n\n      if (updateColumnAndValues.length > 0 || Object.keys(valuesSetNormalized).length === 0) {\n        if (metadata.versionColumn && updatedColumns.indexOf(metadata.versionColumn) === -1) updateColumnAndValues.push(this.escape(metadata.versionColumn.databaseName) + \" = \" + this.escape(metadata.versionColumn.databaseName) + \" + 1\");\n        if (metadata.updateDateColumn && updatedColumns.indexOf(metadata.updateDateColumn) === -1) updateColumnAndValues.push(this.escape(metadata.updateDateColumn.databaseName) + \" = CURRENT_TIMESTAMP\"); // todo: fix issue with CURRENT_TIMESTAMP(6) being used, can \"DEFAULT\" be used?!\n      }\n    } else {\n      Object.keys(valuesSetNormalized).map(key => {\n        let value = valuesSetNormalized[key]; // todo: duplication zone\n\n        if (typeof value === \"function\") {\n          // support for SQL expressions in update query\n          updateColumnAndValues.push(this.escape(key) + \" = \" + value());\n        } else if ((this.connection.driver.options.type === \"sap\" || this.connection.driver.options.type === \"spanner\") && value === null) {\n          updateColumnAndValues.push(this.escape(key) + \" = NULL\");\n        } else {\n          // we need to store array values in a special class to make sure parameter replacement will work correctly\n          // if (value instanceof Array)\n          //     value = new ArrayParameter(value);\n          const paramName = this.createParameter(value);\n          updateColumnAndValues.push(this.escape(key) + \" = \" + paramName);\n        }\n      });\n    }\n\n    if (updateColumnAndValues.length <= 0) {\n      throw new UpdateValuesMissingError();\n    } // get a table name and all column database names\n\n\n    const whereExpression = this.createWhereExpression();\n    const returningExpression = this.createReturningExpression(\"update\");\n\n    if (returningExpression === \"\") {\n      return `UPDATE ${this.getTableName(this.getMainTableName())} SET ${updateColumnAndValues.join(\", \")}${whereExpression}`; // todo: how do we replace aliases in where to nothing?\n    }\n\n    if (this.connection.driver.options.type === \"mssql\") {\n      return `UPDATE ${this.getTableName(this.getMainTableName())} SET ${updateColumnAndValues.join(\", \")} OUTPUT ${returningExpression}${whereExpression}`;\n    }\n\n    return `UPDATE ${this.getTableName(this.getMainTableName())} SET ${updateColumnAndValues.join(\", \")}${whereExpression} RETURNING ${returningExpression}`;\n  }\n  /**\n   * Creates \"ORDER BY\" part of SQL query.\n   */\n\n\n  createOrderByExpression() {\n    const orderBys = this.expressionMap.orderBys;\n    if (Object.keys(orderBys).length > 0) return \" ORDER BY \" + Object.keys(orderBys).map(columnName => {\n      if (typeof orderBys[columnName] === \"string\") {\n        return this.replacePropertyNames(columnName) + \" \" + orderBys[columnName];\n      } else {\n        return this.replacePropertyNames(columnName) + \" \" + orderBys[columnName].order + \" \" + orderBys[columnName].nulls;\n      }\n    }).join(\", \");\n    return \"\";\n  }\n  /**\n   * Creates \"LIMIT\" parts of SQL query.\n   */\n\n\n  createLimitExpression() {\n    let limit = this.expressionMap.limit;\n\n    if (limit) {\n      if (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === \"aurora-mysql\") {\n        return \" LIMIT \" + limit;\n      } else {\n        throw new LimitOnUpdateNotSupportedError();\n      }\n    }\n\n    return \"\";\n  }\n  /**\n   * Gets array of values need to be inserted into the target table.\n   */\n\n\n  getValueSet() {\n    if (typeof this.expressionMap.valuesSet === \"object\") return this.expressionMap.valuesSet;\n    throw new UpdateValuesMissingError();\n  }\n\n}","map":{"version":3,"mappings":"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","names":["QueryBuilder","UpdateResult","ReturningStatementNotSupportedError","ReturningResultsEntityUpdator","LimitOnUpdateNotSupportedError","UpdateValuesMissingError","TypeORMError","EntityPropertyNotFoundError","DriverUtils","UpdateQueryBuilder","constructor","connectionOrQueryBuilder","queryRunner","Symbol","for","expressionMap","aliasNamePrefixingEnabled","getQuery","sql","createComment","createCteExpression","createUpdateExpression","createOrderByExpression","createLimitExpression","trim","execute","obtainQueryRunner","transactionStartedByUs","useTransaction","isTransactionActive","startTransaction","callListeners","mainAlias","hasMetadata","broadcaster","broadcast","metadata","valuesSet","declareSql","selectOutputSql","returningResultsEntityUpdator","returningColumns","Array","isArray","returning","columnPath","push","findColumnsWithPropertyPath","updateEntity","whereEntities","length","extraReturningColumns","getUpdationReturningColumns","filter","c","includes","connection","driver","options","type","buildTableVariableDeclaration","updateSql","parameters","getQueryAndParameters","statements","queryResult","query","join","updateResult","from","update","commitTransaction","error","rollbackTransaction","rollbackError","release","set","values","where","wheres","condition","getWhereCondition","setParameters","andWhere","orWhere","whereInIds","ids","getWhereInIdsCondition","andWhereInIds","orWhereInIds","output","isReturningSqlSupported","orderBy","sort","order","nulls","orderBys","addOrderBy","limit","whereEntity","entity","entities","forEach","entityIdMap","getEntityIdMap","enabled","getValueSet","undefined","valuesSetNormalized","key","updateColumnAndValues","updatedColumns","createPropertyPath","propertyPath","columns","column","isUpdate","value","getEntityValue","referencedColumn","Date","Buffer","isBuffer","preparePersistentValue","escape","databaseName","parametrizeValue","paramName","createParameter","expression","isMySQLFamily","spatialTypes","indexOf","useLegacy","legacySpatialSupport","geomFromText","srid","Object","keys","versionColumn","updateDateColumn","map","whereExpression","createWhereExpression","returningExpression","createReturningExpression","getTableName","getMainTableName","columnName","replacePropertyNames"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\query-builder\\UpdateQueryBuilder.ts"],"sourcesContent":["import { ColumnMetadata } from \"../metadata/ColumnMetadata\"\nimport { QueryBuilder } from \"./QueryBuilder\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\nimport { WhereExpressionBuilder } from \"./WhereExpressionBuilder\"\nimport { Brackets } from \"./Brackets\"\nimport { UpdateResult } from \"./result/UpdateResult\"\nimport { ReturningStatementNotSupportedError } from \"../error/ReturningStatementNotSupportedError\"\nimport { ReturningResultsEntityUpdator } from \"./ReturningResultsEntityUpdator\"\nimport { MysqlDriver } from \"../driver/mysql/MysqlDriver\"\nimport { OrderByCondition } from \"../find-options/OrderByCondition\"\nimport { LimitOnUpdateNotSupportedError } from \"../error/LimitOnUpdateNotSupportedError\"\nimport { UpdateValuesMissingError } from \"../error/UpdateValuesMissingError\"\nimport { QueryDeepPartialEntity } from \"./QueryPartialEntity\"\nimport { AuroraMysqlDriver } from \"../driver/aurora-mysql/AuroraMysqlDriver\"\nimport { TypeORMError } from \"../error\"\nimport { EntityPropertyNotFoundError } from \"../error/EntityPropertyNotFoundError\"\nimport { SqlServerDriver } from \"../driver/sqlserver/SqlServerDriver\"\nimport { DriverUtils } from \"../driver/DriverUtils\"\n\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n */\nexport class UpdateQueryBuilder<Entity extends ObjectLiteral>\n    extends QueryBuilder<Entity>\n    implements WhereExpressionBuilder\n{\n    readonly \"@instanceof\" = Symbol.for(\"UpdateQueryBuilder\")\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        connectionOrQueryBuilder: DataSource | QueryBuilder<any>,\n        queryRunner?: QueryRunner,\n    ) {\n        super(connectionOrQueryBuilder as any, queryRunner)\n        this.expressionMap.aliasNamePrefixingEnabled = false\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Implemented Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets generated SQL query without parameters being replaced.\n     */\n    getQuery(): string {\n        let sql = this.createComment()\n        sql += this.createCteExpression()\n        sql += this.createUpdateExpression()\n        sql += this.createOrderByExpression()\n        sql += this.createLimitExpression()\n        return sql.trim()\n    }\n\n    /**\n     * Executes sql generated by query builder and returns raw database results.\n     */\n    async execute(): Promise<UpdateResult> {\n        const queryRunner = this.obtainQueryRunner()\n        let transactionStartedByUs: boolean = false\n\n        try {\n            // start transaction if it was enabled\n            if (\n                this.expressionMap.useTransaction === true &&\n                queryRunner.isTransactionActive === false\n            ) {\n                await queryRunner.startTransaction()\n                transactionStartedByUs = true\n            }\n\n            // call before updation methods in listeners and subscribers\n            if (\n                this.expressionMap.callListeners === true &&\n                this.expressionMap.mainAlias!.hasMetadata\n            ) {\n                await queryRunner.broadcaster.broadcast(\n                    \"BeforeUpdate\",\n                    this.expressionMap.mainAlias!.metadata,\n                    this.expressionMap.valuesSet,\n                )\n            }\n\n            let declareSql: string | null = null\n            let selectOutputSql: string | null = null\n\n            // if update entity mode is enabled we may need extra columns for the returning statement\n            const returningResultsEntityUpdator =\n                new ReturningResultsEntityUpdator(\n                    queryRunner,\n                    this.expressionMap,\n                )\n\n            const returningColumns: ColumnMetadata[] = []\n\n            if (\n                Array.isArray(this.expressionMap.returning) &&\n                this.expressionMap.mainAlias!.hasMetadata\n            ) {\n                for (const columnPath of this.expressionMap.returning) {\n                    returningColumns.push(\n                        ...this.expressionMap.mainAlias!.metadata.findColumnsWithPropertyPath(\n                            columnPath,\n                        ),\n                    )\n                }\n            }\n\n            if (\n                this.expressionMap.updateEntity === true &&\n                this.expressionMap.mainAlias!.hasMetadata &&\n                this.expressionMap.whereEntities.length > 0\n            ) {\n                this.expressionMap.extraReturningColumns =\n                    returningResultsEntityUpdator.getUpdationReturningColumns()\n\n                returningColumns.push(\n                    ...this.expressionMap.extraReturningColumns.filter(\n                        (c) => !returningColumns.includes(c),\n                    ),\n                )\n            }\n\n            if (\n                returningColumns.length > 0 &&\n                this.connection.driver.options.type === \"mssql\"\n            ) {\n                declareSql = (\n                    this.connection.driver as SqlServerDriver\n                ).buildTableVariableDeclaration(\n                    \"@OutputTable\",\n                    returningColumns,\n                )\n                selectOutputSql = `SELECT * FROM @OutputTable`\n            }\n\n            // execute update query\n            const [updateSql, parameters] = this.getQueryAndParameters()\n\n            const statements = [declareSql, updateSql, selectOutputSql]\n            const queryResult = await queryRunner.query(\n                statements.filter((sql) => sql != null).join(\";\\n\\n\"),\n                parameters,\n                true,\n            )\n            const updateResult = UpdateResult.from(queryResult)\n\n            // if we are updating entities and entity updation is enabled we must update some of entity columns (like version, update date, etc.)\n            if (\n                this.expressionMap.updateEntity === true &&\n                this.expressionMap.mainAlias!.hasMetadata &&\n                this.expressionMap.whereEntities.length > 0\n            ) {\n                await returningResultsEntityUpdator.update(\n                    updateResult,\n                    this.expressionMap.whereEntities,\n                )\n            }\n\n            // call after updation methods in listeners and subscribers\n            if (\n                this.expressionMap.callListeners === true &&\n                this.expressionMap.mainAlias!.hasMetadata\n            ) {\n                await queryRunner.broadcaster.broadcast(\n                    \"AfterUpdate\",\n                    this.expressionMap.mainAlias!.metadata,\n                    this.expressionMap.valuesSet,\n                )\n            }\n\n            // close transaction if we started it\n            if (transactionStartedByUs) await queryRunner.commitTransaction()\n\n            return updateResult\n        } catch (error) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction()\n                } catch (rollbackError) {}\n            }\n            throw error\n        } finally {\n            if (queryRunner !== this.queryRunner) {\n                // means we created our own query runner\n                await queryRunner.release()\n            }\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Values needs to be updated.\n     */\n    set(values: QueryDeepPartialEntity<Entity>): this {\n        this.expressionMap.valuesSet = values\n        return this\n    }\n\n    /**\n     * Sets WHERE condition in the query builder.\n     * If you had previously WHERE expression defined,\n     * calling this function will override previously set WHERE conditions.\n     * Additionally you can add parameters used in where expression.\n     */\n    where(\n        where:\n            | string\n            | ((qb: this) => string)\n            | Brackets\n            | ObjectLiteral\n            | ObjectLiteral[],\n        parameters?: ObjectLiteral,\n    ): this {\n        this.expressionMap.wheres = [] // don't move this block below since computeWhereParameter can add where expressions\n        const condition = this.getWhereCondition(where)\n        if (condition)\n            this.expressionMap.wheres = [\n                { type: \"simple\", condition: condition },\n            ]\n        if (parameters) this.setParameters(parameters)\n        return this\n    }\n\n    /**\n     * Adds new AND WHERE condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    andWhere(\n        where:\n            | string\n            | ((qb: this) => string)\n            | Brackets\n            | ObjectLiteral\n            | ObjectLiteral[],\n        parameters?: ObjectLiteral,\n    ): this {\n        this.expressionMap.wheres.push({\n            type: \"and\",\n            condition: this.getWhereCondition(where),\n        })\n        if (parameters) this.setParameters(parameters)\n        return this\n    }\n\n    /**\n     * Adds new OR WHERE condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    orWhere(\n        where:\n            | string\n            | ((qb: this) => string)\n            | Brackets\n            | ObjectLiteral\n            | ObjectLiteral[],\n        parameters?: ObjectLiteral,\n    ): this {\n        this.expressionMap.wheres.push({\n            type: \"or\",\n            condition: this.getWhereCondition(where),\n        })\n        if (parameters) this.setParameters(parameters)\n        return this\n    }\n\n    /**\n     * Sets WHERE condition in the query builder with a condition for the given ids.\n     * If you had previously WHERE expression defined,\n     * calling this function will override previously set WHERE conditions.\n     */\n    whereInIds(ids: any | any[]): this {\n        return this.where(this.getWhereInIdsCondition(ids))\n    }\n\n    /**\n     * Adds new AND WHERE with conditions for the given ids.\n     */\n    andWhereInIds(ids: any | any[]): this {\n        return this.andWhere(this.getWhereInIdsCondition(ids))\n    }\n\n    /**\n     * Adds new OR WHERE with conditions for the given ids.\n     */\n    orWhereInIds(ids: any | any[]): this {\n        return this.orWhere(this.getWhereInIdsCondition(ids))\n    }\n    /**\n     * Optional returning/output clause.\n     * This will return given column values.\n     */\n    output(columns: string[]): this\n\n    /**\n     * Optional returning/output clause.\n     * Returning is a SQL string containing returning statement.\n     */\n    output(output: string): this\n\n    /**\n     * Optional returning/output clause.\n     */\n    output(output: string | string[]): this\n\n    /**\n     * Optional returning/output clause.\n     */\n    output(output: string | string[]): this {\n        return this.returning(output)\n    }\n\n    /**\n     * Optional returning/output clause.\n     * This will return given column values.\n     */\n    returning(columns: string[]): this\n\n    /**\n     * Optional returning/output clause.\n     * Returning is a SQL string containing returning statement.\n     */\n    returning(returning: string): this\n\n    /**\n     * Optional returning/output clause.\n     */\n    returning(returning: string | string[]): this\n\n    /**\n     * Optional returning/output clause.\n     */\n    returning(returning: string | string[]): this {\n        // not all databases support returning/output cause\n        if (!this.connection.driver.isReturningSqlSupported(\"update\")) {\n            throw new ReturningStatementNotSupportedError()\n        }\n\n        this.expressionMap.returning = returning\n        return this\n    }\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     *\n     * Calling order by without order set will remove all previously set order bys.\n     */\n    orderBy(): this\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(\n        sort: string,\n        order?: \"ASC\" | \"DESC\",\n        nulls?: \"NULLS FIRST\" | \"NULLS LAST\",\n    ): this\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(order: OrderByCondition): this\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(\n        sort?: string | OrderByCondition,\n        order: \"ASC\" | \"DESC\" = \"ASC\",\n        nulls?: \"NULLS FIRST\" | \"NULLS LAST\",\n    ): this {\n        if (sort) {\n            if (typeof sort === \"object\") {\n                this.expressionMap.orderBys = sort as OrderByCondition\n            } else {\n                if (nulls) {\n                    this.expressionMap.orderBys = {\n                        [sort as string]: { order, nulls },\n                    }\n                } else {\n                    this.expressionMap.orderBys = { [sort as string]: order }\n                }\n            }\n        } else {\n            this.expressionMap.orderBys = {}\n        }\n        return this\n    }\n\n    /**\n     * Adds ORDER BY condition in the query builder.\n     */\n    addOrderBy(\n        sort: string,\n        order: \"ASC\" | \"DESC\" = \"ASC\",\n        nulls?: \"NULLS FIRST\" | \"NULLS LAST\",\n    ): this {\n        if (nulls) {\n            this.expressionMap.orderBys[sort] = { order, nulls }\n        } else {\n            this.expressionMap.orderBys[sort] = order\n        }\n        return this\n    }\n\n    /**\n     * Sets LIMIT - maximum number of rows to be selected.\n     */\n    limit(limit?: number): this {\n        this.expressionMap.limit = limit\n        return this\n    }\n\n    /**\n     * Indicates if entity must be updated after update operation.\n     * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).\n     * Enabled by default.\n     */\n    whereEntity(entity: Entity | Entity[]): this {\n        if (!this.expressionMap.mainAlias!.hasMetadata)\n            throw new TypeORMError(\n                `.whereEntity method can only be used on queries which update real entity table.`,\n            )\n\n        this.expressionMap.wheres = []\n        const entities: Entity[] = Array.isArray(entity) ? entity : [entity]\n        entities.forEach((entity) => {\n            const entityIdMap =\n                this.expressionMap.mainAlias!.metadata.getEntityIdMap(entity)\n            if (!entityIdMap)\n                throw new TypeORMError(\n                    `Provided entity does not have ids set, cannot perform operation.`,\n                )\n\n            this.orWhereInIds(entityIdMap)\n        })\n\n        this.expressionMap.whereEntities = entities\n        return this\n    }\n\n    /**\n     * Indicates if entity must be updated after update operation.\n     * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).\n     * Enabled by default.\n     */\n    updateEntity(enabled: boolean): this {\n        this.expressionMap.updateEntity = enabled\n        return this\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates UPDATE express used to perform insert query.\n     */\n    protected createUpdateExpression() {\n        const valuesSet = this.getValueSet()\n        const metadata = this.expressionMap.mainAlias!.hasMetadata\n            ? this.expressionMap.mainAlias!.metadata\n            : undefined\n\n        // it doesn't make sense to update undefined properties, so just skip them\n        const valuesSetNormalized: ObjectLiteral = {}\n        for (let key in valuesSet) {\n            if (valuesSet[key] !== undefined) {\n                valuesSetNormalized[key] = valuesSet[key]\n            }\n        }\n\n        // prepare columns and values to be updated\n        const updateColumnAndValues: string[] = []\n        const updatedColumns: ColumnMetadata[] = []\n        if (metadata) {\n            this.createPropertyPath(metadata, valuesSetNormalized).forEach(\n                (propertyPath) => {\n                    // todo: make this and other query builder to work with properly with tables without metadata\n                    const columns =\n                        metadata.findColumnsWithPropertyPath(propertyPath)\n\n                    if (columns.length <= 0) {\n                        throw new EntityPropertyNotFoundError(\n                            propertyPath,\n                            metadata,\n                        )\n                    }\n\n                    columns.forEach((column) => {\n                        if (\n                            !column.isUpdate ||\n                            updatedColumns.includes(column)\n                        ) {\n                            return\n                        }\n\n                        updatedColumns.push(column)\n\n                        //\n                        let value = column.getEntityValue(valuesSetNormalized)\n                        if (\n                            column.referencedColumn &&\n                            typeof value === \"object\" &&\n                            !(value instanceof Date) &&\n                            value !== null &&\n                            !Buffer.isBuffer(value)\n                        ) {\n                            value =\n                                column.referencedColumn.getEntityValue(value)\n                        } else if (!(typeof value === \"function\")) {\n                            value =\n                                this.connection.driver.preparePersistentValue(\n                                    value,\n                                    column,\n                                )\n                        }\n\n                        // todo: duplication zone\n                        if (typeof value === \"function\") {\n                            // support for SQL expressions in update query\n                            updateColumnAndValues.push(\n                                this.escape(column.databaseName) +\n                                    \" = \" +\n                                    value(),\n                            )\n                        } else if (\n                            (this.connection.driver.options.type === \"sap\" ||\n                                this.connection.driver.options.type ===\n                                    \"spanner\") &&\n                            value === null\n                        ) {\n                            updateColumnAndValues.push(\n                                this.escape(column.databaseName) + \" = NULL\",\n                            )\n                        } else {\n                            if (\n                                this.connection.driver.options.type === \"mssql\"\n                            ) {\n                                value = (\n                                    this.connection.driver as SqlServerDriver\n                                ).parametrizeValue(column, value)\n                            }\n\n                            const paramName = this.createParameter(value)\n\n                            let expression = null\n                            if (\n                                (DriverUtils.isMySQLFamily(\n                                    this.connection.driver,\n                                ) ||\n                                    this.connection.driver.options.type ===\n                                        \"aurora-mysql\") &&\n                                this.connection.driver.spatialTypes.indexOf(\n                                    column.type,\n                                ) !== -1\n                            ) {\n                                const useLegacy = (\n                                    this.connection.driver as\n                                        | MysqlDriver\n                                        | AuroraMysqlDriver\n                                ).options.legacySpatialSupport\n                                const geomFromText = useLegacy\n                                    ? \"GeomFromText\"\n                                    : \"ST_GeomFromText\"\n                                if (column.srid != null) {\n                                    expression = `${geomFromText}(${paramName}, ${column.srid})`\n                                } else {\n                                    expression = `${geomFromText}(${paramName})`\n                                }\n                            } else if (\n                                this.connection.driver.options.type ===\n                                    \"postgres\" &&\n                                this.connection.driver.spatialTypes.indexOf(\n                                    column.type,\n                                ) !== -1\n                            ) {\n                                if (column.srid != null) {\n                                    expression = `ST_SetSRID(ST_GeomFromGeoJSON(${paramName}), ${column.srid})::${column.type}`\n                                } else {\n                                    expression = `ST_GeomFromGeoJSON(${paramName})::${column.type}`\n                                }\n                            } else if (\n                                this.connection.driver.options.type ===\n                                    \"mssql\" &&\n                                this.connection.driver.spatialTypes.indexOf(\n                                    column.type,\n                                ) !== -1\n                            ) {\n                                expression =\n                                    column.type +\n                                    \"::STGeomFromText(\" +\n                                    paramName +\n                                    \", \" +\n                                    (column.srid || \"0\") +\n                                    \")\"\n                            } else {\n                                expression = paramName\n                            }\n                            updateColumnAndValues.push(\n                                this.escape(column.databaseName) +\n                                    \" = \" +\n                                    expression,\n                            )\n                        }\n                    })\n                },\n            )\n\n            // Don't allow calling update only with columns that are `update: false`\n            if (\n                updateColumnAndValues.length > 0 ||\n                Object.keys(valuesSetNormalized).length === 0\n            ) {\n                if (\n                    metadata.versionColumn &&\n                    updatedColumns.indexOf(metadata.versionColumn) === -1\n                )\n                    updateColumnAndValues.push(\n                        this.escape(metadata.versionColumn.databaseName) +\n                            \" = \" +\n                            this.escape(metadata.versionColumn.databaseName) +\n                            \" + 1\",\n                    )\n                if (\n                    metadata.updateDateColumn &&\n                    updatedColumns.indexOf(metadata.updateDateColumn) === -1\n                )\n                    updateColumnAndValues.push(\n                        this.escape(metadata.updateDateColumn.databaseName) +\n                            \" = CURRENT_TIMESTAMP\",\n                    ) // todo: fix issue with CURRENT_TIMESTAMP(6) being used, can \"DEFAULT\" be used?!\n            }\n        } else {\n            Object.keys(valuesSetNormalized).map((key) => {\n                let value = valuesSetNormalized[key]\n\n                // todo: duplication zone\n                if (typeof value === \"function\") {\n                    // support for SQL expressions in update query\n                    updateColumnAndValues.push(\n                        this.escape(key) + \" = \" + value(),\n                    )\n                } else if (\n                    (this.connection.driver.options.type === \"sap\" ||\n                        this.connection.driver.options.type === \"spanner\") &&\n                    value === null\n                ) {\n                    updateColumnAndValues.push(this.escape(key) + \" = NULL\")\n                } else {\n                    // we need to store array values in a special class to make sure parameter replacement will work correctly\n                    // if (value instanceof Array)\n                    //     value = new ArrayParameter(value);\n\n                    const paramName = this.createParameter(value)\n                    updateColumnAndValues.push(\n                        this.escape(key) + \" = \" + paramName,\n                    )\n                }\n            })\n        }\n\n        if (updateColumnAndValues.length <= 0) {\n            throw new UpdateValuesMissingError()\n        }\n\n        // get a table name and all column database names\n        const whereExpression = this.createWhereExpression()\n        const returningExpression = this.createReturningExpression(\"update\")\n\n        if (returningExpression === \"\") {\n            return `UPDATE ${this.getTableName(\n                this.getMainTableName(),\n            )} SET ${updateColumnAndValues.join(\", \")}${whereExpression}` // todo: how do we replace aliases in where to nothing?\n        }\n        if (this.connection.driver.options.type === \"mssql\") {\n            return `UPDATE ${this.getTableName(\n                this.getMainTableName(),\n            )} SET ${updateColumnAndValues.join(\n                \", \",\n            )} OUTPUT ${returningExpression}${whereExpression}`\n        }\n        return `UPDATE ${this.getTableName(\n            this.getMainTableName(),\n        )} SET ${updateColumnAndValues.join(\n            \", \",\n        )}${whereExpression} RETURNING ${returningExpression}`\n    }\n\n    /**\n     * Creates \"ORDER BY\" part of SQL query.\n     */\n    protected createOrderByExpression() {\n        const orderBys = this.expressionMap.orderBys\n        if (Object.keys(orderBys).length > 0)\n            return (\n                \" ORDER BY \" +\n                Object.keys(orderBys)\n                    .map((columnName) => {\n                        if (typeof orderBys[columnName] === \"string\") {\n                            return (\n                                this.replacePropertyNames(columnName) +\n                                \" \" +\n                                orderBys[columnName]\n                            )\n                        } else {\n                            return (\n                                this.replacePropertyNames(columnName) +\n                                \" \" +\n                                (orderBys[columnName] as any).order +\n                                \" \" +\n                                (orderBys[columnName] as any).nulls\n                            )\n                        }\n                    })\n                    .join(\", \")\n            )\n\n        return \"\"\n    }\n\n    /**\n     * Creates \"LIMIT\" parts of SQL query.\n     */\n    protected createLimitExpression(): string {\n        let limit: number | undefined = this.expressionMap.limit\n\n        if (limit) {\n            if (\n                DriverUtils.isMySQLFamily(this.connection.driver) ||\n                this.connection.driver.options.type === \"aurora-mysql\"\n            ) {\n                return \" LIMIT \" + limit\n            } else {\n                throw new LimitOnUpdateNotSupportedError()\n            }\n        }\n\n        return \"\"\n    }\n\n    /**\n     * Gets array of values need to be inserted into the target table.\n     */\n    protected getValueSet(): ObjectLiteral {\n        if (typeof this.expressionMap.valuesSet === \"object\")\n            return this.expressionMap.valuesSet\n\n        throw new UpdateValuesMissingError()\n    }\n}\n"]},"metadata":{},"sourceType":"module"}