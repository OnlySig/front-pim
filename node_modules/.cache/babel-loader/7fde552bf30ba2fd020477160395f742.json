{"ast":null,"code":"import { getMetadataArgsStorage } from \"../../globals\";\nimport { ObjectUtils } from \"../../util/ObjectUtils\";\n/**\n * Many-to-many is a type of relationship when Entity1 can have multiple instances of Entity2, and Entity2 can have\n * multiple instances of Entity1. To achieve it, this type of relation creates a junction table, where it storage\n * entity1 and entity2 ids. This is owner side of the relationship.\n */\n\nexport function ManyToMany(typeFunctionOrTarget, inverseSideOrOptions, options) {\n  // normalize parameters\n  let inverseSideProperty;\n\n  if (ObjectUtils.isObject(inverseSideOrOptions)) {\n    options = inverseSideOrOptions;\n  } else {\n    inverseSideProperty = inverseSideOrOptions;\n  }\n\n  return function (object, propertyName) {\n    if (!options) options = {}; // now try to determine it its lazy relation\n\n    let isLazy = options.lazy === true;\n\n    if (!isLazy && Reflect && Reflect.getMetadata) {\n      // automatic determination\n      const reflectedType = Reflect.getMetadata(\"design:type\", object, propertyName);\n      if (reflectedType && typeof reflectedType.name === \"string\" && reflectedType.name.toLowerCase() === \"promise\") isLazy = true;\n    }\n\n    getMetadataArgsStorage().relations.push({\n      target: object.constructor,\n      propertyName: propertyName,\n      // propertyType: reflectedType,\n      relationType: \"many-to-many\",\n      isLazy: isLazy,\n      type: typeFunctionOrTarget,\n      inverseSideProperty: inverseSideProperty,\n      options: options\n    });\n  };\n}","map":{"version":3,"mappings":"AAAA,SAASA,sBAAT,QAAuC,eAAvC;AAIA,SAASC,WAAT,QAA4B,wBAA5B;AAuBA;;;;;;AAKA,OAAM,SAAUC,UAAV,CACFC,oBADE,EAEFC,oBAFE,EAGFC,OAHE,EAGuB;EAEzB;EACA,IAAIC,mBAAJ;;EACA,IAAIL,WAAW,CAACM,QAAZ,CAAqBH,oBAArB,CAAJ,EAAgD;IAC5CC,OAAO,GAAoBD,oBAA3B;EACH,CAFD,MAEO;IACHE,mBAAmB,GAAGF,oBAAtB;EACH;;EAED,OAAO,UAAUI,MAAV,EAA0BC,YAA1B,EAA8C;IACjD,IAAI,CAACJ,OAAL,EAAcA,OAAO,GAAG,EAAV,CADmC,CAGjD;;IACA,IAAIK,MAAM,GAAGL,OAAO,CAACM,IAAR,KAAiB,IAA9B;;IACA,IAAI,CAACD,MAAD,IAAWE,OAAX,IAAuBA,OAAe,CAACC,WAA3C,EAAwD;MACpD;MACA,MAAMC,aAAa,GAAIF,OAAe,CAACC,WAAhB,CACnB,aADmB,EAEnBL,MAFmB,EAGnBC,YAHmB,CAAvB;MAKA,IACIK,aAAa,IACb,OAAOA,aAAa,CAACC,IAArB,KAA8B,QAD9B,IAEAD,aAAa,CAACC,IAAd,CAAmBC,WAAnB,OAAqC,SAHzC,EAKIN,MAAM,GAAG,IAAT;IACP;;IAEDV,sBAAsB,GAAGiB,SAAzB,CAAmCC,IAAnC,CAAwC;MACpCC,MAAM,EAAEX,MAAM,CAACY,WADqB;MAEpCX,YAAY,EAAEA,YAFsB;MAGpC;MACAY,YAAY,EAAE,cAJsB;MAKpCX,MAAM,EAAEA,MAL4B;MAMpCY,IAAI,EAAEnB,oBAN8B;MAOpCG,mBAAmB,EAAEA,mBAPe;MAQpCD,OAAO,EAAEA;IAR2B,CAAxC;EAUH,CA9BD;AA+BH","names":["getMetadataArgsStorage","ObjectUtils","ManyToMany","typeFunctionOrTarget","inverseSideOrOptions","options","inverseSideProperty","isObject","object","propertyName","isLazy","lazy","Reflect","getMetadata","reflectedType","name","toLowerCase","relations","push","target","constructor","relationType","type"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\decorator\\relations\\ManyToMany.ts"],"sourcesContent":["import { getMetadataArgsStorage } from \"../../globals\"\nimport { RelationMetadataArgs } from \"../../metadata-args/RelationMetadataArgs\"\nimport { ObjectType } from \"../../common/ObjectType\"\nimport { RelationOptions } from \"../options/RelationOptions\"\nimport { ObjectUtils } from \"../../util/ObjectUtils\"\n\n/**\n * Many-to-many is a type of relationship when Entity1 can have multiple instances of Entity2, and Entity2 can have\n * multiple instances of Entity1. To achieve it, this type of relation creates a junction table, where it storage\n * entity1 and entity2 ids. This is owner side of the relationship.\n */\nexport function ManyToMany<T>(\n    typeFunctionOrTarget: string | ((type?: any) => ObjectType<T>),\n    options?: RelationOptions,\n): PropertyDecorator\n\n/**\n * Many-to-many is a type of relationship when Entity1 can have multiple instances of Entity2, and Entity2 can have\n * multiple instances of Entity1. To achieve it, this type of relation creates a junction table, where it storage\n * entity1 and entity2 ids. This is owner side of the relationship.\n */\nexport function ManyToMany<T>(\n    typeFunctionOrTarget: string | ((type?: any) => ObjectType<T>),\n    inverseSide?: string | ((object: T) => any),\n    options?: RelationOptions,\n): PropertyDecorator\n\n/**\n * Many-to-many is a type of relationship when Entity1 can have multiple instances of Entity2, and Entity2 can have\n * multiple instances of Entity1. To achieve it, this type of relation creates a junction table, where it storage\n * entity1 and entity2 ids. This is owner side of the relationship.\n */\nexport function ManyToMany<T>(\n    typeFunctionOrTarget: string | ((type?: any) => ObjectType<T>),\n    inverseSideOrOptions?: string | ((object: T) => any) | RelationOptions,\n    options?: RelationOptions,\n): PropertyDecorator {\n    // normalize parameters\n    let inverseSideProperty: string | ((object: T) => any)\n    if (ObjectUtils.isObject(inverseSideOrOptions)) {\n        options = <RelationOptions>inverseSideOrOptions\n    } else {\n        inverseSideProperty = inverseSideOrOptions as any\n    }\n\n    return function (object: Object, propertyName: string) {\n        if (!options) options = {} as RelationOptions\n\n        // now try to determine it its lazy relation\n        let isLazy = options.lazy === true\n        if (!isLazy && Reflect && (Reflect as any).getMetadata) {\n            // automatic determination\n            const reflectedType = (Reflect as any).getMetadata(\n                \"design:type\",\n                object,\n                propertyName,\n            )\n            if (\n                reflectedType &&\n                typeof reflectedType.name === \"string\" &&\n                reflectedType.name.toLowerCase() === \"promise\"\n            )\n                isLazy = true\n        }\n\n        getMetadataArgsStorage().relations.push({\n            target: object.constructor,\n            propertyName: propertyName,\n            // propertyType: reflectedType,\n            relationType: \"many-to-many\",\n            isLazy: isLazy,\n            type: typeFunctionOrTarget,\n            inverseSideProperty: inverseSideProperty,\n            options: options,\n        } as RelationMetadataArgs)\n    }\n}\n"]},"metadata":{},"sourceType":"module"}