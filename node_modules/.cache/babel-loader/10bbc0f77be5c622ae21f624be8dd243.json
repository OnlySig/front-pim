{"ast":null,"code":"import { FindOptionsUtils } from \"../find-options/FindOptionsUtils\";\n/**\n * Wraps entities and creates getters/setters for their relations\n * to be able to lazily load relations when accessing these relations.\n */\n\nexport class RelationLoader {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection) {\n    this.connection = connection;\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Loads relation data for the given entity and its relation.\n   */\n\n\n  load(relation, entityOrEntities, queryRunner, queryBuilder) {\n    // todo: check all places where it uses non array\n    if (queryRunner && queryRunner.isReleased) queryRunner = undefined; // get new one if already closed\n\n    if (relation.isManyToOne || relation.isOneToOneOwner) {\n      return this.loadManyToOneOrOneToOneOwner(relation, entityOrEntities, queryRunner, queryBuilder);\n    } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n      return this.loadOneToManyOrOneToOneNotOwner(relation, entityOrEntities, queryRunner, queryBuilder);\n    } else if (relation.isManyToManyOwner) {\n      return this.loadManyToManyOwner(relation, entityOrEntities, queryRunner, queryBuilder);\n    } else {\n      // many-to-many non owner\n      return this.loadManyToManyNotOwner(relation, entityOrEntities, queryRunner, queryBuilder);\n    }\n  }\n  /**\n   * Loads data for many-to-one and one-to-one owner relations.\n   *\n   * (ow) post.category<=>category.post\n   * loaded: category from post\n   * example: SELECT category.id AS category_id, category.name AS category_name FROM category category\n   *              INNER JOIN post Post ON Post.category=category.id WHERE Post.id=1\n   */\n\n\n  loadManyToOneOrOneToOneOwner(relation, entityOrEntities, queryRunner, queryBuilder) {\n    const entities = Array.isArray(entityOrEntities) ? entityOrEntities : [entityOrEntities];\n    const joinAliasName = relation.entityMetadata.name;\n    const qb = queryBuilder ? queryBuilder : this.connection.createQueryBuilder(queryRunner).select(relation.propertyName) // category\n    .from(relation.type, relation.propertyName);\n    const mainAlias = qb.expressionMap.mainAlias.name;\n    const columns = relation.entityMetadata.primaryColumns;\n    const joinColumns = relation.isOwning ? relation.joinColumns : relation.inverseRelation.joinColumns;\n    const conditions = joinColumns.map(joinColumn => {\n      return `${relation.entityMetadata.name}.${joinColumn.propertyName} = ${mainAlias}.${joinColumn.referencedColumn.propertyName}`;\n    }).join(\" AND \");\n    qb.innerJoin(relation.entityMetadata.target, joinAliasName, conditions);\n\n    if (columns.length === 1) {\n      qb.where(`${joinAliasName}.${columns[0].propertyPath} IN (:...${joinAliasName + \"_\" + columns[0].propertyName})`);\n      qb.setParameter(joinAliasName + \"_\" + columns[0].propertyName, entities.map(entity => columns[0].getEntityValue(entity, true)));\n    } else {\n      const condition = entities.map((entity, entityIndex) => {\n        return columns.map((column, columnIndex) => {\n          const paramName = joinAliasName + \"_entity_\" + entityIndex + \"_\" + columnIndex;\n          qb.setParameter(paramName, column.getEntityValue(entity, true));\n          return joinAliasName + \".\" + column.propertyPath + \" = :\" + paramName;\n        }).join(\" AND \");\n      }).map(condition => \"(\" + condition + \")\").join(\" OR \");\n      qb.where(condition);\n    }\n\n    FindOptionsUtils.joinEagerRelations(qb, qb.alias, qb.expressionMap.mainAlias.metadata);\n    return qb.getMany(); // return qb.getOne(); todo: fix all usages\n  }\n  /**\n   * Loads data for one-to-many and one-to-one not owner relations.\n   *\n   * SELECT post\n   * FROM post post\n   * WHERE post.[joinColumn.name] = entity[joinColumn.referencedColumn]\n   */\n\n\n  loadOneToManyOrOneToOneNotOwner(relation, entityOrEntities, queryRunner, queryBuilder) {\n    const entities = Array.isArray(entityOrEntities) ? entityOrEntities : [entityOrEntities];\n    const columns = relation.inverseRelation.joinColumns;\n    const qb = queryBuilder ? queryBuilder : this.connection.createQueryBuilder(queryRunner).select(relation.propertyName).from(relation.inverseRelation.entityMetadata.target, relation.propertyName);\n    const aliasName = qb.expressionMap.mainAlias.name;\n\n    if (columns.length === 1) {\n      qb.where(`${aliasName}.${columns[0].propertyPath} IN (:...${aliasName + \"_\" + columns[0].propertyName})`);\n      qb.setParameter(aliasName + \"_\" + columns[0].propertyName, entities.map(entity => columns[0].referencedColumn.getEntityValue(entity, true)));\n    } else {\n      const condition = entities.map((entity, entityIndex) => {\n        return columns.map((column, columnIndex) => {\n          const paramName = aliasName + \"_entity_\" + entityIndex + \"_\" + columnIndex;\n          qb.setParameter(paramName, column.referencedColumn.getEntityValue(entity, true));\n          return aliasName + \".\" + column.propertyPath + \" = :\" + paramName;\n        }).join(\" AND \");\n      }).map(condition => \"(\" + condition + \")\").join(\" OR \");\n      qb.where(condition);\n    }\n\n    FindOptionsUtils.joinEagerRelations(qb, qb.alias, qb.expressionMap.mainAlias.metadata);\n    return qb.getMany(); // return relation.isOneToMany ? qb.getMany() : qb.getOne(); todo: fix all usages\n  }\n  /**\n   * Loads data for many-to-many owner relations.\n   *\n   * SELECT category\n   * FROM category category\n   * INNER JOIN post_categories post_categories\n   * ON post_categories.postId = :postId\n   * AND post_categories.categoryId = category.id\n   */\n\n\n  loadManyToManyOwner(relation, entityOrEntities, queryRunner, queryBuilder) {\n    const entities = Array.isArray(entityOrEntities) ? entityOrEntities : [entityOrEntities];\n    const parameters = relation.joinColumns.reduce((parameters, joinColumn) => {\n      parameters[joinColumn.propertyName] = entities.map(entity => joinColumn.referencedColumn.getEntityValue(entity, true));\n      return parameters;\n    }, {});\n    const qb = queryBuilder ? queryBuilder : this.connection.createQueryBuilder(queryRunner).select(relation.propertyName).from(relation.type, relation.propertyName);\n    const mainAlias = qb.expressionMap.mainAlias.name;\n    const joinAlias = relation.junctionEntityMetadata.tableName;\n    const joinColumnConditions = relation.joinColumns.map(joinColumn => {\n      return `${joinAlias}.${joinColumn.propertyName} IN (:...${joinColumn.propertyName})`;\n    });\n    const inverseJoinColumnConditions = relation.inverseJoinColumns.map(inverseJoinColumn => {\n      return `${joinAlias}.${inverseJoinColumn.propertyName}=${mainAlias}.${inverseJoinColumn.referencedColumn.propertyName}`;\n    });\n    qb.innerJoin(joinAlias, joinAlias, [...joinColumnConditions, ...inverseJoinColumnConditions].join(\" AND \")).setParameters(parameters);\n    FindOptionsUtils.joinEagerRelations(qb, qb.alias, qb.expressionMap.mainAlias.metadata);\n    return qb.getMany();\n  }\n  /**\n   * Loads data for many-to-many not owner relations.\n   *\n   * SELECT post\n   * FROM post post\n   * INNER JOIN post_categories post_categories\n   * ON post_categories.postId = post.id\n   * AND post_categories.categoryId = post_categories.categoryId\n   */\n\n\n  loadManyToManyNotOwner(relation, entityOrEntities, queryRunner, queryBuilder) {\n    const entities = Array.isArray(entityOrEntities) ? entityOrEntities : [entityOrEntities];\n    const qb = queryBuilder ? queryBuilder : this.connection.createQueryBuilder(queryRunner).select(relation.propertyName).from(relation.type, relation.propertyName);\n    const mainAlias = qb.expressionMap.mainAlias.name;\n    const joinAlias = relation.junctionEntityMetadata.tableName;\n    const joinColumnConditions = relation.inverseRelation.joinColumns.map(joinColumn => {\n      return `${joinAlias}.${joinColumn.propertyName} = ${mainAlias}.${joinColumn.referencedColumn.propertyName}`;\n    });\n    const inverseJoinColumnConditions = relation.inverseRelation.inverseJoinColumns.map(inverseJoinColumn => {\n      return `${joinAlias}.${inverseJoinColumn.propertyName} IN (:...${inverseJoinColumn.propertyName})`;\n    });\n    const parameters = relation.inverseRelation.inverseJoinColumns.reduce((parameters, joinColumn) => {\n      parameters[joinColumn.propertyName] = entities.map(entity => joinColumn.referencedColumn.getEntityValue(entity, true));\n      return parameters;\n    }, {});\n    qb.innerJoin(joinAlias, joinAlias, [...joinColumnConditions, ...inverseJoinColumnConditions].join(\" AND \")).setParameters(parameters);\n    FindOptionsUtils.joinEagerRelations(qb, qb.alias, qb.expressionMap.mainAlias.metadata);\n    return qb.getMany();\n  }\n  /**\n   * Wraps given entity and creates getters/setters for its given relation\n   * to be able to lazily load data when accessing this relation.\n   */\n\n\n  enableLazyLoad(relation, entity, queryRunner) {\n    const relationLoader = this;\n    const dataIndex = \"__\" + relation.propertyName + \"__\"; // in what property of the entity loaded data will be stored\n\n    const promiseIndex = \"__promise_\" + relation.propertyName + \"__\"; // in what property of the entity loading promise will be stored\n\n    const resolveIndex = \"__has_\" + relation.propertyName + \"__\"; // indicates if relation data already was loaded or not, we need this flag if loaded data is empty\n\n    const setData = (entity, value) => {\n      entity[dataIndex] = value;\n      entity[resolveIndex] = true;\n      delete entity[promiseIndex];\n      return value;\n    };\n\n    const setPromise = (entity, value) => {\n      delete entity[resolveIndex];\n      delete entity[dataIndex];\n      entity[promiseIndex] = value;\n      value.then( // ensure different value is not assigned yet\n      result => entity[promiseIndex] === value ? setData(entity, result) : result);\n      return value;\n    };\n\n    Object.defineProperty(entity, relation.propertyName, {\n      get: function () {\n        if (this[resolveIndex] === true || this[dataIndex] !== undefined) // if related data already was loaded then simply return it\n          return Promise.resolve(this[dataIndex]);\n        if (this[promiseIndex]) // if related data is loading then return a promise relationLoader loads it\n          return this[promiseIndex]; // nothing is loaded yet, load relation data and save it in the model once they are loaded\n\n        const loader = relationLoader.load(relation, this, queryRunner).then(result => relation.isOneToOne || relation.isManyToOne ? result.length === 0 ? null : result[0] : result);\n        return setPromise(this, loader);\n      },\n      set: function (value) {\n        if (value instanceof Promise) {\n          // if set data is a promise then wait for its resolve and save in the object\n          setPromise(this, value);\n        } else {\n          // if its direct data set (non promise, probably not safe-typed)\n          setData(this, value);\n        }\n      },\n      configurable: true\n    });\n  }\n\n}","map":{"version":3,"mappings":"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","names":["FindOptionsUtils","RelationLoader","constructor","connection","load","relation","entityOrEntities","queryRunner","queryBuilder","isReleased","undefined","isManyToOne","isOneToOneOwner","loadManyToOneOrOneToOneOwner","isOneToMany","isOneToOneNotOwner","loadOneToManyOrOneToOneNotOwner","isManyToManyOwner","loadManyToManyOwner","loadManyToManyNotOwner","entities","Array","isArray","joinAliasName","entityMetadata","name","qb","createQueryBuilder","select","propertyName","from","type","mainAlias","expressionMap","columns","primaryColumns","joinColumns","isOwning","inverseRelation","conditions","map","joinColumn","referencedColumn","join","innerJoin","target","length","where","propertyPath","setParameter","entity","getEntityValue","condition","entityIndex","column","columnIndex","paramName","joinEagerRelations","alias","metadata","getMany","aliasName","parameters","reduce","joinAlias","junctionEntityMetadata","tableName","joinColumnConditions","inverseJoinColumnConditions","inverseJoinColumns","inverseJoinColumn","setParameters","enableLazyLoad","relationLoader","dataIndex","promiseIndex","resolveIndex","setData","value","setPromise","then","result","Object","defineProperty","get","Promise","resolve","loader","isOneToOne","set","configurable"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\query-builder\\RelationLoader.ts"],"sourcesContent":["import { DataSource } from \"../data-source/DataSource\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\nimport { RelationMetadata } from \"../metadata/RelationMetadata\"\nimport { FindOptionsUtils } from \"../find-options/FindOptionsUtils\"\nimport { SelectQueryBuilder } from \"./SelectQueryBuilder\"\n\n/**\n * Wraps entities and creates getters/setters for their relations\n * to be able to lazily load relations when accessing these relations.\n */\nexport class RelationLoader {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private connection: DataSource) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Loads relation data for the given entity and its relation.\n     */\n    load(\n        relation: RelationMetadata,\n        entityOrEntities: ObjectLiteral | ObjectLiteral[],\n        queryRunner?: QueryRunner,\n        queryBuilder?: SelectQueryBuilder<any>,\n    ): Promise<any[]> {\n        // todo: check all places where it uses non array\n        if (queryRunner && queryRunner.isReleased) queryRunner = undefined // get new one if already closed\n        if (relation.isManyToOne || relation.isOneToOneOwner) {\n            return this.loadManyToOneOrOneToOneOwner(\n                relation,\n                entityOrEntities,\n                queryRunner,\n                queryBuilder,\n            )\n        } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n            return this.loadOneToManyOrOneToOneNotOwner(\n                relation,\n                entityOrEntities,\n                queryRunner,\n                queryBuilder,\n            )\n        } else if (relation.isManyToManyOwner) {\n            return this.loadManyToManyOwner(\n                relation,\n                entityOrEntities,\n                queryRunner,\n                queryBuilder,\n            )\n        } else {\n            // many-to-many non owner\n            return this.loadManyToManyNotOwner(\n                relation,\n                entityOrEntities,\n                queryRunner,\n                queryBuilder,\n            )\n        }\n    }\n\n    /**\n     * Loads data for many-to-one and one-to-one owner relations.\n     *\n     * (ow) post.category<=>category.post\n     * loaded: category from post\n     * example: SELECT category.id AS category_id, category.name AS category_name FROM category category\n     *              INNER JOIN post Post ON Post.category=category.id WHERE Post.id=1\n     */\n    loadManyToOneOrOneToOneOwner(\n        relation: RelationMetadata,\n        entityOrEntities: ObjectLiteral | ObjectLiteral[],\n        queryRunner?: QueryRunner,\n        queryBuilder?: SelectQueryBuilder<any>,\n    ): Promise<any> {\n        const entities = Array.isArray(entityOrEntities)\n            ? entityOrEntities\n            : [entityOrEntities]\n\n        const joinAliasName = relation.entityMetadata.name\n        const qb = queryBuilder\n            ? queryBuilder\n            : this.connection\n                  .createQueryBuilder(queryRunner)\n                  .select(relation.propertyName) // category\n                  .from(relation.type, relation.propertyName)\n\n        const mainAlias = qb.expressionMap.mainAlias!.name\n        const columns = relation.entityMetadata.primaryColumns\n        const joinColumns = relation.isOwning\n            ? relation.joinColumns\n            : relation.inverseRelation!.joinColumns\n        const conditions = joinColumns\n            .map((joinColumn) => {\n                return `${relation.entityMetadata.name}.${\n                    joinColumn.propertyName\n                } = ${mainAlias}.${joinColumn.referencedColumn!.propertyName}`\n            })\n            .join(\" AND \")\n\n        qb.innerJoin(\n            relation.entityMetadata.target as Function,\n            joinAliasName,\n            conditions,\n        )\n\n        if (columns.length === 1) {\n            qb.where(\n                `${joinAliasName}.${columns[0].propertyPath} IN (:...${\n                    joinAliasName + \"_\" + columns[0].propertyName\n                })`,\n            )\n            qb.setParameter(\n                joinAliasName + \"_\" + columns[0].propertyName,\n                entities.map((entity) =>\n                    columns[0].getEntityValue(entity, true),\n                ),\n            )\n        } else {\n            const condition = entities\n                .map((entity, entityIndex) => {\n                    return columns\n                        .map((column, columnIndex) => {\n                            const paramName =\n                                joinAliasName +\n                                \"_entity_\" +\n                                entityIndex +\n                                \"_\" +\n                                columnIndex\n                            qb.setParameter(\n                                paramName,\n                                column.getEntityValue(entity, true),\n                            )\n                            return (\n                                joinAliasName +\n                                \".\" +\n                                column.propertyPath +\n                                \" = :\" +\n                                paramName\n                            )\n                        })\n                        .join(\" AND \")\n                })\n                .map((condition) => \"(\" + condition + \")\")\n                .join(\" OR \")\n            qb.where(condition)\n        }\n\n        FindOptionsUtils.joinEagerRelations(\n            qb,\n            qb.alias,\n            qb.expressionMap.mainAlias!.metadata,\n        )\n\n        return qb.getMany()\n        // return qb.getOne(); todo: fix all usages\n    }\n\n    /**\n     * Loads data for one-to-many and one-to-one not owner relations.\n     *\n     * SELECT post\n     * FROM post post\n     * WHERE post.[joinColumn.name] = entity[joinColumn.referencedColumn]\n     */\n    loadOneToManyOrOneToOneNotOwner(\n        relation: RelationMetadata,\n        entityOrEntities: ObjectLiteral | ObjectLiteral[],\n        queryRunner?: QueryRunner,\n        queryBuilder?: SelectQueryBuilder<any>,\n    ): Promise<any> {\n        const entities = Array.isArray(entityOrEntities)\n            ? entityOrEntities\n            : [entityOrEntities]\n        const columns = relation.inverseRelation!.joinColumns\n        const qb = queryBuilder\n            ? queryBuilder\n            : this.connection\n                  .createQueryBuilder(queryRunner)\n                  .select(relation.propertyName)\n                  .from(\n                      relation.inverseRelation!.entityMetadata.target,\n                      relation.propertyName,\n                  )\n\n        const aliasName = qb.expressionMap.mainAlias!.name\n\n        if (columns.length === 1) {\n            qb.where(\n                `${aliasName}.${columns[0].propertyPath} IN (:...${\n                    aliasName + \"_\" + columns[0].propertyName\n                })`,\n            )\n            qb.setParameter(\n                aliasName + \"_\" + columns[0].propertyName,\n                entities.map((entity) =>\n                    columns[0].referencedColumn!.getEntityValue(entity, true),\n                ),\n            )\n        } else {\n            const condition = entities\n                .map((entity, entityIndex) => {\n                    return columns\n                        .map((column, columnIndex) => {\n                            const paramName =\n                                aliasName +\n                                \"_entity_\" +\n                                entityIndex +\n                                \"_\" +\n                                columnIndex\n                            qb.setParameter(\n                                paramName,\n                                column.referencedColumn!.getEntityValue(\n                                    entity,\n                                    true,\n                                ),\n                            )\n                            return (\n                                aliasName +\n                                \".\" +\n                                column.propertyPath +\n                                \" = :\" +\n                                paramName\n                            )\n                        })\n                        .join(\" AND \")\n                })\n                .map((condition) => \"(\" + condition + \")\")\n                .join(\" OR \")\n            qb.where(condition)\n        }\n\n        FindOptionsUtils.joinEagerRelations(\n            qb,\n            qb.alias,\n            qb.expressionMap.mainAlias!.metadata,\n        )\n\n        return qb.getMany()\n        // return relation.isOneToMany ? qb.getMany() : qb.getOne(); todo: fix all usages\n    }\n\n    /**\n     * Loads data for many-to-many owner relations.\n     *\n     * SELECT category\n     * FROM category category\n     * INNER JOIN post_categories post_categories\n     * ON post_categories.postId = :postId\n     * AND post_categories.categoryId = category.id\n     */\n    loadManyToManyOwner(\n        relation: RelationMetadata,\n        entityOrEntities: ObjectLiteral | ObjectLiteral[],\n        queryRunner?: QueryRunner,\n        queryBuilder?: SelectQueryBuilder<any>,\n    ): Promise<any> {\n        const entities = Array.isArray(entityOrEntities)\n            ? entityOrEntities\n            : [entityOrEntities]\n        const parameters = relation.joinColumns.reduce(\n            (parameters, joinColumn) => {\n                parameters[joinColumn.propertyName] = entities.map((entity) =>\n                    joinColumn.referencedColumn!.getEntityValue(entity, true),\n                )\n                return parameters\n            },\n            {} as ObjectLiteral,\n        )\n\n        const qb = queryBuilder\n            ? queryBuilder\n            : this.connection\n                  .createQueryBuilder(queryRunner)\n                  .select(relation.propertyName)\n                  .from(relation.type, relation.propertyName)\n\n        const mainAlias = qb.expressionMap.mainAlias!.name\n        const joinAlias = relation.junctionEntityMetadata!.tableName\n        const joinColumnConditions = relation.joinColumns.map((joinColumn) => {\n            return `${joinAlias}.${joinColumn.propertyName} IN (:...${joinColumn.propertyName})`\n        })\n        const inverseJoinColumnConditions = relation.inverseJoinColumns.map(\n            (inverseJoinColumn) => {\n                return `${joinAlias}.${\n                    inverseJoinColumn.propertyName\n                }=${mainAlias}.${\n                    inverseJoinColumn.referencedColumn!.propertyName\n                }`\n            },\n        )\n\n        qb.innerJoin(\n            joinAlias,\n            joinAlias,\n            [...joinColumnConditions, ...inverseJoinColumnConditions].join(\n                \" AND \",\n            ),\n        ).setParameters(parameters)\n\n        FindOptionsUtils.joinEagerRelations(\n            qb,\n            qb.alias,\n            qb.expressionMap.mainAlias!.metadata,\n        )\n\n        return qb.getMany()\n    }\n\n    /**\n     * Loads data for many-to-many not owner relations.\n     *\n     * SELECT post\n     * FROM post post\n     * INNER JOIN post_categories post_categories\n     * ON post_categories.postId = post.id\n     * AND post_categories.categoryId = post_categories.categoryId\n     */\n    loadManyToManyNotOwner(\n        relation: RelationMetadata,\n        entityOrEntities: ObjectLiteral | ObjectLiteral[],\n        queryRunner?: QueryRunner,\n        queryBuilder?: SelectQueryBuilder<any>,\n    ): Promise<any> {\n        const entities = Array.isArray(entityOrEntities)\n            ? entityOrEntities\n            : [entityOrEntities]\n\n        const qb = queryBuilder\n            ? queryBuilder\n            : this.connection\n                  .createQueryBuilder(queryRunner)\n                  .select(relation.propertyName)\n                  .from(relation.type, relation.propertyName)\n\n        const mainAlias = qb.expressionMap.mainAlias!.name\n        const joinAlias = relation.junctionEntityMetadata!.tableName\n        const joinColumnConditions = relation.inverseRelation!.joinColumns.map(\n            (joinColumn) => {\n                return `${joinAlias}.${\n                    joinColumn.propertyName\n                } = ${mainAlias}.${joinColumn.referencedColumn!.propertyName}`\n            },\n        )\n        const inverseJoinColumnConditions =\n            relation.inverseRelation!.inverseJoinColumns.map(\n                (inverseJoinColumn) => {\n                    return `${joinAlias}.${inverseJoinColumn.propertyName} IN (:...${inverseJoinColumn.propertyName})`\n                },\n            )\n        const parameters = relation.inverseRelation!.inverseJoinColumns.reduce(\n            (parameters, joinColumn) => {\n                parameters[joinColumn.propertyName] = entities.map((entity) =>\n                    joinColumn.referencedColumn!.getEntityValue(entity, true),\n                )\n                return parameters\n            },\n            {} as ObjectLiteral,\n        )\n\n        qb.innerJoin(\n            joinAlias,\n            joinAlias,\n            [...joinColumnConditions, ...inverseJoinColumnConditions].join(\n                \" AND \",\n            ),\n        ).setParameters(parameters)\n\n        FindOptionsUtils.joinEagerRelations(\n            qb,\n            qb.alias,\n            qb.expressionMap.mainAlias!.metadata,\n        )\n\n        return qb.getMany()\n    }\n\n    /**\n     * Wraps given entity and creates getters/setters for its given relation\n     * to be able to lazily load data when accessing this relation.\n     */\n    enableLazyLoad(\n        relation: RelationMetadata,\n        entity: ObjectLiteral,\n        queryRunner?: QueryRunner,\n    ) {\n        const relationLoader = this\n        const dataIndex = \"__\" + relation.propertyName + \"__\" // in what property of the entity loaded data will be stored\n        const promiseIndex = \"__promise_\" + relation.propertyName + \"__\" // in what property of the entity loading promise will be stored\n        const resolveIndex = \"__has_\" + relation.propertyName + \"__\" // indicates if relation data already was loaded or not, we need this flag if loaded data is empty\n\n        const setData = (entity: ObjectLiteral, value: any) => {\n            entity[dataIndex] = value\n            entity[resolveIndex] = true\n            delete entity[promiseIndex]\n            return value\n        }\n        const setPromise = (entity: ObjectLiteral, value: Promise<any>) => {\n            delete entity[resolveIndex]\n            delete entity[dataIndex]\n            entity[promiseIndex] = value\n            value.then(\n                // ensure different value is not assigned yet\n                (result) =>\n                    entity[promiseIndex] === value\n                        ? setData(entity, result)\n                        : result,\n            )\n            return value\n        }\n\n        Object.defineProperty(entity, relation.propertyName, {\n            get: function () {\n                if (\n                    this[resolveIndex] === true ||\n                    this[dataIndex] !== undefined\n                )\n                    // if related data already was loaded then simply return it\n                    return Promise.resolve(this[dataIndex])\n\n                if (this[promiseIndex])\n                    // if related data is loading then return a promise relationLoader loads it\n                    return this[promiseIndex]\n\n                // nothing is loaded yet, load relation data and save it in the model once they are loaded\n                const loader = relationLoader\n                    .load(relation, this, queryRunner)\n                    .then((result) =>\n                        relation.isOneToOne || relation.isManyToOne\n                            ? result.length === 0\n                                ? null\n                                : result[0]\n                            : result,\n                    )\n                return setPromise(this, loader)\n            },\n            set: function (value: any | Promise<any>) {\n                if (value instanceof Promise) {\n                    // if set data is a promise then wait for its resolve and save in the object\n                    setPromise(this, value)\n                } else {\n                    // if its direct data set (non promise, probably not safe-typed)\n                    setData(this, value)\n                }\n            },\n            configurable: true,\n        })\n    }\n}\n"]},"metadata":{},"sourceType":"module"}