{"ast":null,"code":"import { DriverUtils } from \"../../driver/DriverUtils\";\nimport { TypeORMError } from \"../../error/TypeORMError\";\nimport { OrmUtils } from \"../../util/OrmUtils\";\nexport class RelationIdLoader {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection, queryRunner, relationIdAttributes) {\n    this.connection = connection;\n    this.queryRunner = queryRunner;\n    this.relationIdAttributes = relationIdAttributes;\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n\n  async load(rawEntities) {\n    const promises = this.relationIdAttributes.map(async relationIdAttr => {\n      if (relationIdAttr.relation.isManyToOne || relationIdAttr.relation.isOneToOneOwner) {\n        // example: Post and Tag\n        // loadRelationIdAndMap(\"post.tagId\", \"post.tag\")\n        // we expect it to load id of tag\n        if (relationIdAttr.queryBuilderFactory) throw new TypeORMError(\"Additional condition can not be used with ManyToOne or OneToOne owner relations.\");\n        const duplicates = {};\n        const results = rawEntities.map(rawEntity => {\n          const result = {};\n          const duplicateParts = [];\n          relationIdAttr.relation.joinColumns.forEach(joinColumn => {\n            result[joinColumn.databaseName] = this.connection.driver.prepareHydratedValue(rawEntity[DriverUtils.buildAlias(this.connection.driver, relationIdAttr.parentAlias, joinColumn.databaseName)], joinColumn.referencedColumn);\n            const duplicatePart = `${joinColumn.databaseName}:${result[joinColumn.databaseName]}`;\n\n            if (duplicateParts.indexOf(duplicatePart) === -1) {\n              duplicateParts.push(duplicatePart);\n            }\n          });\n          relationIdAttr.relation.entityMetadata.primaryColumns.forEach(primaryColumn => {\n            result[primaryColumn.databaseName] = this.connection.driver.prepareHydratedValue(rawEntity[DriverUtils.buildAlias(this.connection.driver, relationIdAttr.parentAlias, primaryColumn.databaseName)], primaryColumn);\n            const duplicatePart = `${primaryColumn.databaseName}:${result[primaryColumn.databaseName]}`;\n\n            if (duplicateParts.indexOf(duplicatePart) === -1) {\n              duplicateParts.push(duplicatePart);\n            }\n          });\n          duplicateParts.sort();\n          const duplicate = duplicateParts.join(\"::\");\n\n          if (duplicates[duplicate]) {\n            return null;\n          }\n\n          duplicates[duplicate] = true;\n          return result;\n        }).filter(v => v);\n        return {\n          relationIdAttribute: relationIdAttr,\n          results: results\n        };\n      } else if (relationIdAttr.relation.isOneToMany || relationIdAttr.relation.isOneToOneNotOwner) {\n        // example: Post and Category\n        // loadRelationIdAndMap(\"post.categoryIds\", \"post.categories\")\n        // we expect it to load array of category ids\n        const relation = relationIdAttr.relation; // \"post.categories\"\n\n        const joinColumns = relation.isOwning ? relation.joinColumns : relation.inverseRelation.joinColumns;\n        const table = relation.inverseEntityMetadata.target; // category\n\n        const tableName = relation.inverseEntityMetadata.tableName; // category\n\n        const tableAlias = relationIdAttr.alias || tableName; // if condition (custom query builder factory) is set then relationIdAttr.alias defined\n\n        const duplicates = {};\n        const parameters = {};\n        const condition = rawEntities.map((rawEntity, index) => {\n          const duplicateParts = [];\n          const parameterParts = {};\n          const queryPart = joinColumns.map(joinColumn => {\n            const parameterName = joinColumn.databaseName + index;\n            const parameterValue = rawEntity[DriverUtils.buildAlias(this.connection.driver, relationIdAttr.parentAlias, joinColumn.referencedColumn.databaseName)];\n            const duplicatePart = `${tableAlias}:${joinColumn.propertyPath}:${parameterValue}`;\n\n            if (duplicateParts.indexOf(duplicatePart) !== -1) {\n              return \"\";\n            }\n\n            duplicateParts.push(duplicatePart);\n            parameterParts[parameterName] = parameterValue;\n            return tableAlias + \".\" + joinColumn.propertyPath + \" = :\" + parameterName;\n          }).filter(v => v).join(\" AND \");\n          duplicateParts.sort();\n          const duplicate = duplicateParts.join(\"::\");\n\n          if (duplicates[duplicate]) {\n            return \"\";\n          }\n\n          duplicates[duplicate] = true;\n          Object.assign(parameters, parameterParts);\n          return queryPart;\n        }).filter(v => v).map(condition => \"(\" + condition + \")\").join(\" OR \"); // ensure we won't perform redundant queries for joined data which was not found in selection\n        // example: if post.category was not found in db then no need to execute query for category.imageIds\n\n        if (!condition) return {\n          relationIdAttribute: relationIdAttr,\n          results: []\n        }; // generate query:\n        // SELECT category.id, category.postId FROM category category ON category.postId = :postId\n\n        const qb = this.connection.createQueryBuilder(this.queryRunner);\n        const columns = OrmUtils.uniq([...joinColumns, ...relation.inverseRelation.entityMetadata.primaryColumns], column => column.propertyPath);\n        columns.forEach(joinColumn => {\n          qb.addSelect(tableAlias + \".\" + joinColumn.propertyPath, joinColumn.databaseName);\n        });\n        qb.from(table, tableAlias).where(\"(\" + condition + \")\") // need brackets because if we have additional condition and no brackets, it looks like (a = 1) OR (a = 2) AND b = 1, that is incorrect\n        .setParameters(parameters); // apply condition (custom query builder factory)\n\n        if (relationIdAttr.queryBuilderFactory) relationIdAttr.queryBuilderFactory(qb);\n        const results = await qb.getRawMany();\n        results.forEach(result => {\n          joinColumns.forEach(column => {\n            result[column.databaseName] = this.connection.driver.prepareHydratedValue(result[column.databaseName], column.referencedColumn);\n          });\n          relation.inverseRelation.entityMetadata.primaryColumns.forEach(column => {\n            result[column.databaseName] = this.connection.driver.prepareHydratedValue(result[column.databaseName], column);\n          });\n        });\n        return {\n          relationIdAttribute: relationIdAttr,\n          results\n        };\n      } else {\n        // many-to-many\n        // example: Post and Category\n        // owner side: loadRelationIdAndMap(\"post.categoryIds\", \"post.categories\")\n        // inverse side: loadRelationIdAndMap(\"category.postIds\", \"category.posts\")\n        // we expect it to load array of post ids\n        const relation = relationIdAttr.relation;\n        const joinColumns = relation.isOwning ? relation.joinColumns : relation.inverseRelation.inverseJoinColumns;\n        const inverseJoinColumns = relation.isOwning ? relation.inverseJoinColumns : relation.inverseRelation.joinColumns;\n        const junctionAlias = relationIdAttr.junctionAlias;\n        const inverseSideTableName = relationIdAttr.joinInverseSideMetadata.tableName;\n        const inverseSideTableAlias = relationIdAttr.alias || inverseSideTableName;\n        const junctionTableName = relation.isOwning ? relation.junctionEntityMetadata.tableName : relation.inverseRelation.junctionEntityMetadata.tableName;\n        const mappedColumns = rawEntities.map(rawEntity => {\n          return joinColumns.reduce((map, joinColumn) => {\n            map[joinColumn.propertyPath] = rawEntity[DriverUtils.buildAlias(this.connection.driver, relationIdAttr.parentAlias, joinColumn.referencedColumn.databaseName)];\n            return map;\n          }, {});\n        }); // ensure we won't perform redundant queries for joined data which was not found in selection\n        // example: if post.category was not found in db then no need to execute query for category.imageIds\n\n        if (mappedColumns.length === 0) return {\n          relationIdAttribute: relationIdAttr,\n          results: []\n        };\n        const parameters = {};\n        const duplicates = {};\n        const joinColumnConditions = mappedColumns.map((mappedColumn, index) => {\n          const duplicateParts = [];\n          const parameterParts = {};\n          const queryPart = Object.keys(mappedColumn).map(key => {\n            const parameterName = key + index;\n            const parameterValue = mappedColumn[key];\n            const duplicatePart = `${junctionAlias}:${key}:${parameterValue}`;\n\n            if (duplicateParts.indexOf(duplicatePart) !== -1) {\n              return \"\";\n            }\n\n            duplicateParts.push(duplicatePart);\n            parameterParts[parameterName] = parameterValue;\n            return junctionAlias + \".\" + key + \" = :\" + parameterName;\n          }).filter(s => s).join(\" AND \");\n          duplicateParts.sort();\n          const duplicate = duplicateParts.join(\"::\");\n\n          if (duplicates[duplicate]) {\n            return \"\";\n          }\n\n          duplicates[duplicate] = true;\n          Object.assign(parameters, parameterParts);\n          return queryPart;\n        }).filter(s => s);\n        const inverseJoinColumnCondition = inverseJoinColumns.map(joinColumn => {\n          return junctionAlias + \".\" + joinColumn.propertyPath + \" = \" + inverseSideTableAlias + \".\" + joinColumn.referencedColumn.propertyPath;\n        }).join(\" AND \");\n        const condition = joinColumnConditions.map(condition => {\n          return \"(\" + condition + \" AND \" + inverseJoinColumnCondition + \")\";\n        }).join(\" OR \");\n        const qb = this.connection.createQueryBuilder(this.queryRunner);\n        inverseJoinColumns.forEach(joinColumn => {\n          qb.addSelect(junctionAlias + \".\" + joinColumn.propertyPath, joinColumn.databaseName).addOrderBy(junctionAlias + \".\" + joinColumn.propertyPath);\n        });\n        joinColumns.forEach(joinColumn => {\n          qb.addSelect(junctionAlias + \".\" + joinColumn.propertyPath, joinColumn.databaseName).addOrderBy(junctionAlias + \".\" + joinColumn.propertyPath);\n        });\n        qb.from(inverseSideTableName, inverseSideTableAlias).innerJoin(junctionTableName, junctionAlias, condition).setParameters(parameters); // apply condition (custom query builder factory)\n\n        if (relationIdAttr.queryBuilderFactory) relationIdAttr.queryBuilderFactory(qb);\n        const results = await qb.getRawMany();\n        results.forEach(result => {\n          ;\n          [...joinColumns, ...inverseJoinColumns].forEach(column => {\n            result[column.databaseName] = this.connection.driver.prepareHydratedValue(result[column.databaseName], column.referencedColumn);\n          });\n        });\n        return {\n          relationIdAttribute: relationIdAttr,\n          results\n        };\n      }\n    });\n    return Promise.all(promises);\n  }\n\n}","map":{"version":3,"mappings":"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","names":["DriverUtils","TypeORMError","OrmUtils","RelationIdLoader","constructor","connection","queryRunner","relationIdAttributes","load","rawEntities","promises","map","relationIdAttr","relation","isManyToOne","isOneToOneOwner","queryBuilderFactory","duplicates","results","rawEntity","result","duplicateParts","joinColumns","forEach","joinColumn","databaseName","driver","prepareHydratedValue","buildAlias","parentAlias","referencedColumn","duplicatePart","indexOf","push","entityMetadata","primaryColumns","primaryColumn","sort","duplicate","join","filter","v","relationIdAttribute","isOneToMany","isOneToOneNotOwner","isOwning","inverseRelation","table","inverseEntityMetadata","target","tableName","tableAlias","alias","parameters","condition","index","parameterParts","queryPart","parameterName","parameterValue","propertyPath","Object","assign","qb","createQueryBuilder","columns","uniq","column","addSelect","from","where","setParameters","getRawMany","inverseJoinColumns","junctionAlias","inverseSideTableName","joinInverseSideMetadata","inverseSideTableAlias","junctionTableName","junctionEntityMetadata","mappedColumns","reduce","length","joinColumnConditions","mappedColumn","keys","key","s","inverseJoinColumnCondition","addOrderBy","innerJoin","Promise","all"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\query-builder\\relation-id\\RelationIdLoader.ts"],"sourcesContent":["import { RelationIdAttribute } from \"./RelationIdAttribute\"\nimport { DataSource } from \"../../data-source/DataSource\"\nimport { RelationIdLoadResult } from \"./RelationIdLoadResult\"\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { QueryRunner } from \"../../query-runner/QueryRunner\"\nimport { DriverUtils } from \"../../driver/DriverUtils\"\nimport { TypeORMError } from \"../../error/TypeORMError\"\nimport { OrmUtils } from \"../../util/OrmUtils\"\n\nexport class RelationIdLoader {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        protected connection: DataSource,\n        protected queryRunner: QueryRunner | undefined,\n        protected relationIdAttributes: RelationIdAttribute[],\n    ) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    async load(rawEntities: any[]): Promise<RelationIdLoadResult[]> {\n        const promises = this.relationIdAttributes.map(\n            async (relationIdAttr) => {\n                if (\n                    relationIdAttr.relation.isManyToOne ||\n                    relationIdAttr.relation.isOneToOneOwner\n                ) {\n                    // example: Post and Tag\n                    // loadRelationIdAndMap(\"post.tagId\", \"post.tag\")\n                    // we expect it to load id of tag\n\n                    if (relationIdAttr.queryBuilderFactory)\n                        throw new TypeORMError(\n                            \"Additional condition can not be used with ManyToOne or OneToOne owner relations.\",\n                        )\n\n                    const duplicates: { [duplicateKey: string]: boolean } = {}\n                    const results = rawEntities\n                        .map((rawEntity) => {\n                            const result: ObjectLiteral = {}\n                            const duplicateParts: Array<string> = []\n                            relationIdAttr.relation.joinColumns.forEach(\n                                (joinColumn) => {\n                                    result[joinColumn.databaseName] =\n                                        this.connection.driver.prepareHydratedValue(\n                                            rawEntity[\n                                                DriverUtils.buildAlias(\n                                                    this.connection.driver,\n                                                    relationIdAttr.parentAlias,\n                                                    joinColumn.databaseName,\n                                                )\n                                            ],\n                                            joinColumn.referencedColumn!,\n                                        )\n                                    const duplicatePart = `${\n                                        joinColumn.databaseName\n                                    }:${result[joinColumn.databaseName]}`\n                                    if (\n                                        duplicateParts.indexOf(\n                                            duplicatePart,\n                                        ) === -1\n                                    ) {\n                                        duplicateParts.push(duplicatePart)\n                                    }\n                                },\n                            )\n\n                            relationIdAttr.relation.entityMetadata.primaryColumns.forEach(\n                                (primaryColumn) => {\n                                    result[primaryColumn.databaseName] =\n                                        this.connection.driver.prepareHydratedValue(\n                                            rawEntity[\n                                                DriverUtils.buildAlias(\n                                                    this.connection.driver,\n                                                    relationIdAttr.parentAlias,\n                                                    primaryColumn.databaseName,\n                                                )\n                                            ],\n                                            primaryColumn,\n                                        )\n                                    const duplicatePart = `${\n                                        primaryColumn.databaseName\n                                    }:${result[primaryColumn.databaseName]}`\n                                    if (\n                                        duplicateParts.indexOf(\n                                            duplicatePart,\n                                        ) === -1\n                                    ) {\n                                        duplicateParts.push(duplicatePart)\n                                    }\n                                },\n                            )\n\n                            duplicateParts.sort()\n                            const duplicate = duplicateParts.join(\"::\")\n                            if (duplicates[duplicate]) {\n                                return null\n                            }\n                            duplicates[duplicate] = true\n                            return result\n                        })\n                        .filter((v) => v)\n\n                    return {\n                        relationIdAttribute: relationIdAttr,\n                        results: results,\n                    }\n                } else if (\n                    relationIdAttr.relation.isOneToMany ||\n                    relationIdAttr.relation.isOneToOneNotOwner\n                ) {\n                    // example: Post and Category\n                    // loadRelationIdAndMap(\"post.categoryIds\", \"post.categories\")\n                    // we expect it to load array of category ids\n\n                    const relation = relationIdAttr.relation // \"post.categories\"\n                    const joinColumns = relation.isOwning\n                        ? relation.joinColumns\n                        : relation.inverseRelation!.joinColumns\n                    const table = relation.inverseEntityMetadata.target // category\n                    const tableName = relation.inverseEntityMetadata.tableName // category\n                    const tableAlias = relationIdAttr.alias || tableName // if condition (custom query builder factory) is set then relationIdAttr.alias defined\n\n                    const duplicates: { [duplicateKey: string]: boolean } = {}\n                    const parameters: ObjectLiteral = {}\n                    const condition = rawEntities\n                        .map((rawEntity, index) => {\n                            const duplicateParts: Array<string> = []\n                            const parameterParts: ObjectLiteral = {}\n                            const queryPart = joinColumns\n                                .map((joinColumn) => {\n                                    const parameterName =\n                                        joinColumn.databaseName + index\n                                    const parameterValue =\n                                        rawEntity[\n                                            DriverUtils.buildAlias(\n                                                this.connection.driver,\n                                                relationIdAttr.parentAlias,\n                                                joinColumn.referencedColumn!\n                                                    .databaseName,\n                                            )\n                                        ]\n                                    const duplicatePart = `${tableAlias}:${joinColumn.propertyPath}:${parameterValue}`\n                                    if (\n                                        duplicateParts.indexOf(\n                                            duplicatePart,\n                                        ) !== -1\n                                    ) {\n                                        return \"\"\n                                    }\n                                    duplicateParts.push(duplicatePart)\n                                    parameterParts[parameterName] =\n                                        parameterValue\n                                    return (\n                                        tableAlias +\n                                        \".\" +\n                                        joinColumn.propertyPath +\n                                        \" = :\" +\n                                        parameterName\n                                    )\n                                })\n                                .filter((v) => v)\n                                .join(\" AND \")\n                            duplicateParts.sort()\n                            const duplicate = duplicateParts.join(\"::\")\n                            if (duplicates[duplicate]) {\n                                return \"\"\n                            }\n                            duplicates[duplicate] = true\n                            Object.assign(parameters, parameterParts)\n                            return queryPart\n                        })\n                        .filter((v) => v)\n                        .map((condition) => \"(\" + condition + \")\")\n                        .join(\" OR \")\n\n                    // ensure we won't perform redundant queries for joined data which was not found in selection\n                    // example: if post.category was not found in db then no need to execute query for category.imageIds\n                    if (!condition)\n                        return {\n                            relationIdAttribute: relationIdAttr,\n                            results: [],\n                        }\n\n                    // generate query:\n                    // SELECT category.id, category.postId FROM category category ON category.postId = :postId\n                    const qb = this.connection.createQueryBuilder(\n                        this.queryRunner,\n                    )\n\n                    const columns = OrmUtils.uniq(\n                        [\n                            ...joinColumns,\n                            ...relation.inverseRelation!.entityMetadata\n                                .primaryColumns,\n                        ],\n                        (column) => column.propertyPath,\n                    )\n\n                    columns.forEach((joinColumn) => {\n                        qb.addSelect(\n                            tableAlias + \".\" + joinColumn.propertyPath,\n                            joinColumn.databaseName,\n                        )\n                    })\n\n                    qb.from(table, tableAlias)\n                        .where(\"(\" + condition + \")\") // need brackets because if we have additional condition and no brackets, it looks like (a = 1) OR (a = 2) AND b = 1, that is incorrect\n                        .setParameters(parameters)\n\n                    // apply condition (custom query builder factory)\n                    if (relationIdAttr.queryBuilderFactory)\n                        relationIdAttr.queryBuilderFactory(qb)\n\n                    const results = await qb.getRawMany()\n                    results.forEach((result) => {\n                        joinColumns.forEach((column) => {\n                            result[column.databaseName] =\n                                this.connection.driver.prepareHydratedValue(\n                                    result[column.databaseName],\n                                    column.referencedColumn!,\n                                )\n                        })\n                        relation.inverseRelation!.entityMetadata.primaryColumns.forEach(\n                            (column) => {\n                                result[column.databaseName] =\n                                    this.connection.driver.prepareHydratedValue(\n                                        result[column.databaseName],\n                                        column,\n                                    )\n                            },\n                        )\n                    })\n\n                    return {\n                        relationIdAttribute: relationIdAttr,\n                        results,\n                    }\n                } else {\n                    // many-to-many\n                    // example: Post and Category\n                    // owner side: loadRelationIdAndMap(\"post.categoryIds\", \"post.categories\")\n                    // inverse side: loadRelationIdAndMap(\"category.postIds\", \"category.posts\")\n                    // we expect it to load array of post ids\n\n                    const relation = relationIdAttr.relation\n                    const joinColumns = relation.isOwning\n                        ? relation.joinColumns\n                        : relation.inverseRelation!.inverseJoinColumns\n                    const inverseJoinColumns = relation.isOwning\n                        ? relation.inverseJoinColumns\n                        : relation.inverseRelation!.joinColumns\n                    const junctionAlias = relationIdAttr.junctionAlias\n                    const inverseSideTableName =\n                        relationIdAttr.joinInverseSideMetadata.tableName\n                    const inverseSideTableAlias =\n                        relationIdAttr.alias || inverseSideTableName\n                    const junctionTableName = relation.isOwning\n                        ? relation.junctionEntityMetadata!.tableName\n                        : relation.inverseRelation!.junctionEntityMetadata!\n                              .tableName\n\n                    const mappedColumns = rawEntities.map((rawEntity) => {\n                        return joinColumns.reduce((map, joinColumn) => {\n                            map[joinColumn.propertyPath] =\n                                rawEntity[\n                                    DriverUtils.buildAlias(\n                                        this.connection.driver,\n                                        relationIdAttr.parentAlias,\n                                        joinColumn.referencedColumn!\n                                            .databaseName,\n                                    )\n                                ]\n                            return map\n                        }, {} as ObjectLiteral)\n                    })\n\n                    // ensure we won't perform redundant queries for joined data which was not found in selection\n                    // example: if post.category was not found in db then no need to execute query for category.imageIds\n                    if (mappedColumns.length === 0)\n                        return {\n                            relationIdAttribute: relationIdAttr,\n                            results: [],\n                        }\n\n                    const parameters: ObjectLiteral = {}\n                    const duplicates: { [duplicateKey: string]: boolean } = {}\n                    const joinColumnConditions = mappedColumns\n                        .map((mappedColumn, index) => {\n                            const duplicateParts: Array<string> = []\n                            const parameterParts: ObjectLiteral = {}\n                            const queryPart = Object.keys(mappedColumn)\n                                .map((key) => {\n                                    const parameterName = key + index\n                                    const parameterValue = mappedColumn[key]\n                                    const duplicatePart = `${junctionAlias}:${key}:${parameterValue}`\n                                    if (\n                                        duplicateParts.indexOf(\n                                            duplicatePart,\n                                        ) !== -1\n                                    ) {\n                                        return \"\"\n                                    }\n                                    duplicateParts.push(duplicatePart)\n                                    parameterParts[parameterName] =\n                                        parameterValue\n                                    return (\n                                        junctionAlias +\n                                        \".\" +\n                                        key +\n                                        \" = :\" +\n                                        parameterName\n                                    )\n                                })\n                                .filter((s) => s)\n                                .join(\" AND \")\n                            duplicateParts.sort()\n                            const duplicate = duplicateParts.join(\"::\")\n                            if (duplicates[duplicate]) {\n                                return \"\"\n                            }\n                            duplicates[duplicate] = true\n                            Object.assign(parameters, parameterParts)\n                            return queryPart\n                        })\n                        .filter((s) => s)\n\n                    const inverseJoinColumnCondition = inverseJoinColumns\n                        .map((joinColumn) => {\n                            return (\n                                junctionAlias +\n                                \".\" +\n                                joinColumn.propertyPath +\n                                \" = \" +\n                                inverseSideTableAlias +\n                                \".\" +\n                                joinColumn.referencedColumn!.propertyPath\n                            )\n                        })\n                        .join(\" AND \")\n\n                    const condition = joinColumnConditions\n                        .map((condition) => {\n                            return (\n                                \"(\" +\n                                condition +\n                                \" AND \" +\n                                inverseJoinColumnCondition +\n                                \")\"\n                            )\n                        })\n                        .join(\" OR \")\n\n                    const qb = this.connection.createQueryBuilder(\n                        this.queryRunner,\n                    )\n\n                    inverseJoinColumns.forEach((joinColumn) => {\n                        qb.addSelect(\n                            junctionAlias + \".\" + joinColumn.propertyPath,\n                            joinColumn.databaseName,\n                        ).addOrderBy(\n                            junctionAlias + \".\" + joinColumn.propertyPath,\n                        )\n                    })\n\n                    joinColumns.forEach((joinColumn) => {\n                        qb.addSelect(\n                            junctionAlias + \".\" + joinColumn.propertyPath,\n                            joinColumn.databaseName,\n                        ).addOrderBy(\n                            junctionAlias + \".\" + joinColumn.propertyPath,\n                        )\n                    })\n\n                    qb.from(inverseSideTableName, inverseSideTableAlias)\n                        .innerJoin(junctionTableName, junctionAlias, condition)\n                        .setParameters(parameters)\n\n                    // apply condition (custom query builder factory)\n                    if (relationIdAttr.queryBuilderFactory)\n                        relationIdAttr.queryBuilderFactory(qb)\n\n                    const results = await qb.getRawMany()\n                    results.forEach((result) => {\n                        ;[...joinColumns, ...inverseJoinColumns].forEach(\n                            (column) => {\n                                result[column.databaseName] =\n                                    this.connection.driver.prepareHydratedValue(\n                                        result[column.databaseName],\n                                        column.referencedColumn!,\n                                    )\n                            },\n                        )\n                    })\n\n                    return {\n                        relationIdAttribute: relationIdAttr,\n                        results,\n                    }\n                }\n            },\n        )\n\n        return Promise.all(promises)\n    }\n}\n"]},"metadata":{},"sourceType":"module"}