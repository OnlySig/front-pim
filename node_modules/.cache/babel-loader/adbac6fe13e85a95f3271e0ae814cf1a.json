{"ast":null,"code":"import { OrmUtils } from \"../../util/OrmUtils\";\n/**\n * Executes subject operations for materialized-path tree entities.\n */\n\nexport class MaterializedPathSubjectExecutor {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(queryRunner) {\n    this.queryRunner = queryRunner;\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Executes operations when subject is being inserted.\n   */\n\n\n  async insert(subject) {\n    let parent = subject.metadata.treeParentRelation.getEntityValue(subject.entity); // if entity was attached via parent\n\n    if (!parent && subject.parentSubject && subject.parentSubject.entity) // if entity was attached via children\n      parent = subject.parentSubject.insertedValueSet ? subject.parentSubject.insertedValueSet : subject.parentSubject.entity;\n    const parentId = subject.metadata.getEntityIdMap(parent);\n    let parentPath = \"\";\n\n    if (parentId) {\n      parentPath = await this.getEntityPath(subject, parentId);\n    }\n\n    const insertedEntityId = subject.metadata.treeParentRelation.joinColumns.map(joinColumn => {\n      return joinColumn.referencedColumn.getEntityValue(subject.insertedValueSet);\n    }).join(\"_\");\n    await this.queryRunner.manager.createQueryBuilder().update(subject.metadata.target).set({\n      [subject.metadata.materializedPathColumn.propertyPath]: parentPath + insertedEntityId + \".\"\n    }).where(subject.identifier).execute();\n  }\n  /**\n   * Executes operations when subject is being updated.\n   */\n\n\n  async update(subject) {\n    let newParent = subject.metadata.treeParentRelation.getEntityValue(subject.entity); // if entity was attached via parent\n\n    if (!newParent && subject.parentSubject && subject.parentSubject.entity) // if entity was attached via children\n      newParent = subject.parentSubject.entity;\n    let entity = subject.databaseEntity; // if entity was attached via parent\n\n    if (!entity && newParent) // if entity was attached via children\n      entity = subject.metadata.treeChildrenRelation.getEntityValue(newParent).find(child => {\n        return Object.entries(subject.identifier).every(_ref => {\n          let [key, value] = _ref;\n          return child[key] === value;\n        });\n      });\n    const oldParent = subject.metadata.treeParentRelation.getEntityValue(entity);\n    const oldParentId = subject.metadata.getEntityIdMap(oldParent);\n    const newParentId = subject.metadata.getEntityIdMap(newParent); // Exit if the new and old parents are the same\n\n    if (OrmUtils.compareIds(oldParentId, newParentId)) {\n      return;\n    }\n\n    let newParentPath = \"\";\n\n    if (newParentId) {\n      newParentPath = await this.getEntityPath(subject, newParentId);\n    }\n\n    let oldParentPath = \"\";\n\n    if (oldParentId) {\n      oldParentPath = (await this.getEntityPath(subject, oldParentId)) || \"\";\n    }\n\n    const entityPath = subject.metadata.treeParentRelation.joinColumns.map(joinColumn => {\n      return joinColumn.referencedColumn.getEntityValue(entity);\n    }).join(\"_\");\n    const propertyPath = subject.metadata.materializedPathColumn.propertyPath;\n    await this.queryRunner.manager.createQueryBuilder().update(subject.metadata.target).set({\n      [propertyPath]: () => `REPLACE(${propertyPath}, '${oldParentPath}${entityPath}.', '${newParentPath}${entityPath}.')`\n    }).where(`${propertyPath} LIKE :path`, {\n      path: `${oldParentPath}${entityPath}.%`\n    }).execute();\n  }\n\n  getEntityPath(subject, id) {\n    return this.queryRunner.manager.createQueryBuilder().select(subject.metadata.targetName + \".\" + subject.metadata.materializedPathColumn.propertyPath, \"path\").from(subject.metadata.target, subject.metadata.targetName).whereInIds(id).getRawOne().then(result => result ? result[\"path\"] : \"\");\n  }\n\n}","map":{"version":3,"mappings":"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","names":["OrmUtils","MaterializedPathSubjectExecutor","constructor","queryRunner","insert","subject","parent","metadata","treeParentRelation","getEntityValue","entity","parentSubject","insertedValueSet","parentId","getEntityIdMap","parentPath","getEntityPath","insertedEntityId","joinColumns","map","joinColumn","referencedColumn","join","manager","createQueryBuilder","update","target","set","materializedPathColumn","propertyPath","where","identifier","execute","newParent","databaseEntity","treeChildrenRelation","find","child","Object","entries","every","key","value","oldParent","oldParentId","newParentId","compareIds","newParentPath","oldParentPath","entityPath","path","id","select","targetName","from","whereInIds","getRawOne","then","result"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\persistence\\tree\\MaterializedPathSubjectExecutor.ts"],"sourcesContent":["import { Subject } from \"../Subject\"\nimport { QueryRunner } from \"../../query-runner/QueryRunner\"\nimport { OrmUtils } from \"../../util/OrmUtils\"\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\n\n/**\n * Executes subject operations for materialized-path tree entities.\n */\nexport class MaterializedPathSubjectExecutor {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(protected queryRunner: QueryRunner) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Executes operations when subject is being inserted.\n     */\n    async insert(subject: Subject): Promise<void> {\n        let parent = subject.metadata.treeParentRelation!.getEntityValue(\n            subject.entity!,\n        ) // if entity was attached via parent\n        if (!parent && subject.parentSubject && subject.parentSubject.entity)\n            // if entity was attached via children\n            parent = subject.parentSubject.insertedValueSet\n                ? subject.parentSubject.insertedValueSet\n                : subject.parentSubject.entity\n\n        const parentId = subject.metadata.getEntityIdMap(parent)\n\n        let parentPath: string = \"\"\n        if (parentId) {\n            parentPath = await this.getEntityPath(subject, parentId)\n        }\n\n        const insertedEntityId = subject.metadata\n            .treeParentRelation!.joinColumns.map((joinColumn) => {\n                return joinColumn.referencedColumn!.getEntityValue(\n                    subject.insertedValueSet!,\n                )\n            })\n            .join(\"_\")\n\n        await this.queryRunner.manager\n            .createQueryBuilder()\n            .update(subject.metadata.target)\n            .set({\n                [subject.metadata.materializedPathColumn!.propertyPath]:\n                    parentPath + insertedEntityId + \".\",\n            } as any)\n            .where(subject.identifier!)\n            .execute()\n    }\n\n    /**\n     * Executes operations when subject is being updated.\n     */\n    async update(subject: Subject): Promise<void> {\n        let newParent = subject.metadata.treeParentRelation!.getEntityValue(\n            subject.entity!,\n        ) // if entity was attached via parent\n        if (!newParent && subject.parentSubject && subject.parentSubject.entity)\n            // if entity was attached via children\n            newParent = subject.parentSubject.entity\n\n        let entity = subject.databaseEntity // if entity was attached via parent\n        if (!entity && newParent)\n            // if entity was attached via children\n            entity = subject.metadata\n                .treeChildrenRelation!.getEntityValue(newParent)\n                .find((child: any) => {\n                    return Object.entries(subject.identifier!).every(\n                        ([key, value]) => child[key] === value,\n                    )\n                })\n\n        const oldParent = subject.metadata.treeParentRelation!.getEntityValue(\n            entity!,\n        )\n        const oldParentId = subject.metadata.getEntityIdMap(oldParent)\n        const newParentId = subject.metadata.getEntityIdMap(newParent)\n\n        // Exit if the new and old parents are the same\n        if (OrmUtils.compareIds(oldParentId, newParentId)) {\n            return\n        }\n\n        let newParentPath: string = \"\"\n        if (newParentId) {\n            newParentPath = await this.getEntityPath(subject, newParentId)\n        }\n\n        let oldParentPath: string = \"\"\n        if (oldParentId) {\n            oldParentPath =\n                (await this.getEntityPath(subject, oldParentId)) || \"\"\n        }\n\n        const entityPath = subject.metadata\n            .treeParentRelation!.joinColumns.map((joinColumn) => {\n                return joinColumn.referencedColumn!.getEntityValue(entity!)\n            })\n            .join(\"_\")\n\n        const propertyPath =\n            subject.metadata.materializedPathColumn!.propertyPath\n        await this.queryRunner.manager\n            .createQueryBuilder()\n            .update(subject.metadata.target)\n            .set({\n                [propertyPath]: () =>\n                    `REPLACE(${propertyPath}, '${oldParentPath}${entityPath}.', '${newParentPath}${entityPath}.')`,\n            } as any)\n            .where(`${propertyPath} LIKE :path`, {\n                path: `${oldParentPath}${entityPath}.%`,\n            })\n            .execute()\n    }\n\n    private getEntityPath(\n        subject: Subject,\n        id: ObjectLiteral,\n    ): Promise<string> {\n        return this.queryRunner.manager\n            .createQueryBuilder()\n            .select(\n                subject.metadata.targetName +\n                    \".\" +\n                    subject.metadata.materializedPathColumn!.propertyPath,\n                \"path\",\n            )\n            .from(subject.metadata.target, subject.metadata.targetName)\n            .whereInIds(id)\n            .getRawOne()\n            .then((result) => (result ? result[\"path\"] : \"\"))\n    }\n}\n"]},"metadata":{},"sourceType":"module"}