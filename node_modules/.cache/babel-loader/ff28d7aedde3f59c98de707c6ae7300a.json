{"ast":null,"code":"import { CustomRepositoryDoesNotHaveEntityError } from \"../error/CustomRepositoryDoesNotHaveEntityError\";\nimport { getMetadataArgsStorage } from \"../globals\";\nimport { CustomRepositoryNotFoundError } from \"../error/CustomRepositoryNotFoundError\";\n/**\n * Provides abstract class for custom repositories that do not inherit from original orm Repository.\n * Contains all most-necessary methods to simplify code in the custom repository.\n * All methods are protected thus not exposed and it allows to create encapsulated custom repository.\n *\n * @deprecated use Repository.extend function to create a custom repository\n */\n\nexport class AbstractRepository {\n  // -------------------------------------------------------------------------\n  // Protected Accessors\n  // -------------------------------------------------------------------------\n\n  /**\n   * Gets the original ORM repository for the entity that is managed by this repository.\n   * If current repository does not manage any entity, then exception will be thrown.\n   */\n  get repository() {\n    const target = this.getCustomRepositoryTarget(this);\n    if (!target) throw new CustomRepositoryDoesNotHaveEntityError(this.constructor);\n    return this.manager.getRepository(target);\n  }\n  /**\n   * Gets the original ORM tree repository for the entity that is managed by this repository.\n   * If current repository does not manage any entity, then exception will be thrown.\n   */\n\n\n  get treeRepository() {\n    const target = this.getCustomRepositoryTarget(this);\n    if (!target) throw new CustomRepositoryDoesNotHaveEntityError(this.constructor);\n    return this.manager.getTreeRepository(target);\n  } // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Creates a new query builder for the repository's entity that can be used to build a SQL query.\n   * If current repository does not manage any entity, then exception will be thrown.\n   */\n\n\n  createQueryBuilder(alias) {\n    const target = this.getCustomRepositoryTarget(this.constructor);\n    if (!target) throw new CustomRepositoryDoesNotHaveEntityError(this.constructor);\n    return this.manager.getRepository(target).createQueryBuilder(alias);\n  }\n  /**\n   * Creates a new query builder for the given entity that can be used to build a SQL query.\n   */\n\n\n  createQueryBuilderFor(entity, alias) {\n    return this.getRepositoryFor(entity).createQueryBuilder(alias);\n  }\n  /**\n   * Gets the original ORM repository for the given entity class.\n   */\n\n\n  getRepositoryFor(entity) {\n    return this.manager.getRepository(entity);\n  }\n  /**\n   * Gets the original ORM tree repository for the given entity class.\n   */\n\n\n  getTreeRepositoryFor(entity) {\n    return this.manager.getTreeRepository(entity);\n  } // -------------------------------------------------------------------------\n  // Private Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Gets custom repository's managed entity.\n   * If given custom repository does not manage any entity then undefined will be returned.\n   */\n\n\n  getCustomRepositoryTarget(customRepository) {\n    const entityRepositoryMetadataArgs = getMetadataArgsStorage().entityRepositories.find(repository => {\n      return repository.target === (typeof customRepository === \"function\" ? customRepository : customRepository.constructor);\n    });\n    if (!entityRepositoryMetadataArgs) throw new CustomRepositoryNotFoundError(customRepository);\n    return entityRepositoryMetadataArgs.entity;\n  }\n\n}","map":{"version":3,"mappings":"AAMA,SAASA,sCAAT,QAAuD,iDAAvD;AACA,SAASC,sBAAT,QAAuC,YAAvC;AACA,SAASC,6BAAT,QAA8C,wCAA9C;AAGA;;;;;;;;AAOA,OAAM,MAAOC,kBAAP,CAAyB;EAU3B;EACA;EACA;;EAEA;;;;EAIwB,IAAVC,UAAU;IACpB,MAAMC,MAAM,GAAG,KAAKC,yBAAL,CAA+B,IAA/B,CAAf;IACA,IAAI,CAACD,MAAL,EACI,MAAM,IAAIL,sCAAJ,CAA2C,KAAKO,WAAhD,CAAN;IAEJ,OAAO,KAAKC,OAAL,CAAaC,aAAb,CAAmCJ,MAAnC,CAAP;EACH;EAED;;;;;;EAI4B,IAAdK,cAAc;IACxB,MAAML,MAAM,GAAG,KAAKC,yBAAL,CAA+B,IAA/B,CAAf;IACA,IAAI,CAACD,MAAL,EACI,MAAM,IAAIL,sCAAJ,CAA2C,KAAKO,WAAhD,CAAN;IAEJ,OAAO,KAAKC,OAAL,CAAaG,iBAAb,CAAuCN,MAAvC,CAAP;EACH,CApC0B,CAsC3B;EACA;EACA;;EAEA;;;;;;EAIUO,kBAAkB,CAACC,KAAD,EAAc;IACtC,MAAMR,MAAM,GAAG,KAAKC,yBAAL,CAA+B,KAAKC,WAApC,CAAf;IACA,IAAI,CAACF,MAAL,EACI,MAAM,IAAIL,sCAAJ,CAA2C,KAAKO,WAAhD,CAAN;IAEJ,OAAO,KAAKC,OAAL,CACFC,aADE,CACoBJ,MADpB,EAEFO,kBAFE,CAEiBC,KAFjB,CAAP;EAGH;EAED;;;;;EAGUC,qBAAqB,CAC3BC,MAD2B,EAE3BF,KAF2B,EAEd;IAEb,OAAO,KAAKG,gBAAL,CAAsBD,MAAtB,EAA8BH,kBAA9B,CAAiDC,KAAjD,CAAP;EACH;EAED;;;;;EAGUG,gBAAgB,CACtBD,MADsB,EACD;IAErB,OAAO,KAAKP,OAAL,CAAaC,aAAb,CAA2BM,MAA3B,CAAP;EACH;EAED;;;;;EAGUE,oBAAoB,CAC1BF,MAD0B,EACL;IAErB,OAAO,KAAKP,OAAL,CAAaG,iBAAb,CAA+BI,MAA/B,CAAP;EACH,CAlF0B,CAoF3B;EACA;EACA;;EAEA;;;;;;EAIQT,yBAAyB,CAC7BY,gBAD6B,EACR;IAErB,MAAMC,4BAA4B,GAC9BlB,sBAAsB,GAAGmB,kBAAzB,CAA4CC,IAA5C,CAAkDjB,UAAD,IAAe;MAC5D,OACIA,UAAU,CAACC,MAAX,MACC,OAAOa,gBAAP,KAA4B,UAA5B,GACKA,gBADL,GAEMA,gBAAwB,CAACX,WAHhC,CADJ;IAMH,CAPD,CADJ;IASA,IAAI,CAACY,4BAAL,EACI,MAAM,IAAIjB,6BAAJ,CAAkCgB,gBAAlC,CAAN;IAEJ,OAAOC,4BAA4B,CAACJ,MAApC;EACH;;AA5G0B","names":["CustomRepositoryDoesNotHaveEntityError","getMetadataArgsStorage","CustomRepositoryNotFoundError","AbstractRepository","repository","target","getCustomRepositoryTarget","constructor","manager","getRepository","treeRepository","getTreeRepository","createQueryBuilder","alias","createQueryBuilderFor","entity","getRepositoryFor","getTreeRepositoryFor","customRepository","entityRepositoryMetadataArgs","entityRepositories","find"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\repository\\AbstractRepository.ts"],"sourcesContent":["import { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { EntityManager } from \"../entity-manager/EntityManager\"\nimport { Repository } from \"./Repository\"\nimport { TreeRepository } from \"./TreeRepository\"\nimport { EntityTarget } from \"../common/EntityTarget\"\nimport { ObjectType } from \"../common/ObjectType\"\nimport { CustomRepositoryDoesNotHaveEntityError } from \"../error/CustomRepositoryDoesNotHaveEntityError\"\nimport { getMetadataArgsStorage } from \"../globals\"\nimport { CustomRepositoryNotFoundError } from \"../error/CustomRepositoryNotFoundError\"\nimport { SelectQueryBuilder } from \"../query-builder/SelectQueryBuilder\"\n\n/**\n * Provides abstract class for custom repositories that do not inherit from original orm Repository.\n * Contains all most-necessary methods to simplify code in the custom repository.\n * All methods are protected thus not exposed and it allows to create encapsulated custom repository.\n *\n * @deprecated use Repository.extend function to create a custom repository\n */\nexport class AbstractRepository<Entity extends ObjectLiteral> {\n    // -------------------------------------------------------------------------\n    // Protected Methods Set Dynamically\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets entity manager that allows to perform repository operations with any entity.\n     */\n    protected manager: EntityManager\n\n    // -------------------------------------------------------------------------\n    // Protected Accessors\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets the original ORM repository for the entity that is managed by this repository.\n     * If current repository does not manage any entity, then exception will be thrown.\n     */\n    protected get repository(): Repository<Entity> {\n        const target = this.getCustomRepositoryTarget(this as any)\n        if (!target)\n            throw new CustomRepositoryDoesNotHaveEntityError(this.constructor)\n\n        return this.manager.getRepository<Entity>(target)\n    }\n\n    /**\n     * Gets the original ORM tree repository for the entity that is managed by this repository.\n     * If current repository does not manage any entity, then exception will be thrown.\n     */\n    protected get treeRepository(): TreeRepository<Entity> {\n        const target = this.getCustomRepositoryTarget(this as any)\n        if (!target)\n            throw new CustomRepositoryDoesNotHaveEntityError(this.constructor)\n\n        return this.manager.getTreeRepository<Entity>(target)\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates a new query builder for the repository's entity that can be used to build a SQL query.\n     * If current repository does not manage any entity, then exception will be thrown.\n     */\n    protected createQueryBuilder(alias: string): SelectQueryBuilder<Entity> {\n        const target = this.getCustomRepositoryTarget(this.constructor)\n        if (!target)\n            throw new CustomRepositoryDoesNotHaveEntityError(this.constructor)\n\n        return this.manager\n            .getRepository<Entity>(target)\n            .createQueryBuilder(alias)\n    }\n\n    /**\n     * Creates a new query builder for the given entity that can be used to build a SQL query.\n     */\n    protected createQueryBuilderFor<T extends ObjectLiteral>(\n        entity: ObjectType<T>,\n        alias: string,\n    ): SelectQueryBuilder<T> {\n        return this.getRepositoryFor(entity).createQueryBuilder(alias)\n    }\n\n    /**\n     * Gets the original ORM repository for the given entity class.\n     */\n    protected getRepositoryFor<T extends ObjectLiteral>(\n        entity: ObjectType<T>,\n    ): Repository<T> {\n        return this.manager.getRepository(entity)\n    }\n\n    /**\n     * Gets the original ORM tree repository for the given entity class.\n     */\n    protected getTreeRepositoryFor<T extends ObjectLiteral>(\n        entity: ObjectType<T>,\n    ): TreeRepository<T> {\n        return this.manager.getTreeRepository(entity)\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets custom repository's managed entity.\n     * If given custom repository does not manage any entity then undefined will be returned.\n     */\n    private getCustomRepositoryTarget(\n        customRepository: any,\n    ): EntityTarget<any> | undefined {\n        const entityRepositoryMetadataArgs =\n            getMetadataArgsStorage().entityRepositories.find((repository) => {\n                return (\n                    repository.target ===\n                    (typeof customRepository === \"function\"\n                        ? customRepository\n                        : (customRepository as any).constructor)\n                )\n            })\n        if (!entityRepositoryMetadataArgs)\n            throw new CustomRepositoryNotFoundError(customRepository)\n\n        return entityRepositoryMetadataArgs.entity\n    }\n}\n"]},"metadata":{},"sourceType":"module"}