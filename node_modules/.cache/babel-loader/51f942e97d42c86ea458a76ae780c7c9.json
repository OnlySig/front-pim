{"ast":null,"code":"import { PlatformTools } from \"../platform/PlatformTools\";\nimport { TypeORMError } from \"../error/TypeORMError\";\n/**\n * Caches query result into Redis database.\n */\n\nexport class RedisQueryResultCache {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection, clientType) {\n    this.connection = connection;\n    this.clientType = clientType;\n    this.redis = this.loadRedis();\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Creates a connection with given cache provider.\n   */\n\n\n  async connect() {\n    const cacheOptions = this.connection.options.cache;\n\n    if (this.clientType === \"redis\") {\n      this.client = this.redis.createClient({ ...(cacheOptions === null || cacheOptions === void 0 ? void 0 : cacheOptions.options),\n        legacyMode: true\n      });\n\n      if (typeof this.connection.options.cache === \"object\" && this.connection.options.cache.ignoreErrors) {\n        this.client.on(\"error\", err => {\n          this.connection.logger.log(\"warn\", err);\n        });\n      }\n\n      if (\"connect\" in this.client) {\n        await this.client.connect();\n      }\n    } else if (this.clientType === \"ioredis\") {\n      if (cacheOptions && cacheOptions.port) {\n        if (cacheOptions.options) {\n          this.client = new this.redis(cacheOptions.port, cacheOptions.options);\n        } else {\n          this.client = new this.redis(cacheOptions.port);\n        }\n      } else if (cacheOptions && cacheOptions.options) {\n        this.client = new this.redis(cacheOptions.options);\n      } else {\n        this.client = new this.redis();\n      }\n    } else if (this.clientType === \"ioredis/cluster\") {\n      if (cacheOptions && cacheOptions.options && Array.isArray(cacheOptions.options)) {\n        this.client = new this.redis.Cluster(cacheOptions.options);\n      } else if (cacheOptions && cacheOptions.options && cacheOptions.options.startupNodes) {\n        this.client = new this.redis.Cluster(cacheOptions.options.startupNodes, cacheOptions.options.options);\n      } else {\n        throw new TypeORMError(`options.startupNodes required for ${this.clientType}.`);\n      }\n    }\n  }\n  /**\n   * Disconnects the connection\n   */\n\n\n  async disconnect() {\n    return new Promise((ok, fail) => {\n      this.client.quit((err, result) => {\n        if (err) return fail(err);\n        ok();\n        this.client = undefined;\n      });\n    });\n  }\n  /**\n   * Creates table for storing cache if it does not exist yet.\n   */\n\n\n  async synchronize(queryRunner) {}\n  /**\n   * Caches given query result.\n   * Returns cache result if found.\n   * Returns undefined if result is not cached.\n   */\n\n\n  getFromCache(options, queryRunner) {\n    return new Promise((ok, fail) => {\n      if (options.identifier) {\n        this.client.get(options.identifier, (err, result) => {\n          if (err) return fail(err);\n          ok(JSON.parse(result));\n        });\n      } else if (options.query) {\n        this.client.get(options.query, (err, result) => {\n          if (err) return fail(err);\n          ok(JSON.parse(result));\n        });\n      } else {\n        ok(undefined);\n      }\n    });\n  }\n  /**\n   * Checks if cache is expired or not.\n   */\n\n\n  isExpired(savedCache) {\n    return savedCache.time + savedCache.duration < new Date().getTime();\n  }\n  /**\n   * Stores given query result in the cache.\n   */\n\n\n  async storeInCache(options, savedCache, queryRunner) {\n    return new Promise((ok, fail) => {\n      if (options.identifier) {\n        this.client.set(options.identifier, JSON.stringify(options), \"PX\", options.duration, (err, result) => {\n          if (err) return fail(err);\n          ok();\n        });\n      } else if (options.query) {\n        this.client.set(options.query, JSON.stringify(options), \"PX\", options.duration, (err, result) => {\n          if (err) return fail(err);\n          ok();\n        });\n      }\n    });\n  }\n  /**\n   * Clears everything stored in the cache.\n   */\n\n\n  async clear(queryRunner) {\n    return new Promise((ok, fail) => {\n      this.client.flushdb((err, result) => {\n        if (err) return fail(err);\n        ok();\n      });\n    });\n  }\n  /**\n   * Removes all cached results by given identifiers from cache.\n   */\n\n\n  async remove(identifiers, queryRunner) {\n    await Promise.all(identifiers.map(identifier => {\n      return this.deleteKey(identifier);\n    }));\n  } // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Removes a single key from redis database.\n   */\n\n\n  deleteKey(key) {\n    return new Promise((ok, fail) => {\n      this.client.del(key, (err, result) => {\n        if (err) return fail(err);\n        ok();\n      });\n    });\n  }\n  /**\n   * Loads redis dependency.\n   */\n\n\n  loadRedis() {\n    try {\n      if (this.clientType === \"ioredis/cluster\") {\n        return PlatformTools.load(\"ioredis\");\n      } else {\n        return PlatformTools.load(this.clientType);\n      }\n    } catch (e) {\n      throw new TypeORMError(`Cannot use cache because ${this.clientType} is not installed. Please run \"npm i ${this.clientType} --save\".`);\n    }\n  }\n\n}","map":{"version":3,"mappings":"AAEA,SAASA,aAAT,QAA8B,2BAA9B;AAGA,SAASC,YAAT,QAA6B,uBAA7B;AAEA;;;;AAGA,OAAM,MAAOC,qBAAP,CAA4B;EAoB9B;EACA;EACA;EAEAC,YACcC,UADd,EAEIC,UAFJ,EAEuD;IADzC;IAGV,KAAKA,UAAL,GAAkBA,UAAlB;IACA,KAAKC,KAAL,GAAa,KAAKC,SAAL,EAAb;EACH,CA9B6B,CAgC9B;EACA;EACA;;EAEA;;;;;EAGa,MAAPC,OAAO;IACT,MAAMC,YAAY,GAAQ,KAAKL,UAAL,CAAgBM,OAAhB,CAAwBC,KAAlD;;IACA,IAAI,KAAKN,UAAL,KAAoB,OAAxB,EAAiC;MAC7B,KAAKO,MAAL,GAAc,KAAKN,KAAL,CAAWO,YAAX,CAAwB,EAClC,IAAGJ,YAAY,SAAZ,gBAAY,WAAZ,GAAY,MAAZ,eAAY,CAAEC,OAAjB,CADkC;QAElCI,UAAU,EAAE;MAFsB,CAAxB,CAAd;;MAIA,IACI,OAAO,KAAKV,UAAL,CAAgBM,OAAhB,CAAwBC,KAA/B,KAAyC,QAAzC,IACA,KAAKP,UAAL,CAAgBM,OAAhB,CAAwBC,KAAxB,CAA8BI,YAFlC,EAGE;QACE,KAAKH,MAAL,CAAYI,EAAZ,CAAe,OAAf,EAAyBC,GAAD,IAAa;UACjC,KAAKb,UAAL,CAAgBc,MAAhB,CAAuBC,GAAvB,CAA2B,MAA3B,EAAmCF,GAAnC;QACH,CAFD;MAGH;;MACD,IAAI,aAAa,KAAKL,MAAtB,EAA8B;QAC1B,MAAM,KAAKA,MAAL,CAAYJ,OAAZ,EAAN;MACH;IACJ,CAhBD,MAgBO,IAAI,KAAKH,UAAL,KAAoB,SAAxB,EAAmC;MACtC,IAAII,YAAY,IAAIA,YAAY,CAACW,IAAjC,EAAuC;QACnC,IAAIX,YAAY,CAACC,OAAjB,EAA0B;UACtB,KAAKE,MAAL,GAAc,IAAI,KAAKN,KAAT,CACVG,YAAY,CAACW,IADH,EAEVX,YAAY,CAACC,OAFH,CAAd;QAIH,CALD,MAKO;UACH,KAAKE,MAAL,GAAc,IAAI,KAAKN,KAAT,CAAeG,YAAY,CAACW,IAA5B,CAAd;QACH;MACJ,CATD,MASO,IAAIX,YAAY,IAAIA,YAAY,CAACC,OAAjC,EAA0C;QAC7C,KAAKE,MAAL,GAAc,IAAI,KAAKN,KAAT,CAAeG,YAAY,CAACC,OAA5B,CAAd;MACH,CAFM,MAEA;QACH,KAAKE,MAAL,GAAc,IAAI,KAAKN,KAAT,EAAd;MACH;IACJ,CAfM,MAeA,IAAI,KAAKD,UAAL,KAAoB,iBAAxB,EAA2C;MAC9C,IACII,YAAY,IACZA,YAAY,CAACC,OADb,IAEAW,KAAK,CAACC,OAAN,CAAcb,YAAY,CAACC,OAA3B,CAHJ,EAIE;QACE,KAAKE,MAAL,GAAc,IAAI,KAAKN,KAAL,CAAWiB,OAAf,CAAuBd,YAAY,CAACC,OAApC,CAAd;MACH,CAND,MAMO,IACHD,YAAY,IACZA,YAAY,CAACC,OADb,IAEAD,YAAY,CAACC,OAAb,CAAqBc,YAHlB,EAIL;QACE,KAAKZ,MAAL,GAAc,IAAI,KAAKN,KAAL,CAAWiB,OAAf,CACVd,YAAY,CAACC,OAAb,CAAqBc,YADX,EAEVf,YAAY,CAACC,OAAb,CAAqBA,OAFX,CAAd;MAIH,CATM,MASA;QACH,MAAM,IAAIT,YAAJ,CACF,qCAAqC,KAAKI,UAAU,GADlD,CAAN;MAGH;IACJ;EACJ;EAED;;;;;EAGgB,MAAVoB,UAAU;IACZ,OAAO,IAAIC,OAAJ,CAAkB,CAACC,EAAD,EAAKC,IAAL,KAAa;MAClC,KAAKhB,MAAL,CAAYiB,IAAZ,CAAiB,CAACZ,GAAD,EAAWa,MAAX,KAA0B;QACvC,IAAIb,GAAJ,EAAS,OAAOW,IAAI,CAACX,GAAD,CAAX;QACTU,EAAE;QACF,KAAKf,MAAL,GAAcmB,SAAd;MACH,CAJD;IAKH,CANM,CAAP;EAOH;EAED;;;;;EAGiB,MAAXC,WAAW,CAACC,WAAD,EAAyB,CAAmB;EAE7D;;;;;;;EAKAC,YAAY,CACRxB,OADQ,EAERuB,WAFQ,EAEiB;IAEzB,OAAO,IAAIP,OAAJ,CAAiD,CAACC,EAAD,EAAKC,IAAL,KAAa;MACjE,IAAIlB,OAAO,CAACyB,UAAZ,EAAwB;QACpB,KAAKvB,MAAL,CAAYwB,GAAZ,CAAgB1B,OAAO,CAACyB,UAAxB,EAAoC,CAAClB,GAAD,EAAWa,MAAX,KAA0B;UAC1D,IAAIb,GAAJ,EAAS,OAAOW,IAAI,CAACX,GAAD,CAAX;UACTU,EAAE,CAACU,IAAI,CAACC,KAAL,CAAWR,MAAX,CAAD,CAAF;QACH,CAHD;MAIH,CALD,MAKO,IAAIpB,OAAO,CAAC6B,KAAZ,EAAmB;QACtB,KAAK3B,MAAL,CAAYwB,GAAZ,CAAgB1B,OAAO,CAAC6B,KAAxB,EAA+B,CAACtB,GAAD,EAAWa,MAAX,KAA0B;UACrD,IAAIb,GAAJ,EAAS,OAAOW,IAAI,CAACX,GAAD,CAAX;UACTU,EAAE,CAACU,IAAI,CAACC,KAAL,CAAWR,MAAX,CAAD,CAAF;QACH,CAHD;MAIH,CALM,MAKA;QACHH,EAAE,CAACI,SAAD,CAAF;MACH;IACJ,CAdM,CAAP;EAeH;EAED;;;;;EAGAS,SAAS,CAACC,UAAD,EAAoC;IACzC,OAAOA,UAAU,CAACC,IAAX,GAAmBD,UAAU,CAACE,QAA9B,GAAyC,IAAIC,IAAJ,GAAWC,OAAX,EAAhD;EACH;EAED;;;;;EAGkB,MAAZC,YAAY,CACdpC,OADc,EAEd+B,UAFc,EAGdR,WAHc,EAGW;IAEzB,OAAO,IAAIP,OAAJ,CAAkB,CAACC,EAAD,EAAKC,IAAL,KAAa;MAClC,IAAIlB,OAAO,CAACyB,UAAZ,EAAwB;QACpB,KAAKvB,MAAL,CAAYmC,GAAZ,CACIrC,OAAO,CAACyB,UADZ,EAEIE,IAAI,CAACW,SAAL,CAAetC,OAAf,CAFJ,EAGI,IAHJ,EAIIA,OAAO,CAACiC,QAJZ,EAKI,CAAC1B,GAAD,EAAWa,MAAX,KAA0B;UACtB,IAAIb,GAAJ,EAAS,OAAOW,IAAI,CAACX,GAAD,CAAX;UACTU,EAAE;QACL,CARL;MAUH,CAXD,MAWO,IAAIjB,OAAO,CAAC6B,KAAZ,EAAmB;QACtB,KAAK3B,MAAL,CAAYmC,GAAZ,CACIrC,OAAO,CAAC6B,KADZ,EAEIF,IAAI,CAACW,SAAL,CAAetC,OAAf,CAFJ,EAGI,IAHJ,EAIIA,OAAO,CAACiC,QAJZ,EAKI,CAAC1B,GAAD,EAAWa,MAAX,KAA0B;UACtB,IAAIb,GAAJ,EAAS,OAAOW,IAAI,CAACX,GAAD,CAAX;UACTU,EAAE;QACL,CARL;MAUH;IACJ,CAxBM,CAAP;EAyBH;EAED;;;;;EAGW,MAALsB,KAAK,CAAChB,WAAD,EAA0B;IACjC,OAAO,IAAIP,OAAJ,CAAkB,CAACC,EAAD,EAAKC,IAAL,KAAa;MAClC,KAAKhB,MAAL,CAAYsC,OAAZ,CAAoB,CAACjC,GAAD,EAAWa,MAAX,KAA0B;QAC1C,IAAIb,GAAJ,EAAS,OAAOW,IAAI,CAACX,GAAD,CAAX;QACTU,EAAE;MACL,CAHD;IAIH,CALM,CAAP;EAMH;EAED;;;;;EAGY,MAANwB,MAAM,CACRC,WADQ,EAERnB,WAFQ,EAEiB;IAEzB,MAAMP,OAAO,CAAC2B,GAAR,CACFD,WAAW,CAACE,GAAZ,CAAiBnB,UAAD,IAAe;MAC3B,OAAO,KAAKoB,SAAL,CAAepB,UAAf,CAAP;IACH,CAFD,CADE,CAAN;EAKH,CA9M6B,CAgN9B;EACA;EACA;;EAEA;;;;;EAGUoB,SAAS,CAACC,GAAD,EAAY;IAC3B,OAAO,IAAI9B,OAAJ,CAAkB,CAACC,EAAD,EAAKC,IAAL,KAAa;MAClC,KAAKhB,MAAL,CAAY6C,GAAZ,CAAgBD,GAAhB,EAAqB,CAACvC,GAAD,EAAWa,MAAX,KAA0B;QAC3C,IAAIb,GAAJ,EAAS,OAAOW,IAAI,CAACX,GAAD,CAAX;QACTU,EAAE;MACL,CAHD;IAIH,CALM,CAAP;EAMH;EAED;;;;;EAGUpB,SAAS;IACf,IAAI;MACA,IAAI,KAAKF,UAAL,KAAoB,iBAAxB,EAA2C;QACvC,OAAOL,aAAa,CAAC0D,IAAd,CAAmB,SAAnB,CAAP;MACH,CAFD,MAEO;QACH,OAAO1D,aAAa,CAAC0D,IAAd,CAAmB,KAAKrD,UAAxB,CAAP;MACH;IACJ,CAND,CAME,OAAOsD,CAAP,EAAU;MACR,MAAM,IAAI1D,YAAJ,CACF,4BAA4B,KAAKI,UAAU,wCAAwC,KAAKA,UAAU,WADhG,CAAN;IAGH;EACJ;;AA/O6B","names":["PlatformTools","TypeORMError","RedisQueryResultCache","constructor","connection","clientType","redis","loadRedis","connect","cacheOptions","options","cache","client","createClient","legacyMode","ignoreErrors","on","err","logger","log","port","Array","isArray","Cluster","startupNodes","disconnect","Promise","ok","fail","quit","result","undefined","synchronize","queryRunner","getFromCache","identifier","get","JSON","parse","query","isExpired","savedCache","time","duration","Date","getTime","storeInCache","set","stringify","clear","flushdb","remove","identifiers","all","map","deleteKey","key","del","load","e"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\cache\\RedisQueryResultCache.ts"],"sourcesContent":["import { QueryResultCache } from \"./QueryResultCache\"\nimport { QueryResultCacheOptions } from \"./QueryResultCacheOptions\"\nimport { PlatformTools } from \"../platform/PlatformTools\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\nimport { TypeORMError } from \"../error/TypeORMError\"\n\n/**\n * Caches query result into Redis database.\n */\nexport class RedisQueryResultCache implements QueryResultCache {\n    // -------------------------------------------------------------------------\n    // Protected Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Redis module instance loaded dynamically.\n     */\n    protected redis: any\n\n    /**\n     * Connected redis client.\n     */\n    protected client: any\n\n    /**\n     * Type of the Redis Client (redis or ioredis).\n     */\n    protected clientType: \"redis\" | \"ioredis\" | \"ioredis/cluster\"\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        protected connection: DataSource,\n        clientType: \"redis\" | \"ioredis\" | \"ioredis/cluster\",\n    ) {\n        this.clientType = clientType\n        this.redis = this.loadRedis()\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates a connection with given cache provider.\n     */\n    async connect(): Promise<void> {\n        const cacheOptions: any = this.connection.options.cache\n        if (this.clientType === \"redis\") {\n            this.client = this.redis.createClient({\n                ...cacheOptions?.options,\n                legacyMode: true,\n            })\n            if (\n                typeof this.connection.options.cache === \"object\" &&\n                this.connection.options.cache.ignoreErrors\n            ) {\n                this.client.on(\"error\", (err: any) => {\n                    this.connection.logger.log(\"warn\", err)\n                })\n            }\n            if (\"connect\" in this.client) {\n                await this.client.connect()\n            }\n        } else if (this.clientType === \"ioredis\") {\n            if (cacheOptions && cacheOptions.port) {\n                if (cacheOptions.options) {\n                    this.client = new this.redis(\n                        cacheOptions.port,\n                        cacheOptions.options,\n                    )\n                } else {\n                    this.client = new this.redis(cacheOptions.port)\n                }\n            } else if (cacheOptions && cacheOptions.options) {\n                this.client = new this.redis(cacheOptions.options)\n            } else {\n                this.client = new this.redis()\n            }\n        } else if (this.clientType === \"ioredis/cluster\") {\n            if (\n                cacheOptions &&\n                cacheOptions.options &&\n                Array.isArray(cacheOptions.options)\n            ) {\n                this.client = new this.redis.Cluster(cacheOptions.options)\n            } else if (\n                cacheOptions &&\n                cacheOptions.options &&\n                cacheOptions.options.startupNodes\n            ) {\n                this.client = new this.redis.Cluster(\n                    cacheOptions.options.startupNodes,\n                    cacheOptions.options.options,\n                )\n            } else {\n                throw new TypeORMError(\n                    `options.startupNodes required for ${this.clientType}.`,\n                )\n            }\n        }\n    }\n\n    /**\n     * Disconnects the connection\n     */\n    async disconnect(): Promise<void> {\n        return new Promise<void>((ok, fail) => {\n            this.client.quit((err: any, result: any) => {\n                if (err) return fail(err)\n                ok()\n                this.client = undefined\n            })\n        })\n    }\n\n    /**\n     * Creates table for storing cache if it does not exist yet.\n     */\n    async synchronize(queryRunner: QueryRunner): Promise<void> {}\n\n    /**\n     * Caches given query result.\n     * Returns cache result if found.\n     * Returns undefined if result is not cached.\n     */\n    getFromCache(\n        options: QueryResultCacheOptions,\n        queryRunner?: QueryRunner,\n    ): Promise<QueryResultCacheOptions | undefined> {\n        return new Promise<QueryResultCacheOptions | undefined>((ok, fail) => {\n            if (options.identifier) {\n                this.client.get(options.identifier, (err: any, result: any) => {\n                    if (err) return fail(err)\n                    ok(JSON.parse(result))\n                })\n            } else if (options.query) {\n                this.client.get(options.query, (err: any, result: any) => {\n                    if (err) return fail(err)\n                    ok(JSON.parse(result))\n                })\n            } else {\n                ok(undefined)\n            }\n        })\n    }\n\n    /**\n     * Checks if cache is expired or not.\n     */\n    isExpired(savedCache: QueryResultCacheOptions): boolean {\n        return savedCache.time! + savedCache.duration < new Date().getTime()\n    }\n\n    /**\n     * Stores given query result in the cache.\n     */\n    async storeInCache(\n        options: QueryResultCacheOptions,\n        savedCache: QueryResultCacheOptions,\n        queryRunner?: QueryRunner,\n    ): Promise<void> {\n        return new Promise<void>((ok, fail) => {\n            if (options.identifier) {\n                this.client.set(\n                    options.identifier,\n                    JSON.stringify(options),\n                    \"PX\",\n                    options.duration,\n                    (err: any, result: any) => {\n                        if (err) return fail(err)\n                        ok()\n                    },\n                )\n            } else if (options.query) {\n                this.client.set(\n                    options.query,\n                    JSON.stringify(options),\n                    \"PX\",\n                    options.duration,\n                    (err: any, result: any) => {\n                        if (err) return fail(err)\n                        ok()\n                    },\n                )\n            }\n        })\n    }\n\n    /**\n     * Clears everything stored in the cache.\n     */\n    async clear(queryRunner?: QueryRunner): Promise<void> {\n        return new Promise<void>((ok, fail) => {\n            this.client.flushdb((err: any, result: any) => {\n                if (err) return fail(err)\n                ok()\n            })\n        })\n    }\n\n    /**\n     * Removes all cached results by given identifiers from cache.\n     */\n    async remove(\n        identifiers: string[],\n        queryRunner?: QueryRunner,\n    ): Promise<void> {\n        await Promise.all(\n            identifiers.map((identifier) => {\n                return this.deleteKey(identifier)\n            }),\n        )\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Removes a single key from redis database.\n     */\n    protected deleteKey(key: string): Promise<void> {\n        return new Promise<void>((ok, fail) => {\n            this.client.del(key, (err: any, result: any) => {\n                if (err) return fail(err)\n                ok()\n            })\n        })\n    }\n\n    /**\n     * Loads redis dependency.\n     */\n    protected loadRedis(): any {\n        try {\n            if (this.clientType === \"ioredis/cluster\") {\n                return PlatformTools.load(\"ioredis\")\n            } else {\n                return PlatformTools.load(this.clientType)\n            }\n        } catch (e) {\n            throw new TypeORMError(\n                `Cannot use cache because ${this.clientType} is not installed. Please run \"npm i ${this.clientType} --save\".`,\n            )\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}