{"ast":null,"code":"import { MetadataArgsStorage } from \"./metadata-args/MetadataArgsStorage\";\nimport { PlatformTools } from \"./platform/PlatformTools\";\nimport { ConnectionOptionsReader } from \"./connection/ConnectionOptionsReader\";\nimport { ConnectionManager } from \"./connection/ConnectionManager\";\nimport { getFromContainer } from \"./container\";\nimport { ObjectUtils } from \"./util/ObjectUtils\";\n/**\n * Gets metadata args storage.\n */\n\nexport function getMetadataArgsStorage() {\n  // we should store metadata storage in a global variable otherwise it brings too much problems\n  // one of the problem is that if any entity (or any other) will be imported before consumer will call\n  // useContainer method with his own container implementation, that entity will be registered in the\n  // old old container (default one post probably) and consumer will his entity.\n  // calling useContainer before he imports any entity (or any other) is not always convenient.\n  // another reason is that when we run migrations typeorm is being called from a global package\n  // and it may load entities which register decorators in typeorm of local package\n  // this leads to impossibility of usage of entities in migrations and cli related operations\n  const globalScope = PlatformTools.getGlobalVariable();\n  if (!globalScope.typeormMetadataArgsStorage) globalScope.typeormMetadataArgsStorage = new MetadataArgsStorage();\n  return globalScope.typeormMetadataArgsStorage;\n}\n/**\n * Reads connection options stored in ormconfig configuration file.\n *\n * @deprecated\n */\n\nexport async function getConnectionOptions() {\n  let connectionName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"default\";\n  return new ConnectionOptionsReader().get(connectionName);\n}\n/**\n * Gets a ConnectionManager which creates connections.\n *\n * @deprecated\n */\n\nexport function getConnectionManager() {\n  return getFromContainer(ConnectionManager);\n}\n/**\n * Creates a new connection and registers it in the manager.\n *\n * If connection options were not specified, then it will try to create connection automatically,\n * based on content of ormconfig (json/js/yml/xml/env) file or environment variables.\n * Only one connection from ormconfig will be created (name \"default\" or connection without name).\n *\n * @deprecated\n */\n\nexport async function createConnection(optionsOrName) {\n  const connectionName = typeof optionsOrName === \"string\" ? optionsOrName : \"default\";\n  const options = ObjectUtils.isObject(optionsOrName) ? optionsOrName : await getConnectionOptions(connectionName);\n  return getConnectionManager().create(options).connect();\n}\n/**\n * Creates new connections and registers them in the manager.\n *\n * If connection options were not specified, then it will try to create connection automatically,\n * based on content of ormconfig (json/js/yml/xml/env) file or environment variables.\n * All connections from the ormconfig will be created.\n *\n * @deprecated\n */\n\nexport async function createConnections(options) {\n  if (!options) options = await new ConnectionOptionsReader().all();\n  const connections = options.map(options => getConnectionManager().create(options)); // Do not use Promise.all or test 8522 will produce a dangling sqlite connection\n\n  for (const connection of connections) {\n    await connection.connect();\n  }\n\n  return connections;\n}\n/**\n * Gets connection from the connection manager.\n * If connection name wasn't specified, then \"default\" connection will be retrieved.\n *\n * @deprecated\n */\n\nexport function getConnection() {\n  let connectionName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"default\";\n  return getConnectionManager().get(connectionName);\n}\n/**\n * Gets entity manager from the connection.\n * If connection name wasn't specified, then \"default\" connection will be retrieved.\n *\n * @deprecated\n */\n\nexport function getManager() {\n  let connectionName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"default\";\n  return getConnectionManager().get(connectionName).manager;\n}\n/**\n * Gets MongoDB entity manager from the connection.\n * If connection name wasn't specified, then \"default\" connection will be retrieved.\n *\n * @deprecated\n */\n\nexport function getMongoManager() {\n  let connectionName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"default\";\n  return getConnectionManager().get(connectionName).manager;\n}\n/**\n * Gets Sqljs entity manager from connection name.\n * \"default\" connection is used, when no name is specified.\n * Only works when Sqljs driver is used.\n *\n * @deprecated\n */\n\nexport function getSqljsManager() {\n  let connectionName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"default\";\n  return getConnectionManager().get(connectionName).manager;\n}\n/**\n * Gets repository for the given entity class.\n *\n * @deprecated\n */\n\nexport function getRepository(entityClass) {\n  let connectionName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"default\";\n  return getConnectionManager().get(connectionName).getRepository(entityClass);\n}\n/**\n * Gets tree repository for the given entity class.\n *\n * @deprecated\n */\n\nexport function getTreeRepository(entityClass) {\n  let connectionName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"default\";\n  return getConnectionManager().get(connectionName).getTreeRepository(entityClass);\n}\n/**\n * Gets tree repository for the given entity class.\n *\n * @deprecated\n */\n\nexport function getCustomRepository(customRepository) {\n  let connectionName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"default\";\n  return getConnectionManager().get(connectionName).getCustomRepository(customRepository);\n}\n/**\n * Gets mongodb repository for the given entity class or name.\n *\n * @deprecated\n */\n\nexport function getMongoRepository(entityClass) {\n  let connectionName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"default\";\n  return getConnectionManager().get(connectionName).getMongoRepository(entityClass);\n}\n/**\n * Creates a new query builder.\n *\n * @deprecated\n */\n\nexport function createQueryBuilder(entityClass, alias) {\n  let connectionName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"default\";\n\n  if (entityClass) {\n    return getRepository(entityClass, connectionName).createQueryBuilder(alias);\n  }\n\n  return getConnection(connectionName).createQueryBuilder();\n}","map":{"version":3,"mappings":"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","names":["MetadataArgsStorage","PlatformTools","ConnectionOptionsReader","ConnectionManager","getFromContainer","ObjectUtils","getMetadataArgsStorage","globalScope","getGlobalVariable","typeormMetadataArgsStorage","getConnectionOptions","connectionName","get","getConnectionManager","createConnection","optionsOrName","options","isObject","create","connect","createConnections","all","connections","map","connection","getConnection","getManager","manager","getMongoManager","getSqljsManager","getRepository","entityClass","getTreeRepository","getCustomRepository","customRepository","getMongoRepository","createQueryBuilder","alias"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\globals.ts"],"sourcesContent":["import { MetadataArgsStorage } from \"./metadata-args/MetadataArgsStorage\"\nimport { PlatformTools } from \"./platform/PlatformTools\"\nimport { DataSourceOptions } from \"./data-source/DataSourceOptions\"\nimport { ConnectionOptionsReader } from \"./connection/ConnectionOptionsReader\"\nimport { ConnectionManager } from \"./connection/ConnectionManager\"\nimport { getFromContainer } from \"./container\"\nimport { DataSource } from \"./data-source/DataSource\"\nimport { EntityManager } from \"./entity-manager/EntityManager\"\nimport { MongoEntityManager } from \"./entity-manager/MongoEntityManager\"\nimport { SqljsEntityManager } from \"./entity-manager/SqljsEntityManager\"\nimport { EntityTarget } from \"./common/EntityTarget\"\nimport { Repository } from \"./repository/Repository\"\nimport { TreeRepository } from \"./repository/TreeRepository\"\nimport { ObjectType } from \"./common/ObjectType\"\nimport { MongoRepository } from \"./repository/MongoRepository\"\nimport { SelectQueryBuilder } from \"./query-builder/SelectQueryBuilder\"\nimport { ObjectUtils } from \"./util/ObjectUtils\"\nimport { ObjectLiteral } from \"./common/ObjectLiteral\"\n\n/**\n * Gets metadata args storage.\n */\nexport function getMetadataArgsStorage(): MetadataArgsStorage {\n    // we should store metadata storage in a global variable otherwise it brings too much problems\n    // one of the problem is that if any entity (or any other) will be imported before consumer will call\n    // useContainer method with his own container implementation, that entity will be registered in the\n    // old old container (default one post probably) and consumer will his entity.\n    // calling useContainer before he imports any entity (or any other) is not always convenient.\n    // another reason is that when we run migrations typeorm is being called from a global package\n    // and it may load entities which register decorators in typeorm of local package\n    // this leads to impossibility of usage of entities in migrations and cli related operations\n    const globalScope = PlatformTools.getGlobalVariable()\n    if (!globalScope.typeormMetadataArgsStorage)\n        globalScope.typeormMetadataArgsStorage = new MetadataArgsStorage()\n\n    return globalScope.typeormMetadataArgsStorage\n}\n\n/**\n * Reads connection options stored in ormconfig configuration file.\n *\n * @deprecated\n */\nexport async function getConnectionOptions(\n    connectionName: string = \"default\",\n): Promise<DataSourceOptions> {\n    return new ConnectionOptionsReader().get(connectionName)\n}\n\n/**\n * Gets a ConnectionManager which creates connections.\n *\n * @deprecated\n */\nexport function getConnectionManager(): ConnectionManager {\n    return getFromContainer(ConnectionManager)\n}\n\n/**\n * Creates a new connection and registers it in the manager.\n * Only one connection from ormconfig will be created (name \"default\" or connection without name).\n *\n * @deprecated\n */\nexport async function createConnection(): Promise<DataSource>\n\n/**\n * Creates a new connection from the ormconfig file with a given name.\n *\n * @deprecated\n */\nexport async function createConnection(name: string): Promise<DataSource>\n\n/**\n * Creates a new connection and registers it in the manager.\n *\n * @deprecated\n */\nexport async function createConnection(\n    options: DataSourceOptions,\n): Promise<DataSource>\n\n/**\n * Creates a new connection and registers it in the manager.\n *\n * If connection options were not specified, then it will try to create connection automatically,\n * based on content of ormconfig (json/js/yml/xml/env) file or environment variables.\n * Only one connection from ormconfig will be created (name \"default\" or connection without name).\n *\n * @deprecated\n */\nexport async function createConnection(\n    optionsOrName?: any,\n): Promise<DataSource> {\n    const connectionName =\n        typeof optionsOrName === \"string\" ? optionsOrName : \"default\"\n    const options = ObjectUtils.isObject(optionsOrName)\n        ? (optionsOrName as DataSourceOptions)\n        : await getConnectionOptions(connectionName)\n    return getConnectionManager().create(options).connect()\n}\n\n/**\n * Creates new connections and registers them in the manager.\n *\n * If connection options were not specified, then it will try to create connection automatically,\n * based on content of ormconfig (json/js/yml/xml/env) file or environment variables.\n * All connections from the ormconfig will be created.\n *\n * @deprecated\n */\nexport async function createConnections(\n    options?: DataSourceOptions[],\n): Promise<DataSource[]> {\n    if (!options) options = await new ConnectionOptionsReader().all()\n    const connections = options.map((options) =>\n        getConnectionManager().create(options),\n    )\n    // Do not use Promise.all or test 8522 will produce a dangling sqlite connection\n    for (const connection of connections) {\n        await connection.connect()\n    }\n    return connections\n}\n\n/**\n * Gets connection from the connection manager.\n * If connection name wasn't specified, then \"default\" connection will be retrieved.\n *\n * @deprecated\n */\nexport function getConnection(connectionName: string = \"default\"): DataSource {\n    return getConnectionManager().get(connectionName)\n}\n\n/**\n * Gets entity manager from the connection.\n * If connection name wasn't specified, then \"default\" connection will be retrieved.\n *\n * @deprecated\n */\nexport function getManager(connectionName: string = \"default\"): EntityManager {\n    return getConnectionManager().get(connectionName).manager\n}\n\n/**\n * Gets MongoDB entity manager from the connection.\n * If connection name wasn't specified, then \"default\" connection will be retrieved.\n *\n * @deprecated\n */\nexport function getMongoManager(\n    connectionName: string = \"default\",\n): MongoEntityManager {\n    return getConnectionManager().get(connectionName)\n        .manager as MongoEntityManager\n}\n\n/**\n * Gets Sqljs entity manager from connection name.\n * \"default\" connection is used, when no name is specified.\n * Only works when Sqljs driver is used.\n *\n * @deprecated\n */\nexport function getSqljsManager(\n    connectionName: string = \"default\",\n): SqljsEntityManager {\n    return getConnectionManager().get(connectionName)\n        .manager as SqljsEntityManager\n}\n\n/**\n * Gets repository for the given entity class.\n *\n * @deprecated\n */\nexport function getRepository<Entity extends ObjectLiteral>(\n    entityClass: EntityTarget<Entity>,\n    connectionName: string = \"default\",\n): Repository<Entity> {\n    return getConnectionManager()\n        .get(connectionName)\n        .getRepository<Entity>(entityClass)\n}\n\n/**\n * Gets tree repository for the given entity class.\n *\n * @deprecated\n */\nexport function getTreeRepository<Entity extends ObjectLiteral>(\n    entityClass: EntityTarget<Entity>,\n    connectionName: string = \"default\",\n): TreeRepository<Entity> {\n    return getConnectionManager()\n        .get(connectionName)\n        .getTreeRepository<Entity>(entityClass)\n}\n\n/**\n * Gets tree repository for the given entity class.\n *\n * @deprecated\n */\nexport function getCustomRepository<T>(\n    customRepository: ObjectType<T>,\n    connectionName: string = \"default\",\n): T {\n    return getConnectionManager()\n        .get(connectionName)\n        .getCustomRepository(customRepository)\n}\n\n/**\n * Gets mongodb repository for the given entity class or name.\n *\n * @deprecated\n */\nexport function getMongoRepository<Entity extends ObjectLiteral>(\n    entityClass: EntityTarget<Entity>,\n    connectionName: string = \"default\",\n): MongoRepository<Entity> {\n    return getConnectionManager()\n        .get(connectionName)\n        .getMongoRepository<Entity>(entityClass)\n}\n\n/**\n * Creates a new query builder.\n *\n * @deprecated\n */\nexport function createQueryBuilder<Entity extends ObjectLiteral>(\n    entityClass?: EntityTarget<Entity>,\n    alias?: string,\n    connectionName: string = \"default\",\n): SelectQueryBuilder<Entity> {\n    if (entityClass) {\n        return getRepository(entityClass, connectionName).createQueryBuilder(\n            alias,\n        )\n    }\n\n    return getConnection(connectionName).createQueryBuilder()\n}\n"]},"metadata":{},"sourceType":"module"}