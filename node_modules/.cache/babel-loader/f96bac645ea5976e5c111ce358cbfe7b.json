{"ast":null,"code":"import { TypeORMError } from \"../../error\";\nimport { QueryFailedError } from \"../../error/QueryFailedError\";\nimport { QueryRunnerAlreadyReleasedError } from \"../../error/QueryRunnerAlreadyReleasedError\";\nimport { TransactionNotStartedError } from \"../../error/TransactionNotStartedError\";\nimport { BaseQueryRunner } from \"../../query-runner/BaseQueryRunner\";\nimport { QueryResult } from \"../../query-runner/QueryResult\";\nimport { Table } from \"../../schema-builder/table/Table\";\nimport { TableCheck } from \"../../schema-builder/table/TableCheck\";\nimport { TableColumn } from \"../../schema-builder/table/TableColumn\";\nimport { TableExclusion } from \"../../schema-builder/table/TableExclusion\";\nimport { TableForeignKey } from \"../../schema-builder/table/TableForeignKey\";\nimport { TableIndex } from \"../../schema-builder/table/TableIndex\";\nimport { TableUnique } from \"../../schema-builder/table/TableUnique\";\nimport { View } from \"../../schema-builder/view/View\";\nimport { Broadcaster } from \"../../subscriber/Broadcaster\";\nimport { InstanceChecker } from \"../../util/InstanceChecker\";\nimport { OrmUtils } from \"../../util/OrmUtils\";\nimport { VersionUtils } from \"../../util/VersionUtils\";\nimport { Query } from \"../Query\";\nimport { MetadataTableType } from \"../types/MetadataTableType\";\n/**\n * Runs queries on a single postgres database connection.\n */\n\nexport class PostgresQueryRunner extends BaseQueryRunner {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(driver, mode) {\n    super();\n    this.driver = driver;\n    this.connection = driver.connection;\n    this.mode = mode;\n    this.broadcaster = new Broadcaster(this);\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Creates/uses database connection from the connection pool to perform further operations.\n   * Returns obtained database connection.\n   */\n\n\n  connect() {\n    if (this.databaseConnection) return Promise.resolve(this.databaseConnection);\n    if (this.databaseConnectionPromise) return this.databaseConnectionPromise;\n\n    if (this.mode === \"slave\" && this.driver.isReplicated) {\n      this.databaseConnectionPromise = this.driver.obtainSlaveConnection().then(_ref => {\n        let [connection, release] = _ref;\n        this.driver.connectedQueryRunners.push(this);\n        this.databaseConnection = connection;\n\n        const onErrorCallback = err => this.releasePostgresConnection(err);\n\n        this.releaseCallback = err => {\n          this.databaseConnection.removeListener(\"error\", onErrorCallback);\n          release(err);\n        };\n\n        this.databaseConnection.on(\"error\", onErrorCallback);\n        return this.databaseConnection;\n      });\n    } else {\n      // master\n      this.databaseConnectionPromise = this.driver.obtainMasterConnection().then(_ref2 => {\n        let [connection, release] = _ref2;\n        this.driver.connectedQueryRunners.push(this);\n        this.databaseConnection = connection;\n\n        const onErrorCallback = err => this.releasePostgresConnection(err);\n\n        this.releaseCallback = err => {\n          this.databaseConnection.removeListener(\"error\", onErrorCallback);\n          release(err);\n        };\n\n        this.databaseConnection.on(\"error\", onErrorCallback);\n        return this.databaseConnection;\n      });\n    }\n\n    return this.databaseConnectionPromise;\n  }\n  /**\n   * Release a connection back to the pool, optionally specifying an Error to release with.\n   * Per pg-pool documentation this will prevent the pool from re-using the broken connection.\n   */\n\n\n  async releasePostgresConnection(err) {\n    if (this.isReleased) {\n      return;\n    }\n\n    this.isReleased = true;\n\n    if (this.releaseCallback) {\n      this.releaseCallback(err);\n      this.releaseCallback = undefined;\n    }\n\n    const index = this.driver.connectedQueryRunners.indexOf(this);\n\n    if (index !== -1) {\n      this.driver.connectedQueryRunners.splice(index, 1);\n    }\n  }\n  /**\n   * Releases used database connection.\n   * You cannot use query runner methods once its released.\n   */\n\n\n  release() {\n    return this.releasePostgresConnection();\n  }\n  /**\n   * Starts transaction.\n   */\n\n\n  async startTransaction(isolationLevel) {\n    this.isTransactionActive = true;\n\n    try {\n      await this.broadcaster.broadcast(\"BeforeTransactionStart\");\n    } catch (err) {\n      this.isTransactionActive = false;\n      throw err;\n    }\n\n    if (this.transactionDepth === 0) {\n      await this.query(\"START TRANSACTION\");\n\n      if (isolationLevel) {\n        await this.query(\"SET TRANSACTION ISOLATION LEVEL \" + isolationLevel);\n      }\n    } else {\n      await this.query(`SAVEPOINT typeorm_${this.transactionDepth}`);\n    }\n\n    this.transactionDepth += 1;\n    await this.broadcaster.broadcast(\"AfterTransactionStart\");\n  }\n  /**\n   * Commits transaction.\n   * Error will be thrown if transaction was not started.\n   */\n\n\n  async commitTransaction() {\n    if (!this.isTransactionActive) throw new TransactionNotStartedError();\n    await this.broadcaster.broadcast(\"BeforeTransactionCommit\");\n\n    if (this.transactionDepth > 1) {\n      await this.query(`RELEASE SAVEPOINT typeorm_${this.transactionDepth - 1}`);\n    } else {\n      await this.query(\"COMMIT\");\n      this.isTransactionActive = false;\n    }\n\n    this.transactionDepth -= 1;\n    await this.broadcaster.broadcast(\"AfterTransactionCommit\");\n  }\n  /**\n   * Rollbacks transaction.\n   * Error will be thrown if transaction was not started.\n   */\n\n\n  async rollbackTransaction() {\n    if (!this.isTransactionActive) throw new TransactionNotStartedError();\n    await this.broadcaster.broadcast(\"BeforeTransactionRollback\");\n\n    if (this.transactionDepth > 1) {\n      await this.query(`ROLLBACK TO SAVEPOINT typeorm_${this.transactionDepth - 1}`);\n    } else {\n      await this.query(\"ROLLBACK\");\n      this.isTransactionActive = false;\n    }\n\n    this.transactionDepth -= 1;\n    await this.broadcaster.broadcast(\"AfterTransactionRollback\");\n  }\n  /**\n   * Executes a given SQL query.\n   */\n\n\n  async query(query, parameters) {\n    let useStructuredResult = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (this.isReleased) throw new QueryRunnerAlreadyReleasedError();\n    const databaseConnection = await this.connect();\n    this.driver.connection.logger.logQuery(query, parameters, this);\n\n    try {\n      const queryStartTime = +new Date();\n      const raw = await databaseConnection.query(query, parameters); // log slow queries if maxQueryExecution time is set\n\n      const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;\n      const queryEndTime = +new Date();\n      const queryExecutionTime = queryEndTime - queryStartTime;\n      if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);\n      const result = new QueryResult();\n\n      if (raw) {\n        if (raw.hasOwnProperty(\"rows\")) {\n          result.records = raw.rows;\n        }\n\n        if (raw.hasOwnProperty(\"rowCount\")) {\n          result.affected = raw.rowCount;\n        }\n\n        switch (raw.command) {\n          case \"DELETE\":\n          case \"UPDATE\":\n            // for UPDATE and DELETE query additionally return number of affected rows\n            result.raw = [raw.rows, raw.rowCount];\n            break;\n\n          default:\n            result.raw = raw.rows;\n        }\n\n        if (!useStructuredResult) {\n          return result.raw;\n        }\n      }\n\n      return result;\n    } catch (err) {\n      this.driver.connection.logger.logQueryError(err, query, parameters, this);\n      throw new QueryFailedError(query, parameters, err);\n    }\n  }\n  /**\n   * Returns raw data stream.\n   */\n\n\n  async stream(query, parameters, onEnd, onError) {\n    const QueryStream = this.driver.loadStreamDependency();\n    if (this.isReleased) throw new QueryRunnerAlreadyReleasedError();\n    const databaseConnection = await this.connect();\n    this.driver.connection.logger.logQuery(query, parameters, this);\n    const stream = databaseConnection.query(new QueryStream(query, parameters));\n    if (onEnd) stream.on(\"end\", onEnd);\n    if (onError) stream.on(\"error\", onError);\n    return stream;\n  }\n  /**\n   * Returns all available database names including system databases.\n   */\n\n\n  async getDatabases() {\n    return Promise.resolve([]);\n  }\n  /**\n   * Returns all available schema names including system schemas.\n   * If database parameter specified, returns schemas of that database.\n   */\n\n\n  async getSchemas(database) {\n    return Promise.resolve([]);\n  }\n  /**\n   * Checks if database with the given name exist.\n   */\n\n\n  async hasDatabase(database) {\n    const result = await this.query(`SELECT * FROM pg_database WHERE datname='${database}';`);\n    return result.length ? true : false;\n  }\n  /**\n   * Loads currently using database\n   */\n\n\n  async getCurrentDatabase() {\n    const query = await this.query(`SELECT * FROM current_database()`);\n    return query[0][\"current_database\"];\n  }\n  /**\n   * Checks if schema with the given name exist.\n   */\n\n\n  async hasSchema(schema) {\n    const result = await this.query(`SELECT * FROM \"information_schema\".\"schemata\" WHERE \"schema_name\" = '${schema}'`);\n    return result.length ? true : false;\n  }\n  /**\n   * Loads currently using database schema\n   */\n\n\n  async getCurrentSchema() {\n    const query = await this.query(`SELECT * FROM current_schema()`);\n    return query[0][\"current_schema\"];\n  }\n  /**\n   * Checks if table with the given name exist in the database.\n   */\n\n\n  async hasTable(tableOrName) {\n    const parsedTableName = this.driver.parseTableName(tableOrName);\n\n    if (!parsedTableName.schema) {\n      parsedTableName.schema = await this.getCurrentSchema();\n    }\n\n    const sql = `SELECT * FROM \"information_schema\".\"tables\" WHERE \"table_schema\" = '${parsedTableName.schema}' AND \"table_name\" = '${parsedTableName.tableName}'`;\n    const result = await this.query(sql);\n    return result.length ? true : false;\n  }\n  /**\n   * Checks if column with the given name exist in the given table.\n   */\n\n\n  async hasColumn(tableOrName, columnName) {\n    const parsedTableName = this.driver.parseTableName(tableOrName);\n\n    if (!parsedTableName.schema) {\n      parsedTableName.schema = await this.getCurrentSchema();\n    }\n\n    const sql = `SELECT * FROM \"information_schema\".\"columns\" WHERE \"table_schema\" = '${parsedTableName.schema}' AND \"table_name\" = '${parsedTableName.tableName}' AND \"column_name\" = '${columnName}'`;\n    const result = await this.query(sql);\n    return result.length ? true : false;\n  }\n  /**\n   * Creates a new database.\n   * Note: Postgres does not support database creation inside a transaction block.\n   */\n\n\n  async createDatabase(database, ifNotExist) {\n    if (ifNotExist) {\n      const databaseAlreadyExists = await this.hasDatabase(database);\n      if (databaseAlreadyExists) return Promise.resolve();\n    }\n\n    const up = `CREATE DATABASE \"${database}\"`;\n    const down = `DROP DATABASE \"${database}\"`;\n    await this.executeQueries(new Query(up), new Query(down));\n  }\n  /**\n   * Drops database.\n   * Note: Postgres does not support database dropping inside a transaction block.\n   */\n\n\n  async dropDatabase(database, ifExist) {\n    const up = ifExist ? `DROP DATABASE IF EXISTS \"${database}\"` : `DROP DATABASE \"${database}\"`;\n    const down = `CREATE DATABASE \"${database}\"`;\n    await this.executeQueries(new Query(up), new Query(down));\n  }\n  /**\n   * Creates a new table schema.\n   */\n\n\n  async createSchema(schemaPath, ifNotExist) {\n    const schema = schemaPath.indexOf(\".\") === -1 ? schemaPath : schemaPath.split(\".\")[1];\n    const up = ifNotExist ? `CREATE SCHEMA IF NOT EXISTS \"${schema}\"` : `CREATE SCHEMA \"${schema}\"`;\n    const down = `DROP SCHEMA \"${schema}\" CASCADE`;\n    await this.executeQueries(new Query(up), new Query(down));\n  }\n  /**\n   * Drops table schema.\n   */\n\n\n  async dropSchema(schemaPath, ifExist, isCascade) {\n    const schema = schemaPath.indexOf(\".\") === -1 ? schemaPath : schemaPath.split(\".\")[1];\n    const up = ifExist ? `DROP SCHEMA IF EXISTS \"${schema}\" ${isCascade ? \"CASCADE\" : \"\"}` : `DROP SCHEMA \"${schema}\" ${isCascade ? \"CASCADE\" : \"\"}`;\n    const down = `CREATE SCHEMA \"${schema}\"`;\n    await this.executeQueries(new Query(up), new Query(down));\n  }\n  /**\n   * Creates a new table.\n   */\n\n\n  async createTable(table) {\n    let ifNotExist = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let createForeignKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let createIndices = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n    if (ifNotExist) {\n      const isTableExist = await this.hasTable(table);\n      if (isTableExist) return Promise.resolve();\n    }\n\n    const upQueries = [];\n    const downQueries = []; // if table have column with ENUM type, we must create this type in postgres.\n\n    const enumColumns = table.columns.filter(column => column.type === \"enum\" || column.type === \"simple-enum\");\n    const createdEnumTypes = [];\n\n    for (const column of enumColumns) {\n      // TODO: Should also check if values of existing type matches expected ones\n      const hasEnum = await this.hasEnumType(table, column);\n      const enumName = this.buildEnumName(table, column); // if enum with the same \"enumName\" is defined more then once, me must prevent double creation\n\n      if (!hasEnum && createdEnumTypes.indexOf(enumName) === -1) {\n        createdEnumTypes.push(enumName);\n        upQueries.push(this.createEnumTypeSql(table, column, enumName));\n        downQueries.push(this.dropEnumTypeSql(table, column, enumName));\n      }\n    } // if table have column with generated type, we must add the expression to the metadata table\n\n\n    const generatedColumns = table.columns.filter(column => column.generatedType === \"STORED\" && column.asExpression);\n\n    for (const column of generatedColumns) {\n      const tableNameWithSchema = (await this.getTableNameWithSchema(table.name)).split(\".\");\n      const tableName = tableNameWithSchema[1];\n      const schema = tableNameWithSchema[0];\n      const insertQuery = this.insertTypeormMetadataSql({\n        database: this.driver.database,\n        schema,\n        table: tableName,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name,\n        value: column.asExpression\n      });\n      const deleteQuery = this.deleteTypeormMetadataSql({\n        database: this.driver.database,\n        schema,\n        table: tableName,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name\n      });\n      upQueries.push(insertQuery);\n      downQueries.push(deleteQuery);\n    }\n\n    upQueries.push(this.createTableSql(table, createForeignKeys));\n    downQueries.push(this.dropTableSql(table)); // if createForeignKeys is true, we must drop created foreign keys in down query.\n    // createTable does not need separate method to create foreign keys, because it create fk's in the same query with table creation.\n\n    if (createForeignKeys) table.foreignKeys.forEach(foreignKey => downQueries.push(this.dropForeignKeySql(table, foreignKey)));\n\n    if (createIndices) {\n      table.indices.forEach(index => {\n        // new index may be passed without name. In this case we generate index name manually.\n        if (!index.name) index.name = this.connection.namingStrategy.indexName(table, index.columnNames, index.where);\n        upQueries.push(this.createIndexSql(table, index));\n        downQueries.push(this.dropIndexSql(table, index));\n      });\n    }\n\n    await this.executeQueries(upQueries, downQueries);\n  }\n  /**\n   * Drops the table.\n   */\n\n\n  async dropTable(target, ifExist) {\n    let dropForeignKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let dropIndices = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n    // It needs because if table does not exist and dropForeignKeys or dropIndices is true, we don't need\n    // to perform drop queries for foreign keys and indices.\n    if (ifExist) {\n      const isTableExist = await this.hasTable(target);\n      if (!isTableExist) return Promise.resolve();\n    } // if dropTable called with dropForeignKeys = true, we must create foreign keys in down query.\n\n\n    const createForeignKeys = dropForeignKeys;\n    const tablePath = this.getTablePath(target);\n    const table = await this.getCachedTable(tablePath);\n    const upQueries = [];\n    const downQueries = [];\n\n    if (dropIndices) {\n      table.indices.forEach(index => {\n        upQueries.push(this.dropIndexSql(table, index));\n        downQueries.push(this.createIndexSql(table, index));\n      });\n    }\n\n    if (dropForeignKeys) table.foreignKeys.forEach(foreignKey => upQueries.push(this.dropForeignKeySql(table, foreignKey)));\n    upQueries.push(this.dropTableSql(table));\n    downQueries.push(this.createTableSql(table, createForeignKeys)); // if table had columns with generated type, we must remove the expression from the metadata table\n\n    const generatedColumns = table.columns.filter(column => column.generatedType && column.asExpression);\n\n    for (const column of generatedColumns) {\n      const tableNameWithSchema = (await this.getTableNameWithSchema(table.name)).split(\".\");\n      const tableName = tableNameWithSchema[1];\n      const schema = tableNameWithSchema[0];\n      const deleteQuery = this.deleteTypeormMetadataSql({\n        database: this.driver.database,\n        schema,\n        table: tableName,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name\n      });\n      const insertQuery = this.insertTypeormMetadataSql({\n        database: this.driver.database,\n        schema,\n        table: tableName,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name,\n        value: column.asExpression\n      });\n      upQueries.push(deleteQuery);\n      downQueries.push(insertQuery);\n    }\n\n    await this.executeQueries(upQueries, downQueries);\n  }\n  /**\n   * Creates a new view.\n   */\n\n\n  async createView(view) {\n    const upQueries = [];\n    const downQueries = [];\n    upQueries.push(this.createViewSql(view));\n    upQueries.push(await this.insertViewDefinitionSql(view));\n    downQueries.push(this.dropViewSql(view));\n    downQueries.push(await this.deleteViewDefinitionSql(view));\n    await this.executeQueries(upQueries, downQueries);\n  }\n  /**\n   * Drops the view.\n   */\n\n\n  async dropView(target) {\n    const viewName = InstanceChecker.isView(target) ? target.name : target;\n    const view = await this.getCachedView(viewName);\n    const upQueries = [];\n    const downQueries = [];\n    upQueries.push(await this.deleteViewDefinitionSql(view));\n    upQueries.push(this.dropViewSql(view));\n    downQueries.push(await this.insertViewDefinitionSql(view));\n    downQueries.push(this.createViewSql(view));\n    await this.executeQueries(upQueries, downQueries);\n  }\n  /**\n   * Renames the given table.\n   */\n\n\n  async renameTable(oldTableOrName, newTableName) {\n    const upQueries = [];\n    const downQueries = [];\n    const oldTable = InstanceChecker.isTable(oldTableOrName) ? oldTableOrName : await this.getCachedTable(oldTableOrName);\n    const newTable = oldTable.clone();\n    const {\n      schema: schemaName,\n      tableName: oldTableName\n    } = this.driver.parseTableName(oldTable);\n    newTable.name = schemaName ? `${schemaName}.${newTableName}` : newTableName;\n    upQueries.push(new Query(`ALTER TABLE ${this.escapePath(oldTable)} RENAME TO \"${newTableName}\"`));\n    downQueries.push(new Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME TO \"${oldTableName}\"`)); // rename column primary key constraint if it has default constraint name\n\n    if (newTable.primaryColumns.length > 0 && !newTable.primaryColumns[0].primaryKeyConstraintName) {\n      const columnNames = newTable.primaryColumns.map(column => column.name);\n      const oldPkName = this.connection.namingStrategy.primaryKeyName(oldTable, columnNames);\n      const newPkName = this.connection.namingStrategy.primaryKeyName(newTable, columnNames);\n      upQueries.push(new Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT \"${oldPkName}\" TO \"${newPkName}\"`));\n      downQueries.push(new Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT \"${newPkName}\" TO \"${oldPkName}\"`));\n    } // rename sequences\n\n\n    newTable.columns.map(col => {\n      if (col.isGenerated && col.generationStrategy === \"increment\") {\n        const sequencePath = this.buildSequencePath(oldTable, col.name);\n        const sequenceName = this.buildSequenceName(oldTable, col.name);\n        const newSequencePath = this.buildSequencePath(newTable, col.name);\n        const newSequenceName = this.buildSequenceName(newTable, col.name);\n        const up = `ALTER SEQUENCE ${this.escapePath(sequencePath)} RENAME TO \"${newSequenceName}\"`;\n        const down = `ALTER SEQUENCE ${this.escapePath(newSequencePath)} RENAME TO \"${sequenceName}\"`;\n        upQueries.push(new Query(up));\n        downQueries.push(new Query(down));\n      }\n    }); // rename unique constraints\n\n    newTable.uniques.forEach(unique => {\n      const oldUniqueName = this.connection.namingStrategy.uniqueConstraintName(oldTable, unique.columnNames); // Skip renaming if Unique has user defined constraint name\n\n      if (unique.name !== oldUniqueName) return; // build new constraint name\n\n      const newUniqueName = this.connection.namingStrategy.uniqueConstraintName(newTable, unique.columnNames); // build queries\n\n      upQueries.push(new Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT \"${unique.name}\" TO \"${newUniqueName}\"`));\n      downQueries.push(new Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT \"${newUniqueName}\" TO \"${unique.name}\"`)); // replace constraint name\n\n      unique.name = newUniqueName;\n    }); // rename index constraints\n\n    newTable.indices.forEach(index => {\n      const oldIndexName = this.connection.namingStrategy.indexName(oldTable, index.columnNames, index.where); // Skip renaming if Index has user defined constraint name\n\n      if (index.name !== oldIndexName) return; // build new constraint name\n\n      const {\n        schema\n      } = this.driver.parseTableName(newTable);\n      const newIndexName = this.connection.namingStrategy.indexName(newTable, index.columnNames, index.where); // build queries\n\n      const up = schema ? `ALTER INDEX \"${schema}\".\"${index.name}\" RENAME TO \"${newIndexName}\"` : `ALTER INDEX \"${index.name}\" RENAME TO \"${newIndexName}\"`;\n      const down = schema ? `ALTER INDEX \"${schema}\".\"${newIndexName}\" RENAME TO \"${index.name}\"` : `ALTER INDEX \"${newIndexName}\" RENAME TO \"${index.name}\"`;\n      upQueries.push(new Query(up));\n      downQueries.push(new Query(down)); // replace constraint name\n\n      index.name = newIndexName;\n    }); // rename foreign key constraints\n\n    newTable.foreignKeys.forEach(foreignKey => {\n      const oldForeignKeyName = this.connection.namingStrategy.foreignKeyName(oldTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames); // Skip renaming if foreign key has user defined constraint name\n\n      if (foreignKey.name !== oldForeignKeyName) return; // build new constraint name\n\n      const newForeignKeyName = this.connection.namingStrategy.foreignKeyName(newTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames); // build queries\n\n      upQueries.push(new Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT \"${foreignKey.name}\" TO \"${newForeignKeyName}\"`));\n      downQueries.push(new Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT \"${newForeignKeyName}\" TO \"${foreignKey.name}\"`)); // replace constraint name\n\n      foreignKey.name = newForeignKeyName;\n    }); // rename ENUM types\n\n    const enumColumns = newTable.columns.filter(column => column.type === \"enum\" || column.type === \"simple-enum\");\n\n    for (let column of enumColumns) {\n      // skip renaming for user-defined enum name\n      if (column.enumName) continue;\n      const oldEnumType = await this.getUserDefinedTypeName(oldTable, column);\n      upQueries.push(new Query(`ALTER TYPE \"${oldEnumType.schema}\".\"${oldEnumType.name}\" RENAME TO ${this.buildEnumName(newTable, column, false)}`));\n      downQueries.push(new Query(`ALTER TYPE ${this.buildEnumName(newTable, column)} RENAME TO \"${oldEnumType.name}\"`));\n    }\n\n    await this.executeQueries(upQueries, downQueries);\n  }\n  /**\n   * Creates a new column from the column in the table.\n   */\n\n\n  async addColumn(tableOrName, column) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const clonedTable = table.clone();\n    const upQueries = [];\n    const downQueries = [];\n\n    if (column.type === \"enum\" || column.type === \"simple-enum\") {\n      const hasEnum = await this.hasEnumType(table, column);\n\n      if (!hasEnum) {\n        upQueries.push(this.createEnumTypeSql(table, column));\n        downQueries.push(this.dropEnumTypeSql(table, column));\n      }\n    }\n\n    upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(table, column)}`));\n    downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN \"${column.name}\"`)); // create or update primary key constraint\n\n    if (column.isPrimary) {\n      const primaryColumns = clonedTable.primaryColumns; // if table already have primary key, me must drop it and recreate again\n\n      if (primaryColumns.length > 0) {\n        const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map(column => column.name));\n        const columnNames = primaryColumns.map(column => `\"${column.name}\"`).join(\", \");\n        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${pkName}\"`));\n        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`));\n      }\n\n      primaryColumns.push(column);\n      const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map(column => column.name));\n      const columnNames = primaryColumns.map(column => `\"${column.name}\"`).join(\", \");\n      upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`));\n      downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${pkName}\"`));\n    } // create column index\n\n\n    const columnIndex = clonedTable.indices.find(index => index.columnNames.length === 1 && index.columnNames[0] === column.name);\n\n    if (columnIndex) {\n      upQueries.push(this.createIndexSql(table, columnIndex));\n      downQueries.push(this.dropIndexSql(table, columnIndex));\n    } // create unique constraint\n\n\n    if (column.isUnique) {\n      const uniqueConstraint = new TableUnique({\n        name: this.connection.namingStrategy.uniqueConstraintName(table, [column.name]),\n        columnNames: [column.name]\n      });\n      clonedTable.uniques.push(uniqueConstraint);\n      upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${uniqueConstraint.name}\" UNIQUE (\"${column.name}\")`));\n      downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${uniqueConstraint.name}\"`));\n    }\n\n    if (column.generatedType === \"STORED\" && column.asExpression) {\n      const tableNameWithSchema = (await this.getTableNameWithSchema(table.name)).split(\".\");\n      const tableName = tableNameWithSchema[1];\n      const schema = tableNameWithSchema[0];\n      const insertQuery = this.insertTypeormMetadataSql({\n        database: this.driver.database,\n        schema,\n        table: tableName,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name,\n        value: column.asExpression\n      });\n      const deleteQuery = this.deleteTypeormMetadataSql({\n        database: this.driver.database,\n        schema,\n        table: tableName,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name\n      });\n      upQueries.push(insertQuery);\n      downQueries.push(deleteQuery);\n    } // create column's comment\n\n\n    if (column.comment) {\n      upQueries.push(new Query(`COMMENT ON COLUMN ${this.escapePath(table)}.\"${column.name}\" IS ${this.escapeComment(column.comment)}`));\n      downQueries.push(new Query(`COMMENT ON COLUMN ${this.escapePath(table)}.\"${column.name}\" IS ${this.escapeComment(column.comment)}`));\n    }\n\n    await this.executeQueries(upQueries, downQueries);\n    clonedTable.addColumn(column);\n    this.replaceCachedTable(table, clonedTable);\n  }\n  /**\n   * Creates a new columns from the column in the table.\n   */\n\n\n  async addColumns(tableOrName, columns) {\n    for (const column of columns) {\n      await this.addColumn(tableOrName, column);\n    }\n  }\n  /**\n   * Renames column in the given table.\n   */\n\n\n  async renameColumn(tableOrName, oldTableColumnOrName, newTableColumnOrName) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const oldColumn = InstanceChecker.isTableColumn(oldTableColumnOrName) ? oldTableColumnOrName : table.columns.find(c => c.name === oldTableColumnOrName);\n    if (!oldColumn) throw new TypeORMError(`Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`);\n    let newColumn;\n\n    if (InstanceChecker.isTableColumn(newTableColumnOrName)) {\n      newColumn = newTableColumnOrName;\n    } else {\n      newColumn = oldColumn.clone();\n      newColumn.name = newTableColumnOrName;\n    }\n\n    return this.changeColumn(table, oldColumn, newColumn);\n  }\n  /**\n   * Changes a column in the table.\n   */\n\n\n  async changeColumn(tableOrName, oldTableColumnOrName, newColumn) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    let clonedTable = table.clone();\n    const upQueries = [];\n    const downQueries = [];\n    let defaultValueChanged = false;\n    const oldColumn = InstanceChecker.isTableColumn(oldTableColumnOrName) ? oldTableColumnOrName : table.columns.find(column => column.name === oldTableColumnOrName);\n    if (!oldColumn) throw new TypeORMError(`Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`);\n\n    if (oldColumn.type !== newColumn.type || oldColumn.length !== newColumn.length || newColumn.isArray !== oldColumn.isArray || !oldColumn.generatedType && newColumn.generatedType === \"STORED\" || oldColumn.asExpression !== newColumn.asExpression && newColumn.generatedType === \"STORED\") {\n      // To avoid data conversion, we just recreate column\n      await this.dropColumn(table, oldColumn);\n      await this.addColumn(table, newColumn); // update cloned table\n\n      clonedTable = table.clone();\n    } else {\n      if (oldColumn.name !== newColumn.name) {\n        // rename column\n        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} RENAME COLUMN \"${oldColumn.name}\" TO \"${newColumn.name}\"`));\n        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} RENAME COLUMN \"${newColumn.name}\" TO \"${oldColumn.name}\"`)); // rename ENUM type\n\n        if (oldColumn.type === \"enum\" || oldColumn.type === \"simple-enum\") {\n          const oldEnumType = await this.getUserDefinedTypeName(table, oldColumn);\n          upQueries.push(new Query(`ALTER TYPE \"${oldEnumType.schema}\".\"${oldEnumType.name}\" RENAME TO ${this.buildEnumName(table, newColumn, false)}`));\n          downQueries.push(new Query(`ALTER TYPE ${this.buildEnumName(table, newColumn)} RENAME TO \"${oldEnumType.name}\"`));\n        } // rename column primary key constraint\n\n\n        if (oldColumn.isPrimary === true && !oldColumn.primaryKeyConstraintName) {\n          const primaryColumns = clonedTable.primaryColumns; // build old primary constraint name\n\n          const columnNames = primaryColumns.map(column => column.name);\n          const oldPkName = this.connection.namingStrategy.primaryKeyName(clonedTable, columnNames); // replace old column name with new column name\n\n          columnNames.splice(columnNames.indexOf(oldColumn.name), 1);\n          columnNames.push(newColumn.name); // build new primary constraint name\n\n          const newPkName = this.connection.namingStrategy.primaryKeyName(clonedTable, columnNames);\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT \"${oldPkName}\" TO \"${newPkName}\"`));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT \"${newPkName}\" TO \"${oldPkName}\"`));\n        } // rename column sequence\n\n\n        if (oldColumn.isGenerated === true && newColumn.generationStrategy === \"increment\") {\n          const sequencePath = this.buildSequencePath(table, oldColumn.name);\n          const sequenceName = this.buildSequenceName(table, oldColumn.name);\n          const newSequencePath = this.buildSequencePath(table, newColumn.name);\n          const newSequenceName = this.buildSequenceName(table, newColumn.name);\n          const up = `ALTER SEQUENCE ${this.escapePath(sequencePath)} RENAME TO \"${newSequenceName}\"`;\n          const down = `ALTER SEQUENCE ${this.escapePath(newSequencePath)} RENAME TO \"${sequenceName}\"`;\n          upQueries.push(new Query(up));\n          downQueries.push(new Query(down));\n        } // rename unique constraints\n\n\n        clonedTable.findColumnUniques(oldColumn).forEach(unique => {\n          const oldUniqueName = this.connection.namingStrategy.uniqueConstraintName(clonedTable, unique.columnNames); // Skip renaming if Unique has user defined constraint name\n\n          if (unique.name !== oldUniqueName) return; // build new constraint name\n\n          unique.columnNames.splice(unique.columnNames.indexOf(oldColumn.name), 1);\n          unique.columnNames.push(newColumn.name);\n          const newUniqueName = this.connection.namingStrategy.uniqueConstraintName(clonedTable, unique.columnNames); // build queries\n\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT \"${unique.name}\" TO \"${newUniqueName}\"`));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT \"${newUniqueName}\" TO \"${unique.name}\"`)); // replace constraint name\n\n          unique.name = newUniqueName;\n        }); // rename index constraints\n\n        clonedTable.findColumnIndices(oldColumn).forEach(index => {\n          const oldIndexName = this.connection.namingStrategy.indexName(clonedTable, index.columnNames, index.where); // Skip renaming if Index has user defined constraint name\n\n          if (index.name !== oldIndexName) return; // build new constraint name\n\n          index.columnNames.splice(index.columnNames.indexOf(oldColumn.name), 1);\n          index.columnNames.push(newColumn.name);\n          const {\n            schema\n          } = this.driver.parseTableName(table);\n          const newIndexName = this.connection.namingStrategy.indexName(clonedTable, index.columnNames, index.where); // build queries\n\n          const up = schema ? `ALTER INDEX \"${schema}\".\"${index.name}\" RENAME TO \"${newIndexName}\"` : `ALTER INDEX \"${index.name}\" RENAME TO \"${newIndexName}\"`;\n          const down = schema ? `ALTER INDEX \"${schema}\".\"${newIndexName}\" RENAME TO \"${index.name}\"` : `ALTER INDEX \"${newIndexName}\" RENAME TO \"${index.name}\"`;\n          upQueries.push(new Query(up));\n          downQueries.push(new Query(down)); // replace constraint name\n\n          index.name = newIndexName;\n        }); // rename foreign key constraints\n\n        clonedTable.findColumnForeignKeys(oldColumn).forEach(foreignKey => {\n          const foreignKeyName = this.connection.namingStrategy.foreignKeyName(clonedTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames); // Skip renaming if foreign key has user defined constraint name\n\n          if (foreignKey.name !== foreignKeyName) return; // build new constraint name\n\n          foreignKey.columnNames.splice(foreignKey.columnNames.indexOf(oldColumn.name), 1);\n          foreignKey.columnNames.push(newColumn.name);\n          const newForeignKeyName = this.connection.namingStrategy.foreignKeyName(clonedTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames); // build queries\n\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT \"${foreignKey.name}\" TO \"${newForeignKeyName}\"`));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT \"${newForeignKeyName}\" TO \"${foreignKey.name}\"`)); // replace constraint name\n\n          foreignKey.name = newForeignKeyName;\n        }); // rename old column in the Table object\n\n        const oldTableColumn = clonedTable.columns.find(column => column.name === oldColumn.name);\n        clonedTable.columns[clonedTable.columns.indexOf(oldTableColumn)].name = newColumn.name;\n        oldColumn.name = newColumn.name;\n      }\n\n      if (newColumn.precision !== oldColumn.precision || newColumn.scale !== oldColumn.scale) {\n        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" TYPE ${this.driver.createFullType(newColumn)}`));\n        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" TYPE ${this.driver.createFullType(oldColumn)}`));\n      }\n\n      if ((newColumn.type === \"enum\" || newColumn.type === \"simple-enum\") && (oldColumn.type === \"enum\" || oldColumn.type === \"simple-enum\") && (!OrmUtils.isArraysEqual(newColumn.enum, oldColumn.enum) || newColumn.enumName !== oldColumn.enumName)) {\n        const arraySuffix = newColumn.isArray ? \"[]\" : \"\"; // \"public\".\"new_enum\"\n\n        const newEnumName = this.buildEnumName(table, newColumn); // \"public\".\"old_enum\"\n\n        const oldEnumName = this.buildEnumName(table, oldColumn); // \"old_enum\"\n\n        const oldEnumNameWithoutSchema = this.buildEnumName(table, oldColumn, false); //\"public\".\"old_enum_old\"\n\n        const oldEnumNameWithSchema_old = this.buildEnumName(table, oldColumn, true, false, true); //\"old_enum_old\"\n\n        const oldEnumNameWithoutSchema_old = this.buildEnumName(table, oldColumn, false, false, true); // rename old ENUM\n\n        upQueries.push(new Query(`ALTER TYPE ${oldEnumName} RENAME TO ${oldEnumNameWithoutSchema_old}`));\n        downQueries.push(new Query(`ALTER TYPE ${oldEnumNameWithSchema_old} RENAME TO ${oldEnumNameWithoutSchema}`)); // create new ENUM\n\n        upQueries.push(this.createEnumTypeSql(table, newColumn, newEnumName));\n        downQueries.push(this.dropEnumTypeSql(table, newColumn, newEnumName)); // if column have default value, we must drop it to avoid issues with type casting\n\n        if (oldColumn.default !== null && oldColumn.default !== undefined) {\n          // mark default as changed to prevent double update\n          defaultValueChanged = true;\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" DROP DEFAULT`));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" SET DEFAULT ${oldColumn.default}`));\n        } // build column types\n\n\n        const upType = `${newEnumName}${arraySuffix} USING \"${newColumn.name}\"::\"text\"::${newEnumName}${arraySuffix}`;\n        const downType = `${oldEnumNameWithSchema_old}${arraySuffix} USING \"${newColumn.name}\"::\"text\"::${oldEnumNameWithSchema_old}${arraySuffix}`; // update column to use new type\n\n        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" TYPE ${upType}`));\n        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" TYPE ${downType}`)); // restore column default or create new one\n\n        if (newColumn.default !== null && newColumn.default !== undefined) {\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" SET DEFAULT ${newColumn.default}`));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" DROP DEFAULT`));\n        } // remove old ENUM\n\n\n        upQueries.push(this.dropEnumTypeSql(table, oldColumn, oldEnumNameWithSchema_old));\n        downQueries.push(this.createEnumTypeSql(table, oldColumn, oldEnumNameWithSchema_old));\n      }\n\n      if (oldColumn.isNullable !== newColumn.isNullable) {\n        if (newColumn.isNullable) {\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" DROP NOT NULL`));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" SET NOT NULL`));\n        } else {\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" SET NOT NULL`));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" DROP NOT NULL`));\n        }\n      }\n\n      if (oldColumn.comment !== newColumn.comment) {\n        upQueries.push(new Query(`COMMENT ON COLUMN ${this.escapePath(table)}.\"${oldColumn.name}\" IS ${this.escapeComment(newColumn.comment)}`));\n        downQueries.push(new Query(`COMMENT ON COLUMN ${this.escapePath(table)}.\"${newColumn.name}\" IS ${this.escapeComment(oldColumn.comment)}`));\n      }\n\n      if (newColumn.isPrimary !== oldColumn.isPrimary) {\n        const primaryColumns = clonedTable.primaryColumns; // if primary column state changed, we must always drop existed constraint.\n\n        if (primaryColumns.length > 0) {\n          const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map(column => column.name));\n          const columnNames = primaryColumns.map(column => `\"${column.name}\"`).join(\", \");\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${pkName}\"`));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`));\n        }\n\n        if (newColumn.isPrimary === true) {\n          primaryColumns.push(newColumn); // update column in table\n\n          const column = clonedTable.columns.find(column => column.name === newColumn.name);\n          column.isPrimary = true;\n          const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map(column => column.name));\n          const columnNames = primaryColumns.map(column => `\"${column.name}\"`).join(\", \");\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${pkName}\"`));\n        } else {\n          const primaryColumn = primaryColumns.find(c => c.name === newColumn.name);\n          primaryColumns.splice(primaryColumns.indexOf(primaryColumn), 1); // update column in table\n\n          const column = clonedTable.columns.find(column => column.name === newColumn.name);\n          column.isPrimary = false; // if we have another primary keys, we must recreate constraint.\n\n          if (primaryColumns.length > 0) {\n            const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map(column => column.name));\n            const columnNames = primaryColumns.map(column => `\"${column.name}\"`).join(\", \");\n            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`));\n            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${pkName}\"`));\n          }\n        }\n      }\n\n      if (newColumn.isUnique !== oldColumn.isUnique) {\n        if (newColumn.isUnique === true) {\n          const uniqueConstraint = new TableUnique({\n            name: this.connection.namingStrategy.uniqueConstraintName(table, [newColumn.name]),\n            columnNames: [newColumn.name]\n          });\n          clonedTable.uniques.push(uniqueConstraint);\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${uniqueConstraint.name}\" UNIQUE (\"${newColumn.name}\")`));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${uniqueConstraint.name}\"`));\n        } else {\n          const uniqueConstraint = clonedTable.uniques.find(unique => {\n            return unique.columnNames.length === 1 && !!unique.columnNames.find(columnName => columnName === newColumn.name);\n          });\n          clonedTable.uniques.splice(clonedTable.uniques.indexOf(uniqueConstraint), 1);\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${uniqueConstraint.name}\"`));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${uniqueConstraint.name}\" UNIQUE (\"${newColumn.name}\")`));\n        }\n      }\n\n      if (oldColumn.isGenerated !== newColumn.isGenerated) {\n        // if old column was \"generated\", we should clear defaults\n        if (oldColumn.isGenerated) {\n          if (oldColumn.generationStrategy === \"uuid\") {\n            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" DROP DEFAULT`));\n            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" SET DEFAULT ${this.driver.uuidGenerator}`));\n          } else if (oldColumn.generationStrategy === \"increment\") {\n            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" DROP DEFAULT`));\n            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" SET DEFAULT nextval('${this.escapePath(this.buildSequencePath(table, newColumn))}')`));\n            upQueries.push(new Query(`DROP SEQUENCE ${this.escapePath(this.buildSequencePath(table, newColumn))}`));\n            downQueries.push(new Query(`CREATE SEQUENCE IF NOT EXISTS ${this.escapePath(this.buildSequencePath(table, newColumn))} OWNED BY ${this.escapePath(table)}.\"${newColumn.name}\"`));\n          }\n        }\n\n        if (newColumn.generationStrategy === \"uuid\") {\n          if (newColumn.isGenerated === true) {\n            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" SET DEFAULT ${this.driver.uuidGenerator}`));\n            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" DROP DEFAULT`));\n          } else {\n            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" DROP DEFAULT`));\n            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" SET DEFAULT ${this.driver.uuidGenerator}`));\n          }\n        } else if (newColumn.generationStrategy === \"increment\") {\n          if (newColumn.isGenerated === true) {\n            upQueries.push(new Query(`CREATE SEQUENCE IF NOT EXISTS ${this.escapePath(this.buildSequencePath(table, newColumn))} OWNED BY ${this.escapePath(table)}.\"${newColumn.name}\"`));\n            downQueries.push(new Query(`DROP SEQUENCE ${this.escapePath(this.buildSequencePath(table, newColumn))}`));\n            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" SET DEFAULT nextval('${this.escapePath(this.buildSequencePath(table, newColumn))}')`));\n            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" DROP DEFAULT`));\n          } else {\n            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" DROP DEFAULT`));\n            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" SET DEFAULT nextval('${this.escapePath(this.buildSequencePath(table, newColumn))}')`));\n            upQueries.push(new Query(`DROP SEQUENCE ${this.escapePath(this.buildSequencePath(table, newColumn))}`));\n            downQueries.push(new Query(`CREATE SEQUENCE IF NOT EXISTS ${this.escapePath(this.buildSequencePath(table, newColumn))} OWNED BY ${this.escapePath(table)}.\"${newColumn.name}\"`));\n          }\n        }\n      } // the default might have changed when the enum changed\n\n\n      if (newColumn.default !== oldColumn.default && !defaultValueChanged) {\n        if (newColumn.default !== null && newColumn.default !== undefined) {\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" SET DEFAULT ${newColumn.default}`));\n\n          if (oldColumn.default !== null && oldColumn.default !== undefined) {\n            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" SET DEFAULT ${oldColumn.default}`));\n          } else {\n            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" DROP DEFAULT`));\n          }\n        } else if (oldColumn.default !== null && oldColumn.default !== undefined) {\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" DROP DEFAULT`));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" SET DEFAULT ${oldColumn.default}`));\n        }\n      }\n\n      if ((newColumn.spatialFeatureType || \"\").toLowerCase() !== (oldColumn.spatialFeatureType || \"\").toLowerCase() || newColumn.srid !== oldColumn.srid) {\n        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" TYPE ${this.driver.createFullType(newColumn)}`));\n        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" TYPE ${this.driver.createFullType(oldColumn)}`));\n      }\n\n      if (newColumn.generatedType !== oldColumn.generatedType) {\n        // Convert generated column data to normal column\n        if (!newColumn.generatedType || newColumn.generatedType === \"VIRTUAL\") {\n          // We can copy the generated data to the new column\n          const tableNameWithSchema = (await this.getTableNameWithSchema(table.name)).split(\".\");\n          const tableName = tableNameWithSchema[1];\n          const schema = tableNameWithSchema[0];\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} RENAME COLUMN \"${oldColumn.name}\" TO \"TEMP_OLD_${oldColumn.name}\"`));\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(table, newColumn)}`));\n          upQueries.push(new Query(`UPDATE ${this.escapePath(table)} SET \"${newColumn.name}\" = \"TEMP_OLD_${oldColumn.name}\"`));\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN \"TEMP_OLD_${oldColumn.name}\"`));\n          upQueries.push(this.deleteTypeormMetadataSql({\n            database: this.driver.database,\n            schema,\n            table: tableName,\n            type: MetadataTableType.GENERATED_COLUMN,\n            name: oldColumn.name\n          })); // However, we can't copy it back on downgrade. It needs to regenerate.\n\n          downQueries.push(this.insertTypeormMetadataSql({\n            database: this.driver.database,\n            schema,\n            table: tableName,\n            type: MetadataTableType.GENERATED_COLUMN,\n            name: oldColumn.name,\n            value: oldColumn.asExpression\n          }));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(table, oldColumn)}`));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN \"${newColumn.name}\"`)); // downQueries.push(\n          //     this.deleteTypeormMetadataSql({\n          //         database: this.driver.database,\n          //         schema,\n          //         table: tableName,\n          //         type: MetadataTableType.GENERATED_COLUMN,\n          //         name: newColumn.name,\n          //     }),\n          // )\n        }\n      }\n    }\n\n    await this.executeQueries(upQueries, downQueries);\n    this.replaceCachedTable(table, clonedTable);\n  }\n  /**\n   * Changes a column in the table.\n   */\n\n\n  async changeColumns(tableOrName, changedColumns) {\n    for (const {\n      oldColumn,\n      newColumn\n    } of changedColumns) {\n      await this.changeColumn(tableOrName, oldColumn, newColumn);\n    }\n  }\n  /**\n   * Drops column in the table.\n   */\n\n\n  async dropColumn(tableOrName, columnOrName) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const column = InstanceChecker.isTableColumn(columnOrName) ? columnOrName : table.findColumnByName(columnOrName);\n    if (!column) throw new TypeORMError(`Column \"${columnOrName}\" was not found in table \"${table.name}\"`);\n    const clonedTable = table.clone();\n    const upQueries = [];\n    const downQueries = []; // drop primary key constraint\n\n    if (column.isPrimary) {\n      const pkName = column.primaryKeyConstraintName ? column.primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, clonedTable.primaryColumns.map(column => column.name));\n      const columnNames = clonedTable.primaryColumns.map(primaryColumn => `\"${primaryColumn.name}\"`).join(\", \");\n      upQueries.push(new Query(`ALTER TABLE ${this.escapePath(clonedTable)} DROP CONSTRAINT \"${pkName}\"`));\n      downQueries.push(new Query(`ALTER TABLE ${this.escapePath(clonedTable)} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`)); // update column in table\n\n      const tableColumn = clonedTable.findColumnByName(column.name);\n      tableColumn.isPrimary = false; // if primary key have multiple columns, we must recreate it without dropped column\n\n      if (clonedTable.primaryColumns.length > 0) {\n        const pkName = clonedTable.primaryColumns[0].primaryKeyConstraintName ? clonedTable.primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, clonedTable.primaryColumns.map(column => column.name));\n        const columnNames = clonedTable.primaryColumns.map(primaryColumn => `\"${primaryColumn.name}\"`).join(\", \");\n        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(clonedTable)} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`));\n        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(clonedTable)} DROP CONSTRAINT \"${pkName}\"`));\n      }\n    } // drop column index\n\n\n    const columnIndex = clonedTable.indices.find(index => index.columnNames.length === 1 && index.columnNames[0] === column.name);\n\n    if (columnIndex) {\n      clonedTable.indices.splice(clonedTable.indices.indexOf(columnIndex), 1);\n      upQueries.push(this.dropIndexSql(table, columnIndex));\n      downQueries.push(this.createIndexSql(table, columnIndex));\n    } // drop column check\n\n\n    const columnCheck = clonedTable.checks.find(check => !!check.columnNames && check.columnNames.length === 1 && check.columnNames[0] === column.name);\n\n    if (columnCheck) {\n      clonedTable.checks.splice(clonedTable.checks.indexOf(columnCheck), 1);\n      upQueries.push(this.dropCheckConstraintSql(table, columnCheck));\n      downQueries.push(this.createCheckConstraintSql(table, columnCheck));\n    } // drop column unique\n\n\n    const columnUnique = clonedTable.uniques.find(unique => unique.columnNames.length === 1 && unique.columnNames[0] === column.name);\n\n    if (columnUnique) {\n      clonedTable.uniques.splice(clonedTable.uniques.indexOf(columnUnique), 1);\n      upQueries.push(this.dropUniqueConstraintSql(table, columnUnique));\n      downQueries.push(this.createUniqueConstraintSql(table, columnUnique));\n    }\n\n    upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN \"${column.name}\"`));\n    downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(table, column)}`)); // drop enum type\n\n    if (column.type === \"enum\" || column.type === \"simple-enum\") {\n      const hasEnum = await this.hasEnumType(table, column);\n\n      if (hasEnum) {\n        const enumType = await this.getUserDefinedTypeName(table, column);\n        const escapedEnumName = `\"${enumType.schema}\".\"${enumType.name}\"`;\n        upQueries.push(this.dropEnumTypeSql(table, column, escapedEnumName));\n        downQueries.push(this.createEnumTypeSql(table, column, escapedEnumName));\n      }\n    }\n\n    if (column.generatedType === \"STORED\") {\n      const tableNameWithSchema = (await this.getTableNameWithSchema(table.name)).split(\".\");\n      const tableName = tableNameWithSchema[1];\n      const schema = tableNameWithSchema[0];\n      const deleteQuery = this.deleteTypeormMetadataSql({\n        database: this.driver.database,\n        schema,\n        table: tableName,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name\n      });\n      const insertQuery = this.insertTypeormMetadataSql({\n        database: this.driver.database,\n        schema,\n        table: tableName,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name,\n        value: column.asExpression\n      });\n      upQueries.push(deleteQuery);\n      downQueries.push(insertQuery);\n    }\n\n    await this.executeQueries(upQueries, downQueries);\n    clonedTable.removeColumn(column);\n    this.replaceCachedTable(table, clonedTable);\n  }\n  /**\n   * Drops the columns in the table.\n   */\n\n\n  async dropColumns(tableOrName, columns) {\n    for (const column of columns) {\n      await this.dropColumn(tableOrName, column);\n    }\n  }\n  /**\n   * Creates a new primary key.\n   */\n\n\n  async createPrimaryKey(tableOrName, columnNames, constraintName) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const clonedTable = table.clone();\n    const up = this.createPrimaryKeySql(table, columnNames, constraintName); // mark columns as primary, because dropPrimaryKeySql build constraint name from table primary column names.\n\n    clonedTable.columns.forEach(column => {\n      if (columnNames.find(columnName => columnName === column.name)) column.isPrimary = true;\n    });\n    const down = this.dropPrimaryKeySql(clonedTable);\n    await this.executeQueries(up, down);\n    this.replaceCachedTable(table, clonedTable);\n  }\n  /**\n   * Updates composite primary keys.\n   */\n\n\n  async updatePrimaryKeys(tableOrName, columns) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const clonedTable = table.clone();\n    const columnNames = columns.map(column => column.name);\n    const upQueries = [];\n    const downQueries = []; // if table already have primary columns, we must drop them.\n\n    const primaryColumns = clonedTable.primaryColumns;\n\n    if (primaryColumns.length > 0) {\n      const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map(column => column.name));\n      const columnNamesString = primaryColumns.map(column => `\"${column.name}\"`).join(\", \");\n      upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${pkName}\"`));\n      downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNamesString})`));\n    } // update columns in table.\n\n\n    clonedTable.columns.filter(column => columnNames.indexOf(column.name) !== -1).forEach(column => column.isPrimary = true);\n    const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, columnNames);\n    const columnNamesString = columnNames.map(columnName => `\"${columnName}\"`).join(\", \");\n    upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNamesString})`));\n    downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${pkName}\"`));\n    await this.executeQueries(upQueries, downQueries);\n    this.replaceCachedTable(table, clonedTable);\n  }\n  /**\n   * Drops a primary key.\n   */\n\n\n  async dropPrimaryKey(tableOrName, constraintName) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const up = this.dropPrimaryKeySql(table);\n    const down = this.createPrimaryKeySql(table, table.primaryColumns.map(column => column.name), constraintName);\n    await this.executeQueries(up, down);\n    table.primaryColumns.forEach(column => {\n      column.isPrimary = false;\n    });\n  }\n  /**\n   * Creates new unique constraint.\n   */\n\n\n  async createUniqueConstraint(tableOrName, uniqueConstraint) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName); // new unique constraint may be passed without name. In this case we generate unique name manually.\n\n    if (!uniqueConstraint.name) uniqueConstraint.name = this.connection.namingStrategy.uniqueConstraintName(table, uniqueConstraint.columnNames);\n    const up = this.createUniqueConstraintSql(table, uniqueConstraint);\n    const down = this.dropUniqueConstraintSql(table, uniqueConstraint);\n    await this.executeQueries(up, down);\n    table.addUniqueConstraint(uniqueConstraint);\n  }\n  /**\n   * Creates new unique constraints.\n   */\n\n\n  async createUniqueConstraints(tableOrName, uniqueConstraints) {\n    for (const uniqueConstraint of uniqueConstraints) {\n      await this.createUniqueConstraint(tableOrName, uniqueConstraint);\n    }\n  }\n  /**\n   * Drops unique constraint.\n   */\n\n\n  async dropUniqueConstraint(tableOrName, uniqueOrName) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const uniqueConstraint = InstanceChecker.isTableUnique(uniqueOrName) ? uniqueOrName : table.uniques.find(u => u.name === uniqueOrName);\n    if (!uniqueConstraint) throw new TypeORMError(`Supplied unique constraint was not found in table ${table.name}`);\n    const up = this.dropUniqueConstraintSql(table, uniqueConstraint);\n    const down = this.createUniqueConstraintSql(table, uniqueConstraint);\n    await this.executeQueries(up, down);\n    table.removeUniqueConstraint(uniqueConstraint);\n  }\n  /**\n   * Drops unique constraints.\n   */\n\n\n  async dropUniqueConstraints(tableOrName, uniqueConstraints) {\n    for (const uniqueConstraint of uniqueConstraints) {\n      await this.dropUniqueConstraint(tableOrName, uniqueConstraint);\n    }\n  }\n  /**\n   * Creates new check constraint.\n   */\n\n\n  async createCheckConstraint(tableOrName, checkConstraint) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName); // new unique constraint may be passed without name. In this case we generate unique name manually.\n\n    if (!checkConstraint.name) checkConstraint.name = this.connection.namingStrategy.checkConstraintName(table, checkConstraint.expression);\n    const up = this.createCheckConstraintSql(table, checkConstraint);\n    const down = this.dropCheckConstraintSql(table, checkConstraint);\n    await this.executeQueries(up, down);\n    table.addCheckConstraint(checkConstraint);\n  }\n  /**\n   * Creates new check constraints.\n   */\n\n\n  async createCheckConstraints(tableOrName, checkConstraints) {\n    const promises = checkConstraints.map(checkConstraint => this.createCheckConstraint(tableOrName, checkConstraint));\n    await Promise.all(promises);\n  }\n  /**\n   * Drops check constraint.\n   */\n\n\n  async dropCheckConstraint(tableOrName, checkOrName) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const checkConstraint = InstanceChecker.isTableCheck(checkOrName) ? checkOrName : table.checks.find(c => c.name === checkOrName);\n    if (!checkConstraint) throw new TypeORMError(`Supplied check constraint was not found in table ${table.name}`);\n    const up = this.dropCheckConstraintSql(table, checkConstraint);\n    const down = this.createCheckConstraintSql(table, checkConstraint);\n    await this.executeQueries(up, down);\n    table.removeCheckConstraint(checkConstraint);\n  }\n  /**\n   * Drops check constraints.\n   */\n\n\n  async dropCheckConstraints(tableOrName, checkConstraints) {\n    const promises = checkConstraints.map(checkConstraint => this.dropCheckConstraint(tableOrName, checkConstraint));\n    await Promise.all(promises);\n  }\n  /**\n   * Creates new exclusion constraint.\n   */\n\n\n  async createExclusionConstraint(tableOrName, exclusionConstraint) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName); // new unique constraint may be passed without name. In this case we generate unique name manually.\n\n    if (!exclusionConstraint.name) exclusionConstraint.name = this.connection.namingStrategy.exclusionConstraintName(table, exclusionConstraint.expression);\n    const up = this.createExclusionConstraintSql(table, exclusionConstraint);\n    const down = this.dropExclusionConstraintSql(table, exclusionConstraint);\n    await this.executeQueries(up, down);\n    table.addExclusionConstraint(exclusionConstraint);\n  }\n  /**\n   * Creates new exclusion constraints.\n   */\n\n\n  async createExclusionConstraints(tableOrName, exclusionConstraints) {\n    const promises = exclusionConstraints.map(exclusionConstraint => this.createExclusionConstraint(tableOrName, exclusionConstraint));\n    await Promise.all(promises);\n  }\n  /**\n   * Drops exclusion constraint.\n   */\n\n\n  async dropExclusionConstraint(tableOrName, exclusionOrName) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const exclusionConstraint = InstanceChecker.isTableExclusion(exclusionOrName) ? exclusionOrName : table.exclusions.find(c => c.name === exclusionOrName);\n    if (!exclusionConstraint) throw new TypeORMError(`Supplied exclusion constraint was not found in table ${table.name}`);\n    const up = this.dropExclusionConstraintSql(table, exclusionConstraint);\n    const down = this.createExclusionConstraintSql(table, exclusionConstraint);\n    await this.executeQueries(up, down);\n    table.removeExclusionConstraint(exclusionConstraint);\n  }\n  /**\n   * Drops exclusion constraints.\n   */\n\n\n  async dropExclusionConstraints(tableOrName, exclusionConstraints) {\n    const promises = exclusionConstraints.map(exclusionConstraint => this.dropExclusionConstraint(tableOrName, exclusionConstraint));\n    await Promise.all(promises);\n  }\n  /**\n   * Creates a new foreign key.\n   */\n\n\n  async createForeignKey(tableOrName, foreignKey) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName); // new FK may be passed without name. In this case we generate FK name manually.\n\n    if (!foreignKey.name) foreignKey.name = this.connection.namingStrategy.foreignKeyName(table, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);\n    const up = this.createForeignKeySql(table, foreignKey);\n    const down = this.dropForeignKeySql(table, foreignKey);\n    await this.executeQueries(up, down);\n    table.addForeignKey(foreignKey);\n  }\n  /**\n   * Creates a new foreign keys.\n   */\n\n\n  async createForeignKeys(tableOrName, foreignKeys) {\n    for (const foreignKey of foreignKeys) {\n      await this.createForeignKey(tableOrName, foreignKey);\n    }\n  }\n  /**\n   * Drops a foreign key from the table.\n   */\n\n\n  async dropForeignKey(tableOrName, foreignKeyOrName) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const foreignKey = InstanceChecker.isTableForeignKey(foreignKeyOrName) ? foreignKeyOrName : table.foreignKeys.find(fk => fk.name === foreignKeyOrName);\n    if (!foreignKey) throw new TypeORMError(`Supplied foreign key was not found in table ${table.name}`);\n    const up = this.dropForeignKeySql(table, foreignKey);\n    const down = this.createForeignKeySql(table, foreignKey);\n    await this.executeQueries(up, down);\n    table.removeForeignKey(foreignKey);\n  }\n  /**\n   * Drops a foreign keys from the table.\n   */\n\n\n  async dropForeignKeys(tableOrName, foreignKeys) {\n    for (const foreignKey of foreignKeys) {\n      await this.dropForeignKey(tableOrName, foreignKey);\n    }\n  }\n  /**\n   * Creates a new index.\n   */\n\n\n  async createIndex(tableOrName, index) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName); // new index may be passed without name. In this case we generate index name manually.\n\n    if (!index.name) index.name = this.generateIndexName(table, index);\n    const up = this.createIndexSql(table, index);\n    const down = this.dropIndexSql(table, index);\n    await this.executeQueries(up, down);\n    table.addIndex(index);\n  }\n  /**\n   * Creates a new indices\n   */\n\n\n  async createIndices(tableOrName, indices) {\n    for (const index of indices) {\n      await this.createIndex(tableOrName, index);\n    }\n  }\n  /**\n   * Drops an index from the table.\n   */\n\n\n  async dropIndex(tableOrName, indexOrName) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const index = InstanceChecker.isTableIndex(indexOrName) ? indexOrName : table.indices.find(i => i.name === indexOrName);\n    if (!index) throw new TypeORMError(`Supplied index ${indexOrName} was not found in table ${table.name}`); // old index may be passed without name. In this case we generate index name manually.\n\n    if (!index.name) index.name = this.generateIndexName(table, index);\n    const up = this.dropIndexSql(table, index);\n    const down = this.createIndexSql(table, index);\n    await this.executeQueries(up, down);\n    table.removeIndex(index);\n  }\n  /**\n   * Drops an indices from the table.\n   */\n\n\n  async dropIndices(tableOrName, indices) {\n    for (const index of indices) {\n      await this.dropIndex(tableOrName, index);\n    }\n  }\n  /**\n   * Clears all table contents.\n   * Note: this operation uses SQL's TRUNCATE query which cannot be reverted in transactions.\n   */\n\n\n  async clearTable(tableName) {\n    await this.query(`TRUNCATE TABLE ${this.escapePath(tableName)}`);\n  }\n  /**\n   * Removes all tables from the currently connected database.\n   */\n\n\n  async clearDatabase() {\n    const schemas = [];\n    this.connection.entityMetadatas.filter(metadata => metadata.schema).forEach(metadata => {\n      const isSchemaExist = !!schemas.find(schema => schema === metadata.schema);\n      if (!isSchemaExist) schemas.push(metadata.schema);\n    });\n    schemas.push(this.driver.options.schema || \"current_schema()\");\n    const schemaNamesString = schemas.map(name => {\n      return name === \"current_schema()\" ? name : \"'\" + name + \"'\";\n    }).join(\", \");\n    const isAnotherTransactionActive = this.isTransactionActive;\n    if (!isAnotherTransactionActive) await this.startTransaction();\n\n    try {\n      const version = await this.getVersion(); // drop views\n\n      const selectViewDropsQuery = `SELECT 'DROP VIEW IF EXISTS \"' || schemaname || '\".\"' || viewname || '\" CASCADE;' as \"query\" ` + `FROM \"pg_views\" WHERE \"schemaname\" IN (${schemaNamesString}) AND \"viewname\" NOT IN ('geography_columns', 'geometry_columns', 'raster_columns', 'raster_overviews')`;\n      const dropViewQueries = await this.query(selectViewDropsQuery);\n      await Promise.all(dropViewQueries.map(q => this.query(q[\"query\"]))); // drop materialized views\n      // Note: materialized views introduced in Postgres 9.3\n\n      if (VersionUtils.isGreaterOrEqual(version, \"9.3\")) {\n        const selectMatViewDropsQuery = `SELECT 'DROP MATERIALIZED VIEW IF EXISTS \"' || schemaname || '\".\"' || matviewname || '\" CASCADE;' as \"query\" ` + `FROM \"pg_matviews\" WHERE \"schemaname\" IN (${schemaNamesString})`;\n        const dropMatViewQueries = await this.query(selectMatViewDropsQuery);\n        await Promise.all(dropMatViewQueries.map(q => this.query(q[\"query\"])));\n      } // ignore spatial_ref_sys; it's a special table supporting PostGIS\n      // TODO generalize this as this.driver.ignoreTables\n      // drop tables\n\n\n      const selectTableDropsQuery = `SELECT 'DROP TABLE IF EXISTS \"' || schemaname || '\".\"' || tablename || '\" CASCADE;' as \"query\" FROM \"pg_tables\" WHERE \"schemaname\" IN (${schemaNamesString}) AND \"tablename\" NOT IN ('spatial_ref_sys')`;\n      const dropTableQueries = await this.query(selectTableDropsQuery);\n      await Promise.all(dropTableQueries.map(q => this.query(q[\"query\"]))); // drop enum types\n\n      await this.dropEnumTypes(schemaNamesString);\n\n      if (!isAnotherTransactionActive) {\n        await this.commitTransaction();\n      }\n    } catch (error) {\n      try {\n        // we throw original error even if rollback thrown an error\n        if (!isAnotherTransactionActive) {\n          await this.rollbackTransaction();\n        }\n      } catch (rollbackError) {}\n\n      throw error;\n    }\n  } // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n\n  async loadViews(viewNames) {\n    const hasTable = await this.hasTable(this.getTypeormMetadataTableName());\n    if (!hasTable) return [];\n\n    if (!viewNames) {\n      viewNames = [];\n    }\n\n    const currentDatabase = await this.getCurrentDatabase();\n    const currentSchema = await this.getCurrentSchema();\n    const viewsCondition = viewNames.length === 0 ? \"1=1\" : viewNames.map(tableName => this.driver.parseTableName(tableName)).map(_ref3 => {\n      let {\n        schema,\n        tableName\n      } = _ref3;\n\n      if (!schema) {\n        schema = this.driver.options.schema || currentSchema;\n      }\n\n      return `(\"t\".\"schema\" = '${schema}' AND \"t\".\"name\" = '${tableName}')`;\n    }).join(\" OR \");\n    const query = `SELECT \"t\".* FROM ${this.escapePath(this.getTypeormMetadataTableName())} \"t\" ` + `INNER JOIN \"pg_catalog\".\"pg_class\" \"c\" ON \"c\".\"relname\" = \"t\".\"name\" ` + `INNER JOIN \"pg_namespace\" \"n\" ON \"n\".\"oid\" = \"c\".\"relnamespace\" AND \"n\".\"nspname\" = \"t\".\"schema\" ` + `WHERE \"t\".\"type\" IN ('${MetadataTableType.VIEW}', '${MetadataTableType.MATERIALIZED_VIEW}') ${viewsCondition ? `AND (${viewsCondition})` : \"\"}`;\n    const dbViews = await this.query(query);\n    return dbViews.map(dbView => {\n      const view = new View();\n      const schema = dbView[\"schema\"] === currentSchema && !this.driver.options.schema ? undefined : dbView[\"schema\"];\n      view.database = currentDatabase;\n      view.schema = dbView[\"schema\"];\n      view.name = this.driver.buildTableName(dbView[\"name\"], schema);\n      view.expression = dbView[\"value\"];\n      view.materialized = dbView[\"type\"] === MetadataTableType.MATERIALIZED_VIEW;\n      return view;\n    });\n  }\n  /**\n   * Loads all tables (with given names) from the database and creates a Table from them.\n   */\n\n\n  async loadTables(tableNames) {\n    // if no tables given then no need to proceed\n    if (tableNames && tableNames.length === 0) {\n      return [];\n    }\n\n    const currentSchema = await this.getCurrentSchema();\n    const currentDatabase = await this.getCurrentDatabase();\n    const dbTables = [];\n\n    if (!tableNames) {\n      const tablesSql = `SELECT \"table_schema\", \"table_name\" FROM \"information_schema\".\"tables\"`;\n      dbTables.push(...(await this.query(tablesSql)));\n    } else {\n      const tablesCondition = tableNames.map(tableName => this.driver.parseTableName(tableName)).map(_ref4 => {\n        let {\n          schema,\n          tableName\n        } = _ref4;\n        return `(\"table_schema\" = '${schema || currentSchema}' AND \"table_name\" = '${tableName}')`;\n      }).join(\" OR \");\n      const tablesSql = `SELECT \"table_schema\", \"table_name\" FROM \"information_schema\".\"tables\" WHERE ` + tablesCondition;\n      dbTables.push(...(await this.query(tablesSql)));\n    } // if tables were not found in the db, no need to proceed\n\n\n    if (dbTables.length === 0) {\n      return [];\n    }\n    /**\n     * Uses standard SQL information_schema.columns table and postgres-specific\n     * pg_catalog.pg_attribute table to get column information.\n     * @see https://stackoverflow.com/a/19541865\n     */\n\n\n    const columnsCondition = dbTables.map(_ref5 => {\n      let {\n        table_schema,\n        table_name\n      } = _ref5;\n      return `(\"table_schema\" = '${table_schema}' AND \"table_name\" = '${table_name}')`;\n    }).join(\" OR \");\n    const columnsSql = `SELECT columns.*, pg_catalog.col_description(('\"' || table_catalog || '\".\"' || table_schema || '\".\"' || table_name || '\"')::regclass::oid, ordinal_position) AS description, ` + `('\"' || \"udt_schema\" || '\".\"' || \"udt_name\" || '\"')::\"regtype\" AS \"regtype\", pg_catalog.format_type(\"col_attr\".\"atttypid\", \"col_attr\".\"atttypmod\") AS \"format_type\" ` + `FROM \"information_schema\".\"columns\" ` + `LEFT JOIN \"pg_catalog\".\"pg_attribute\" AS \"col_attr\" ON \"col_attr\".\"attname\" = \"columns\".\"column_name\" ` + `AND \"col_attr\".\"attrelid\" = ( ` + `SELECT \"cls\".\"oid\" FROM \"pg_catalog\".\"pg_class\" AS \"cls\" ` + `LEFT JOIN \"pg_catalog\".\"pg_namespace\" AS \"ns\" ON \"ns\".\"oid\" = \"cls\".\"relnamespace\" ` + `WHERE \"cls\".\"relname\" = \"columns\".\"table_name\" ` + `AND \"ns\".\"nspname\" = \"columns\".\"table_schema\" ` + `) ` + `WHERE ` + columnsCondition;\n    const constraintsCondition = dbTables.map(_ref6 => {\n      let {\n        table_schema,\n        table_name\n      } = _ref6;\n      return `(\"ns\".\"nspname\" = '${table_schema}' AND \"t\".\"relname\" = '${table_name}')`;\n    }).join(\" OR \");\n    const constraintsSql = `SELECT \"ns\".\"nspname\" AS \"table_schema\", \"t\".\"relname\" AS \"table_name\", \"cnst\".\"conname\" AS \"constraint_name\", ` + `pg_get_constraintdef(\"cnst\".\"oid\") AS \"expression\", ` + `CASE \"cnst\".\"contype\" WHEN 'p' THEN 'PRIMARY' WHEN 'u' THEN 'UNIQUE' WHEN 'c' THEN 'CHECK' WHEN 'x' THEN 'EXCLUDE' END AS \"constraint_type\", \"a\".\"attname\" AS \"column_name\" ` + `FROM \"pg_constraint\" \"cnst\" ` + `INNER JOIN \"pg_class\" \"t\" ON \"t\".\"oid\" = \"cnst\".\"conrelid\" ` + `INNER JOIN \"pg_namespace\" \"ns\" ON \"ns\".\"oid\" = \"cnst\".\"connamespace\" ` + `LEFT JOIN \"pg_attribute\" \"a\" ON \"a\".\"attrelid\" = \"cnst\".\"conrelid\" AND \"a\".\"attnum\" = ANY (\"cnst\".\"conkey\") ` + `WHERE \"t\".\"relkind\" IN ('r', 'p') AND (${constraintsCondition})`;\n    const indicesSql = `SELECT \"ns\".\"nspname\" AS \"table_schema\", \"t\".\"relname\" AS \"table_name\", \"i\".\"relname\" AS \"constraint_name\", \"a\".\"attname\" AS \"column_name\", ` + `CASE \"ix\".\"indisunique\" WHEN 't' THEN 'TRUE' ELSE'FALSE' END AS \"is_unique\", pg_get_expr(\"ix\".\"indpred\", \"ix\".\"indrelid\") AS \"condition\", ` + `\"types\".\"typname\" AS \"type_name\" ` + `FROM \"pg_class\" \"t\" ` + `INNER JOIN \"pg_index\" \"ix\" ON \"ix\".\"indrelid\" = \"t\".\"oid\" ` + `INNER JOIN \"pg_attribute\" \"a\" ON \"a\".\"attrelid\" = \"t\".\"oid\"  AND \"a\".\"attnum\" = ANY (\"ix\".\"indkey\") ` + `INNER JOIN \"pg_namespace\" \"ns\" ON \"ns\".\"oid\" = \"t\".\"relnamespace\" ` + `INNER JOIN \"pg_class\" \"i\" ON \"i\".\"oid\" = \"ix\".\"indexrelid\" ` + `INNER JOIN \"pg_type\" \"types\" ON \"types\".\"oid\" = \"a\".\"atttypid\" ` + `LEFT JOIN \"pg_constraint\" \"cnst\" ON \"cnst\".\"conname\" = \"i\".\"relname\" ` + `WHERE \"t\".\"relkind\" IN ('r', 'p') AND \"cnst\".\"contype\" IS NULL AND (${constraintsCondition})`;\n    const foreignKeysCondition = dbTables.map(_ref7 => {\n      let {\n        table_schema,\n        table_name\n      } = _ref7;\n      return `(\"ns\".\"nspname\" = '${table_schema}' AND \"cl\".\"relname\" = '${table_name}')`;\n    }).join(\" OR \");\n    const hasRelispartitionColumn = await this.hasSupportForPartitionedTables();\n    const isPartitionCondition = hasRelispartitionColumn ? ` AND \"cl\".\"relispartition\" = 'f'` : \"\";\n    const foreignKeysSql = `SELECT \"con\".\"conname\" AS \"constraint_name\", \"con\".\"nspname\" AS \"table_schema\", \"con\".\"relname\" AS \"table_name\", \"att2\".\"attname\" AS \"column_name\", ` + `\"ns\".\"nspname\" AS \"referenced_table_schema\", \"cl\".\"relname\" AS \"referenced_table_name\", \"att\".\"attname\" AS \"referenced_column_name\", \"con\".\"confdeltype\" AS \"on_delete\", ` + `\"con\".\"confupdtype\" AS \"on_update\", \"con\".\"condeferrable\" AS \"deferrable\", \"con\".\"condeferred\" AS \"deferred\" ` + `FROM ( ` + `SELECT UNNEST (\"con1\".\"conkey\") AS \"parent\", UNNEST (\"con1\".\"confkey\") AS \"child\", \"con1\".\"confrelid\", \"con1\".\"conrelid\", \"con1\".\"conname\", \"con1\".\"contype\", \"ns\".\"nspname\", ` + `\"cl\".\"relname\", \"con1\".\"condeferrable\", ` + `CASE WHEN \"con1\".\"condeferred\" THEN 'INITIALLY DEFERRED' ELSE 'INITIALLY IMMEDIATE' END as condeferred, ` + `CASE \"con1\".\"confdeltype\" WHEN 'a' THEN 'NO ACTION' WHEN 'r' THEN 'RESTRICT' WHEN 'c' THEN 'CASCADE' WHEN 'n' THEN 'SET NULL' WHEN 'd' THEN 'SET DEFAULT' END as \"confdeltype\", ` + `CASE \"con1\".\"confupdtype\" WHEN 'a' THEN 'NO ACTION' WHEN 'r' THEN 'RESTRICT' WHEN 'c' THEN 'CASCADE' WHEN 'n' THEN 'SET NULL' WHEN 'd' THEN 'SET DEFAULT' END as \"confupdtype\" ` + `FROM \"pg_class\" \"cl\" ` + `INNER JOIN \"pg_namespace\" \"ns\" ON \"cl\".\"relnamespace\" = \"ns\".\"oid\" ` + `INNER JOIN \"pg_constraint\" \"con1\" ON \"con1\".\"conrelid\" = \"cl\".\"oid\" ` + `WHERE \"con1\".\"contype\" = 'f' AND (${foreignKeysCondition}) ` + `) \"con\" ` + `INNER JOIN \"pg_attribute\" \"att\" ON \"att\".\"attrelid\" = \"con\".\"confrelid\" AND \"att\".\"attnum\" = \"con\".\"child\" ` + `INNER JOIN \"pg_class\" \"cl\" ON \"cl\".\"oid\" = \"con\".\"confrelid\" ${isPartitionCondition}` + `INNER JOIN \"pg_namespace\" \"ns\" ON \"cl\".\"relnamespace\" = \"ns\".\"oid\" ` + `INNER JOIN \"pg_attribute\" \"att2\" ON \"att2\".\"attrelid\" = \"con\".\"conrelid\" AND \"att2\".\"attnum\" = \"con\".\"parent\"`;\n    const [dbColumns, dbConstraints, dbIndices, dbForeignKeys] = await Promise.all([this.query(columnsSql), this.query(constraintsSql), this.query(indicesSql), this.query(foreignKeysSql)]); // create tables for loaded tables\n\n    return Promise.all(dbTables.map(async dbTable => {\n      const table = new Table();\n\n      const getSchemaFromKey = (dbObject, key) => {\n        return dbObject[key] === currentSchema && (!this.driver.options.schema || this.driver.options.schema === currentSchema) ? undefined : dbObject[key];\n      }; // We do not need to join schema name, when database is by default.\n\n\n      const schema = getSchemaFromKey(dbTable, \"table_schema\");\n      table.database = currentDatabase;\n      table.schema = dbTable[\"table_schema\"];\n      table.name = this.driver.buildTableName(dbTable[\"table_name\"], schema); // create columns from the loaded columns\n\n      table.columns = await Promise.all(dbColumns.filter(dbColumn => dbColumn[\"table_name\"] === dbTable[\"table_name\"] && dbColumn[\"table_schema\"] === dbTable[\"table_schema\"]).map(async dbColumn => {\n        const columnConstraints = dbConstraints.filter(dbConstraint => {\n          return dbConstraint[\"table_name\"] === dbColumn[\"table_name\"] && dbConstraint[\"table_schema\"] === dbColumn[\"table_schema\"] && dbConstraint[\"column_name\"] === dbColumn[\"column_name\"];\n        });\n        const tableColumn = new TableColumn();\n        tableColumn.name = dbColumn[\"column_name\"];\n        tableColumn.type = dbColumn[\"regtype\"].toLowerCase();\n\n        if (tableColumn.type === \"numeric\" || tableColumn.type === \"decimal\" || tableColumn.type === \"float\") {\n          // If one of these properties was set, and another was not, Postgres sets '0' in to unspecified property\n          // we set 'undefined' in to unspecified property to avoid changing column on sync\n          if (dbColumn[\"numeric_precision\"] !== null && !this.isDefaultColumnPrecision(table, tableColumn, dbColumn[\"numeric_precision\"])) {\n            tableColumn.precision = dbColumn[\"numeric_precision\"];\n          } else if (dbColumn[\"numeric_scale\"] !== null && !this.isDefaultColumnScale(table, tableColumn, dbColumn[\"numeric_scale\"])) {\n            tableColumn.precision = undefined;\n          }\n\n          if (dbColumn[\"numeric_scale\"] !== null && !this.isDefaultColumnScale(table, tableColumn, dbColumn[\"numeric_scale\"])) {\n            tableColumn.scale = dbColumn[\"numeric_scale\"];\n          } else if (dbColumn[\"numeric_precision\"] !== null && !this.isDefaultColumnPrecision(table, tableColumn, dbColumn[\"numeric_precision\"])) {\n            tableColumn.scale = undefined;\n          }\n        }\n\n        if (tableColumn.type === \"interval\" || tableColumn.type === \"time without time zone\" || tableColumn.type === \"time with time zone\" || tableColumn.type === \"timestamp without time zone\" || tableColumn.type === \"timestamp with time zone\") {\n          tableColumn.precision = !this.isDefaultColumnPrecision(table, tableColumn, dbColumn[\"datetime_precision\"]) ? dbColumn[\"datetime_precision\"] : undefined;\n        } // check if column has user-defined data type.\n        // NOTE: if ENUM type defined with \"array:true\" it comes with ARRAY type instead of USER-DEFINED\n\n\n        if (dbColumn[\"data_type\"] === \"USER-DEFINED\" || dbColumn[\"data_type\"] === \"ARRAY\") {\n          const {\n            name\n          } = await this.getUserDefinedTypeName(table, tableColumn); // check if `enumName` is specified by user\n\n          const builtEnumName = this.buildEnumName(table, tableColumn, false, true);\n          const enumName = builtEnumName !== name ? name : undefined; // check if type is ENUM\n\n          const sql = `SELECT \"e\".\"enumlabel\" AS \"value\" FROM \"pg_enum\" \"e\" ` + `INNER JOIN \"pg_type\" \"t\" ON \"t\".\"oid\" = \"e\".\"enumtypid\" ` + `INNER JOIN \"pg_namespace\" \"n\" ON \"n\".\"oid\" = \"t\".\"typnamespace\" ` + `WHERE \"n\".\"nspname\" = '${dbTable[\"table_schema\"]}' AND \"t\".\"typname\" = '${enumName || name}'`;\n          const results = await this.query(sql);\n\n          if (results.length) {\n            tableColumn.type = \"enum\";\n            tableColumn.enum = results.map(result => result[\"value\"]);\n            tableColumn.enumName = enumName;\n          }\n\n          if (dbColumn[\"data_type\"] === \"ARRAY\") {\n            tableColumn.isArray = true;\n            const type = tableColumn.type.replace(\"[]\", \"\");\n            tableColumn.type = this.connection.driver.normalizeType({\n              type: type\n            });\n          }\n        }\n\n        if (tableColumn.type === \"geometry\") {\n          const geometryColumnSql = `SELECT * FROM (\n                        SELECT\n                          \"f_table_schema\" \"table_schema\",\n                          \"f_table_name\" \"table_name\",\n                          \"f_geometry_column\" \"column_name\",\n                          \"srid\",\n                          \"type\"\n                        FROM \"geometry_columns\"\n                      ) AS _\n                      WHERE\n                          \"column_name\" = '${dbColumn[\"column_name\"]}' AND\n                          \"table_schema\" = '${dbColumn[\"table_schema\"]}' AND\n                          \"table_name\" = '${dbColumn[\"table_name\"]}'`;\n          const results = await this.query(geometryColumnSql);\n\n          if (results.length > 0) {\n            tableColumn.spatialFeatureType = results[0].type;\n            tableColumn.srid = results[0].srid;\n          }\n        }\n\n        if (tableColumn.type === \"geography\") {\n          const geographyColumnSql = `SELECT * FROM (\n                        SELECT\n                          \"f_table_schema\" \"table_schema\",\n                          \"f_table_name\" \"table_name\",\n                          \"f_geography_column\" \"column_name\",\n                          \"srid\",\n                          \"type\"\n                        FROM \"geography_columns\"\n                      ) AS _\n                      WHERE\n                          \"column_name\" = '${dbColumn[\"column_name\"]}' AND\n                          \"table_schema\" = '${dbColumn[\"table_schema\"]}' AND\n                          \"table_name\" = '${dbColumn[\"table_name\"]}'`;\n          const results = await this.query(geographyColumnSql);\n\n          if (results.length > 0) {\n            tableColumn.spatialFeatureType = results[0].type;\n            tableColumn.srid = results[0].srid;\n          }\n        } // check only columns that have length property\n\n\n        if (this.driver.withLengthColumnTypes.indexOf(tableColumn.type) !== -1) {\n          let length;\n\n          if (tableColumn.isArray) {\n            const match = /\\((\\d+)\\)/.exec(dbColumn[\"format_type\"]);\n            length = match ? match[1] : undefined;\n          } else if (dbColumn[\"character_maximum_length\"]) {\n            length = dbColumn[\"character_maximum_length\"].toString();\n          }\n\n          if (length) {\n            tableColumn.length = !this.isDefaultColumnLength(table, tableColumn, length) ? length : \"\";\n          }\n        }\n\n        tableColumn.isNullable = dbColumn[\"is_nullable\"] === \"YES\";\n        const primaryConstraint = columnConstraints.find(constraint => constraint[\"constraint_type\"] === \"PRIMARY\");\n\n        if (primaryConstraint) {\n          tableColumn.isPrimary = true; // find another columns involved in primary key constraint\n\n          const anotherPrimaryConstraints = dbConstraints.filter(constraint => constraint[\"table_name\"] === dbColumn[\"table_name\"] && constraint[\"table_schema\"] === dbColumn[\"table_schema\"] && constraint[\"column_name\"] !== dbColumn[\"column_name\"] && constraint[\"constraint_type\"] === \"PRIMARY\"); // collect all column names\n\n          const columnNames = anotherPrimaryConstraints.map(constraint => constraint[\"column_name\"]);\n          columnNames.push(dbColumn[\"column_name\"]); // build default primary key constraint name\n\n          const pkName = this.connection.namingStrategy.primaryKeyName(table, columnNames); // if primary key has user-defined constraint name, write it in table column\n\n          if (primaryConstraint[\"constraint_name\"] !== pkName) {\n            tableColumn.primaryKeyConstraintName = primaryConstraint[\"constraint_name\"];\n          }\n        }\n\n        const uniqueConstraints = columnConstraints.filter(constraint => constraint[\"constraint_type\"] === \"UNIQUE\");\n        const isConstraintComposite = uniqueConstraints.every(uniqueConstraint => {\n          return dbConstraints.some(dbConstraint => dbConstraint[\"constraint_type\"] === \"UNIQUE\" && dbConstraint[\"constraint_name\"] === uniqueConstraint[\"constraint_name\"] && dbConstraint[\"column_name\"] !== dbColumn[\"column_name\"]);\n        });\n        tableColumn.isUnique = uniqueConstraints.length > 0 && !isConstraintComposite;\n\n        if (dbColumn.is_identity === \"YES\") {\n          // Postgres 10+ Identity column\n          tableColumn.isGenerated = true;\n          tableColumn.generationStrategy = \"identity\";\n          tableColumn.generatedIdentity = dbColumn.identity_generation;\n        } else if (dbColumn[\"column_default\"] !== null && dbColumn[\"column_default\"] !== undefined) {\n          const serialDefaultName = `nextval('${this.buildSequenceName(table, dbColumn[\"column_name\"])}'::regclass)`;\n          const serialDefaultPath = `nextval('${this.buildSequencePath(table, dbColumn[\"column_name\"])}'::regclass)`;\n          const defaultWithoutQuotes = dbColumn[\"column_default\"].replace(/\"/g, \"\");\n\n          if (defaultWithoutQuotes === serialDefaultName || defaultWithoutQuotes === serialDefaultPath) {\n            tableColumn.isGenerated = true;\n            tableColumn.generationStrategy = \"increment\";\n          } else if (dbColumn[\"column_default\"] === \"gen_random_uuid()\" || /^uuid_generate_v\\d\\(\\)/.test(dbColumn[\"column_default\"])) {\n            if (tableColumn.type === \"uuid\") {\n              tableColumn.isGenerated = true;\n              tableColumn.generationStrategy = \"uuid\";\n            } else {\n              tableColumn.default = dbColumn[\"column_default\"];\n            }\n          } else if (dbColumn[\"column_default\"] === \"now()\" || dbColumn[\"column_default\"].indexOf(\"'now'::text\") !== -1) {\n            tableColumn.default = dbColumn[\"column_default\"];\n          } else {\n            tableColumn.default = dbColumn[\"column_default\"].replace(/::[\\w\\s\\.\\[\\]\\\"]+/g, \"\");\n            tableColumn.default = tableColumn.default.replace(/^(-?\\d+)$/, \"'$1'\");\n          }\n        }\n\n        if (dbColumn[\"is_generated\"] === \"ALWAYS\" && dbColumn[\"generation_expression\"]) {\n          // In postgres there is no VIRTUAL generated column type\n          tableColumn.generatedType = \"STORED\"; // We cannot relay on information_schema.columns.generation_expression, because it is formatted different.\n\n          const asExpressionQuery = await this.selectTypeormMetadataSql({\n            database: currentDatabase,\n            schema: dbTable[\"table_schema\"],\n            table: dbTable[\"table_name\"],\n            type: MetadataTableType.GENERATED_COLUMN,\n            name: tableColumn.name\n          });\n          const results = await this.query(asExpressionQuery.query, asExpressionQuery.parameters);\n\n          if (results[0] && results[0].value) {\n            tableColumn.asExpression = results[0].value;\n          } else {\n            tableColumn.asExpression = \"\";\n          }\n        }\n\n        tableColumn.comment = dbColumn[\"description\"] ? dbColumn[\"description\"] : undefined;\n        if (dbColumn[\"character_set_name\"]) tableColumn.charset = dbColumn[\"character_set_name\"];\n        if (dbColumn[\"collation_name\"]) tableColumn.collation = dbColumn[\"collation_name\"];\n        return tableColumn;\n      })); // find unique constraints of table, group them by constraint name and build TableUnique.\n\n      const tableUniqueConstraints = OrmUtils.uniq(dbConstraints.filter(dbConstraint => {\n        return dbConstraint[\"table_name\"] === dbTable[\"table_name\"] && dbConstraint[\"table_schema\"] === dbTable[\"table_schema\"] && dbConstraint[\"constraint_type\"] === \"UNIQUE\";\n      }), dbConstraint => dbConstraint[\"constraint_name\"]);\n      table.uniques = tableUniqueConstraints.map(constraint => {\n        const uniques = dbConstraints.filter(dbC => dbC[\"constraint_name\"] === constraint[\"constraint_name\"]);\n        return new TableUnique({\n          name: constraint[\"constraint_name\"],\n          columnNames: uniques.map(u => u[\"column_name\"]),\n          deferrable: constraint[\"deferrable\"] ? constraint[\"deferred\"] : undefined\n        });\n      }); // find check constraints of table, group them by constraint name and build TableCheck.\n\n      const tableCheckConstraints = OrmUtils.uniq(dbConstraints.filter(dbConstraint => {\n        return dbConstraint[\"table_name\"] === dbTable[\"table_name\"] && dbConstraint[\"table_schema\"] === dbTable[\"table_schema\"] && dbConstraint[\"constraint_type\"] === \"CHECK\";\n      }), dbConstraint => dbConstraint[\"constraint_name\"]);\n      table.checks = tableCheckConstraints.map(constraint => {\n        const checks = dbConstraints.filter(dbC => dbC[\"constraint_name\"] === constraint[\"constraint_name\"]);\n        return new TableCheck({\n          name: constraint[\"constraint_name\"],\n          columnNames: checks.map(c => c[\"column_name\"]),\n          expression: constraint[\"expression\"].replace(/^\\s*CHECK\\s*\\((.*)\\)\\s*$/i, \"$1\")\n        });\n      }); // find exclusion constraints of table, group them by constraint name and build TableExclusion.\n\n      const tableExclusionConstraints = OrmUtils.uniq(dbConstraints.filter(dbConstraint => {\n        return dbConstraint[\"table_name\"] === dbTable[\"table_name\"] && dbConstraint[\"table_schema\"] === dbTable[\"table_schema\"] && dbConstraint[\"constraint_type\"] === \"EXCLUDE\";\n      }), dbConstraint => dbConstraint[\"constraint_name\"]);\n      table.exclusions = tableExclusionConstraints.map(constraint => {\n        return new TableExclusion({\n          name: constraint[\"constraint_name\"],\n          expression: constraint[\"expression\"].substring(8) // trim EXCLUDE from start of expression\n\n        });\n      }); // find foreign key constraints of table, group them by constraint name and build TableForeignKey.\n\n      const tableForeignKeyConstraints = OrmUtils.uniq(dbForeignKeys.filter(dbForeignKey => {\n        return dbForeignKey[\"table_name\"] === dbTable[\"table_name\"] && dbForeignKey[\"table_schema\"] === dbTable[\"table_schema\"];\n      }), dbForeignKey => dbForeignKey[\"constraint_name\"]);\n      table.foreignKeys = tableForeignKeyConstraints.map(dbForeignKey => {\n        const foreignKeys = dbForeignKeys.filter(dbFk => dbFk[\"constraint_name\"] === dbForeignKey[\"constraint_name\"]); // if referenced table located in currently used schema, we don't need to concat schema name to table name.\n\n        const schema = getSchemaFromKey(dbForeignKey, \"referenced_table_schema\");\n        const referencedTableName = this.driver.buildTableName(dbForeignKey[\"referenced_table_name\"], schema);\n        return new TableForeignKey({\n          name: dbForeignKey[\"constraint_name\"],\n          columnNames: foreignKeys.map(dbFk => dbFk[\"column_name\"]),\n          referencedSchema: dbForeignKey[\"referenced_table_schema\"],\n          referencedTableName: referencedTableName,\n          referencedColumnNames: foreignKeys.map(dbFk => dbFk[\"referenced_column_name\"]),\n          onDelete: dbForeignKey[\"on_delete\"],\n          onUpdate: dbForeignKey[\"on_update\"],\n          deferrable: dbForeignKey[\"deferrable\"] ? dbForeignKey[\"deferred\"] : undefined\n        });\n      }); // find index constraints of table, group them by constraint name and build TableIndex.\n\n      const tableIndexConstraints = OrmUtils.uniq(dbIndices.filter(dbIndex => {\n        return dbIndex[\"table_name\"] === dbTable[\"table_name\"] && dbIndex[\"table_schema\"] === dbTable[\"table_schema\"];\n      }), dbIndex => dbIndex[\"constraint_name\"]);\n      table.indices = tableIndexConstraints.map(constraint => {\n        const indices = dbIndices.filter(index => {\n          return index[\"table_schema\"] === constraint[\"table_schema\"] && index[\"table_name\"] === constraint[\"table_name\"] && index[\"constraint_name\"] === constraint[\"constraint_name\"];\n        });\n        return new TableIndex({\n          table: table,\n          name: constraint[\"constraint_name\"],\n          columnNames: indices.map(i => i[\"column_name\"]),\n          isUnique: constraint[\"is_unique\"] === \"TRUE\",\n          where: constraint[\"condition\"],\n          isSpatial: indices.every(i => this.driver.spatialTypes.indexOf(i[\"type_name\"]) >= 0),\n          isFulltext: false\n        });\n      });\n      return table;\n    }));\n  }\n  /**\n   * Builds create table sql.\n   */\n\n\n  createTableSql(table, createForeignKeys) {\n    const columnDefinitions = table.columns.map(column => this.buildCreateColumnSql(table, column)).join(\", \");\n    let sql = `CREATE TABLE ${this.escapePath(table)} (${columnDefinitions}`;\n    table.columns.filter(column => column.isUnique).forEach(column => {\n      const isUniqueExist = table.uniques.some(unique => unique.columnNames.length === 1 && unique.columnNames[0] === column.name);\n      if (!isUniqueExist) table.uniques.push(new TableUnique({\n        name: this.connection.namingStrategy.uniqueConstraintName(table, [column.name]),\n        columnNames: [column.name]\n      }));\n    });\n\n    if (table.uniques.length > 0) {\n      const uniquesSql = table.uniques.map(unique => {\n        const uniqueName = unique.name ? unique.name : this.connection.namingStrategy.uniqueConstraintName(table, unique.columnNames);\n        const columnNames = unique.columnNames.map(columnName => `\"${columnName}\"`).join(\", \");\n        let constraint = `CONSTRAINT \"${uniqueName}\" UNIQUE (${columnNames})`;\n        if (unique.deferrable) constraint += ` DEFERRABLE ${unique.deferrable}`;\n        return constraint;\n      }).join(\", \");\n      sql += `, ${uniquesSql}`;\n    }\n\n    if (table.checks.length > 0) {\n      const checksSql = table.checks.map(check => {\n        const checkName = check.name ? check.name : this.connection.namingStrategy.checkConstraintName(table, check.expression);\n        return `CONSTRAINT \"${checkName}\" CHECK (${check.expression})`;\n      }).join(\", \");\n      sql += `, ${checksSql}`;\n    }\n\n    if (table.exclusions.length > 0) {\n      const exclusionsSql = table.exclusions.map(exclusion => {\n        const exclusionName = exclusion.name ? exclusion.name : this.connection.namingStrategy.exclusionConstraintName(table, exclusion.expression);\n        return `CONSTRAINT \"${exclusionName}\" EXCLUDE ${exclusion.expression}`;\n      }).join(\", \");\n      sql += `, ${exclusionsSql}`;\n    }\n\n    if (table.foreignKeys.length > 0 && createForeignKeys) {\n      const foreignKeysSql = table.foreignKeys.map(fk => {\n        const columnNames = fk.columnNames.map(columnName => `\"${columnName}\"`).join(\", \");\n        if (!fk.name) fk.name = this.connection.namingStrategy.foreignKeyName(table, fk.columnNames, this.getTablePath(fk), fk.referencedColumnNames);\n        const referencedColumnNames = fk.referencedColumnNames.map(columnName => `\"${columnName}\"`).join(\", \");\n        let constraint = `CONSTRAINT \"${fk.name}\" FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(fk))} (${referencedColumnNames})`;\n        if (fk.onDelete) constraint += ` ON DELETE ${fk.onDelete}`;\n        if (fk.onUpdate) constraint += ` ON UPDATE ${fk.onUpdate}`;\n        if (fk.deferrable) constraint += ` DEFERRABLE ${fk.deferrable}`;\n        return constraint;\n      }).join(\", \");\n      sql += `, ${foreignKeysSql}`;\n    }\n\n    const primaryColumns = table.columns.filter(column => column.isPrimary);\n\n    if (primaryColumns.length > 0) {\n      const primaryKeyName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(table, primaryColumns.map(column => column.name));\n      const columnNames = primaryColumns.map(column => `\"${column.name}\"`).join(\", \");\n      sql += `, CONSTRAINT \"${primaryKeyName}\" PRIMARY KEY (${columnNames})`;\n    }\n\n    sql += `)`;\n    table.columns.filter(it => it.comment).forEach(it => sql += `; COMMENT ON COLUMN ${this.escapePath(table)}.\"${it.name}\" IS ${this.escapeComment(it.comment)}`);\n    return new Query(sql);\n  }\n  /**\n   * Loads Postgres version.\n   */\n\n\n  async getVersion() {\n    const result = await this.query(`SELECT version()`);\n    return result[0][\"version\"].replace(/^PostgreSQL ([\\d\\.]+) .*$/, \"$1\");\n  }\n  /**\n   * Builds drop table sql.\n   */\n\n\n  dropTableSql(tableOrPath) {\n    return new Query(`DROP TABLE ${this.escapePath(tableOrPath)}`);\n  }\n\n  createViewSql(view) {\n    const materializedClause = view.materialized ? \"MATERIALIZED \" : \"\";\n    const viewName = this.escapePath(view);\n\n    if (typeof view.expression === \"string\") {\n      return new Query(`CREATE ${materializedClause}VIEW ${viewName} AS ${view.expression}`);\n    } else {\n      return new Query(`CREATE ${materializedClause}VIEW ${viewName} AS ${view.expression(this.connection).getQuery()}`);\n    }\n  }\n\n  async insertViewDefinitionSql(view) {\n    const currentSchema = await this.getCurrentSchema();\n    let {\n      schema,\n      tableName: name\n    } = this.driver.parseTableName(view);\n\n    if (!schema) {\n      schema = currentSchema;\n    }\n\n    const type = view.materialized ? MetadataTableType.MATERIALIZED_VIEW : MetadataTableType.VIEW;\n    const expression = typeof view.expression === \"string\" ? view.expression.trim() : view.expression(this.connection).getQuery();\n    return this.insertTypeormMetadataSql({\n      type,\n      schema,\n      name,\n      value: expression\n    });\n  }\n  /**\n   * Builds drop view sql.\n   */\n\n\n  dropViewSql(view) {\n    const materializedClause = view.materialized ? \"MATERIALIZED \" : \"\";\n    return new Query(`DROP ${materializedClause}VIEW ${this.escapePath(view)}`);\n  }\n  /**\n   * Builds remove view sql.\n   */\n\n\n  async deleteViewDefinitionSql(view) {\n    const currentSchema = await this.getCurrentSchema();\n    let {\n      schema,\n      tableName: name\n    } = this.driver.parseTableName(view);\n\n    if (!schema) {\n      schema = currentSchema;\n    }\n\n    const type = view.materialized ? MetadataTableType.MATERIALIZED_VIEW : MetadataTableType.VIEW;\n    return this.deleteTypeormMetadataSql({\n      type,\n      schema,\n      name\n    });\n  }\n  /**\n   * Drops ENUM type from given schemas.\n   */\n\n\n  async dropEnumTypes(schemaNames) {\n    const selectDropsQuery = `SELECT 'DROP TYPE IF EXISTS \"' || n.nspname || '\".\"' || t.typname || '\" CASCADE;' as \"query\" FROM \"pg_type\" \"t\" ` + `INNER JOIN \"pg_enum\" \"e\" ON \"e\".\"enumtypid\" = \"t\".\"oid\" ` + `INNER JOIN \"pg_namespace\" \"n\" ON \"n\".\"oid\" = \"t\".\"typnamespace\" ` + `WHERE \"n\".\"nspname\" IN (${schemaNames}) GROUP BY \"n\".\"nspname\", \"t\".\"typname\"`;\n    const dropQueries = await this.query(selectDropsQuery);\n    await Promise.all(dropQueries.map(q => this.query(q[\"query\"])));\n  }\n  /**\n   * Checks if enum with the given name exist in the database.\n   */\n\n\n  async hasEnumType(table, column) {\n    let {\n      schema\n    } = this.driver.parseTableName(table);\n\n    if (!schema) {\n      schema = await this.getCurrentSchema();\n    }\n\n    const enumName = this.buildEnumName(table, column, false, true);\n    const sql = `SELECT \"n\".\"nspname\", \"t\".\"typname\" FROM \"pg_type\" \"t\" ` + `INNER JOIN \"pg_namespace\" \"n\" ON \"n\".\"oid\" = \"t\".\"typnamespace\" ` + `WHERE \"n\".\"nspname\" = '${schema}' AND \"t\".\"typname\" = '${enumName}'`;\n    const result = await this.query(sql);\n    return result.length ? true : false;\n  }\n  /**\n   * Builds create ENUM type sql.\n   */\n\n\n  createEnumTypeSql(table, column, enumName) {\n    if (!enumName) enumName = this.buildEnumName(table, column);\n    const enumValues = column.enum.map(value => `'${value.replace(\"'\", \"''\")}'`).join(\", \");\n    return new Query(`CREATE TYPE ${enumName} AS ENUM(${enumValues})`);\n  }\n  /**\n   * Builds create ENUM type sql.\n   */\n\n\n  dropEnumTypeSql(table, column, enumName) {\n    if (!enumName) enumName = this.buildEnumName(table, column);\n    return new Query(`DROP TYPE ${enumName}`);\n  }\n  /**\n   * Builds create index sql.\n   */\n\n\n  createIndexSql(table, index) {\n    const columns = index.columnNames.map(columnName => `\"${columnName}\"`).join(\", \");\n    return new Query(`CREATE ${index.isUnique ? \"UNIQUE \" : \"\"}INDEX \"${index.name}\" ON ${this.escapePath(table)} ${index.isSpatial ? \"USING GiST \" : \"\"}(${columns}) ${index.where ? \"WHERE \" + index.where : \"\"}`);\n  }\n  /**\n   * Builds drop index sql.\n   */\n\n\n  dropIndexSql(table, indexOrName) {\n    let indexName = InstanceChecker.isTableIndex(indexOrName) ? indexOrName.name : indexOrName;\n    const {\n      schema\n    } = this.driver.parseTableName(table);\n    return schema ? new Query(`DROP INDEX \"${schema}\".\"${indexName}\"`) : new Query(`DROP INDEX \"${indexName}\"`);\n  }\n  /**\n   * Builds create primary key sql.\n   */\n\n\n  createPrimaryKeySql(table, columnNames, constraintName) {\n    const primaryKeyName = constraintName ? constraintName : this.connection.namingStrategy.primaryKeyName(table, columnNames);\n    const columnNamesString = columnNames.map(columnName => `\"${columnName}\"`).join(\", \");\n    return new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${primaryKeyName}\" PRIMARY KEY (${columnNamesString})`);\n  }\n  /**\n   * Builds drop primary key sql.\n   */\n\n\n  dropPrimaryKeySql(table) {\n    if (!table.primaryColumns.length) throw new TypeORMError(`Table ${table} has no primary keys.`);\n    const columnNames = table.primaryColumns.map(column => column.name);\n    const constraintName = table.primaryColumns[0].primaryKeyConstraintName;\n    const primaryKeyName = constraintName ? constraintName : this.connection.namingStrategy.primaryKeyName(table, columnNames);\n    return new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${primaryKeyName}\"`);\n  }\n  /**\n   * Builds create unique constraint sql.\n   */\n\n\n  createUniqueConstraintSql(table, uniqueConstraint) {\n    const columnNames = uniqueConstraint.columnNames.map(column => `\"` + column + `\"`).join(\", \");\n    let sql = `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${uniqueConstraint.name}\" UNIQUE (${columnNames})`;\n    if (uniqueConstraint.deferrable) sql += ` DEFERRABLE ${uniqueConstraint.deferrable}`;\n    return new Query(sql);\n  }\n  /**\n   * Builds drop unique constraint sql.\n   */\n\n\n  dropUniqueConstraintSql(table, uniqueOrName) {\n    const uniqueName = InstanceChecker.isTableUnique(uniqueOrName) ? uniqueOrName.name : uniqueOrName;\n    return new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${uniqueName}\"`);\n  }\n  /**\n   * Builds create check constraint sql.\n   */\n\n\n  createCheckConstraintSql(table, checkConstraint) {\n    return new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${checkConstraint.name}\" CHECK (${checkConstraint.expression})`);\n  }\n  /**\n   * Builds drop check constraint sql.\n   */\n\n\n  dropCheckConstraintSql(table, checkOrName) {\n    const checkName = InstanceChecker.isTableCheck(checkOrName) ? checkOrName.name : checkOrName;\n    return new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${checkName}\"`);\n  }\n  /**\n   * Builds create exclusion constraint sql.\n   */\n\n\n  createExclusionConstraintSql(table, exclusionConstraint) {\n    return new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${exclusionConstraint.name}\" EXCLUDE ${exclusionConstraint.expression}`);\n  }\n  /**\n   * Builds drop exclusion constraint sql.\n   */\n\n\n  dropExclusionConstraintSql(table, exclusionOrName) {\n    const exclusionName = InstanceChecker.isTableExclusion(exclusionOrName) ? exclusionOrName.name : exclusionOrName;\n    return new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${exclusionName}\"`);\n  }\n  /**\n   * Builds create foreign key sql.\n   */\n\n\n  createForeignKeySql(table, foreignKey) {\n    const columnNames = foreignKey.columnNames.map(column => `\"` + column + `\"`).join(\", \");\n    const referencedColumnNames = foreignKey.referencedColumnNames.map(column => `\"` + column + `\"`).join(\",\");\n    let sql = `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${foreignKey.name}\" FOREIGN KEY (${columnNames}) ` + `REFERENCES ${this.escapePath(this.getTablePath(foreignKey))}(${referencedColumnNames})`;\n    if (foreignKey.onDelete) sql += ` ON DELETE ${foreignKey.onDelete}`;\n    if (foreignKey.onUpdate) sql += ` ON UPDATE ${foreignKey.onUpdate}`;\n    if (foreignKey.deferrable) sql += ` DEFERRABLE ${foreignKey.deferrable}`;\n    return new Query(sql);\n  }\n  /**\n   * Builds drop foreign key sql.\n   */\n\n\n  dropForeignKeySql(table, foreignKeyOrName) {\n    const foreignKeyName = InstanceChecker.isTableForeignKey(foreignKeyOrName) ? foreignKeyOrName.name : foreignKeyOrName;\n    return new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${foreignKeyName}\"`);\n  }\n  /**\n   * Builds sequence name from given table and column.\n   */\n\n\n  buildSequenceName(table, columnOrName) {\n    const {\n      tableName\n    } = this.driver.parseTableName(table);\n    const columnName = InstanceChecker.isTableColumn(columnOrName) ? columnOrName.name : columnOrName;\n    let seqName = `${tableName}_${columnName}_seq`;\n\n    if (seqName.length > this.connection.driver.maxAliasLength) {\n      // note doesn't yet handle corner cases where .length differs from number of UTF-8 bytes\n      seqName = `${tableName.substring(0, 29)}_${columnName.substring(0, Math.max(29, 63 - table.name.length - 5))}_seq`;\n    }\n\n    return seqName;\n  }\n\n  buildSequencePath(table, columnOrName) {\n    const {\n      schema\n    } = this.driver.parseTableName(table);\n    return schema ? `${schema}.${this.buildSequenceName(table, columnOrName)}` : this.buildSequenceName(table, columnOrName);\n  }\n  /**\n   * Builds ENUM type name from given table and column.\n   */\n\n\n  buildEnumName(table, column) {\n    let withSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let disableEscape = arguments.length > 3 ? arguments[3] : undefined;\n    let toOld = arguments.length > 4 ? arguments[4] : undefined;\n    const {\n      schema,\n      tableName\n    } = this.driver.parseTableName(table);\n    let enumName = column.enumName ? column.enumName : `${tableName}_${column.name.toLowerCase()}_enum`;\n    if (schema && withSchema) enumName = `${schema}.${enumName}`;\n    if (toOld) enumName = enumName + \"_old\";\n    return enumName.split(\".\").map(i => {\n      return disableEscape ? i : `\"${i}\"`;\n    }).join(\".\");\n  }\n\n  async getUserDefinedTypeName(table, column) {\n    let {\n      schema,\n      tableName: name\n    } = this.driver.parseTableName(table);\n\n    if (!schema) {\n      schema = await this.getCurrentSchema();\n    }\n\n    const result = await this.query(`SELECT \"udt_schema\", \"udt_name\" ` + `FROM \"information_schema\".\"columns\" WHERE \"table_schema\" = '${schema}' AND \"table_name\" = '${name}' AND \"column_name\"='${column.name}'`); // docs: https://www.postgresql.org/docs/current/xtypes.html\n    // When you define a new base type, PostgreSQL automatically provides support for arrays of that type.\n    // The array type typically has the same name as the base type with the underscore character (_) prepended.\n    // ----\n    // so, we must remove this underscore character from enum type name\n\n    let udtName = result[0][\"udt_name\"];\n\n    if (udtName.indexOf(\"_\") === 0) {\n      udtName = udtName.substr(1, udtName.length);\n    }\n\n    return {\n      schema: result[0][\"udt_schema\"],\n      name: udtName\n    };\n  }\n  /**\n   * Escapes a given comment so it's safe to include in a query.\n   */\n\n\n  escapeComment(comment) {\n    if (!comment || comment.length === 0) {\n      return \"NULL\";\n    }\n\n    comment = comment.replace(/'/g, \"''\").replace(/\\u0000/g, \"\"); // Null bytes aren't allowed in comments\n\n    return `'${comment}'`;\n  }\n  /**\n   * Escapes given table or view path.\n   */\n\n\n  escapePath(target) {\n    const {\n      schema,\n      tableName\n    } = this.driver.parseTableName(target);\n\n    if (schema && schema !== this.driver.searchSchema) {\n      return `\"${schema}\".\"${tableName}\"`;\n    }\n\n    return `\"${tableName}\"`;\n  }\n  /**\n   * Get the table name with table schema\n   * Note: Without ' or \"\n   */\n\n\n  async getTableNameWithSchema(target) {\n    const tableName = InstanceChecker.isTable(target) ? target.name : target;\n\n    if (tableName.indexOf(\".\") === -1) {\n      const schemaResult = await this.query(`SELECT current_schema()`);\n      const schema = schemaResult[0][\"current_schema\"];\n      return `${schema}.${tableName}`;\n    } else {\n      return `${tableName.split(\".\")[0]}.${tableName.split(\".\")[1]}`;\n    }\n  }\n  /**\n   * Builds a query for create column.\n   */\n\n\n  buildCreateColumnSql(table, column) {\n    let c = '\"' + column.name + '\"';\n\n    if (column.isGenerated === true && column.generationStrategy !== \"uuid\") {\n      if (column.generationStrategy === \"identity\") {\n        // Postgres 10+ Identity generated column\n        const generatedIdentityOrDefault = column.generatedIdentity || \"BY DEFAULT\";\n        c += ` ${column.type} GENERATED ${generatedIdentityOrDefault} AS IDENTITY`;\n      } else {\n        // classic SERIAL primary column\n        if (column.type === \"integer\" || column.type === \"int\" || column.type === \"int4\") c += \" SERIAL\";\n        if (column.type === \"smallint\" || column.type === \"int2\") c += \" SMALLSERIAL\";\n        if (column.type === \"bigint\" || column.type === \"int8\") c += \" BIGSERIAL\";\n      }\n    }\n\n    if (column.type === \"enum\" || column.type === \"simple-enum\") {\n      c += \" \" + this.buildEnumName(table, column);\n      if (column.isArray) c += \" array\";\n    } else if (!column.isGenerated || column.type === \"uuid\") {\n      c += \" \" + this.connection.driver.createFullType(column);\n    } // Postgres only supports the stored generated column type\n\n\n    if (column.generatedType === \"STORED\" && column.asExpression) {\n      c += ` GENERATED ALWAYS AS (${column.asExpression}) STORED`;\n    }\n\n    if (column.charset) c += ' CHARACTER SET \"' + column.charset + '\"';\n    if (column.collation) c += ' COLLATE \"' + column.collation + '\"';\n    if (column.isNullable !== true) c += \" NOT NULL\";\n    if (column.default !== undefined && column.default !== null) c += \" DEFAULT \" + column.default;\n    if (column.isGenerated && column.generationStrategy === \"uuid\" && !column.default) c += ` DEFAULT ${this.driver.uuidGenerator}`;\n    return c;\n  }\n  /**\n   * Checks if the PostgreSQL server has support for partitioned tables\n   */\n\n\n  async hasSupportForPartitionedTables() {\n    const result = await this.query(`SELECT TRUE FROM information_schema.columns WHERE table_name = 'pg_class' and column_name = 'relispartition'`);\n    return result.length ? true : false;\n  }\n\n}","map":{"version":3,"mappings":"AACA,SAASA,YAAT,QAA6B,aAA7B;AACA,SAASC,gBAAT,QAAiC,8BAAjC;AACA,SAASC,+BAAT,QAAgD,6CAAhD;AACA,SAASC,0BAAT,QAA2C,wCAA3C;AAEA,SAASC,eAAT,QAAgC,oCAAhC;AACA,SAASC,WAAT,QAA4B,gCAA5B;AAGA,SAASC,KAAT,QAAsB,kCAAtB;AACA,SAASC,UAAT,QAA2B,uCAA3B;AACA,SAASC,WAAT,QAA4B,wCAA5B;AACA,SAASC,cAAT,QAA+B,2CAA/B;AACA,SAASC,eAAT,QAAgC,4CAAhC;AACA,SAASC,UAAT,QAA2B,uCAA3B;AACA,SAASC,WAAT,QAA4B,wCAA5B;AACA,SAASC,IAAT,QAAqB,gCAArB;AACA,SAASC,WAAT,QAA4B,8BAA5B;AACA,SAASC,eAAT,QAAgC,4BAAhC;AACA,SAASC,QAAT,QAAyB,qBAAzB;AACA,SAASC,YAAT,QAA6B,yBAA7B;AACA,SAASC,KAAT,QAAsB,UAAtB;AAGA,SAASC,iBAAT,QAAkC,4BAAlC;AAIA;;;;AAGA,OAAM,MAAOC,mBAAP,SACMhB,eADN,CACqB;EA0BvB;EACA;EACA;EAEAiB,YAAYC,MAAZ,EAAoCC,IAApC,EAAyD;IACrD;IACA,KAAKD,MAAL,GAAcA,MAAd;IACA,KAAKE,UAAL,GAAkBF,MAAM,CAACE,UAAzB;IACA,KAAKD,IAAL,GAAYA,IAAZ;IACA,KAAKE,WAAL,GAAmB,IAAIX,WAAJ,CAAgB,IAAhB,CAAnB;EACH,CApCsB,CAsCvB;EACA;EACA;;EAEA;;;;;;EAIAY,OAAO;IACH,IAAI,KAAKC,kBAAT,EACI,OAAOC,OAAO,CAACC,OAAR,CAAgB,KAAKF,kBAArB,CAAP;IAEJ,IAAI,KAAKG,yBAAT,EACI,OAAO,KAAKA,yBAAZ;;IAEJ,IAAI,KAAKP,IAAL,KAAc,OAAd,IAAyB,KAAKD,MAAL,CAAYS,YAAzC,EAAuD;MACnD,KAAKD,yBAAL,GAAiC,KAAKR,MAAL,CAC5BU,qBAD4B,GAE5BC,IAF4B,CAEvB,QAAiC;QAAA,IAAhC,CAACT,UAAD,EAAaU,OAAb,CAAgC;QACnC,KAAKZ,MAAL,CAAYa,qBAAZ,CAAkCC,IAAlC,CAAuC,IAAvC;QACA,KAAKT,kBAAL,GAA0BH,UAA1B;;QAEA,MAAMa,eAAe,GAAIC,GAAD,IACpB,KAAKC,yBAAL,CAA+BD,GAA/B,CADJ;;QAEA,KAAKE,eAAL,GAAwBF,GAAD,IAAgB;UACnC,KAAKX,kBAAL,CAAwBc,cAAxB,CACI,OADJ,EAEIJ,eAFJ;UAIAH,OAAO,CAACI,GAAD,CAAP;QACH,CAND;;QAOA,KAAKX,kBAAL,CAAwBe,EAAxB,CAA2B,OAA3B,EAAoCL,eAApC;QAEA,OAAO,KAAKV,kBAAZ;MACH,CAlB4B,CAAjC;IAmBH,CApBD,MAoBO;MACH;MACA,KAAKG,yBAAL,GAAiC,KAAKR,MAAL,CAC5BqB,sBAD4B,GAE5BV,IAF4B,CAEvB,SAAiC;QAAA,IAAhC,CAACT,UAAD,EAAaU,OAAb,CAAgC;QACnC,KAAKZ,MAAL,CAAYa,qBAAZ,CAAkCC,IAAlC,CAAuC,IAAvC;QACA,KAAKT,kBAAL,GAA0BH,UAA1B;;QAEA,MAAMa,eAAe,GAAIC,GAAD,IACpB,KAAKC,yBAAL,CAA+BD,GAA/B,CADJ;;QAEA,KAAKE,eAAL,GAAwBF,GAAD,IAAgB;UACnC,KAAKX,kBAAL,CAAwBc,cAAxB,CACI,OADJ,EAEIJ,eAFJ;UAIAH,OAAO,CAACI,GAAD,CAAP;QACH,CAND;;QAOA,KAAKX,kBAAL,CAAwBe,EAAxB,CAA2B,OAA3B,EAAoCL,eAApC;QAEA,OAAO,KAAKV,kBAAZ;MACH,CAlB4B,CAAjC;IAmBH;;IAED,OAAO,KAAKG,yBAAZ;EACH;EAED;;;;;;EAIuC,MAAzBS,yBAAyB,CAACD,GAAD,EAAY;IAC/C,IAAI,KAAKM,UAAT,EAAqB;MACjB;IACH;;IAED,KAAKA,UAAL,GAAkB,IAAlB;;IACA,IAAI,KAAKJ,eAAT,EAA0B;MACtB,KAAKA,eAAL,CAAqBF,GAArB;MACA,KAAKE,eAAL,GAAuBK,SAAvB;IACH;;IAED,MAAMC,KAAK,GAAG,KAAKxB,MAAL,CAAYa,qBAAZ,CAAkCY,OAAlC,CAA0C,IAA1C,CAAd;;IAEA,IAAID,KAAK,KAAK,CAAC,CAAf,EAAkB;MACd,KAAKxB,MAAL,CAAYa,qBAAZ,CAAkCa,MAAlC,CAAyCF,KAAzC,EAAgD,CAAhD;IACH;EACJ;EAED;;;;;;EAIAZ,OAAO;IACH,OAAO,KAAKK,yBAAL,EAAP;EACH;EAED;;;;;EAGsB,MAAhBU,gBAAgB,CAACC,cAAD,EAAgC;IAClD,KAAKC,mBAAL,GAA2B,IAA3B;;IACA,IAAI;MACA,MAAM,KAAK1B,WAAL,CAAiB2B,SAAjB,CAA2B,wBAA3B,CAAN;IACH,CAFD,CAEE,OAAOd,GAAP,EAAY;MACV,KAAKa,mBAAL,GAA2B,KAA3B;MACA,MAAMb,GAAN;IACH;;IAED,IAAI,KAAKe,gBAAL,KAA0B,CAA9B,EAAiC;MAC7B,MAAM,KAAKC,KAAL,CAAW,mBAAX,CAAN;;MACA,IAAIJ,cAAJ,EAAoB;QAChB,MAAM,KAAKI,KAAL,CACF,qCAAqCJ,cADnC,CAAN;MAGH;IACJ,CAPD,MAOO;MACH,MAAM,KAAKI,KAAL,CAAW,qBAAqB,KAAKD,gBAAgB,EAArD,CAAN;IACH;;IACD,KAAKA,gBAAL,IAAyB,CAAzB;IAEA,MAAM,KAAK5B,WAAL,CAAiB2B,SAAjB,CAA2B,uBAA3B,CAAN;EACH;EAED;;;;;;EAIuB,MAAjBG,iBAAiB;IACnB,IAAI,CAAC,KAAKJ,mBAAV,EAA+B,MAAM,IAAIhD,0BAAJ,EAAN;IAE/B,MAAM,KAAKsB,WAAL,CAAiB2B,SAAjB,CAA2B,yBAA3B,CAAN;;IAEA,IAAI,KAAKC,gBAAL,GAAwB,CAA5B,EAA+B;MAC3B,MAAM,KAAKC,KAAL,CACF,6BAA6B,KAAKD,gBAAL,GAAwB,CAAC,EADpD,CAAN;IAGH,CAJD,MAIO;MACH,MAAM,KAAKC,KAAL,CAAW,QAAX,CAAN;MACA,KAAKH,mBAAL,GAA2B,KAA3B;IACH;;IACD,KAAKE,gBAAL,IAAyB,CAAzB;IAEA,MAAM,KAAK5B,WAAL,CAAiB2B,SAAjB,CAA2B,wBAA3B,CAAN;EACH;EAED;;;;;;EAIyB,MAAnBI,mBAAmB;IACrB,IAAI,CAAC,KAAKL,mBAAV,EAA+B,MAAM,IAAIhD,0BAAJ,EAAN;IAE/B,MAAM,KAAKsB,WAAL,CAAiB2B,SAAjB,CAA2B,2BAA3B,CAAN;;IAEA,IAAI,KAAKC,gBAAL,GAAwB,CAA5B,EAA+B;MAC3B,MAAM,KAAKC,KAAL,CACF,iCAAiC,KAAKD,gBAAL,GAAwB,CAAC,EADxD,CAAN;IAGH,CAJD,MAIO;MACH,MAAM,KAAKC,KAAL,CAAW,UAAX,CAAN;MACA,KAAKH,mBAAL,GAA2B,KAA3B;IACH;;IACD,KAAKE,gBAAL,IAAyB,CAAzB;IAEA,MAAM,KAAK5B,WAAL,CAAiB2B,SAAjB,CAA2B,0BAA3B,CAAN;EACH;EAED;;;;;EAGW,MAALE,KAAK,CACPA,KADO,EAEPG,UAFO,EAG6B;IAAA,IAApCC,mBAAoC,uEAAL,KAAK;IAEpC,IAAI,KAAKd,UAAT,EAAqB,MAAM,IAAI1C,+BAAJ,EAAN;IAErB,MAAMyB,kBAAkB,GAAG,MAAM,KAAKD,OAAL,EAAjC;IAEA,KAAKJ,MAAL,CAAYE,UAAZ,CAAuBmC,MAAvB,CAA8BC,QAA9B,CAAuCN,KAAvC,EAA8CG,UAA9C,EAA0D,IAA1D;;IACA,IAAI;MACA,MAAMI,cAAc,GAAG,CAAC,IAAIC,IAAJ,EAAxB;MACA,MAAMC,GAAG,GAAG,MAAMpC,kBAAkB,CAAC2B,KAAnB,CAAyBA,KAAzB,EAAgCG,UAAhC,CAAlB,CAFA,CAGA;;MACA,MAAMO,qBAAqB,GACvB,KAAK1C,MAAL,CAAY2C,OAAZ,CAAoBD,qBADxB;MAEA,MAAME,YAAY,GAAG,CAAC,IAAIJ,IAAJ,EAAtB;MACA,MAAMK,kBAAkB,GAAGD,YAAY,GAAGL,cAA1C;MACA,IACIG,qBAAqB,IACrBG,kBAAkB,GAAGH,qBAFzB,EAII,KAAK1C,MAAL,CAAYE,UAAZ,CAAuBmC,MAAvB,CAA8BS,YAA9B,CACID,kBADJ,EAEIb,KAFJ,EAGIG,UAHJ,EAII,IAJJ;MAOJ,MAAMY,MAAM,GAAG,IAAIhE,WAAJ,EAAf;;MACA,IAAI0D,GAAJ,EAAS;QACL,IAAIA,GAAG,CAACO,cAAJ,CAAmB,MAAnB,CAAJ,EAAgC;UAC5BD,MAAM,CAACE,OAAP,GAAiBR,GAAG,CAACS,IAArB;QACH;;QAED,IAAIT,GAAG,CAACO,cAAJ,CAAmB,UAAnB,CAAJ,EAAoC;UAChCD,MAAM,CAACI,QAAP,GAAkBV,GAAG,CAACW,QAAtB;QACH;;QAED,QAAQX,GAAG,CAACY,OAAZ;UACI,KAAK,QAAL;UACA,KAAK,QAAL;YACI;YACAN,MAAM,CAACN,GAAP,GAAa,CAACA,GAAG,CAACS,IAAL,EAAWT,GAAG,CAACW,QAAf,CAAb;YACA;;UACJ;YACIL,MAAM,CAACN,GAAP,GAAaA,GAAG,CAACS,IAAjB;QAPR;;QAUA,IAAI,CAACd,mBAAL,EAA0B;UACtB,OAAOW,MAAM,CAACN,GAAd;QACH;MACJ;;MAED,OAAOM,MAAP;IACH,CA7CD,CA6CE,OAAO/B,GAAP,EAAY;MACV,KAAKhB,MAAL,CAAYE,UAAZ,CAAuBmC,MAAvB,CAA8BiB,aAA9B,CACItC,GADJ,EAEIgB,KAFJ,EAGIG,UAHJ,EAII,IAJJ;MAMA,MAAM,IAAIxD,gBAAJ,CAAqBqD,KAArB,EAA4BG,UAA5B,EAAwCnB,GAAxC,CAAN;IACH;EACJ;EAED;;;;;EAGY,MAANuC,MAAM,CACRvB,KADQ,EAERG,UAFQ,EAGRqB,KAHQ,EAIRC,OAJQ,EAIU;IAElB,MAAMC,WAAW,GAAG,KAAK1D,MAAL,CAAY2D,oBAAZ,EAApB;IACA,IAAI,KAAKrC,UAAT,EAAqB,MAAM,IAAI1C,+BAAJ,EAAN;IAErB,MAAMyB,kBAAkB,GAAG,MAAM,KAAKD,OAAL,EAAjC;IACA,KAAKJ,MAAL,CAAYE,UAAZ,CAAuBmC,MAAvB,CAA8BC,QAA9B,CAAuCN,KAAvC,EAA8CG,UAA9C,EAA0D,IAA1D;IACA,MAAMoB,MAAM,GAAGlD,kBAAkB,CAAC2B,KAAnB,CACX,IAAI0B,WAAJ,CAAgB1B,KAAhB,EAAuBG,UAAvB,CADW,CAAf;IAGA,IAAIqB,KAAJ,EAAWD,MAAM,CAACnC,EAAP,CAAU,KAAV,EAAiBoC,KAAjB;IACX,IAAIC,OAAJ,EAAaF,MAAM,CAACnC,EAAP,CAAU,OAAV,EAAmBqC,OAAnB;IAEb,OAAOF,MAAP;EACH;EAED;;;;;EAGkB,MAAZK,YAAY;IACd,OAAOtD,OAAO,CAACC,OAAR,CAAgB,EAAhB,CAAP;EACH;EAED;;;;;;EAIgB,MAAVsD,UAAU,CAACC,QAAD,EAAkB;IAC9B,OAAOxD,OAAO,CAACC,OAAR,CAAgB,EAAhB,CAAP;EACH;EAED;;;;;EAGiB,MAAXwD,WAAW,CAACD,QAAD,EAAiB;IAC9B,MAAMf,MAAM,GAAG,MAAM,KAAKf,KAAL,CACjB,4CAA4C8B,QAAQ,IADnC,CAArB;IAGA,OAAOf,MAAM,CAACiB,MAAP,GAAgB,IAAhB,GAAuB,KAA9B;EACH;EAED;;;;;EAGwB,MAAlBC,kBAAkB;IACpB,MAAMjC,KAAK,GAAG,MAAM,KAAKA,KAAL,CAAW,kCAAX,CAApB;IACA,OAAOA,KAAK,CAAC,CAAD,CAAL,CAAS,kBAAT,CAAP;EACH;EAED;;;;;EAGe,MAATkC,SAAS,CAACC,MAAD,EAAe;IAC1B,MAAMpB,MAAM,GAAG,MAAM,KAAKf,KAAL,CACjB,wEAAwEmC,MAAM,GAD7D,CAArB;IAGA,OAAOpB,MAAM,CAACiB,MAAP,GAAgB,IAAhB,GAAuB,KAA9B;EACH;EAED;;;;;EAGsB,MAAhBI,gBAAgB;IAClB,MAAMpC,KAAK,GAAG,MAAM,KAAKA,KAAL,CAAW,gCAAX,CAApB;IACA,OAAOA,KAAK,CAAC,CAAD,CAAL,CAAS,gBAAT,CAAP;EACH;EAED;;;;;EAGc,MAARqC,QAAQ,CAACC,WAAD,EAA4B;IACtC,MAAMC,eAAe,GAAG,KAAKvE,MAAL,CAAYwE,cAAZ,CAA2BF,WAA3B,CAAxB;;IAEA,IAAI,CAACC,eAAe,CAACJ,MAArB,EAA6B;MACzBI,eAAe,CAACJ,MAAhB,GAAyB,MAAM,KAAKC,gBAAL,EAA/B;IACH;;IAED,MAAMK,GAAG,GAAG,uEAAuEF,eAAe,CAACJ,MAAM,yBAAyBI,eAAe,CAACG,SAAS,GAA3J;IACA,MAAM3B,MAAM,GAAG,MAAM,KAAKf,KAAL,CAAWyC,GAAX,CAArB;IACA,OAAO1B,MAAM,CAACiB,MAAP,GAAgB,IAAhB,GAAuB,KAA9B;EACH;EAED;;;;;EAGe,MAATW,SAAS,CACXL,WADW,EAEXM,UAFW,EAEO;IAElB,MAAML,eAAe,GAAG,KAAKvE,MAAL,CAAYwE,cAAZ,CAA2BF,WAA3B,CAAxB;;IAEA,IAAI,CAACC,eAAe,CAACJ,MAArB,EAA6B;MACzBI,eAAe,CAACJ,MAAhB,GAAyB,MAAM,KAAKC,gBAAL,EAA/B;IACH;;IAED,MAAMK,GAAG,GAAG,wEAAwEF,eAAe,CAACJ,MAAM,yBAAyBI,eAAe,CAACG,SAAS,0BAA0BE,UAAU,GAAhM;IACA,MAAM7B,MAAM,GAAG,MAAM,KAAKf,KAAL,CAAWyC,GAAX,CAArB;IACA,OAAO1B,MAAM,CAACiB,MAAP,GAAgB,IAAhB,GAAuB,KAA9B;EACH;EAED;;;;;;EAIoB,MAAda,cAAc,CAChBf,QADgB,EAEhBgB,UAFgB,EAEI;IAEpB,IAAIA,UAAJ,EAAgB;MACZ,MAAMC,qBAAqB,GAAG,MAAM,KAAKhB,WAAL,CAAiBD,QAAjB,CAApC;MAEA,IAAIiB,qBAAJ,EAA2B,OAAOzE,OAAO,CAACC,OAAR,EAAP;IAC9B;;IAED,MAAMyE,EAAE,GAAG,oBAAoBlB,QAAQ,GAAvC;IACA,MAAMmB,IAAI,GAAG,kBAAkBnB,QAAQ,GAAvC;IACA,MAAM,KAAKoB,cAAL,CAAoB,IAAItF,KAAJ,CAAUoF,EAAV,CAApB,EAAmC,IAAIpF,KAAJ,CAAUqF,IAAV,CAAnC,CAAN;EACH;EAED;;;;;;EAIkB,MAAZE,YAAY,CAACrB,QAAD,EAAmBsB,OAAnB,EAAoC;IAClD,MAAMJ,EAAE,GAAGI,OAAO,GACZ,4BAA4BtB,QAAQ,GADxB,GAEZ,kBAAkBA,QAAQ,GAFhC;IAGA,MAAMmB,IAAI,GAAG,oBAAoBnB,QAAQ,GAAzC;IACA,MAAM,KAAKoB,cAAL,CAAoB,IAAItF,KAAJ,CAAUoF,EAAV,CAApB,EAAmC,IAAIpF,KAAJ,CAAUqF,IAAV,CAAnC,CAAN;EACH;EAED;;;;;EAGkB,MAAZI,YAAY,CACdC,UADc,EAEdR,UAFc,EAEM;IAEpB,MAAMX,MAAM,GACRmB,UAAU,CAAC7D,OAAX,CAAmB,GAAnB,MAA4B,CAAC,CAA7B,GACM6D,UADN,GAEMA,UAAU,CAACC,KAAX,CAAiB,GAAjB,EAAsB,CAAtB,CAHV;IAKA,MAAMP,EAAE,GAAGF,UAAU,GACf,gCAAgCX,MAAM,GADvB,GAEf,kBAAkBA,MAAM,GAF9B;IAGA,MAAMc,IAAI,GAAG,gBAAgBd,MAAM,WAAnC;IACA,MAAM,KAAKe,cAAL,CAAoB,IAAItF,KAAJ,CAAUoF,EAAV,CAApB,EAAmC,IAAIpF,KAAJ,CAAUqF,IAAV,CAAnC,CAAN;EACH;EAED;;;;;EAGgB,MAAVO,UAAU,CACZF,UADY,EAEZF,OAFY,EAGZK,SAHY,EAGO;IAEnB,MAAMtB,MAAM,GACRmB,UAAU,CAAC7D,OAAX,CAAmB,GAAnB,MAA4B,CAAC,CAA7B,GACM6D,UADN,GAEMA,UAAU,CAACC,KAAX,CAAiB,GAAjB,EAAsB,CAAtB,CAHV;IAKA,MAAMP,EAAE,GAAGI,OAAO,GACZ,0BAA0BjB,MAAM,KAAKsB,SAAS,GAAG,SAAH,GAAe,EAAE,EADnD,GAEZ,gBAAgBtB,MAAM,KAAKsB,SAAS,GAAG,SAAH,GAAe,EAAE,EAF3D;IAGA,MAAMR,IAAI,GAAG,kBAAkBd,MAAM,GAArC;IACA,MAAM,KAAKe,cAAL,CAAoB,IAAItF,KAAJ,CAAUoF,EAAV,CAApB,EAAmC,IAAIpF,KAAJ,CAAUqF,IAAV,CAAnC,CAAN;EACH;EAED;;;;;EAGiB,MAAXS,WAAW,CACbC,KADa,EAIgB;IAAA,IAF7Bb,UAE6B,uEAFP,KAEO;IAAA,IAD7Bc,iBAC6B,uEADA,IACA;IAAA,IAA7BC,aAA6B,uEAAJ,IAAI;;IAE7B,IAAIf,UAAJ,EAAgB;MACZ,MAAMgB,YAAY,GAAG,MAAM,KAAKzB,QAAL,CAAcsB,KAAd,CAA3B;MACA,IAAIG,YAAJ,EAAkB,OAAOxF,OAAO,CAACC,OAAR,EAAP;IACrB;;IACD,MAAMwF,SAAS,GAAY,EAA3B;IACA,MAAMC,WAAW,GAAY,EAA7B,CAP6B,CAS7B;;IACA,MAAMC,WAAW,GAAGN,KAAK,CAACO,OAAN,CAAcC,MAAd,CACfC,MAAD,IAAYA,MAAM,CAACC,IAAP,KAAgB,MAAhB,IAA0BD,MAAM,CAACC,IAAP,KAAgB,aADtC,CAApB;IAGA,MAAMC,gBAAgB,GAAa,EAAnC;;IACA,KAAK,MAAMF,MAAX,IAAqBH,WAArB,EAAkC;MAC9B;MACA,MAAMM,OAAO,GAAG,MAAM,KAAKC,WAAL,CAAiBb,KAAjB,EAAwBS,MAAxB,CAAtB;MACA,MAAMK,QAAQ,GAAG,KAAKC,aAAL,CAAmBf,KAAnB,EAA0BS,MAA1B,CAAjB,CAH8B,CAK9B;;MACA,IAAI,CAACG,OAAD,IAAYD,gBAAgB,CAAC7E,OAAjB,CAAyBgF,QAAzB,MAAuC,CAAC,CAAxD,EAA2D;QACvDH,gBAAgB,CAACxF,IAAjB,CAAsB2F,QAAtB;QACAV,SAAS,CAACjF,IAAV,CAAe,KAAK6F,iBAAL,CAAuBhB,KAAvB,EAA8BS,MAA9B,EAAsCK,QAAtC,CAAf;QACAT,WAAW,CAAClF,IAAZ,CAAiB,KAAK8F,eAAL,CAAqBjB,KAArB,EAA4BS,MAA5B,EAAoCK,QAApC,CAAjB;MACH;IACJ,CAzB4B,CA2B7B;;;IACA,MAAMI,gBAAgB,GAAGlB,KAAK,CAACO,OAAN,CAAcC,MAAd,CACpBC,MAAD,IACIA,MAAM,CAACU,aAAP,KAAyB,QAAzB,IAAqCV,MAAM,CAACW,YAF3B,CAAzB;;IAIA,KAAK,MAAMX,MAAX,IAAqBS,gBAArB,EAAuC;MACnC,MAAMG,mBAAmB,GAAG,CACxB,MAAM,KAAKC,sBAAL,CAA4BtB,KAAK,CAACuB,IAAlC,CADkB,EAE1B3B,KAF0B,CAEpB,GAFoB,CAA5B;MAGA,MAAMb,SAAS,GAAGsC,mBAAmB,CAAC,CAAD,CAArC;MACA,MAAM7C,MAAM,GAAG6C,mBAAmB,CAAC,CAAD,CAAlC;MAEA,MAAMG,WAAW,GAAG,KAAKC,wBAAL,CAA8B;QAC9CtD,QAAQ,EAAE,KAAK9D,MAAL,CAAY8D,QADwB;QAE9CK,MAF8C;QAG9CwB,KAAK,EAAEjB,SAHuC;QAI9C2B,IAAI,EAAExG,iBAAiB,CAACwH,gBAJsB;QAK9CH,IAAI,EAAEd,MAAM,CAACc,IALiC;QAM9CI,KAAK,EAAElB,MAAM,CAACW;MANgC,CAA9B,CAApB;MASA,MAAMQ,WAAW,GAAG,KAAKC,wBAAL,CAA8B;QAC9C1D,QAAQ,EAAE,KAAK9D,MAAL,CAAY8D,QADwB;QAE9CK,MAF8C;QAG9CwB,KAAK,EAAEjB,SAHuC;QAI9C2B,IAAI,EAAExG,iBAAiB,CAACwH,gBAJsB;QAK9CH,IAAI,EAAEd,MAAM,CAACc;MALiC,CAA9B,CAApB;MAQAnB,SAAS,CAACjF,IAAV,CAAeqG,WAAf;MACAnB,WAAW,CAAClF,IAAZ,CAAiByG,WAAjB;IACH;;IAEDxB,SAAS,CAACjF,IAAV,CAAe,KAAK2G,cAAL,CAAoB9B,KAApB,EAA2BC,iBAA3B,CAAf;IACAI,WAAW,CAAClF,IAAZ,CAAiB,KAAK4G,YAAL,CAAkB/B,KAAlB,CAAjB,EA7D6B,CA+D7B;IACA;;IACA,IAAIC,iBAAJ,EACID,KAAK,CAACgC,WAAN,CAAkBC,OAAlB,CAA2BC,UAAD,IACtB7B,WAAW,CAAClF,IAAZ,CAAiB,KAAKgH,iBAAL,CAAuBnC,KAAvB,EAA8BkC,UAA9B,CAAjB,CADJ;;IAIJ,IAAIhC,aAAJ,EAAmB;MACfF,KAAK,CAACoC,OAAN,CAAcH,OAAd,CAAuBpG,KAAD,IAAU;QAC5B;QACA,IAAI,CAACA,KAAK,CAAC0F,IAAX,EACI1F,KAAK,CAAC0F,IAAN,GAAa,KAAKhH,UAAL,CAAgB8H,cAAhB,CAA+BC,SAA/B,CACTtC,KADS,EAETnE,KAAK,CAAC0G,WAFG,EAGT1G,KAAK,CAAC2G,KAHG,CAAb;QAKJpC,SAAS,CAACjF,IAAV,CAAe,KAAKsH,cAAL,CAAoBzC,KAApB,EAA2BnE,KAA3B,CAAf;QACAwE,WAAW,CAAClF,IAAZ,CAAiB,KAAKuH,YAAL,CAAkB1C,KAAlB,EAAyBnE,KAAzB,CAAjB;MACH,CAVD;IAWH;;IAED,MAAM,KAAK0D,cAAL,CAAoBa,SAApB,EAA+BC,WAA/B,CAAN;EACH;EAED;;;;;EAGe,MAATsC,SAAS,CACXC,MADW,EAEXnD,OAFW,EAIgB;IAAA,IAD3BoD,eAC2B,uEADA,IACA;IAAA,IAA3BC,WAA2B,uEAAJ,IAAI;;IAE3B;IACA;IACA,IAAIrD,OAAJ,EAAa;MACT,MAAMU,YAAY,GAAG,MAAM,KAAKzB,QAAL,CAAckE,MAAd,CAA3B;MACA,IAAI,CAACzC,YAAL,EAAmB,OAAOxF,OAAO,CAACC,OAAR,EAAP;IACtB,CAP0B,CAS3B;;;IACA,MAAMqF,iBAAiB,GAAY4C,eAAnC;IACA,MAAME,SAAS,GAAG,KAAKC,YAAL,CAAkBJ,MAAlB,CAAlB;IACA,MAAM5C,KAAK,GAAG,MAAM,KAAKiD,cAAL,CAAoBF,SAApB,CAApB;IACA,MAAM3C,SAAS,GAAY,EAA3B;IACA,MAAMC,WAAW,GAAY,EAA7B;;IAEA,IAAIyC,WAAJ,EAAiB;MACb9C,KAAK,CAACoC,OAAN,CAAcH,OAAd,CAAuBpG,KAAD,IAAU;QAC5BuE,SAAS,CAACjF,IAAV,CAAe,KAAKuH,YAAL,CAAkB1C,KAAlB,EAAyBnE,KAAzB,CAAf;QACAwE,WAAW,CAAClF,IAAZ,CAAiB,KAAKsH,cAAL,CAAoBzC,KAApB,EAA2BnE,KAA3B,CAAjB;MACH,CAHD;IAIH;;IAED,IAAIgH,eAAJ,EACI7C,KAAK,CAACgC,WAAN,CAAkBC,OAAlB,CAA2BC,UAAD,IACtB9B,SAAS,CAACjF,IAAV,CAAe,KAAKgH,iBAAL,CAAuBnC,KAAvB,EAA8BkC,UAA9B,CAAf,CADJ;IAIJ9B,SAAS,CAACjF,IAAV,CAAe,KAAK4G,YAAL,CAAkB/B,KAAlB,CAAf;IACAK,WAAW,CAAClF,IAAZ,CAAiB,KAAK2G,cAAL,CAAoB9B,KAApB,EAA2BC,iBAA3B,CAAjB,EA7B2B,CA+B3B;;IACA,MAAMiB,gBAAgB,GAAGlB,KAAK,CAACO,OAAN,CAAcC,MAAd,CACpBC,MAAD,IAAYA,MAAM,CAACU,aAAP,IAAwBV,MAAM,CAACW,YADtB,CAAzB;;IAGA,KAAK,MAAMX,MAAX,IAAqBS,gBAArB,EAAuC;MACnC,MAAMG,mBAAmB,GAAG,CACxB,MAAM,KAAKC,sBAAL,CAA4BtB,KAAK,CAACuB,IAAlC,CADkB,EAE1B3B,KAF0B,CAEpB,GAFoB,CAA5B;MAGA,MAAMb,SAAS,GAAGsC,mBAAmB,CAAC,CAAD,CAArC;MACA,MAAM7C,MAAM,GAAG6C,mBAAmB,CAAC,CAAD,CAAlC;MAEA,MAAMO,WAAW,GAAG,KAAKC,wBAAL,CAA8B;QAC9C1D,QAAQ,EAAE,KAAK9D,MAAL,CAAY8D,QADwB;QAE9CK,MAF8C;QAG9CwB,KAAK,EAAEjB,SAHuC;QAI9C2B,IAAI,EAAExG,iBAAiB,CAACwH,gBAJsB;QAK9CH,IAAI,EAAEd,MAAM,CAACc;MALiC,CAA9B,CAApB;MAQA,MAAMC,WAAW,GAAG,KAAKC,wBAAL,CAA8B;QAC9CtD,QAAQ,EAAE,KAAK9D,MAAL,CAAY8D,QADwB;QAE9CK,MAF8C;QAG9CwB,KAAK,EAAEjB,SAHuC;QAI9C2B,IAAI,EAAExG,iBAAiB,CAACwH,gBAJsB;QAK9CH,IAAI,EAAEd,MAAM,CAACc,IALiC;QAM9CI,KAAK,EAAElB,MAAM,CAACW;MANgC,CAA9B,CAApB;MASAhB,SAAS,CAACjF,IAAV,CAAeyG,WAAf;MACAvB,WAAW,CAAClF,IAAZ,CAAiBqG,WAAjB;IACH;;IAED,MAAM,KAAKjC,cAAL,CAAoBa,SAApB,EAA+BC,WAA/B,CAAN;EACH;EAED;;;;;EAGgB,MAAV6C,UAAU,CAACC,IAAD,EAAW;IACvB,MAAM/C,SAAS,GAAY,EAA3B;IACA,MAAMC,WAAW,GAAY,EAA7B;IACAD,SAAS,CAACjF,IAAV,CAAe,KAAKiI,aAAL,CAAmBD,IAAnB,CAAf;IACA/C,SAAS,CAACjF,IAAV,CAAe,MAAM,KAAKkI,uBAAL,CAA6BF,IAA7B,CAArB;IACA9C,WAAW,CAAClF,IAAZ,CAAiB,KAAKmI,WAAL,CAAiBH,IAAjB,CAAjB;IACA9C,WAAW,CAAClF,IAAZ,CAAiB,MAAM,KAAKoI,uBAAL,CAA6BJ,IAA7B,CAAvB;IACA,MAAM,KAAK5D,cAAL,CAAoBa,SAApB,EAA+BC,WAA/B,CAAN;EACH;EAED;;;;;EAGc,MAARmD,QAAQ,CAACZ,MAAD,EAAsB;IAChC,MAAMa,QAAQ,GAAG3J,eAAe,CAAC4J,MAAhB,CAAuBd,MAAvB,IAAiCA,MAAM,CAACrB,IAAxC,GAA+CqB,MAAhE;IACA,MAAMO,IAAI,GAAG,MAAM,KAAKQ,aAAL,CAAmBF,QAAnB,CAAnB;IAEA,MAAMrD,SAAS,GAAY,EAA3B;IACA,MAAMC,WAAW,GAAY,EAA7B;IACAD,SAAS,CAACjF,IAAV,CAAe,MAAM,KAAKoI,uBAAL,CAA6BJ,IAA7B,CAArB;IACA/C,SAAS,CAACjF,IAAV,CAAe,KAAKmI,WAAL,CAAiBH,IAAjB,CAAf;IACA9C,WAAW,CAAClF,IAAZ,CAAiB,MAAM,KAAKkI,uBAAL,CAA6BF,IAA7B,CAAvB;IACA9C,WAAW,CAAClF,IAAZ,CAAiB,KAAKiI,aAAL,CAAmBD,IAAnB,CAAjB;IACA,MAAM,KAAK5D,cAAL,CAAoBa,SAApB,EAA+BC,WAA/B,CAAN;EACH;EAED;;;;;EAGiB,MAAXuD,WAAW,CACbC,cADa,EAEbC,YAFa,EAEO;IAEpB,MAAM1D,SAAS,GAAY,EAA3B;IACA,MAAMC,WAAW,GAAY,EAA7B;IACA,MAAM0D,QAAQ,GAAGjK,eAAe,CAACkK,OAAhB,CAAwBH,cAAxB,IACXA,cADW,GAEX,MAAM,KAAKZ,cAAL,CAAoBY,cAApB,CAFZ;IAGA,MAAMI,QAAQ,GAAGF,QAAQ,CAACG,KAAT,EAAjB;IAEA,MAAM;MAAE1F,MAAM,EAAE2F,UAAV;MAAsBpF,SAAS,EAAEqF;IAAjC,IACF,KAAK/J,MAAL,CAAYwE,cAAZ,CAA2BkF,QAA3B,CADJ;IAGAE,QAAQ,CAAC1C,IAAT,GAAgB4C,UAAU,GACpB,GAAGA,UAAU,IAAIL,YAAY,EADT,GAEpBA,YAFN;IAIA1D,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXN,QADW,CAEd,eAAeD,YAAY,GAHhC,CADJ;IAOAzD,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXJ,QADW,CAEd,eAAeG,YAAY,GAHhC,CADJ,EAvBoB,CA+BpB;;IACA,IACIH,QAAQ,CAACK,cAAT,CAAwBjG,MAAxB,GAAiC,CAAjC,IACA,CAAC4F,QAAQ,CAACK,cAAT,CAAwB,CAAxB,EAA2BC,wBAFhC,EAGE;MACE,MAAMhC,WAAW,GAAG0B,QAAQ,CAACK,cAAT,CAAwBE,GAAxB,CACf/D,MAAD,IAAYA,MAAM,CAACc,IADH,CAApB;MAIA,MAAMkD,SAAS,GAAG,KAAKlK,UAAL,CAAgB8H,cAAhB,CAA+BqC,cAA/B,CACdX,QADc,EAEdxB,WAFc,CAAlB;MAKA,MAAMoC,SAAS,GAAG,KAAKpK,UAAL,CAAgB8H,cAAhB,CAA+BqC,cAA/B,CACdT,QADc,EAEd1B,WAFc,CAAlB;MAKAnC,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXJ,QADW,CAEd,uBAAuBQ,SAAS,SAASE,SAAS,GAHvD,CADJ;MAOAtE,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXJ,QADW,CAEd,uBAAuBU,SAAS,SAASF,SAAS,GAHvD,CADJ;IAOH,CAhEmB,CAkEpB;;;IACAR,QAAQ,CAAC1D,OAAT,CAAiBiE,GAAjB,CAAsBI,GAAD,IAAQ;MACzB,IAAIA,GAAG,CAACC,WAAJ,IAAmBD,GAAG,CAACE,kBAAJ,KAA2B,WAAlD,EAA+D;QAC3D,MAAMC,YAAY,GAAG,KAAKC,iBAAL,CAAuBjB,QAAvB,EAAiCa,GAAG,CAACrD,IAArC,CAArB;QACA,MAAM0D,YAAY,GAAG,KAAKC,iBAAL,CAAuBnB,QAAvB,EAAiCa,GAAG,CAACrD,IAArC,CAArB;QAEA,MAAM4D,eAAe,GAAG,KAAKH,iBAAL,CACpBf,QADoB,EAEpBW,GAAG,CAACrD,IAFgB,CAAxB;QAIA,MAAM6D,eAAe,GAAG,KAAKF,iBAAL,CACpBjB,QADoB,EAEpBW,GAAG,CAACrD,IAFgB,CAAxB;QAKA,MAAMlC,EAAE,GAAG,kBAAkB,KAAKgF,UAAL,CACzBU,YADyB,CAE5B,eAAeK,eAAe,GAF/B;QAGA,MAAM9F,IAAI,GAAG,kBAAkB,KAAK+E,UAAL,CAC3Bc,eAD2B,CAE9B,eAAeF,YAAY,GAF5B;QAIA7E,SAAS,CAACjF,IAAV,CAAe,IAAIlB,KAAJ,CAAUoF,EAAV,CAAf;QACAgB,WAAW,CAAClF,IAAZ,CAAiB,IAAIlB,KAAJ,CAAUqF,IAAV,CAAjB;MACH;IACJ,CAxBD,EAnEoB,CA6FpB;;IACA2E,QAAQ,CAACoB,OAAT,CAAiBpD,OAAjB,CAA0BqD,MAAD,IAAW;MAChC,MAAMC,aAAa,GACf,KAAKhL,UAAL,CAAgB8H,cAAhB,CAA+BmD,oBAA/B,CACIzB,QADJ,EAEIuB,MAAM,CAAC/C,WAFX,CADJ,CADgC,CAOhC;;MACA,IAAI+C,MAAM,CAAC/D,IAAP,KAAgBgE,aAApB,EAAmC,OARH,CAUhC;;MACA,MAAME,aAAa,GACf,KAAKlL,UAAL,CAAgB8H,cAAhB,CAA+BmD,oBAA/B,CACIvB,QADJ,EAEIqB,MAAM,CAAC/C,WAFX,CADJ,CAXgC,CAiBhC;;MACAnC,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXJ,QADW,CAEd,uBACGqB,MAAM,CAAC/D,IACX,SAASkE,aAAa,GAL1B,CADJ;MASApF,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXJ,QADW,CAEd,uBAAuBwB,aAAa,SACjCH,MAAM,CAAC/D,IACX,GALJ,CADJ,EA3BgC,CAqChC;;MACA+D,MAAM,CAAC/D,IAAP,GAAckE,aAAd;IACH,CAvCD,EA9FoB,CAuIpB;;IACAxB,QAAQ,CAAC7B,OAAT,CAAiBH,OAAjB,CAA0BpG,KAAD,IAAU;MAC/B,MAAM6J,YAAY,GAAG,KAAKnL,UAAL,CAAgB8H,cAAhB,CAA+BC,SAA/B,CACjByB,QADiB,EAEjBlI,KAAK,CAAC0G,WAFW,EAGjB1G,KAAK,CAAC2G,KAHW,CAArB,CAD+B,CAO/B;;MACA,IAAI3G,KAAK,CAAC0F,IAAN,KAAemE,YAAnB,EAAiC,OARF,CAU/B;;MACA,MAAM;QAAElH;MAAF,IAAa,KAAKnE,MAAL,CAAYwE,cAAZ,CAA2BoF,QAA3B,CAAnB;MACA,MAAM0B,YAAY,GAAG,KAAKpL,UAAL,CAAgB8H,cAAhB,CAA+BC,SAA/B,CACjB2B,QADiB,EAEjBpI,KAAK,CAAC0G,WAFW,EAGjB1G,KAAK,CAAC2G,KAHW,CAArB,CAZ+B,CAkB/B;;MACA,MAAMnD,EAAE,GAAGb,MAAM,GACX,gBAAgBA,MAAM,MAAM3C,KAAK,CAAC0F,IAAI,gBAAgBoE,YAAY,GADvD,GAEX,gBAAgB9J,KAAK,CAAC0F,IAAI,gBAAgBoE,YAAY,GAF5D;MAGA,MAAMrG,IAAI,GAAGd,MAAM,GACb,gBAAgBA,MAAM,MAAMmH,YAAY,gBAAgB9J,KAAK,CAAC0F,IAAI,GADrD,GAEb,gBAAgBoE,YAAY,gBAAgB9J,KAAK,CAAC0F,IAAI,GAF5D;MAGAnB,SAAS,CAACjF,IAAV,CAAe,IAAIlB,KAAJ,CAAUoF,EAAV,CAAf;MACAgB,WAAW,CAAClF,IAAZ,CAAiB,IAAIlB,KAAJ,CAAUqF,IAAV,CAAjB,EA1B+B,CA4B/B;;MACAzD,KAAK,CAAC0F,IAAN,GAAaoE,YAAb;IACH,CA9BD,EAxIoB,CAwKpB;;IACA1B,QAAQ,CAACjC,WAAT,CAAqBC,OAArB,CAA8BC,UAAD,IAAe;MACxC,MAAM0D,iBAAiB,GACnB,KAAKrL,UAAL,CAAgB8H,cAAhB,CAA+BwD,cAA/B,CACI9B,QADJ,EAEI7B,UAAU,CAACK,WAFf,EAGI,KAAKS,YAAL,CAAkBd,UAAlB,CAHJ,EAIIA,UAAU,CAAC4D,qBAJf,CADJ,CADwC,CASxC;;MACA,IAAI5D,UAAU,CAACX,IAAX,KAAoBqE,iBAAxB,EAA2C,OAVH,CAYxC;;MACA,MAAMG,iBAAiB,GACnB,KAAKxL,UAAL,CAAgB8H,cAAhB,CAA+BwD,cAA/B,CACI5B,QADJ,EAEI/B,UAAU,CAACK,WAFf,EAGI,KAAKS,YAAL,CAAkBd,UAAlB,CAHJ,EAIIA,UAAU,CAAC4D,qBAJf,CADJ,CAbwC,CAqBxC;;MACA1F,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXJ,QADW,CAEd,uBACG/B,UAAU,CAACX,IACf,SAASwE,iBAAiB,GAL9B,CADJ;MASA1F,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXJ,QADW,CAEd,uBAAuB8B,iBAAiB,SACrC7D,UAAU,CAACX,IACf,GALJ,CADJ,EA/BwC,CAyCxC;;MACAW,UAAU,CAACX,IAAX,GAAkBwE,iBAAlB;IACH,CA3CD,EAzKoB,CAsNpB;;IACA,MAAMzF,WAAW,GAAG2D,QAAQ,CAAC1D,OAAT,CAAiBC,MAAjB,CACfC,MAAD,IAAYA,MAAM,CAACC,IAAP,KAAgB,MAAhB,IAA0BD,MAAM,CAACC,IAAP,KAAgB,aADtC,CAApB;;IAGA,KAAK,IAAID,MAAT,IAAmBH,WAAnB,EAAgC;MAC5B;MACA,IAAIG,MAAM,CAACK,QAAX,EAAqB;MAErB,MAAMkF,WAAW,GAAG,MAAM,KAAKC,sBAAL,CACtBlC,QADsB,EAEtBtD,MAFsB,CAA1B;MAIAL,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,eAAe+L,WAAW,CAACxH,MAAM,MAC7BwH,WAAW,CAACzE,IAChB,eAAe,KAAKR,aAAL,CACXkD,QADW,EAEXxD,MAFW,EAGX,KAHW,CAId,EAPL,CADJ;MAWAJ,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,cAAc,KAAK8G,aAAL,CACVkD,QADU,EAEVxD,MAFU,CAGb,eAAeuF,WAAW,CAACzE,IAAI,GAJpC,CADJ;IAQH;;IACD,MAAM,KAAKhC,cAAL,CAAoBa,SAApB,EAA+BC,WAA/B,CAAN;EACH;EAED;;;;;EAGe,MAAT6F,SAAS,CACXvH,WADW,EAEX8B,MAFW,EAEQ;IAEnB,MAAMT,KAAK,GAAGlG,eAAe,CAACkK,OAAhB,CAAwBrF,WAAxB,IACRA,WADQ,GAER,MAAM,KAAKsE,cAAL,CAAoBtE,WAApB,CAFZ;IAGA,MAAMwH,WAAW,GAAGnG,KAAK,CAACkE,KAAN,EAApB;IACA,MAAM9D,SAAS,GAAY,EAA3B;IACA,MAAMC,WAAW,GAAY,EAA7B;;IAEA,IAAII,MAAM,CAACC,IAAP,KAAgB,MAAhB,IAA0BD,MAAM,CAACC,IAAP,KAAgB,aAA9C,EAA6D;MACzD,MAAME,OAAO,GAAG,MAAM,KAAKC,WAAL,CAAiBb,KAAjB,EAAwBS,MAAxB,CAAtB;;MACA,IAAI,CAACG,OAAL,EAAc;QACVR,SAAS,CAACjF,IAAV,CAAe,KAAK6F,iBAAL,CAAuBhB,KAAvB,EAA8BS,MAA9B,CAAf;QACAJ,WAAW,CAAClF,IAAZ,CAAiB,KAAK8F,eAAL,CAAqBjB,KAArB,EAA4BS,MAA5B,CAAjB;MACH;IACJ;;IAEDL,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,QAAQ,KAAKoG,oBAAL,CAA0BpG,KAA1B,EAAiCS,MAAjC,CAAwC,EAHrD,CADJ;IAOAJ,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CAAgBrE,KAAhB,CAAsB,iBACjCS,MAAM,CAACc,IACX,GAHJ,CADJ,EAxBmB,CAgCnB;;IACA,IAAId,MAAM,CAAC4F,SAAX,EAAsB;MAClB,MAAM/B,cAAc,GAAG6B,WAAW,CAAC7B,cAAnC,CADkB,CAElB;;MACA,IAAIA,cAAc,CAACjG,MAAf,GAAwB,CAA5B,EAA+B;QAC3B,MAAMiI,MAAM,GAAGhC,cAAc,CAAC,CAAD,CAAd,CAAkBC,wBAAlB,GACTD,cAAc,CAAC,CAAD,CAAd,CAAkBC,wBADT,GAET,KAAKhK,UAAL,CAAgB8H,cAAhB,CAA+BqC,cAA/B,CACIyB,WADJ,EAEI7B,cAAc,CAACE,GAAf,CAAoB/D,MAAD,IAAYA,MAAM,CAACc,IAAtC,CAFJ,CAFN;QAOA,MAAMgB,WAAW,GAAG+B,cAAc,CAC7BE,GADe,CACV/D,MAAD,IAAY,IAAIA,MAAM,CAACc,IAAI,GADhB,EAEfgF,IAFe,CAEV,IAFU,CAApB;QAIAnG,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,qBAAqBsG,MAAM,GAHhC,CADJ;QAOAjG,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,oBAAoBsG,MAAM,kBAAkB/D,WAAW,GAH5D,CADJ;MAOH;;MAED+B,cAAc,CAACnJ,IAAf,CAAoBsF,MAApB;MACA,MAAM6F,MAAM,GAAGhC,cAAc,CAAC,CAAD,CAAd,CAAkBC,wBAAlB,GACTD,cAAc,CAAC,CAAD,CAAd,CAAkBC,wBADT,GAET,KAAKhK,UAAL,CAAgB8H,cAAhB,CAA+BqC,cAA/B,CACIyB,WADJ,EAEI7B,cAAc,CAACE,GAAf,CAAoB/D,MAAD,IAAYA,MAAM,CAACc,IAAtC,CAFJ,CAFN;MAOA,MAAMgB,WAAW,GAAG+B,cAAc,CAC7BE,GADe,CACV/D,MAAD,IAAY,IAAIA,MAAM,CAACc,IAAI,GADhB,EAEfgF,IAFe,CAEV,IAFU,CAApB;MAIAnG,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,oBAAoBsG,MAAM,kBAAkB/D,WAAW,GAH5D,CADJ;MAOAlC,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,qBAAqBsG,MAAM,GAHhC,CADJ;IAOH,CA1FkB,CA4FnB;;;IACA,MAAME,WAAW,GAAGL,WAAW,CAAC/D,OAAZ,CAAoBqE,IAApB,CACf5K,KAAD,IACIA,KAAK,CAAC0G,WAAN,CAAkBlE,MAAlB,KAA6B,CAA7B,IACAxC,KAAK,CAAC0G,WAAN,CAAkB,CAAlB,MAAyB9B,MAAM,CAACc,IAHpB,CAApB;;IAKA,IAAIiF,WAAJ,EAAiB;MACbpG,SAAS,CAACjF,IAAV,CAAe,KAAKsH,cAAL,CAAoBzC,KAApB,EAA2BwG,WAA3B,CAAf;MACAnG,WAAW,CAAClF,IAAZ,CAAiB,KAAKuH,YAAL,CAAkB1C,KAAlB,EAAyBwG,WAAzB,CAAjB;IACH,CArGkB,CAuGnB;;;IACA,IAAI/F,MAAM,CAACiG,QAAX,EAAqB;MACjB,MAAMC,gBAAgB,GAAG,IAAIhN,WAAJ,CAAgB;QACrC4H,IAAI,EAAE,KAAKhH,UAAL,CAAgB8H,cAAhB,CAA+BmD,oBAA/B,CACFxF,KADE,EAEF,CAACS,MAAM,CAACc,IAAR,CAFE,CAD+B;QAKrCgB,WAAW,EAAE,CAAC9B,MAAM,CAACc,IAAR;MALwB,CAAhB,CAAzB;MAOA4E,WAAW,CAACd,OAAZ,CAAoBlK,IAApB,CAAyBwL,gBAAzB;MACAvG,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CAAgBrE,KAAhB,CAAsB,oBACjC2G,gBAAgB,CAACpF,IACrB,cAAcd,MAAM,CAACc,IAAI,IAH7B,CADJ;MAOAlB,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CAAgBrE,KAAhB,CAAsB,qBACjC2G,gBAAgB,CAACpF,IACrB,GAHJ,CADJ;IAOH;;IAED,IAAId,MAAM,CAACU,aAAP,KAAyB,QAAzB,IAAqCV,MAAM,CAACW,YAAhD,EAA8D;MAC1D,MAAMC,mBAAmB,GAAG,CACxB,MAAM,KAAKC,sBAAL,CAA4BtB,KAAK,CAACuB,IAAlC,CADkB,EAE1B3B,KAF0B,CAEpB,GAFoB,CAA5B;MAGA,MAAMb,SAAS,GAAGsC,mBAAmB,CAAC,CAAD,CAArC;MACA,MAAM7C,MAAM,GAAG6C,mBAAmB,CAAC,CAAD,CAAlC;MAEA,MAAMG,WAAW,GAAG,KAAKC,wBAAL,CAA8B;QAC9CtD,QAAQ,EAAE,KAAK9D,MAAL,CAAY8D,QADwB;QAE9CK,MAF8C;QAG9CwB,KAAK,EAAEjB,SAHuC;QAI9C2B,IAAI,EAAExG,iBAAiB,CAACwH,gBAJsB;QAK9CH,IAAI,EAAEd,MAAM,CAACc,IALiC;QAM9CI,KAAK,EAAElB,MAAM,CAACW;MANgC,CAA9B,CAApB;MASA,MAAMQ,WAAW,GAAG,KAAKC,wBAAL,CAA8B;QAC9C1D,QAAQ,EAAE,KAAK9D,MAAL,CAAY8D,QADwB;QAE9CK,MAF8C;QAG9CwB,KAAK,EAAEjB,SAHuC;QAI9C2B,IAAI,EAAExG,iBAAiB,CAACwH,gBAJsB;QAK9CH,IAAI,EAAEd,MAAM,CAACc;MALiC,CAA9B,CAApB;MAQAnB,SAAS,CAACjF,IAAV,CAAeqG,WAAf;MACAnB,WAAW,CAAClF,IAAZ,CAAiByG,WAAjB;IACH,CA3JkB,CA6JnB;;;IACA,IAAInB,MAAM,CAACmG,OAAX,EAAoB;MAChBxG,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,qBAAqB,KAAKoK,UAAL,CAAgBrE,KAAhB,CAAsB,KACvCS,MAAM,CAACc,IACX,QAAQ,KAAKsF,aAAL,CAAmBpG,MAAM,CAACmG,OAA1B,CAAkC,EAH9C,CADJ;MAOAvG,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,qBAAqB,KAAKoK,UAAL,CAAgBrE,KAAhB,CAAsB,KACvCS,MAAM,CAACc,IACX,QAAQ,KAAKsF,aAAL,CAAmBpG,MAAM,CAACmG,OAA1B,CAAkC,EAH9C,CADJ;IAOH;;IAED,MAAM,KAAKrH,cAAL,CAAoBa,SAApB,EAA+BC,WAA/B,CAAN;IAEA8F,WAAW,CAACD,SAAZ,CAAsBzF,MAAtB;IACA,KAAKqG,kBAAL,CAAwB9G,KAAxB,EAA+BmG,WAA/B;EACH;EAED;;;;;EAGgB,MAAVY,UAAU,CACZpI,WADY,EAEZ4B,OAFY,EAEU;IAEtB,KAAK,MAAME,MAAX,IAAqBF,OAArB,EAA8B;MAC1B,MAAM,KAAK2F,SAAL,CAAevH,WAAf,EAA4B8B,MAA5B,CAAN;IACH;EACJ;EAED;;;;;EAGkB,MAAZuG,YAAY,CACdrI,WADc,EAEdsI,oBAFc,EAGdC,oBAHc,EAG4B;IAE1C,MAAMlH,KAAK,GAAGlG,eAAe,CAACkK,OAAhB,CAAwBrF,WAAxB,IACRA,WADQ,GAER,MAAM,KAAKsE,cAAL,CAAoBtE,WAApB,CAFZ;IAGA,MAAMwI,SAAS,GAAGrN,eAAe,CAACsN,aAAhB,CAA8BH,oBAA9B,IACZA,oBADY,GAEZjH,KAAK,CAACO,OAAN,CAAckG,IAAd,CAAoBY,CAAD,IAAOA,CAAC,CAAC9F,IAAF,KAAW0F,oBAArC,CAFN;IAGA,IAAI,CAACE,SAAL,EACI,MAAM,IAAIpO,YAAJ,CACF,WAAWkO,oBAAoB,2BAA2BjH,KAAK,CAACuB,IAAI,UADlE,CAAN;IAIJ,IAAI+F,SAAJ;;IACA,IAAIxN,eAAe,CAACsN,aAAhB,CAA8BF,oBAA9B,CAAJ,EAAyD;MACrDI,SAAS,GAAGJ,oBAAZ;IACH,CAFD,MAEO;MACHI,SAAS,GAAGH,SAAS,CAACjD,KAAV,EAAZ;MACAoD,SAAS,CAAC/F,IAAV,GAAiB2F,oBAAjB;IACH;;IAED,OAAO,KAAKK,YAAL,CAAkBvH,KAAlB,EAAyBmH,SAAzB,EAAoCG,SAApC,CAAP;EACH;EAED;;;;;EAGkB,MAAZC,YAAY,CACd5I,WADc,EAEdsI,oBAFc,EAGdK,SAHc,EAGQ;IAEtB,MAAMtH,KAAK,GAAGlG,eAAe,CAACkK,OAAhB,CAAwBrF,WAAxB,IACRA,WADQ,GAER,MAAM,KAAKsE,cAAL,CAAoBtE,WAApB,CAFZ;IAGA,IAAIwH,WAAW,GAAGnG,KAAK,CAACkE,KAAN,EAAlB;IACA,MAAM9D,SAAS,GAAY,EAA3B;IACA,MAAMC,WAAW,GAAY,EAA7B;IACA,IAAImH,mBAAmB,GAAG,KAA1B;IAEA,MAAML,SAAS,GAAGrN,eAAe,CAACsN,aAAhB,CAA8BH,oBAA9B,IACZA,oBADY,GAEZjH,KAAK,CAACO,OAAN,CAAckG,IAAd,CACKhG,MAAD,IAAYA,MAAM,CAACc,IAAP,KAAgB0F,oBADhC,CAFN;IAKA,IAAI,CAACE,SAAL,EACI,MAAM,IAAIpO,YAAJ,CACF,WAAWkO,oBAAoB,2BAA2BjH,KAAK,CAACuB,IAAI,UADlE,CAAN;;IAIJ,IACI4F,SAAS,CAACzG,IAAV,KAAmB4G,SAAS,CAAC5G,IAA7B,IACAyG,SAAS,CAAC9I,MAAV,KAAqBiJ,SAAS,CAACjJ,MAD/B,IAEAiJ,SAAS,CAACG,OAAV,KAAsBN,SAAS,CAACM,OAFhC,IAGC,CAACN,SAAS,CAAChG,aAAX,IACGmG,SAAS,CAACnG,aAAV,KAA4B,QAJhC,IAKCgG,SAAS,CAAC/F,YAAV,KAA2BkG,SAAS,CAAClG,YAArC,IACGkG,SAAS,CAACnG,aAAV,KAA4B,QAPpC,EAQE;MACE;MACA,MAAM,KAAKuG,UAAL,CAAgB1H,KAAhB,EAAuBmH,SAAvB,CAAN;MACA,MAAM,KAAKjB,SAAL,CAAelG,KAAf,EAAsBsH,SAAtB,CAAN,CAHF,CAKE;;MACAnB,WAAW,GAAGnG,KAAK,CAACkE,KAAN,EAAd;IACH,CAfD,MAeO;MACH,IAAIiD,SAAS,CAAC5F,IAAV,KAAmB+F,SAAS,CAAC/F,IAAjC,EAAuC;QACnC;QACAnB,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CAAgBrE,KAAhB,CAAsB,mBACjCmH,SAAS,CAAC5F,IACd,SAAS+F,SAAS,CAAC/F,IAAI,GAH3B,CADJ;QAOAlB,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CAAgBrE,KAAhB,CAAsB,mBACjCsH,SAAS,CAAC/F,IACd,SAAS4F,SAAS,CAAC5F,IAAI,GAH3B,CADJ,EATmC,CAiBnC;;QACA,IACI4F,SAAS,CAACzG,IAAV,KAAmB,MAAnB,IACAyG,SAAS,CAACzG,IAAV,KAAmB,aAFvB,EAGE;UACE,MAAMsF,WAAW,GAAG,MAAM,KAAKC,sBAAL,CACtBjG,KADsB,EAEtBmH,SAFsB,CAA1B;UAIA/G,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,eAAe+L,WAAW,CAACxH,MAAM,MAC7BwH,WAAW,CAACzE,IAChB,eAAe,KAAKR,aAAL,CACXf,KADW,EAEXsH,SAFW,EAGX,KAHW,CAId,EAPL,CADJ;UAWAjH,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,cAAc,KAAK8G,aAAL,CACVf,KADU,EAEVsH,SAFU,CAGb,eAAetB,WAAW,CAACzE,IAAI,GAJpC,CADJ;QAQH,CA7CkC,CA+CnC;;;QACA,IACI4F,SAAS,CAACd,SAAV,KAAwB,IAAxB,IACA,CAACc,SAAS,CAAC5C,wBAFf,EAGE;UACE,MAAMD,cAAc,GAAG6B,WAAW,CAAC7B,cAAnC,CADF,CAGE;;UACA,MAAM/B,WAAW,GAAG+B,cAAc,CAACE,GAAf,CACf/D,MAAD,IAAYA,MAAM,CAACc,IADH,CAApB;UAGA,MAAMkD,SAAS,GACX,KAAKlK,UAAL,CAAgB8H,cAAhB,CAA+BqC,cAA/B,CACIyB,WADJ,EAEI5D,WAFJ,CADJ,CAPF,CAaE;;UACAA,WAAW,CAACxG,MAAZ,CAAmBwG,WAAW,CAACzG,OAAZ,CAAoBqL,SAAS,CAAC5F,IAA9B,CAAnB,EAAwD,CAAxD;UACAgB,WAAW,CAACpH,IAAZ,CAAiBmM,SAAS,CAAC/F,IAA3B,EAfF,CAiBE;;UACA,MAAMoD,SAAS,GACX,KAAKpK,UAAL,CAAgB8H,cAAhB,CAA+BqC,cAA/B,CACIyB,WADJ,EAEI5D,WAFJ,CADJ;UAMAnC,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,uBAAuByE,SAAS,SAASE,SAAS,GAHvD,CADJ;UAOAtE,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,uBAAuB2E,SAAS,SAASF,SAAS,GAHvD,CADJ;QAOH,CAzFkC,CA2FnC;;;QACA,IACI0C,SAAS,CAACtC,WAAV,KAA0B,IAA1B,IACAyC,SAAS,CAACxC,kBAAV,KAAiC,WAFrC,EAGE;UACE,MAAMC,YAAY,GAAG,KAAKC,iBAAL,CACjBhF,KADiB,EAEjBmH,SAAS,CAAC5F,IAFO,CAArB;UAIA,MAAM0D,YAAY,GAAG,KAAKC,iBAAL,CACjBlF,KADiB,EAEjBmH,SAAS,CAAC5F,IAFO,CAArB;UAKA,MAAM4D,eAAe,GAAG,KAAKH,iBAAL,CACpBhF,KADoB,EAEpBsH,SAAS,CAAC/F,IAFU,CAAxB;UAIA,MAAM6D,eAAe,GAAG,KAAKF,iBAAL,CACpBlF,KADoB,EAEpBsH,SAAS,CAAC/F,IAFU,CAAxB;UAKA,MAAMlC,EAAE,GAAG,kBAAkB,KAAKgF,UAAL,CACzBU,YADyB,CAE5B,eAAeK,eAAe,GAF/B;UAGA,MAAM9F,IAAI,GAAG,kBAAkB,KAAK+E,UAAL,CAC3Bc,eAD2B,CAE9B,eAAeF,YAAY,GAF5B;UAIA7E,SAAS,CAACjF,IAAV,CAAe,IAAIlB,KAAJ,CAAUoF,EAAV,CAAf;UACAgB,WAAW,CAAClF,IAAZ,CAAiB,IAAIlB,KAAJ,CAAUqF,IAAV,CAAjB;QACH,CA3HkC,CA6HnC;;;QACA6G,WAAW,CAACwB,iBAAZ,CAA8BR,SAA9B,EAAyClF,OAAzC,CAAkDqD,MAAD,IAAW;UACxD,MAAMC,aAAa,GACf,KAAKhL,UAAL,CAAgB8H,cAAhB,CAA+BmD,oBAA/B,CACIW,WADJ,EAEIb,MAAM,CAAC/C,WAFX,CADJ,CADwD,CAOxD;;UACA,IAAI+C,MAAM,CAAC/D,IAAP,KAAgBgE,aAApB,EAAmC,OARqB,CAUxD;;UACAD,MAAM,CAAC/C,WAAP,CAAmBxG,MAAnB,CACIuJ,MAAM,CAAC/C,WAAP,CAAmBzG,OAAnB,CAA2BqL,SAAS,CAAC5F,IAArC,CADJ,EAEI,CAFJ;UAIA+D,MAAM,CAAC/C,WAAP,CAAmBpH,IAAnB,CAAwBmM,SAAS,CAAC/F,IAAlC;UACA,MAAMkE,aAAa,GACf,KAAKlL,UAAL,CAAgB8H,cAAhB,CAA+BmD,oBAA/B,CACIW,WADJ,EAEIb,MAAM,CAAC/C,WAFX,CADJ,CAhBwD,CAsBxD;;UACAnC,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,uBACGsF,MAAM,CAAC/D,IACX,SAASkE,aAAa,GAL1B,CADJ;UASApF,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,uBAAuByF,aAAa,SACjCH,MAAM,CAAC/D,IACX,GALJ,CADJ,EAhCwD,CA0CxD;;UACA+D,MAAM,CAAC/D,IAAP,GAAckE,aAAd;QACH,CA5CD,EA9HmC,CA4KnC;;QACAU,WAAW,CAACyB,iBAAZ,CAA8BT,SAA9B,EAAyClF,OAAzC,CAAkDpG,KAAD,IAAU;UACvD,MAAM6J,YAAY,GACd,KAAKnL,UAAL,CAAgB8H,cAAhB,CAA+BC,SAA/B,CACI6D,WADJ,EAEItK,KAAK,CAAC0G,WAFV,EAGI1G,KAAK,CAAC2G,KAHV,CADJ,CADuD,CAQvD;;UACA,IAAI3G,KAAK,CAAC0F,IAAN,KAAemE,YAAnB,EAAiC,OATsB,CAWvD;;UACA7J,KAAK,CAAC0G,WAAN,CAAkBxG,MAAlB,CACIF,KAAK,CAAC0G,WAAN,CAAkBzG,OAAlB,CAA0BqL,SAAS,CAAC5F,IAApC,CADJ,EAEI,CAFJ;UAIA1F,KAAK,CAAC0G,WAAN,CAAkBpH,IAAlB,CAAuBmM,SAAS,CAAC/F,IAAjC;UACA,MAAM;YAAE/C;UAAF,IAAa,KAAKnE,MAAL,CAAYwE,cAAZ,CAA2BmB,KAA3B,CAAnB;UACA,MAAM2F,YAAY,GACd,KAAKpL,UAAL,CAAgB8H,cAAhB,CAA+BC,SAA/B,CACI6D,WADJ,EAEItK,KAAK,CAAC0G,WAFV,EAGI1G,KAAK,CAAC2G,KAHV,CADJ,CAlBuD,CAyBvD;;UACA,MAAMnD,EAAE,GAAGb,MAAM,GACX,gBAAgBA,MAAM,MAAM3C,KAAK,CAAC0F,IAAI,gBAAgBoE,YAAY,GADvD,GAEX,gBAAgB9J,KAAK,CAAC0F,IAAI,gBAAgBoE,YAAY,GAF5D;UAGA,MAAMrG,IAAI,GAAGd,MAAM,GACb,gBAAgBA,MAAM,MAAMmH,YAAY,gBAAgB9J,KAAK,CAAC0F,IAAI,GADrD,GAEb,gBAAgBoE,YAAY,gBAAgB9J,KAAK,CAAC0F,IAAI,GAF5D;UAIAnB,SAAS,CAACjF,IAAV,CAAe,IAAIlB,KAAJ,CAAUoF,EAAV,CAAf;UACAgB,WAAW,CAAClF,IAAZ,CAAiB,IAAIlB,KAAJ,CAAUqF,IAAV,CAAjB,EAlCuD,CAoCvD;;UACAzD,KAAK,CAAC0F,IAAN,GAAaoE,YAAb;QACH,CAtCD,EA7KmC,CAqNnC;;QACAQ,WAAW,CACN0B,qBADL,CAC2BV,SAD3B,EAEKlF,OAFL,CAEcC,UAAD,IAAe;UACpB,MAAM2D,cAAc,GAChB,KAAKtL,UAAL,CAAgB8H,cAAhB,CAA+BwD,cAA/B,CACIM,WADJ,EAEIjE,UAAU,CAACK,WAFf,EAGI,KAAKS,YAAL,CAAkBd,UAAlB,CAHJ,EAIIA,UAAU,CAAC4D,qBAJf,CADJ,CADoB,CASpB;;UACA,IAAI5D,UAAU,CAACX,IAAX,KAAoBsE,cAAxB,EAAwC,OAVpB,CAYpB;;UACA3D,UAAU,CAACK,WAAX,CAAuBxG,MAAvB,CACImG,UAAU,CAACK,WAAX,CAAuBzG,OAAvB,CAA+BqL,SAAS,CAAC5F,IAAzC,CADJ,EAEI,CAFJ;UAIAW,UAAU,CAACK,WAAX,CAAuBpH,IAAvB,CAA4BmM,SAAS,CAAC/F,IAAtC;UACA,MAAMwE,iBAAiB,GACnB,KAAKxL,UAAL,CAAgB8H,cAAhB,CAA+BwD,cAA/B,CACIM,WADJ,EAEIjE,UAAU,CAACK,WAFf,EAGI,KAAKS,YAAL,CAAkBd,UAAlB,CAHJ,EAIIA,UAAU,CAAC4D,qBAJf,CADJ,CAlBoB,CA0BpB;;UACA1F,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,uBACGkC,UAAU,CAACX,IACf,SAASwE,iBAAiB,GAL9B,CADJ;UASA1F,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,uBAAuB+F,iBAAiB,SACrC7D,UAAU,CAACX,IACf,GALJ,CADJ,EApCoB,CA8CpB;;UACAW,UAAU,CAACX,IAAX,GAAkBwE,iBAAlB;QACH,CAlDL,EAtNmC,CA0QnC;;QACA,MAAM+B,cAAc,GAAG3B,WAAW,CAAC5F,OAAZ,CAAoBkG,IAApB,CAClBhG,MAAD,IAAYA,MAAM,CAACc,IAAP,KAAgB4F,SAAS,CAAC5F,IADnB,CAAvB;QAGA4E,WAAW,CAAC5F,OAAZ,CACI4F,WAAW,CAAC5F,OAAZ,CAAoBzE,OAApB,CAA4BgM,cAA5B,CADJ,EAEEvG,IAFF,GAES+F,SAAS,CAAC/F,IAFnB;QAGA4F,SAAS,CAAC5F,IAAV,GAAiB+F,SAAS,CAAC/F,IAA3B;MACH;;MAED,IACI+F,SAAS,CAACS,SAAV,KAAwBZ,SAAS,CAACY,SAAlC,IACAT,SAAS,CAACU,KAAV,KAAoBb,SAAS,CAACa,KAFlC,EAGE;QACE5H,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CAAgBrE,KAAhB,CAAsB,kBACjCsH,SAAS,CAAC/F,IACd,UAAU,KAAKlH,MAAL,CAAY4N,cAAZ,CAA2BX,SAA3B,CAAqC,EAHnD,CADJ;QAOAjH,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CAAgBrE,KAAhB,CAAsB,kBACjCsH,SAAS,CAAC/F,IACd,UAAU,KAAKlH,MAAL,CAAY4N,cAAZ,CAA2Bd,SAA3B,CAAqC,EAHnD,CADJ;MAOH;;MAED,IACI,CAACG,SAAS,CAAC5G,IAAV,KAAmB,MAAnB,IACG4G,SAAS,CAAC5G,IAAV,KAAmB,aADvB,MAECyG,SAAS,CAACzG,IAAV,KAAmB,MAAnB,IACGyG,SAAS,CAACzG,IAAV,KAAmB,aAHvB,MAIC,CAAC3G,QAAQ,CAACmO,aAAT,CAAuBZ,SAAS,CAACa,IAAjC,EAAwChB,SAAS,CAACgB,IAAlD,CAAD,IACGb,SAAS,CAACxG,QAAV,KAAuBqG,SAAS,CAACrG,QALrC,CADJ,EAOE;QACE,MAAMsH,WAAW,GAAGd,SAAS,CAACG,OAAV,GAAoB,IAApB,GAA2B,EAA/C,CADF,CAGE;;QACA,MAAMY,WAAW,GAAG,KAAKtH,aAAL,CAAmBf,KAAnB,EAA0BsH,SAA1B,CAApB,CAJF,CAME;;QACA,MAAMgB,WAAW,GAAG,KAAKvH,aAAL,CAAmBf,KAAnB,EAA0BmH,SAA1B,CAApB,CAPF,CASE;;QACA,MAAMoB,wBAAwB,GAAG,KAAKxH,aAAL,CAC7Bf,KAD6B,EAE7BmH,SAF6B,EAG7B,KAH6B,CAAjC,CAVF,CAgBE;;QACA,MAAMqB,yBAAyB,GAAG,KAAKzH,aAAL,CAC9Bf,KAD8B,EAE9BmH,SAF8B,EAG9B,IAH8B,EAI9B,KAJ8B,EAK9B,IAL8B,CAAlC,CAjBF,CAyBE;;QACA,MAAMsB,4BAA4B,GAAG,KAAK1H,aAAL,CACjCf,KADiC,EAEjCmH,SAFiC,EAGjC,KAHiC,EAIjC,KAJiC,EAKjC,IALiC,CAArC,CA1BF,CAkCE;;QACA/G,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,cAAcqO,WAAW,cAAcG,4BAA4B,EADvE,CADJ;QAKApI,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,cAAcuO,yBAAyB,cAAcD,wBAAwB,EADjF,CADJ,EAxCF,CA8CE;;QACAnI,SAAS,CAACjF,IAAV,CACI,KAAK6F,iBAAL,CAAuBhB,KAAvB,EAA8BsH,SAA9B,EAAyCe,WAAzC,CADJ;QAGAhI,WAAW,CAAClF,IAAZ,CACI,KAAK8F,eAAL,CAAqBjB,KAArB,EAA4BsH,SAA5B,EAAuCe,WAAvC,CADJ,EAlDF,CAsDE;;QACA,IACIlB,SAAS,CAACuB,OAAV,KAAsB,IAAtB,IACAvB,SAAS,CAACuB,OAAV,KAAsB9M,SAF1B,EAGE;UACE;UACA4L,mBAAmB,GAAG,IAAtB;UACApH,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,kBAAkBmH,SAAS,CAAC5F,IAAI,gBAHrC,CADJ;UAOAlB,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,kBAAkBmH,SAAS,CAAC5F,IAAI,iBAC7B4F,SAAS,CAACuB,OACd,EALJ,CADJ;QASH,CA7EH,CA+EE;;;QACA,MAAMC,MAAM,GAAG,GAAGN,WAAW,GAAGD,WAAW,WAAWd,SAAS,CAAC/F,IAAI,cAAc8G,WAAW,GAAGD,WAAW,EAA3G;QACA,MAAMQ,QAAQ,GAAG,GAAGJ,yBAAyB,GAAGJ,WAAW,WAAWd,SAAS,CAAC/F,IAAI,cAAciH,yBAAyB,GAAGJ,WAAW,EAAzI,CAjFF,CAmFE;;QACAhI,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CAAgBrE,KAAhB,CAAsB,kBACjCsH,SAAS,CAAC/F,IACd,UAAUoH,MAAM,EAHpB,CADJ;QAOAtI,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CAAgBrE,KAAhB,CAAsB,kBACjCsH,SAAS,CAAC/F,IACd,UAAUqH,QAAQ,EAHtB,CADJ,EA3FF,CAmGE;;QACA,IACItB,SAAS,CAACoB,OAAV,KAAsB,IAAtB,IACApB,SAAS,CAACoB,OAAV,KAAsB9M,SAF1B,EAGE;UACEwE,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,kBAAkBsH,SAAS,CAAC/F,IAAI,iBAC7B+F,SAAS,CAACoB,OACd,EALJ,CADJ;UASArI,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,kBAAkBsH,SAAS,CAAC/F,IAAI,gBAHrC,CADJ;QAOH,CAxHH,CA0HE;;;QACAnB,SAAS,CAACjF,IAAV,CACI,KAAK8F,eAAL,CACIjB,KADJ,EAEImH,SAFJ,EAGIqB,yBAHJ,CADJ;QAOAnI,WAAW,CAAClF,IAAZ,CACI,KAAK6F,iBAAL,CACIhB,KADJ,EAEImH,SAFJ,EAGIqB,yBAHJ,CADJ;MAOH;;MAED,IAAIrB,SAAS,CAAC0B,UAAV,KAAyBvB,SAAS,CAACuB,UAAvC,EAAmD;QAC/C,IAAIvB,SAAS,CAACuB,UAAd,EAA0B;UACtBzI,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,kBAAkBmH,SAAS,CAAC5F,IAAI,iBAHrC,CADJ;UAOAlB,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,kBAAkBmH,SAAS,CAAC5F,IAAI,gBAHrC,CADJ;QAOH,CAfD,MAeO;UACHnB,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,kBAAkBmH,SAAS,CAAC5F,IAAI,gBAHrC,CADJ;UAOAlB,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,kBAAkBmH,SAAS,CAAC5F,IAAI,iBAHrC,CADJ;QAOH;MACJ;;MAED,IAAI4F,SAAS,CAACP,OAAV,KAAsBU,SAAS,CAACV,OAApC,EAA6C;QACzCxG,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,qBAAqB,KAAKoK,UAAL,CAAgBrE,KAAhB,CAAsB,KACvCmH,SAAS,CAAC5F,IACd,QAAQ,KAAKsF,aAAL,CAAmBS,SAAS,CAACV,OAA7B,CAAqC,EAHjD,CADJ;QAOAvG,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,qBAAqB,KAAKoK,UAAL,CAAgBrE,KAAhB,CAAsB,KACvCsH,SAAS,CAAC/F,IACd,QAAQ,KAAKsF,aAAL,CAAmBM,SAAS,CAACP,OAA7B,CAAqC,EAHjD,CADJ;MAOH;;MAED,IAAIU,SAAS,CAACjB,SAAV,KAAwBc,SAAS,CAACd,SAAtC,EAAiD;QAC7C,MAAM/B,cAAc,GAAG6B,WAAW,CAAC7B,cAAnC,CAD6C,CAG7C;;QACA,IAAIA,cAAc,CAACjG,MAAf,GAAwB,CAA5B,EAA+B;UAC3B,MAAMiI,MAAM,GAAGhC,cAAc,CAAC,CAAD,CAAd,CAAkBC,wBAAlB,GACTD,cAAc,CAAC,CAAD,CAAd,CAAkBC,wBADT,GAET,KAAKhK,UAAL,CAAgB8H,cAAhB,CAA+BqC,cAA/B,CACIyB,WADJ,EAEI7B,cAAc,CAACE,GAAf,CAAoB/D,MAAD,IAAYA,MAAM,CAACc,IAAtC,CAFJ,CAFN;UAOA,MAAMgB,WAAW,GAAG+B,cAAc,CAC7BE,GADe,CACV/D,MAAD,IAAY,IAAIA,MAAM,CAACc,IAAI,GADhB,EAEfgF,IAFe,CAEV,IAFU,CAApB;UAIAnG,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,qBAAqBsG,MAAM,GAHhC,CADJ;UAOAjG,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,oBAAoBsG,MAAM,kBAAkB/D,WAAW,GAH5D,CADJ;QAOH;;QAED,IAAI+E,SAAS,CAACjB,SAAV,KAAwB,IAA5B,EAAkC;UAC9B/B,cAAc,CAACnJ,IAAf,CAAoBmM,SAApB,EAD8B,CAE9B;;UACA,MAAM7G,MAAM,GAAG0F,WAAW,CAAC5F,OAAZ,CAAoBkG,IAApB,CACVhG,MAAD,IAAYA,MAAM,CAACc,IAAP,KAAgB+F,SAAS,CAAC/F,IAD3B,CAAf;UAGAd,MAAO,CAAC4F,SAAR,GAAoB,IAApB;UACA,MAAMC,MAAM,GAAGhC,cAAc,CAAC,CAAD,CAAd,CAAkBC,wBAAlB,GACTD,cAAc,CAAC,CAAD,CAAd,CAAkBC,wBADT,GAET,KAAKhK,UAAL,CAAgB8H,cAAhB,CAA+BqC,cAA/B,CACIyB,WADJ,EAEI7B,cAAc,CAACE,GAAf,CAAoB/D,MAAD,IAAYA,MAAM,CAACc,IAAtC,CAFJ,CAFN;UAOA,MAAMgB,WAAW,GAAG+B,cAAc,CAC7BE,GADe,CACV/D,MAAD,IAAY,IAAIA,MAAM,CAACc,IAAI,GADhB,EAEfgF,IAFe,CAEV,IAFU,CAApB;UAIAnG,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,oBAAoBsG,MAAM,kBAAkB/D,WAAW,GAH5D,CADJ;UAOAlC,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,qBAAqBsG,MAAM,GAHhC,CADJ;QAOH,CAhCD,MAgCO;UACH,MAAMwC,aAAa,GAAGxE,cAAc,CAACmC,IAAf,CACjBY,CAAD,IAAOA,CAAC,CAAC9F,IAAF,KAAW+F,SAAS,CAAC/F,IADV,CAAtB;UAGA+C,cAAc,CAACvI,MAAf,CACIuI,cAAc,CAACxI,OAAf,CAAuBgN,aAAvB,CADJ,EAEI,CAFJ,EAJG,CASH;;UACA,MAAMrI,MAAM,GAAG0F,WAAW,CAAC5F,OAAZ,CAAoBkG,IAApB,CACVhG,MAAD,IAAYA,MAAM,CAACc,IAAP,KAAgB+F,SAAS,CAAC/F,IAD3B,CAAf;UAGAd,MAAO,CAAC4F,SAAR,GAAoB,KAApB,CAbG,CAeH;;UACA,IAAI/B,cAAc,CAACjG,MAAf,GAAwB,CAA5B,EAA+B;YAC3B,MAAMiI,MAAM,GAAGhC,cAAc,CAAC,CAAD,CAAd,CACVC,wBADU,GAETD,cAAc,CAAC,CAAD,CAAd,CAAkBC,wBAFT,GAGT,KAAKhK,UAAL,CAAgB8H,cAAhB,CAA+BqC,cAA/B,CACIyB,WADJ,EAEI7B,cAAc,CAACE,GAAf,CAAoB/D,MAAD,IAAYA,MAAM,CAACc,IAAtC,CAFJ,CAHN;YAQA,MAAMgB,WAAW,GAAG+B,cAAc,CAC7BE,GADe,CACV/D,MAAD,IAAY,IAAIA,MAAM,CAACc,IAAI,GADhB,EAEfgF,IAFe,CAEV,IAFU,CAApB;YAIAnG,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,oBAAoBsG,MAAM,kBAAkB/D,WAAW,GAH5D,CADJ;YAOAlC,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,qBAAqBsG,MAAM,GAHhC,CADJ;UAOH;QACJ;MACJ;;MAED,IAAIgB,SAAS,CAACZ,QAAV,KAAuBS,SAAS,CAACT,QAArC,EAA+C;QAC3C,IAAIY,SAAS,CAACZ,QAAV,KAAuB,IAA3B,EAAiC;UAC7B,MAAMC,gBAAgB,GAAG,IAAIhN,WAAJ,CAAgB;YACrC4H,IAAI,EAAE,KAAKhH,UAAL,CAAgB8H,cAAhB,CAA+BmD,oBAA/B,CACFxF,KADE,EAEF,CAACsH,SAAS,CAAC/F,IAAX,CAFE,CAD+B;YAKrCgB,WAAW,EAAE,CAAC+E,SAAS,CAAC/F,IAAX;UALwB,CAAhB,CAAzB;UAOA4E,WAAW,CAACd,OAAZ,CAAoBlK,IAApB,CAAyBwL,gBAAzB;UACAvG,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,oBACG2G,gBAAgB,CAACpF,IACrB,cAAc+F,SAAS,CAAC/F,IAAI,IALhC,CADJ;UASAlB,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,qBAAqB2G,gBAAgB,CAACpF,IAAI,GAH/C,CADJ;QAOH,CAzBD,MAyBO;UACH,MAAMoF,gBAAgB,GAAGR,WAAW,CAACd,OAAZ,CAAoBoB,IAApB,CACpBnB,MAAD,IAAW;YACP,OACIA,MAAM,CAAC/C,WAAP,CAAmBlE,MAAnB,KAA8B,CAA9B,IACA,CAAC,CAACiH,MAAM,CAAC/C,WAAP,CAAmBkE,IAAnB,CACGxH,UAAD,IACIA,UAAU,KAAKqI,SAAS,CAAC/F,IAF/B,CAFN;UAOH,CAToB,CAAzB;UAWA4E,WAAW,CAACd,OAAZ,CAAoBtJ,MAApB,CACIoK,WAAW,CAACd,OAAZ,CAAoBvJ,OAApB,CAA4B6K,gBAA5B,CADJ,EAEI,CAFJ;UAIAvG,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,qBAAqB2G,gBAAiB,CAACpF,IAAI,GAHhD,CADJ;UAOAlB,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,oBACG2G,gBAAiB,CAACpF,IACtB,cAAc+F,SAAS,CAAC/F,IAAI,IALhC,CADJ;QASH;MACJ;;MAED,IAAI4F,SAAS,CAACtC,WAAV,KAA0ByC,SAAS,CAACzC,WAAxC,EAAqD;QACjD;QACA,IAAIsC,SAAS,CAACtC,WAAd,EAA2B;UACvB,IAAIsC,SAAS,CAACrC,kBAAV,KAAiC,MAArC,EAA6C;YACzC1E,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,kBACGmH,SAAS,CAAC5F,IACd,gBALJ,CADJ;YASAlB,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,kBACGmH,SAAS,CAAC5F,IACd,iBAAiB,KAAKlH,MAAL,CAAY0O,aAAa,EAL9C,CADJ;UASH,CAnBD,MAmBO,IAAI5B,SAAS,CAACrC,kBAAV,KAAiC,WAArC,EAAkD;YACrD1E,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,kBACGsH,SAAS,CAAC/F,IACd,gBALJ,CADJ;YASAlB,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,kBACGsH,SAAS,CAAC/F,IACd,0BAA0B,KAAK8C,UAAL,CACtB,KAAKW,iBAAL,CAAuBhF,KAAvB,EAA8BsH,SAA9B,CADsB,CAEzB,IAPL,CADJ;YAYAlH,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,iBAAiB,KAAKoK,UAAL,CACb,KAAKW,iBAAL,CAAuBhF,KAAvB,EAA8BsH,SAA9B,CADa,CAEhB,EAHL,CADJ;YAOAjH,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,iCAAiC,KAAKoK,UAAL,CAC7B,KAAKW,iBAAL,CAAuBhF,KAAvB,EAA8BsH,SAA9B,CAD6B,CAEhC,aAAa,KAAKjD,UAAL,CAAgBrE,KAAhB,CAAsB,KAChCsH,SAAS,CAAC/F,IACd,GALJ,CADJ;UASH;QACJ;;QAED,IAAI+F,SAAS,CAACxC,kBAAV,KAAiC,MAArC,EAA6C;UACzC,IAAIwC,SAAS,CAACzC,WAAV,KAA0B,IAA9B,EAAoC;YAChCzE,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,kBACGsH,SAAS,CAAC/F,IACd,iBAAiB,KAAKlH,MAAL,CAAY0O,aAAa,EAL9C,CADJ;YASA1I,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,kBACGsH,SAAS,CAAC/F,IACd,gBALJ,CADJ;UASH,CAnBD,MAmBO;YACHnB,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,kBACGsH,SAAS,CAAC/F,IACd,gBALJ,CADJ;YASAlB,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,kBACGsH,SAAS,CAAC/F,IACd,iBAAiB,KAAKlH,MAAL,CAAY0O,aAAa,EAL9C,CADJ;UASH;QACJ,CAxCD,MAwCO,IAAIzB,SAAS,CAACxC,kBAAV,KAAiC,WAArC,EAAkD;UACrD,IAAIwC,SAAS,CAACzC,WAAV,KAA0B,IAA9B,EAAoC;YAChCzE,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,iCAAiC,KAAKoK,UAAL,CAC7B,KAAKW,iBAAL,CAAuBhF,KAAvB,EAA8BsH,SAA9B,CAD6B,CAEhC,aAAa,KAAKjD,UAAL,CAAgBrE,KAAhB,CAAsB,KAChCsH,SAAS,CAAC/F,IACd,GALJ,CADJ;YASAlB,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,iBAAiB,KAAKoK,UAAL,CACb,KAAKW,iBAAL,CAAuBhF,KAAvB,EAA8BsH,SAA9B,CADa,CAEhB,EAHL,CADJ;YAQAlH,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,kBACGsH,SAAS,CAAC/F,IACd,0BAA0B,KAAK8C,UAAL,CACtB,KAAKW,iBAAL,CAAuBhF,KAAvB,EAA8BsH,SAA9B,CADsB,CAEzB,IAPL,CADJ;YAWAjH,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,kBACGsH,SAAS,CAAC/F,IACd,gBALJ,CADJ;UASH,CAtCD,MAsCO;YACHnB,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,kBACGsH,SAAS,CAAC/F,IACd,gBALJ,CADJ;YASAlB,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,kBACGsH,SAAS,CAAC/F,IACd,0BAA0B,KAAK8C,UAAL,CACtB,KAAKW,iBAAL,CAAuBhF,KAAvB,EAA8BsH,SAA9B,CADsB,CAEzB,IAPL,CADJ;YAYAlH,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,iBAAiB,KAAKoK,UAAL,CACb,KAAKW,iBAAL,CAAuBhF,KAAvB,EAA8BsH,SAA9B,CADa,CAEhB,EAHL,CADJ;YAOAjH,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,iCAAiC,KAAKoK,UAAL,CAC7B,KAAKW,iBAAL,CAAuBhF,KAAvB,EAA8BsH,SAA9B,CAD6B,CAEhC,aAAa,KAAKjD,UAAL,CAAgBrE,KAAhB,CAAsB,KAChCsH,SAAS,CAAC/F,IACd,GALJ,CADJ;UASH;QACJ;MACJ,CAh1BE,CAk1BH;;;MACA,IACI+F,SAAS,CAACoB,OAAV,KAAsBvB,SAAS,CAACuB,OAAhC,IACA,CAAClB,mBAFL,EAGE;QACE,IACIF,SAAS,CAACoB,OAAV,KAAsB,IAAtB,IACApB,SAAS,CAACoB,OAAV,KAAsB9M,SAF1B,EAGE;UACEwE,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,kBAAkBsH,SAAS,CAAC/F,IAAI,iBAC7B+F,SAAS,CAACoB,OACd,EALJ,CADJ;;UAUA,IACIvB,SAAS,CAACuB,OAAV,KAAsB,IAAtB,IACAvB,SAAS,CAACuB,OAAV,KAAsB9M,SAF1B,EAGE;YACEyE,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,kBACGsH,SAAS,CAAC/F,IACd,iBAAiB4F,SAAS,CAACuB,OAAO,EALtC,CADJ;UASH,CAbD,MAaO;YACHrI,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,kBACGsH,SAAS,CAAC/F,IACd,gBALJ,CADJ;UASH;QACJ,CAtCD,MAsCO,IACH4F,SAAS,CAACuB,OAAV,KAAsB,IAAtB,IACAvB,SAAS,CAACuB,OAAV,KAAsB9M,SAFnB,EAGL;UACEwE,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,kBAAkBsH,SAAS,CAAC/F,IAAI,gBAHrC,CADJ;UAOAlB,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,kBAAkBsH,SAAS,CAAC/F,IAAI,iBAC7B4F,SAAS,CAACuB,OACd,EALJ,CADJ;QASH;MACJ;;MAED,IACI,CAACpB,SAAS,CAAC0B,kBAAV,IAAgC,EAAjC,EAAqCC,WAArC,OACI,CAAC9B,SAAS,CAAC6B,kBAAV,IAAgC,EAAjC,EAAqCC,WAArC,EADJ,IAEA3B,SAAS,CAAC4B,IAAV,KAAmB/B,SAAS,CAAC+B,IAHjC,EAIE;QACE9I,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CAAgBrE,KAAhB,CAAsB,kBACjCsH,SAAS,CAAC/F,IACd,UAAU,KAAKlH,MAAL,CAAY4N,cAAZ,CAA2BX,SAA3B,CAAqC,EAHnD,CADJ;QAOAjH,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CAAgBrE,KAAhB,CAAsB,kBACjCsH,SAAS,CAAC/F,IACd,UAAU,KAAKlH,MAAL,CAAY4N,cAAZ,CAA2Bd,SAA3B,CAAqC,EAHnD,CADJ;MAOH;;MAED,IAAIG,SAAS,CAACnG,aAAV,KAA4BgG,SAAS,CAAChG,aAA1C,EAAyD;QACrD;QACA,IACI,CAACmG,SAAS,CAACnG,aAAX,IACAmG,SAAS,CAACnG,aAAV,KAA4B,SAFhC,EAGE;UACE;UACA,MAAME,mBAAmB,GAAG,CACxB,MAAM,KAAKC,sBAAL,CAA4BtB,KAAK,CAACuB,IAAlC,CADkB,EAE1B3B,KAF0B,CAEpB,GAFoB,CAA5B;UAGA,MAAMb,SAAS,GAAGsC,mBAAmB,CAAC,CAAD,CAArC;UACA,MAAM7C,MAAM,GAAG6C,mBAAmB,CAAC,CAAD,CAAlC;UAEAjB,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,mBAAmBmH,SAAS,CAAC5F,IAAI,kBAC9B4F,SAAS,CAAC5F,IACd,GALJ,CADJ;UASAnB,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,QAAQ,KAAKoG,oBAAL,CACLpG,KADK,EAELsH,SAFK,CAGR,EANL,CADJ;UAUAlH,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,UAAU,KAAKoK,UAAL,CAAgBrE,KAAhB,CAAsB,SAC5BsH,SAAS,CAAC/F,IACd,iBAAiB4F,SAAS,CAAC5F,IAAI,GAHnC,CADJ;UAOAnB,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,0BAA0BmH,SAAS,CAAC5F,IAAI,GAH7C,CADJ;UAOAnB,SAAS,CAACjF,IAAV,CACI,KAAK0G,wBAAL,CAA8B;YAC1B1D,QAAQ,EAAE,KAAK9D,MAAL,CAAY8D,QADI;YAE1BK,MAF0B;YAG1BwB,KAAK,EAAEjB,SAHmB;YAI1B2B,IAAI,EAAExG,iBAAiB,CAACwH,gBAJE;YAK1BH,IAAI,EAAE4F,SAAS,CAAC5F;UALU,CAA9B,CADJ,EAzCF,CAkDE;;UACAlB,WAAW,CAAClF,IAAZ,CACI,KAAKsG,wBAAL,CAA8B;YAC1BtD,QAAQ,EAAE,KAAK9D,MAAL,CAAY8D,QADI;YAE1BK,MAF0B;YAG1BwB,KAAK,EAAEjB,SAHmB;YAI1B2B,IAAI,EAAExG,iBAAiB,CAACwH,gBAJE;YAK1BH,IAAI,EAAE4F,SAAS,CAAC5F,IALU;YAM1BI,KAAK,EAAEwF,SAAS,CAAC/F;UANS,CAA9B,CADJ;UAUAf,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,QAAQ,KAAKoG,oBAAL,CACLpG,KADK,EAELmH,SAFK,CAGR,EANL,CADJ;UAUA9G,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,iBAAiBsH,SAAS,CAAC/F,IAAI,GAHpC,CADJ,EAvEF,CA8EE;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;QACH;MACJ;IACJ;;IAED,MAAM,KAAKhC,cAAL,CAAoBa,SAApB,EAA+BC,WAA/B,CAAN;IACA,KAAKyG,kBAAL,CAAwB9G,KAAxB,EAA+BmG,WAA/B;EACH;EAED;;;;;EAGmB,MAAbgD,aAAa,CACfxK,WADe,EAEfyK,cAFe,EAEqD;IAEpE,KAAK,MAAM;MAAEjC,SAAF;MAAaG;IAAb,CAAX,IAAuC8B,cAAvC,EAAuD;MACnD,MAAM,KAAK7B,YAAL,CAAkB5I,WAAlB,EAA+BwI,SAA/B,EAA0CG,SAA1C,CAAN;IACH;EACJ;EAED;;;;;EAGgB,MAAVI,UAAU,CACZ/I,WADY,EAEZ0K,YAFY,EAEsB;IAElC,MAAMrJ,KAAK,GAAGlG,eAAe,CAACkK,OAAhB,CAAwBrF,WAAxB,IACRA,WADQ,GAER,MAAM,KAAKsE,cAAL,CAAoBtE,WAApB,CAFZ;IAGA,MAAM8B,MAAM,GAAG3G,eAAe,CAACsN,aAAhB,CAA8BiC,YAA9B,IACTA,YADS,GAETrJ,KAAK,CAACsJ,gBAAN,CAAuBD,YAAvB,CAFN;IAGA,IAAI,CAAC5I,MAAL,EACI,MAAM,IAAI1H,YAAJ,CACF,WAAWsQ,YAAY,6BAA6BrJ,KAAK,CAACuB,IAAI,GAD5D,CAAN;IAIJ,MAAM4E,WAAW,GAAGnG,KAAK,CAACkE,KAAN,EAApB;IACA,MAAM9D,SAAS,GAAY,EAA3B;IACA,MAAMC,WAAW,GAAY,EAA7B,CAfkC,CAiBlC;;IACA,IAAII,MAAM,CAAC4F,SAAX,EAAsB;MAClB,MAAMC,MAAM,GAAG7F,MAAM,CAAC8D,wBAAP,GACT9D,MAAM,CAAC8D,wBADE,GAET,KAAKhK,UAAL,CAAgB8H,cAAhB,CAA+BqC,cAA/B,CACIyB,WADJ,EAEIA,WAAW,CAAC7B,cAAZ,CAA2BE,GAA3B,CAAgC/D,MAAD,IAAYA,MAAM,CAACc,IAAlD,CAFJ,CAFN;MAOA,MAAMgB,WAAW,GAAG4D,WAAW,CAAC7B,cAAZ,CACfE,GADe,CACVsE,aAAD,IAAmB,IAAIA,aAAa,CAACvH,IAAI,GAD9B,EAEfgF,IAFe,CAEV,IAFU,CAApB;MAIAnG,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACX8B,WADW,CAEd,qBAAqBG,MAAM,GAHhC,CADJ;MAOAjG,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACX8B,WADW,CAEd,oBAAoBG,MAAM,kBAAkB/D,WAAW,GAH5D,CADJ,EAnBkB,CA2BlB;;MACA,MAAMgH,WAAW,GAAGpD,WAAW,CAACmD,gBAAZ,CAA6B7I,MAAM,CAACc,IAApC,CAApB;MACAgI,WAAY,CAAClD,SAAb,GAAyB,KAAzB,CA7BkB,CA+BlB;;MACA,IAAIF,WAAW,CAAC7B,cAAZ,CAA2BjG,MAA3B,GAAoC,CAAxC,EAA2C;QACvC,MAAMiI,MAAM,GAAGH,WAAW,CAAC7B,cAAZ,CAA2B,CAA3B,EACVC,wBADU,GAET4B,WAAW,CAAC7B,cAAZ,CAA2B,CAA3B,EAA8BC,wBAFrB,GAGT,KAAKhK,UAAL,CAAgB8H,cAAhB,CAA+BqC,cAA/B,CACIyB,WADJ,EAEIA,WAAW,CAAC7B,cAAZ,CAA2BE,GAA3B,CACK/D,MAAD,IAAYA,MAAM,CAACc,IADvB,CAFJ,CAHN;QAUA,MAAMgB,WAAW,GAAG4D,WAAW,CAAC7B,cAAZ,CACfE,GADe,CACVsE,aAAD,IAAmB,IAAIA,aAAa,CAACvH,IAAI,GAD9B,EAEfgF,IAFe,CAEV,IAFU,CAApB;QAIAnG,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACX8B,WADW,CAEd,oBAAoBG,MAAM,kBAAkB/D,WAAW,GAH5D,CADJ;QAOAlC,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACX8B,WADW,CAEd,qBAAqBG,MAAM,GAHhC,CADJ;MAOH;IACJ,CAhFiC,CAkFlC;;;IACA,MAAME,WAAW,GAAGL,WAAW,CAAC/D,OAAZ,CAAoBqE,IAApB,CACf5K,KAAD,IACIA,KAAK,CAAC0G,WAAN,CAAkBlE,MAAlB,KAA6B,CAA7B,IACAxC,KAAK,CAAC0G,WAAN,CAAkB,CAAlB,MAAyB9B,MAAM,CAACc,IAHpB,CAApB;;IAKA,IAAIiF,WAAJ,EAAiB;MACbL,WAAW,CAAC/D,OAAZ,CAAoBrG,MAApB,CACIoK,WAAW,CAAC/D,OAAZ,CAAoBtG,OAApB,CAA4B0K,WAA5B,CADJ,EAEI,CAFJ;MAIApG,SAAS,CAACjF,IAAV,CAAe,KAAKuH,YAAL,CAAkB1C,KAAlB,EAAyBwG,WAAzB,CAAf;MACAnG,WAAW,CAAClF,IAAZ,CAAiB,KAAKsH,cAAL,CAAoBzC,KAApB,EAA2BwG,WAA3B,CAAjB;IACH,CA/FiC,CAiGlC;;;IACA,MAAMgD,WAAW,GAAGrD,WAAW,CAACsD,MAAZ,CAAmBhD,IAAnB,CACfiD,KAAD,IACI,CAAC,CAACA,KAAK,CAACnH,WAAR,IACAmH,KAAK,CAACnH,WAAN,CAAkBlE,MAAlB,KAA6B,CAD7B,IAEAqL,KAAK,CAACnH,WAAN,CAAkB,CAAlB,MAAyB9B,MAAM,CAACc,IAJpB,CAApB;;IAMA,IAAIiI,WAAJ,EAAiB;MACbrD,WAAW,CAACsD,MAAZ,CAAmB1N,MAAnB,CACIoK,WAAW,CAACsD,MAAZ,CAAmB3N,OAAnB,CAA2B0N,WAA3B,CADJ,EAEI,CAFJ;MAIApJ,SAAS,CAACjF,IAAV,CAAe,KAAKwO,sBAAL,CAA4B3J,KAA5B,EAAmCwJ,WAAnC,CAAf;MACAnJ,WAAW,CAAClF,IAAZ,CAAiB,KAAKyO,wBAAL,CAA8B5J,KAA9B,EAAqCwJ,WAArC,CAAjB;IACH,CA/GiC,CAiHlC;;;IACA,MAAMK,YAAY,GAAG1D,WAAW,CAACd,OAAZ,CAAoBoB,IAApB,CAChBnB,MAAD,IACIA,MAAM,CAAC/C,WAAP,CAAmBlE,MAAnB,KAA8B,CAA9B,IACAiH,MAAM,CAAC/C,WAAP,CAAmB,CAAnB,MAA0B9B,MAAM,CAACc,IAHpB,CAArB;;IAKA,IAAIsI,YAAJ,EAAkB;MACd1D,WAAW,CAACd,OAAZ,CAAoBtJ,MAApB,CACIoK,WAAW,CAACd,OAAZ,CAAoBvJ,OAApB,CAA4B+N,YAA5B,CADJ,EAEI,CAFJ;MAIAzJ,SAAS,CAACjF,IAAV,CAAe,KAAK2O,uBAAL,CAA6B9J,KAA7B,EAAoC6J,YAApC,CAAf;MACAxJ,WAAW,CAAClF,IAAZ,CACI,KAAK4O,yBAAL,CAA+B/J,KAA/B,EAAsC6J,YAAtC,CADJ;IAGH;;IAEDzJ,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CAAgBrE,KAAhB,CAAsB,iBACjCS,MAAM,CAACc,IACX,GAHJ,CADJ;IAOAlB,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,QAAQ,KAAKoG,oBAAL,CAA0BpG,KAA1B,EAAiCS,MAAjC,CAAwC,EAHrD,CADJ,EAzIkC,CAiJlC;;IACA,IAAIA,MAAM,CAACC,IAAP,KAAgB,MAAhB,IAA0BD,MAAM,CAACC,IAAP,KAAgB,aAA9C,EAA6D;MACzD,MAAME,OAAO,GAAG,MAAM,KAAKC,WAAL,CAAiBb,KAAjB,EAAwBS,MAAxB,CAAtB;;MACA,IAAIG,OAAJ,EAAa;QACT,MAAMoJ,QAAQ,GAAG,MAAM,KAAK/D,sBAAL,CACnBjG,KADmB,EAEnBS,MAFmB,CAAvB;QAIA,MAAMwJ,eAAe,GAAG,IAAID,QAAQ,CAACxL,MAAM,MAAMwL,QAAQ,CAACzI,IAAI,GAA9D;QACAnB,SAAS,CAACjF,IAAV,CACI,KAAK8F,eAAL,CAAqBjB,KAArB,EAA4BS,MAA5B,EAAoCwJ,eAApC,CADJ;QAGA5J,WAAW,CAAClF,IAAZ,CACI,KAAK6F,iBAAL,CAAuBhB,KAAvB,EAA8BS,MAA9B,EAAsCwJ,eAAtC,CADJ;MAGH;IACJ;;IAED,IAAIxJ,MAAM,CAACU,aAAP,KAAyB,QAA7B,EAAuC;MACnC,MAAME,mBAAmB,GAAG,CACxB,MAAM,KAAKC,sBAAL,CAA4BtB,KAAK,CAACuB,IAAlC,CADkB,EAE1B3B,KAF0B,CAEpB,GAFoB,CAA5B;MAGA,MAAMb,SAAS,GAAGsC,mBAAmB,CAAC,CAAD,CAArC;MACA,MAAM7C,MAAM,GAAG6C,mBAAmB,CAAC,CAAD,CAAlC;MACA,MAAMO,WAAW,GAAG,KAAKC,wBAAL,CAA8B;QAC9C1D,QAAQ,EAAE,KAAK9D,MAAL,CAAY8D,QADwB;QAE9CK,MAF8C;QAG9CwB,KAAK,EAAEjB,SAHuC;QAI9C2B,IAAI,EAAExG,iBAAiB,CAACwH,gBAJsB;QAK9CH,IAAI,EAAEd,MAAM,CAACc;MALiC,CAA9B,CAApB;MAOA,MAAMC,WAAW,GAAG,KAAKC,wBAAL,CAA8B;QAC9CtD,QAAQ,EAAE,KAAK9D,MAAL,CAAY8D,QADwB;QAE9CK,MAF8C;QAG9CwB,KAAK,EAAEjB,SAHuC;QAI9C2B,IAAI,EAAExG,iBAAiB,CAACwH,gBAJsB;QAK9CH,IAAI,EAAEd,MAAM,CAACc,IALiC;QAM9CI,KAAK,EAAElB,MAAM,CAACW;MANgC,CAA9B,CAApB;MASAhB,SAAS,CAACjF,IAAV,CAAeyG,WAAf;MACAvB,WAAW,CAAClF,IAAZ,CAAiBqG,WAAjB;IACH;;IAED,MAAM,KAAKjC,cAAL,CAAoBa,SAApB,EAA+BC,WAA/B,CAAN;IAEA8F,WAAW,CAAC+D,YAAZ,CAAyBzJ,MAAzB;IACA,KAAKqG,kBAAL,CAAwB9G,KAAxB,EAA+BmG,WAA/B;EACH;EAED;;;;;EAGiB,MAAXgE,WAAW,CACbxL,WADa,EAEb4B,OAFa,EAEoB;IAEjC,KAAK,MAAME,MAAX,IAAqBF,OAArB,EAA8B;MAC1B,MAAM,KAAKmH,UAAL,CAAgB/I,WAAhB,EAA6B8B,MAA7B,CAAN;IACH;EACJ;EAED;;;;;EAGsB,MAAhB2J,gBAAgB,CAClBzL,WADkB,EAElB4D,WAFkB,EAGlB8H,cAHkB,EAGK;IAEvB,MAAMrK,KAAK,GAAGlG,eAAe,CAACkK,OAAhB,CAAwBrF,WAAxB,IACRA,WADQ,GAER,MAAM,KAAKsE,cAAL,CAAoBtE,WAApB,CAFZ;IAGA,MAAMwH,WAAW,GAAGnG,KAAK,CAACkE,KAAN,EAApB;IAEA,MAAM7E,EAAE,GAAG,KAAKiL,mBAAL,CAAyBtK,KAAzB,EAAgCuC,WAAhC,EAA6C8H,cAA7C,CAAX,CAPuB,CASvB;;IACAlE,WAAW,CAAC5F,OAAZ,CAAoB0B,OAApB,CAA6BxB,MAAD,IAAW;MACnC,IAAI8B,WAAW,CAACkE,IAAZ,CAAkBxH,UAAD,IAAgBA,UAAU,KAAKwB,MAAM,CAACc,IAAvD,CAAJ,EACId,MAAM,CAAC4F,SAAP,GAAmB,IAAnB;IACP,CAHD;IAIA,MAAM/G,IAAI,GAAG,KAAKiL,iBAAL,CAAuBpE,WAAvB,CAAb;IAEA,MAAM,KAAK5G,cAAL,CAAoBF,EAApB,EAAwBC,IAAxB,CAAN;IACA,KAAKwH,kBAAL,CAAwB9G,KAAxB,EAA+BmG,WAA/B;EACH;EAED;;;;;EAGuB,MAAjBqE,iBAAiB,CACnB7L,WADmB,EAEnB4B,OAFmB,EAEG;IAEtB,MAAMP,KAAK,GAAGlG,eAAe,CAACkK,OAAhB,CAAwBrF,WAAxB,IACRA,WADQ,GAER,MAAM,KAAKsE,cAAL,CAAoBtE,WAApB,CAFZ;IAGA,MAAMwH,WAAW,GAAGnG,KAAK,CAACkE,KAAN,EAApB;IACA,MAAM3B,WAAW,GAAGhC,OAAO,CAACiE,GAAR,CAAa/D,MAAD,IAAYA,MAAM,CAACc,IAA/B,CAApB;IACA,MAAMnB,SAAS,GAAY,EAA3B;IACA,MAAMC,WAAW,GAAY,EAA7B,CARsB,CAUtB;;IACA,MAAMiE,cAAc,GAAG6B,WAAW,CAAC7B,cAAnC;;IACA,IAAIA,cAAc,CAACjG,MAAf,GAAwB,CAA5B,EAA+B;MAC3B,MAAMiI,MAAM,GAAGhC,cAAc,CAAC,CAAD,CAAd,CAAkBC,wBAAlB,GACTD,cAAc,CAAC,CAAD,CAAd,CAAkBC,wBADT,GAET,KAAKhK,UAAL,CAAgB8H,cAAhB,CAA+BqC,cAA/B,CACIyB,WADJ,EAEI7B,cAAc,CAACE,GAAf,CAAoB/D,MAAD,IAAYA,MAAM,CAACc,IAAtC,CAFJ,CAFN;MAOA,MAAMkJ,iBAAiB,GAAGnG,cAAc,CACnCE,GADqB,CAChB/D,MAAD,IAAY,IAAIA,MAAM,CAACc,IAAI,GADV,EAErBgF,IAFqB,CAEhB,IAFgB,CAA1B;MAIAnG,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,qBAAqBsG,MAAM,GAHhC,CADJ;MAOAjG,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,oBAAoBsG,MAAM,kBAAkBmE,iBAAiB,GAHlE,CADJ;IAOH,CAtCqB,CAwCtB;;;IACAtE,WAAW,CAAC5F,OAAZ,CACKC,MADL,CACaC,MAAD,IAAY8B,WAAW,CAACzG,OAAZ,CAAoB2E,MAAM,CAACc,IAA3B,MAAqC,CAAC,CAD9D,EAEKU,OAFL,CAEcxB,MAAD,IAAaA,MAAM,CAAC4F,SAAP,GAAmB,IAF7C;IAIA,MAAMC,MAAM,GAAGhC,cAAc,CAAC,CAAD,CAAd,CAAkBC,wBAAlB,GACTD,cAAc,CAAC,CAAD,CAAd,CAAkBC,wBADT,GAET,KAAKhK,UAAL,CAAgB8H,cAAhB,CAA+BqC,cAA/B,CACIyB,WADJ,EAEI5D,WAFJ,CAFN;IAOA,MAAMkI,iBAAiB,GAAGlI,WAAW,CAChCiC,GADqB,CAChBvF,UAAD,IAAgB,IAAIA,UAAU,GADb,EAErBsH,IAFqB,CAEhB,IAFgB,CAA1B;IAIAnG,SAAS,CAACjF,IAAV,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,oBAAoBsG,MAAM,kBAAkBmE,iBAAiB,GAHlE,CADJ;IAOApK,WAAW,CAAClF,IAAZ,CACI,IAAIlB,KAAJ,CACI,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,qBAAqBsG,MAAM,GAHhC,CADJ;IAQA,MAAM,KAAK/G,cAAL,CAAoBa,SAApB,EAA+BC,WAA/B,CAAN;IACA,KAAKyG,kBAAL,CAAwB9G,KAAxB,EAA+BmG,WAA/B;EACH;EAED;;;;;EAGoB,MAAduE,cAAc,CAChB/L,WADgB,EAEhB0L,cAFgB,EAEO;IAEvB,MAAMrK,KAAK,GAAGlG,eAAe,CAACkK,OAAhB,CAAwBrF,WAAxB,IACRA,WADQ,GAER,MAAM,KAAKsE,cAAL,CAAoBtE,WAApB,CAFZ;IAGA,MAAMU,EAAE,GAAG,KAAKkL,iBAAL,CAAuBvK,KAAvB,CAAX;IACA,MAAMV,IAAI,GAAG,KAAKgL,mBAAL,CACTtK,KADS,EAETA,KAAK,CAACsE,cAAN,CAAqBE,GAArB,CAA0B/D,MAAD,IAAYA,MAAM,CAACc,IAA5C,CAFS,EAGT8I,cAHS,CAAb;IAKA,MAAM,KAAK9K,cAAL,CAAoBF,EAApB,EAAwBC,IAAxB,CAAN;IACAU,KAAK,CAACsE,cAAN,CAAqBrC,OAArB,CAA8BxB,MAAD,IAAW;MACpCA,MAAM,CAAC4F,SAAP,GAAmB,KAAnB;IACH,CAFD;EAGH;EAED;;;;;EAG4B,MAAtBsE,sBAAsB,CACxBhM,WADwB,EAExBgI,gBAFwB,EAEK;IAE7B,MAAM3G,KAAK,GAAGlG,eAAe,CAACkK,OAAhB,CAAwBrF,WAAxB,IACRA,WADQ,GAER,MAAM,KAAKsE,cAAL,CAAoBtE,WAApB,CAFZ,CAF6B,CAM7B;;IACA,IAAI,CAACgI,gBAAgB,CAACpF,IAAtB,EACIoF,gBAAgB,CAACpF,IAAjB,GACI,KAAKhH,UAAL,CAAgB8H,cAAhB,CAA+BmD,oBAA/B,CACIxF,KADJ,EAEI2G,gBAAgB,CAACpE,WAFrB,CADJ;IAMJ,MAAMlD,EAAE,GAAG,KAAK0K,yBAAL,CAA+B/J,KAA/B,EAAsC2G,gBAAtC,CAAX;IACA,MAAMrH,IAAI,GAAG,KAAKwK,uBAAL,CAA6B9J,KAA7B,EAAoC2G,gBAApC,CAAb;IACA,MAAM,KAAKpH,cAAL,CAAoBF,EAApB,EAAwBC,IAAxB,CAAN;IACAU,KAAK,CAAC4K,mBAAN,CAA0BjE,gBAA1B;EACH;EAED;;;;;EAG6B,MAAvBkE,uBAAuB,CACzBlM,WADyB,EAEzBmM,iBAFyB,EAEO;IAEhC,KAAK,MAAMnE,gBAAX,IAA+BmE,iBAA/B,EAAkD;MAC9C,MAAM,KAAKH,sBAAL,CAA4BhM,WAA5B,EAAyCgI,gBAAzC,CAAN;IACH;EACJ;EAED;;;;;EAG0B,MAApBoE,oBAAoB,CACtBpM,WADsB,EAEtBqM,YAFsB,EAEY;IAElC,MAAMhL,KAAK,GAAGlG,eAAe,CAACkK,OAAhB,CAAwBrF,WAAxB,IACRA,WADQ,GAER,MAAM,KAAKsE,cAAL,CAAoBtE,WAApB,CAFZ;IAGA,MAAMgI,gBAAgB,GAAG7M,eAAe,CAACmR,aAAhB,CAA8BD,YAA9B,IACnBA,YADmB,GAEnBhL,KAAK,CAACqF,OAAN,CAAcoB,IAAd,CAAoByE,CAAD,IAAOA,CAAC,CAAC3J,IAAF,KAAWyJ,YAArC,CAFN;IAGA,IAAI,CAACrE,gBAAL,EACI,MAAM,IAAI5N,YAAJ,CACF,qDAAqDiH,KAAK,CAACuB,IAAI,EAD7D,CAAN;IAIJ,MAAMlC,EAAE,GAAG,KAAKyK,uBAAL,CAA6B9J,KAA7B,EAAoC2G,gBAApC,CAAX;IACA,MAAMrH,IAAI,GAAG,KAAKyK,yBAAL,CAA+B/J,KAA/B,EAAsC2G,gBAAtC,CAAb;IACA,MAAM,KAAKpH,cAAL,CAAoBF,EAApB,EAAwBC,IAAxB,CAAN;IACAU,KAAK,CAACmL,sBAAN,CAA6BxE,gBAA7B;EACH;EAED;;;;;EAG2B,MAArByE,qBAAqB,CACvBzM,WADuB,EAEvBmM,iBAFuB,EAES;IAEhC,KAAK,MAAMnE,gBAAX,IAA+BmE,iBAA/B,EAAkD;MAC9C,MAAM,KAAKC,oBAAL,CAA0BpM,WAA1B,EAAuCgI,gBAAvC,CAAN;IACH;EACJ;EAED;;;;;EAG2B,MAArB0E,qBAAqB,CACvB1M,WADuB,EAEvB2M,eAFuB,EAEI;IAE3B,MAAMtL,KAAK,GAAGlG,eAAe,CAACkK,OAAhB,CAAwBrF,WAAxB,IACRA,WADQ,GAER,MAAM,KAAKsE,cAAL,CAAoBtE,WAApB,CAFZ,CAF2B,CAM3B;;IACA,IAAI,CAAC2M,eAAe,CAAC/J,IAArB,EACI+J,eAAe,CAAC/J,IAAhB,GACI,KAAKhH,UAAL,CAAgB8H,cAAhB,CAA+BkJ,mBAA/B,CACIvL,KADJ,EAEIsL,eAAe,CAACE,UAFpB,CADJ;IAMJ,MAAMnM,EAAE,GAAG,KAAKuK,wBAAL,CAA8B5J,KAA9B,EAAqCsL,eAArC,CAAX;IACA,MAAMhM,IAAI,GAAG,KAAKqK,sBAAL,CAA4B3J,KAA5B,EAAmCsL,eAAnC,CAAb;IACA,MAAM,KAAK/L,cAAL,CAAoBF,EAApB,EAAwBC,IAAxB,CAAN;IACAU,KAAK,CAACyL,kBAAN,CAAyBH,eAAzB;EACH;EAED;;;;;EAG4B,MAAtBI,sBAAsB,CACxB/M,WADwB,EAExBgN,gBAFwB,EAEM;IAE9B,MAAMC,QAAQ,GAAGD,gBAAgB,CAACnH,GAAjB,CAAsB8G,eAAD,IAClC,KAAKD,qBAAL,CAA2B1M,WAA3B,EAAwC2M,eAAxC,CADa,CAAjB;IAGA,MAAM3Q,OAAO,CAACkR,GAAR,CAAYD,QAAZ,CAAN;EACH;EAED;;;;;EAGyB,MAAnBE,mBAAmB,CACrBnN,WADqB,EAErBoN,WAFqB,EAEW;IAEhC,MAAM/L,KAAK,GAAGlG,eAAe,CAACkK,OAAhB,CAAwBrF,WAAxB,IACRA,WADQ,GAER,MAAM,KAAKsE,cAAL,CAAoBtE,WAApB,CAFZ;IAGA,MAAM2M,eAAe,GAAGxR,eAAe,CAACkS,YAAhB,CAA6BD,WAA7B,IAClBA,WADkB,GAElB/L,KAAK,CAACyJ,MAAN,CAAahD,IAAb,CAAmBY,CAAD,IAAOA,CAAC,CAAC9F,IAAF,KAAWwK,WAApC,CAFN;IAGA,IAAI,CAACT,eAAL,EACI,MAAM,IAAIvS,YAAJ,CACF,oDAAoDiH,KAAK,CAACuB,IAAI,EAD5D,CAAN;IAIJ,MAAMlC,EAAE,GAAG,KAAKsK,sBAAL,CAA4B3J,KAA5B,EAAmCsL,eAAnC,CAAX;IACA,MAAMhM,IAAI,GAAG,KAAKsK,wBAAL,CAA8B5J,KAA9B,EAAqCsL,eAArC,CAAb;IACA,MAAM,KAAK/L,cAAL,CAAoBF,EAApB,EAAwBC,IAAxB,CAAN;IACAU,KAAK,CAACiM,qBAAN,CAA4BX,eAA5B;EACH;EAED;;;;;EAG0B,MAApBY,oBAAoB,CACtBvN,WADsB,EAEtBgN,gBAFsB,EAEQ;IAE9B,MAAMC,QAAQ,GAAGD,gBAAgB,CAACnH,GAAjB,CAAsB8G,eAAD,IAClC,KAAKQ,mBAAL,CAAyBnN,WAAzB,EAAsC2M,eAAtC,CADa,CAAjB;IAGA,MAAM3Q,OAAO,CAACkR,GAAR,CAAYD,QAAZ,CAAN;EACH;EAED;;;;;EAG+B,MAAzBO,yBAAyB,CAC3BxN,WAD2B,EAE3ByN,mBAF2B,EAEQ;IAEnC,MAAMpM,KAAK,GAAGlG,eAAe,CAACkK,OAAhB,CAAwBrF,WAAxB,IACRA,WADQ,GAER,MAAM,KAAKsE,cAAL,CAAoBtE,WAApB,CAFZ,CAFmC,CAMnC;;IACA,IAAI,CAACyN,mBAAmB,CAAC7K,IAAzB,EACI6K,mBAAmB,CAAC7K,IAApB,GACI,KAAKhH,UAAL,CAAgB8H,cAAhB,CAA+BgK,uBAA/B,CACIrM,KADJ,EAEIoM,mBAAmB,CAACZ,UAFxB,CADJ;IAMJ,MAAMnM,EAAE,GAAG,KAAKiN,4BAAL,CAAkCtM,KAAlC,EAAyCoM,mBAAzC,CAAX;IACA,MAAM9M,IAAI,GAAG,KAAKiN,0BAAL,CAAgCvM,KAAhC,EAAuCoM,mBAAvC,CAAb;IACA,MAAM,KAAK7M,cAAL,CAAoBF,EAApB,EAAwBC,IAAxB,CAAN;IACAU,KAAK,CAACwM,sBAAN,CAA6BJ,mBAA7B;EACH;EAED;;;;;EAGgC,MAA1BK,0BAA0B,CAC5B9N,WAD4B,EAE5B+N,oBAF4B,EAEU;IAEtC,MAAMd,QAAQ,GAAGc,oBAAoB,CAAClI,GAArB,CAA0B4H,mBAAD,IACtC,KAAKD,yBAAL,CAA+BxN,WAA/B,EAA4CyN,mBAA5C,CADa,CAAjB;IAGA,MAAMzR,OAAO,CAACkR,GAAR,CAAYD,QAAZ,CAAN;EACH;EAED;;;;;EAG6B,MAAvBe,uBAAuB,CACzBhO,WADyB,EAEzBiO,eAFyB,EAEe;IAExC,MAAM5M,KAAK,GAAGlG,eAAe,CAACkK,OAAhB,CAAwBrF,WAAxB,IACRA,WADQ,GAER,MAAM,KAAKsE,cAAL,CAAoBtE,WAApB,CAFZ;IAGA,MAAMyN,mBAAmB,GAAGtS,eAAe,CAAC+S,gBAAhB,CACxBD,eADwB,IAGtBA,eAHsB,GAItB5M,KAAK,CAAC8M,UAAN,CAAiBrG,IAAjB,CAAuBY,CAAD,IAAOA,CAAC,CAAC9F,IAAF,KAAWqL,eAAxC,CAJN;IAKA,IAAI,CAACR,mBAAL,EACI,MAAM,IAAIrT,YAAJ,CACF,wDAAwDiH,KAAK,CAACuB,IAAI,EADhE,CAAN;IAIJ,MAAMlC,EAAE,GAAG,KAAKkN,0BAAL,CAAgCvM,KAAhC,EAAuCoM,mBAAvC,CAAX;IACA,MAAM9M,IAAI,GAAG,KAAKgN,4BAAL,CACTtM,KADS,EAEToM,mBAFS,CAAb;IAIA,MAAM,KAAK7M,cAAL,CAAoBF,EAApB,EAAwBC,IAAxB,CAAN;IACAU,KAAK,CAAC+M,yBAAN,CAAgCX,mBAAhC;EACH;EAED;;;;;EAG8B,MAAxBY,wBAAwB,CAC1BrO,WAD0B,EAE1B+N,oBAF0B,EAEY;IAEtC,MAAMd,QAAQ,GAAGc,oBAAoB,CAAClI,GAArB,CAA0B4H,mBAAD,IACtC,KAAKO,uBAAL,CAA6BhO,WAA7B,EAA0CyN,mBAA1C,CADa,CAAjB;IAGA,MAAMzR,OAAO,CAACkR,GAAR,CAAYD,QAAZ,CAAN;EACH;EAED;;;;;EAGsB,MAAhBqB,gBAAgB,CAClBtO,WADkB,EAElBuD,UAFkB,EAES;IAE3B,MAAMlC,KAAK,GAAGlG,eAAe,CAACkK,OAAhB,CAAwBrF,WAAxB,IACRA,WADQ,GAER,MAAM,KAAKsE,cAAL,CAAoBtE,WAApB,CAFZ,CAF2B,CAM3B;;IACA,IAAI,CAACuD,UAAU,CAACX,IAAhB,EACIW,UAAU,CAACX,IAAX,GAAkB,KAAKhH,UAAL,CAAgB8H,cAAhB,CAA+BwD,cAA/B,CACd7F,KADc,EAEdkC,UAAU,CAACK,WAFG,EAGd,KAAKS,YAAL,CAAkBd,UAAlB,CAHc,EAIdA,UAAU,CAAC4D,qBAJG,CAAlB;IAOJ,MAAMzG,EAAE,GAAG,KAAK6N,mBAAL,CAAyBlN,KAAzB,EAAgCkC,UAAhC,CAAX;IACA,MAAM5C,IAAI,GAAG,KAAK6C,iBAAL,CAAuBnC,KAAvB,EAA8BkC,UAA9B,CAAb;IACA,MAAM,KAAK3C,cAAL,CAAoBF,EAApB,EAAwBC,IAAxB,CAAN;IACAU,KAAK,CAACmN,aAAN,CAAoBjL,UAApB;EACH;EAED;;;;;EAGuB,MAAjBjC,iBAAiB,CACnBtB,WADmB,EAEnBqD,WAFmB,EAEW;IAE9B,KAAK,MAAME,UAAX,IAAyBF,WAAzB,EAAsC;MAClC,MAAM,KAAKiL,gBAAL,CAAsBtO,WAAtB,EAAmCuD,UAAnC,CAAN;IACH;EACJ;EAED;;;;;EAGoB,MAAdkL,cAAc,CAChBzO,WADgB,EAEhB0O,gBAFgB,EAE0B;IAE1C,MAAMrN,KAAK,GAAGlG,eAAe,CAACkK,OAAhB,CAAwBrF,WAAxB,IACRA,WADQ,GAER,MAAM,KAAKsE,cAAL,CAAoBtE,WAApB,CAFZ;IAGA,MAAMuD,UAAU,GAAGpI,eAAe,CAACwT,iBAAhB,CAAkCD,gBAAlC,IACbA,gBADa,GAEbrN,KAAK,CAACgC,WAAN,CAAkByE,IAAlB,CAAwB8G,EAAD,IAAQA,EAAE,CAAChM,IAAH,KAAY8L,gBAA3C,CAFN;IAGA,IAAI,CAACnL,UAAL,EACI,MAAM,IAAInJ,YAAJ,CACF,+CAA+CiH,KAAK,CAACuB,IAAI,EADvD,CAAN;IAIJ,MAAMlC,EAAE,GAAG,KAAK8C,iBAAL,CAAuBnC,KAAvB,EAA8BkC,UAA9B,CAAX;IACA,MAAM5C,IAAI,GAAG,KAAK4N,mBAAL,CAAyBlN,KAAzB,EAAgCkC,UAAhC,CAAb;IACA,MAAM,KAAK3C,cAAL,CAAoBF,EAApB,EAAwBC,IAAxB,CAAN;IACAU,KAAK,CAACwN,gBAAN,CAAuBtL,UAAvB;EACH;EAED;;;;;EAGqB,MAAfW,eAAe,CACjBlE,WADiB,EAEjBqD,WAFiB,EAEa;IAE9B,KAAK,MAAME,UAAX,IAAyBF,WAAzB,EAAsC;MAClC,MAAM,KAAKoL,cAAL,CAAoBzO,WAApB,EAAiCuD,UAAjC,CAAN;IACH;EACJ;EAED;;;;;EAGiB,MAAXuL,WAAW,CACb9O,WADa,EAEb9C,KAFa,EAEI;IAEjB,MAAMmE,KAAK,GAAGlG,eAAe,CAACkK,OAAhB,CAAwBrF,WAAxB,IACRA,WADQ,GAER,MAAM,KAAKsE,cAAL,CAAoBtE,WAApB,CAFZ,CAFiB,CAMjB;;IACA,IAAI,CAAC9C,KAAK,CAAC0F,IAAX,EAAiB1F,KAAK,CAAC0F,IAAN,GAAa,KAAKmM,iBAAL,CAAuB1N,KAAvB,EAA8BnE,KAA9B,CAAb;IAEjB,MAAMwD,EAAE,GAAG,KAAKoD,cAAL,CAAoBzC,KAApB,EAA2BnE,KAA3B,CAAX;IACA,MAAMyD,IAAI,GAAG,KAAKoD,YAAL,CAAkB1C,KAAlB,EAAyBnE,KAAzB,CAAb;IACA,MAAM,KAAK0D,cAAL,CAAoBF,EAApB,EAAwBC,IAAxB,CAAN;IACAU,KAAK,CAAC2N,QAAN,CAAe9R,KAAf;EACH;EAED;;;;;EAGmB,MAAbqE,aAAa,CACfvB,WADe,EAEfyD,OAFe,EAEM;IAErB,KAAK,MAAMvG,KAAX,IAAoBuG,OAApB,EAA6B;MACzB,MAAM,KAAKqL,WAAL,CAAiB9O,WAAjB,EAA8B9C,KAA9B,CAAN;IACH;EACJ;EAED;;;;;EAGe,MAAT+R,SAAS,CACXjP,WADW,EAEXkP,WAFW,EAEqB;IAEhC,MAAM7N,KAAK,GAAGlG,eAAe,CAACkK,OAAhB,CAAwBrF,WAAxB,IACRA,WADQ,GAER,MAAM,KAAKsE,cAAL,CAAoBtE,WAApB,CAFZ;IAGA,MAAM9C,KAAK,GAAG/B,eAAe,CAACgU,YAAhB,CAA6BD,WAA7B,IACRA,WADQ,GAER7N,KAAK,CAACoC,OAAN,CAAcqE,IAAd,CAAoBsH,CAAD,IAAOA,CAAC,CAACxM,IAAF,KAAWsM,WAArC,CAFN;IAGA,IAAI,CAAChS,KAAL,EACI,MAAM,IAAI9C,YAAJ,CACF,kBAAkB8U,WAAW,2BAA2B7N,KAAK,CAACuB,IAAI,EADhE,CAAN,CAT4B,CAYhC;;IACA,IAAI,CAAC1F,KAAK,CAAC0F,IAAX,EAAiB1F,KAAK,CAAC0F,IAAN,GAAa,KAAKmM,iBAAL,CAAuB1N,KAAvB,EAA8BnE,KAA9B,CAAb;IAEjB,MAAMwD,EAAE,GAAG,KAAKqD,YAAL,CAAkB1C,KAAlB,EAAyBnE,KAAzB,CAAX;IACA,MAAMyD,IAAI,GAAG,KAAKmD,cAAL,CAAoBzC,KAApB,EAA2BnE,KAA3B,CAAb;IACA,MAAM,KAAK0D,cAAL,CAAoBF,EAApB,EAAwBC,IAAxB,CAAN;IACAU,KAAK,CAACgO,WAAN,CAAkBnS,KAAlB;EACH;EAED;;;;;EAGiB,MAAXiH,WAAW,CACbnE,WADa,EAEbyD,OAFa,EAEQ;IAErB,KAAK,MAAMvG,KAAX,IAAoBuG,OAApB,EAA6B;MACzB,MAAM,KAAKwL,SAAL,CAAejP,WAAf,EAA4B9C,KAA5B,CAAN;IACH;EACJ;EAED;;;;;;EAIgB,MAAVoS,UAAU,CAAClP,SAAD,EAAkB;IAC9B,MAAM,KAAK1C,KAAL,CAAW,kBAAkB,KAAKgI,UAAL,CAAgBtF,SAAhB,CAA0B,EAAvD,CAAN;EACH;EAED;;;;;EAGmB,MAAbmP,aAAa;IACf,MAAMC,OAAO,GAAa,EAA1B;IACA,KAAK5T,UAAL,CAAgB6T,eAAhB,CACK5N,MADL,CACa6N,QAAD,IAAcA,QAAQ,CAAC7P,MADnC,EAEKyD,OAFL,CAEcoM,QAAD,IAAa;MAClB,MAAMC,aAAa,GAAG,CAAC,CAACH,OAAO,CAAC1H,IAAR,CACnBjI,MAAD,IAAYA,MAAM,KAAK6P,QAAQ,CAAC7P,MADZ,CAAxB;MAGA,IAAI,CAAC8P,aAAL,EAAoBH,OAAO,CAAChT,IAAR,CAAakT,QAAQ,CAAC7P,MAAtB;IACvB,CAPL;IAQA2P,OAAO,CAAChT,IAAR,CAAa,KAAKd,MAAL,CAAY2C,OAAZ,CAAoBwB,MAApB,IAA8B,kBAA3C;IACA,MAAM+P,iBAAiB,GAAGJ,OAAO,CAC5B3J,GADqB,CAChBjD,IAAD,IAAS;MACV,OAAOA,IAAI,KAAK,kBAAT,GAA8BA,IAA9B,GAAqC,MAAMA,IAAN,GAAa,GAAzD;IACH,CAHqB,EAIrBgF,IAJqB,CAIhB,IAJgB,CAA1B;IAMA,MAAMiI,0BAA0B,GAAG,KAAKtS,mBAAxC;IACA,IAAI,CAACsS,0BAAL,EAAiC,MAAM,KAAKxS,gBAAL,EAAN;;IACjC,IAAI;MACA,MAAMyS,OAAO,GAAG,MAAM,KAAKC,UAAL,EAAtB,CADA,CAEA;;MACA,MAAMC,oBAAoB,GACtB,kGACA,0CAA0CJ,iBAAiB,yGAF/D;MAGA,MAAMK,eAAe,GAAoB,MAAM,KAAKvS,KAAL,CAC3CsS,oBAD2C,CAA/C;MAGA,MAAMhU,OAAO,CAACkR,GAAR,CACF+C,eAAe,CAACpK,GAAhB,CAAqBqK,CAAD,IAAO,KAAKxS,KAAL,CAAWwS,CAAC,CAAC,OAAD,CAAZ,CAA3B,CADE,CAAN,CATA,CAaA;MACA;;MACA,IAAI7U,YAAY,CAAC8U,gBAAb,CAA8BL,OAA9B,EAAuC,KAAvC,CAAJ,EAAmD;QAC/C,MAAMM,uBAAuB,GACzB,kHACA,6CAA6CR,iBAAiB,GAFlE;QAGA,MAAMS,kBAAkB,GAAoB,MAAM,KAAK3S,KAAL,CAC9C0S,uBAD8C,CAAlD;QAGA,MAAMpU,OAAO,CAACkR,GAAR,CACFmD,kBAAkB,CAACxK,GAAnB,CAAwBqK,CAAD,IAAO,KAAKxS,KAAL,CAAWwS,CAAC,CAAC,OAAD,CAAZ,CAA9B,CADE,CAAN;MAGH,CAzBD,CA2BA;MACA;MAEA;;;MACA,MAAMI,qBAAqB,GAAG,0IAA0IV,iBAAiB,8CAAzL;MACA,MAAMW,gBAAgB,GAAoB,MAAM,KAAK7S,KAAL,CAC5C4S,qBAD4C,CAAhD;MAGA,MAAMtU,OAAO,CAACkR,GAAR,CACFqD,gBAAgB,CAAC1K,GAAjB,CAAsBqK,CAAD,IAAO,KAAKxS,KAAL,CAAWwS,CAAC,CAAC,OAAD,CAAZ,CAA5B,CADE,CAAN,CAnCA,CAuCA;;MACA,MAAM,KAAKM,aAAL,CAAmBZ,iBAAnB,CAAN;;MAEA,IAAI,CAACC,0BAAL,EAAiC;QAC7B,MAAM,KAAKlS,iBAAL,EAAN;MACH;IACJ,CA7CD,CA6CE,OAAO8S,KAAP,EAAc;MACZ,IAAI;QACA;QACA,IAAI,CAACZ,0BAAL,EAAiC;UAC7B,MAAM,KAAKjS,mBAAL,EAAN;QACH;MACJ,CALD,CAKE,OAAO8S,aAAP,EAAsB,CAAE;;MAC1B,MAAMD,KAAN;IACH;EACJ,CAl8FsB,CAo8FvB;EACA;EACA;;;EAEyB,MAATE,SAAS,CAACC,SAAD,EAAqB;IAC1C,MAAM7Q,QAAQ,GAAG,MAAM,KAAKA,QAAL,CAAc,KAAK8Q,2BAAL,EAAd,CAAvB;IAEA,IAAI,CAAC9Q,QAAL,EAAe,OAAO,EAAP;;IAEf,IAAI,CAAC6Q,SAAL,EAAgB;MACZA,SAAS,GAAG,EAAZ;IACH;;IAED,MAAME,eAAe,GAAG,MAAM,KAAKnR,kBAAL,EAA9B;IACA,MAAMoR,aAAa,GAAG,MAAM,KAAKjR,gBAAL,EAA5B;IACA,MAAMkR,cAAc,GAChBJ,SAAS,CAAClR,MAAV,KAAqB,CAArB,GACM,KADN,GAEMkR,SAAS,CACJ/K,GADL,CACUzF,SAAD,IAAe,KAAK1E,MAAL,CAAYwE,cAAZ,CAA2BE,SAA3B,CADxB,EAEKyF,GAFL,CAES,SAA0B;MAAA,IAAzB;QAAEhG,MAAF;QAAUO;MAAV,CAAyB;;MAC3B,IAAI,CAACP,MAAL,EAAa;QACTA,MAAM,GACF,KAAKnE,MAAL,CAAY2C,OAAZ,CAAoBwB,MAApB,IAA8BkR,aADlC;MAEH;;MAED,OAAO,oBAAoBlR,MAAM,uBAAuBO,SAAS,IAAjE;IACH,CATL,EAUKwH,IAVL,CAUU,MAVV,CAHV;IAeA,MAAMlK,KAAK,GACP,qBAAqB,KAAKgI,UAAL,CACjB,KAAKmL,2BAAL,EADiB,CAEpB,OAFD,GAGA,uEAHA,GAIA,mGAJA,GAKA,yBAAyBtV,iBAAiB,CAAC0V,IAAI,OAC3C1V,iBAAiB,CAAC2V,iBACtB,MAAMF,cAAc,GAAG,QAAQA,cAAc,GAAzB,GAA+B,EAAE,EARzD;IAUA,MAAMG,OAAO,GAAG,MAAM,KAAKzT,KAAL,CAAWA,KAAX,CAAtB;IACA,OAAOyT,OAAO,CAACtL,GAAR,CAAauL,MAAD,IAAgB;MAC/B,MAAM5M,IAAI,GAAG,IAAIvJ,IAAJ,EAAb;MACA,MAAM4E,MAAM,GACRuR,MAAM,CAAC,QAAD,CAAN,KAAqBL,aAArB,IACA,CAAC,KAAKrV,MAAL,CAAY2C,OAAZ,CAAoBwB,MADrB,GAEM5C,SAFN,GAGMmU,MAAM,CAAC,QAAD,CAJhB;MAKA5M,IAAI,CAAChF,QAAL,GAAgBsR,eAAhB;MACAtM,IAAI,CAAC3E,MAAL,GAAcuR,MAAM,CAAC,QAAD,CAApB;MACA5M,IAAI,CAAC5B,IAAL,GAAY,KAAKlH,MAAL,CAAY2V,cAAZ,CAA2BD,MAAM,CAAC,MAAD,CAAjC,EAA2CvR,MAA3C,CAAZ;MACA2E,IAAI,CAACqI,UAAL,GAAkBuE,MAAM,CAAC,OAAD,CAAxB;MACA5M,IAAI,CAAC8M,YAAL,GACIF,MAAM,CAAC,MAAD,CAAN,KAAmB7V,iBAAiB,CAAC2V,iBADzC;MAEA,OAAO1M,IAAP;IACH,CAdM,CAAP;EAeH;EAED;;;;;EAG0B,MAAV+M,UAAU,CAACC,UAAD,EAAsB;IAC5C;IACA,IAAIA,UAAU,IAAIA,UAAU,CAAC9R,MAAX,KAAsB,CAAxC,EAA2C;MACvC,OAAO,EAAP;IACH;;IAED,MAAMqR,aAAa,GAAG,MAAM,KAAKjR,gBAAL,EAA5B;IACA,MAAMgR,eAAe,GAAG,MAAM,KAAKnR,kBAAL,EAA9B;IAEA,MAAM8R,QAAQ,GAAmD,EAAjE;;IAEA,IAAI,CAACD,UAAL,EAAiB;MACb,MAAME,SAAS,GAAG,wEAAlB;MACAD,QAAQ,CAACjV,IAAT,CAAc,IAAI,MAAM,KAAKkB,KAAL,CAAWgU,SAAX,CAAV,CAAd;IACH,CAHD,MAGO;MACH,MAAMC,eAAe,GAAGH,UAAU,CAC7B3L,GADmB,CACdzF,SAAD,IAAe,KAAK1E,MAAL,CAAYwE,cAAZ,CAA2BE,SAA3B,CADA,EAEnByF,GAFmB,CAEf,SAA0B;QAAA,IAAzB;UAAEhG,MAAF;UAAUO;QAAV,CAAyB;QAC3B,OAAO,sBACHP,MAAM,IAAIkR,aACd,yBAAyB3Q,SAAS,IAFlC;MAGH,CANmB,EAOnBwH,IAPmB,CAOd,MAPc,CAAxB;MASA,MAAM8J,SAAS,GACX,kFACAC,eAFJ;MAGAF,QAAQ,CAACjV,IAAT,CAAc,IAAI,MAAM,KAAKkB,KAAL,CAAWgU,SAAX,CAAV,CAAd;IACH,CA5B2C,CA8B5C;;;IACA,IAAID,QAAQ,CAAC/R,MAAT,KAAoB,CAAxB,EAA2B;MACvB,OAAO,EAAP;IACH;IAED;;;;;;;IAKA,MAAMkS,gBAAgB,GAAGH,QAAQ,CAC5B5L,GADoB,CAChB,SAAiC;MAAA,IAAhC;QAAEgM,YAAF;QAAgBC;MAAhB,CAAgC;MAClC,OAAO,sBAAsBD,YAAY,yBAAyBC,UAAU,IAA5E;IACH,CAHoB,EAIpBlK,IAJoB,CAIf,MAJe,CAAzB;IAKA,MAAMmK,UAAU,GACZ,kLACA,sKADA,GAEA,sCAFA,GAGA,wGAHA,GAIA,gCAJA,GAKA,2DALA,GAMA,qFANA,GAOA,iDAPA,GAQA,gDARA,GASA,IATA,GAUA,QAVA,GAWAH,gBAZJ;IAcA,MAAMI,oBAAoB,GAAGP,QAAQ,CAChC5L,GADwB,CACpB,SAAiC;MAAA,IAAhC;QAAEgM,YAAF;QAAgBC;MAAhB,CAAgC;MAClC,OAAO,sBAAsBD,YAAY,0BAA0BC,UAAU,IAA7E;IACH,CAHwB,EAIxBlK,IAJwB,CAInB,MAJmB,CAA7B;IAMA,MAAMqK,cAAc,GAChB,oHACA,sDADA,GAEA,8KAFA,GAGA,8BAHA,GAIA,6DAJA,GAKA,uEALA,GAMA,8GANA,GAOA,0CAA0CD,oBAAoB,GARlE;IAUA,MAAME,UAAU,GACZ,iJACA,4IADA,GAEA,mCAFA,GAGA,sBAHA,GAIA,4DAJA,GAKA,sGALA,GAMA,oEANA,GAOA,6DAPA,GAQA,iEARA,GASA,uEATA,GAUA,uEAAuEF,oBAAoB,GAX/F;IAaA,MAAMG,oBAAoB,GAAGV,QAAQ,CAChC5L,GADwB,CACpB,SAAiC;MAAA,IAAhC;QAAEgM,YAAF;QAAgBC;MAAhB,CAAgC;MAClC,OAAO,sBAAsBD,YAAY,2BAA2BC,UAAU,IAA9E;IACH,CAHwB,EAIxBlK,IAJwB,CAInB,MAJmB,CAA7B;IAMA,MAAMwK,uBAAuB,GACzB,MAAM,KAAKC,8BAAL,EADV;IAEA,MAAMC,oBAAoB,GAAGF,uBAAuB,GAC9C,kCAD8C,GAE9C,EAFN;IAIA,MAAMG,cAAc,GAChB,yJACA,2KADA,GAEA,+GAFA,GAGA,SAHA,GAIA,gLAJA,GAKA,0CALA,GAMA,0GANA,GAOA,kLAPA,GAQA,iLARA,GASA,uBATA,GAUA,qEAVA,GAWA,sEAXA,GAYA,qCAAqCJ,oBAAoB,IAZzD,GAaA,UAbA,GAcA,6GAdA,GAeA,gEAAgEG,oBAAoB,EAfpF,GAgBA,qEAhBA,GAiBA,+GAlBJ;IAoBA,MAAM,CACFE,SADE,EAEFC,aAFE,EAGFC,SAHE,EAIFC,aAJE,IAKiB,MAAM3W,OAAO,CAACkR,GAAR,CAAY,CACrC,KAAKxP,KAAL,CAAWqU,UAAX,CADqC,EAErC,KAAKrU,KAAL,CAAWuU,cAAX,CAFqC,EAGrC,KAAKvU,KAAL,CAAWwU,UAAX,CAHqC,EAIrC,KAAKxU,KAAL,CAAW6U,cAAX,CAJqC,CAAZ,CAL7B,CAxH4C,CAoI5C;;IACA,OAAOvW,OAAO,CAACkR,GAAR,CACHuE,QAAQ,CAAC5L,GAAT,CAAa,MAAO+M,OAAP,IAAkB;MAC3B,MAAMvR,KAAK,GAAG,IAAI3G,KAAJ,EAAd;;MAEA,MAAMmY,gBAAgB,GAAG,CAACC,QAAD,EAAgBC,GAAhB,KAA+B;QACpD,OAAOD,QAAQ,CAACC,GAAD,CAAR,KAAkBhC,aAAlB,KACF,CAAC,KAAKrV,MAAL,CAAY2C,OAAZ,CAAoBwB,MAArB,IACG,KAAKnE,MAAL,CAAY2C,OAAZ,CAAoBwB,MAApB,KAA+BkR,aAFhC,IAGD9T,SAHC,GAID6V,QAAQ,CAACC,GAAD,CAJd;MAKH,CAND,CAH2B,CAU3B;;;MACA,MAAMlT,MAAM,GAAGgT,gBAAgB,CAACD,OAAD,EAAU,cAAV,CAA/B;MACAvR,KAAK,CAAC7B,QAAN,GAAiBsR,eAAjB;MACAzP,KAAK,CAACxB,MAAN,GAAe+S,OAAO,CAAC,cAAD,CAAtB;MACAvR,KAAK,CAACuB,IAAN,GAAa,KAAKlH,MAAL,CAAY2V,cAAZ,CACTuB,OAAO,CAAC,YAAD,CADE,EAET/S,MAFS,CAAb,CAd2B,CAmB3B;;MACAwB,KAAK,CAACO,OAAN,GAAgB,MAAM5F,OAAO,CAACkR,GAAR,CAClBsF,SAAS,CACJ3Q,MADL,CAESmR,QAAD,IACIA,QAAQ,CAAC,YAAD,CAAR,KACIJ,OAAO,CAAC,YAAD,CADX,IAEAI,QAAQ,CAAC,cAAD,CAAR,KACIJ,OAAO,CAAC,cAAD,CANvB,EAQK/M,GARL,CAQS,MAAOmN,QAAP,IAAmB;QACpB,MAAMC,iBAAiB,GAAGR,aAAa,CAAC5Q,MAAd,CACrBqR,YAAD,IAAiB;UACb,OACIA,YAAY,CAAC,YAAD,CAAZ,KACIF,QAAQ,CAAC,YAAD,CADZ,IAEAE,YAAY,CAAC,cAAD,CAAZ,KACIF,QAAQ,CAAC,cAAD,CAHZ,IAIAE,YAAY,CAAC,aAAD,CAAZ,KACIF,QAAQ,CAAC,aAAD,CANhB;QAQH,CAVqB,CAA1B;QAaA,MAAMpI,WAAW,GAAG,IAAIhQ,WAAJ,EAApB;QACAgQ,WAAW,CAAChI,IAAZ,GAAmBoQ,QAAQ,CAAC,aAAD,CAA3B;QACApI,WAAW,CAAC7I,IAAZ,GAAmBiR,QAAQ,CAAC,SAAD,CAAR,CAAoB1I,WAApB,EAAnB;;QAEA,IACIM,WAAW,CAAC7I,IAAZ,KAAqB,SAArB,IACA6I,WAAW,CAAC7I,IAAZ,KAAqB,SADrB,IAEA6I,WAAW,CAAC7I,IAAZ,KAAqB,OAHzB,EAIE;UACE;UACA;UACA,IACIiR,QAAQ,CAAC,mBAAD,CAAR,KAAkC,IAAlC,IACA,CAAC,KAAKG,wBAAL,CACG9R,KADH,EAEGuJ,WAFH,EAGGoI,QAAQ,CAAC,mBAAD,CAHX,CAFL,EAOE;YACEpI,WAAW,CAACxB,SAAZ,GACI4J,QAAQ,CAAC,mBAAD,CADZ;UAEH,CAVD,MAUO,IACHA,QAAQ,CAAC,eAAD,CAAR,KAA8B,IAA9B,IACA,CAAC,KAAKI,oBAAL,CACG/R,KADH,EAEGuJ,WAFH,EAGGoI,QAAQ,CAAC,eAAD,CAHX,CAFE,EAOL;YACEpI,WAAW,CAACxB,SAAZ,GAAwBnM,SAAxB;UACH;;UACD,IACI+V,QAAQ,CAAC,eAAD,CAAR,KAA8B,IAA9B,IACA,CAAC,KAAKI,oBAAL,CACG/R,KADH,EAEGuJ,WAFH,EAGGoI,QAAQ,CAAC,eAAD,CAHX,CAFL,EAOE;YACEpI,WAAW,CAACvB,KAAZ,GACI2J,QAAQ,CAAC,eAAD,CADZ;UAEH,CAVD,MAUO,IACHA,QAAQ,CAAC,mBAAD,CAAR,KAAkC,IAAlC,IACA,CAAC,KAAKG,wBAAL,CACG9R,KADH,EAEGuJ,WAFH,EAGGoI,QAAQ,CAAC,mBAAD,CAHX,CAFE,EAOL;YACEpI,WAAW,CAACvB,KAAZ,GAAoBpM,SAApB;UACH;QACJ;;QAED,IACI2N,WAAW,CAAC7I,IAAZ,KAAqB,UAArB,IACA6I,WAAW,CAAC7I,IAAZ,KAAqB,wBADrB,IAEA6I,WAAW,CAAC7I,IAAZ,KAAqB,qBAFrB,IAGA6I,WAAW,CAAC7I,IAAZ,KACI,6BAJJ,IAKA6I,WAAW,CAAC7I,IAAZ,KAAqB,0BANzB,EAOE;UACE6I,WAAW,CAACxB,SAAZ,GACI,CAAC,KAAK+J,wBAAL,CACG9R,KADH,EAEGuJ,WAFH,EAGGoI,QAAQ,CAAC,oBAAD,CAHX,CAAD,GAKMA,QAAQ,CAAC,oBAAD,CALd,GAMM/V,SAPV;QAQH,CAnFmB,CAqFpB;QACA;;;QACA,IACI+V,QAAQ,CAAC,WAAD,CAAR,KAA0B,cAA1B,IACAA,QAAQ,CAAC,WAAD,CAAR,KAA0B,OAF9B,EAGE;UACE,MAAM;YAAEpQ;UAAF,IACF,MAAM,KAAK0E,sBAAL,CACFjG,KADE,EAEFuJ,WAFE,CADV,CADF,CAOE;;UACA,MAAMyI,aAAa,GAAG,KAAKjR,aAAL,CAClBf,KADkB,EAElBuJ,WAFkB,EAGlB,KAHkB,EAIlB,IAJkB,CAAtB;UAMA,MAAMzI,QAAQ,GACVkR,aAAa,KAAKzQ,IAAlB,GAAyBA,IAAzB,GAAgC3F,SADpC,CAdF,CAiBE;;UACA,MAAMkD,GAAG,GACL,0DACA,0DADA,GAEA,kEAFA,GAGA,0BACIyS,OAAO,CAAC,cAAD,CACX,0BACIzQ,QAAQ,IAAIS,IAChB,GARJ;UASA,MAAM0Q,OAAO,GACT,MAAM,KAAK5V,KAAL,CAAWyC,GAAX,CADV;;UAGA,IAAImT,OAAO,CAAC5T,MAAZ,EAAoB;YAChBkL,WAAW,CAAC7I,IAAZ,GAAmB,MAAnB;YACA6I,WAAW,CAACpB,IAAZ,GAAmB8J,OAAO,CAACzN,GAAR,CACdpH,MAAD,IAAYA,MAAM,CAAC,OAAD,CADH,CAAnB;YAGAmM,WAAW,CAACzI,QAAZ,GAAuBA,QAAvB;UACH;;UAED,IAAI6Q,QAAQ,CAAC,WAAD,CAAR,KAA0B,OAA9B,EAAuC;YACnCpI,WAAW,CAAC9B,OAAZ,GAAsB,IAAtB;YACA,MAAM/G,IAAI,GAAG6I,WAAW,CAAC7I,IAAZ,CAAiBwR,OAAjB,CACT,IADS,EAET,EAFS,CAAb;YAIA3I,WAAW,CAAC7I,IAAZ,GACI,KAAKnG,UAAL,CAAgBF,MAAhB,CAAuB8X,aAAvB,CAAqC;cACjCzR,IAAI,EAAEA;YAD2B,CAArC,CADJ;UAIH;QACJ;;QAED,IAAI6I,WAAW,CAAC7I,IAAZ,KAAqB,UAAzB,EAAqC;UACjC,MAAM0R,iBAAiB,GAAG;;;;;;;;;;6CAUbT,QAAQ,CAAC,aAAD,CAAe;8CACtBA,QAAQ,CAAC,cAAD,CAAgB;4CAC1BA,QAAQ,CAAC,YAAD,CAAc,GAZlC;UAcA,MAAMM,OAAO,GACT,MAAM,KAAK5V,KAAL,CAAW+V,iBAAX,CADV;;UAGA,IAAIH,OAAO,CAAC5T,MAAR,GAAiB,CAArB,EAAwB;YACpBkL,WAAW,CAACP,kBAAZ,GACIiJ,OAAO,CAAC,CAAD,CAAP,CAAWvR,IADf;YAEA6I,WAAW,CAACL,IAAZ,GAAmB+I,OAAO,CAAC,CAAD,CAAP,CAAW/I,IAA9B;UACH;QACJ;;QAED,IAAIK,WAAW,CAAC7I,IAAZ,KAAqB,WAAzB,EAAsC;UAClC,MAAM2R,kBAAkB,GAAG;;;;;;;;;;6CAUdV,QAAQ,CAAC,aAAD,CAAe;8CACtBA,QAAQ,CAAC,cAAD,CAAgB;4CAC1BA,QAAQ,CAAC,YAAD,CAAc,GAZlC;UAcA,MAAMM,OAAO,GACT,MAAM,KAAK5V,KAAL,CAAWgW,kBAAX,CADV;;UAGA,IAAIJ,OAAO,CAAC5T,MAAR,GAAiB,CAArB,EAAwB;YACpBkL,WAAW,CAACP,kBAAZ,GACIiJ,OAAO,CAAC,CAAD,CAAP,CAAWvR,IADf;YAEA6I,WAAW,CAACL,IAAZ,GAAmB+I,OAAO,CAAC,CAAD,CAAP,CAAW/I,IAA9B;UACH;QACJ,CA7LmB,CA+LpB;;;QACA,IACI,KAAK7O,MAAL,CAAYiY,qBAAZ,CAAkCxW,OAAlC,CACIyN,WAAW,CAAC7I,IADhB,MAEM,CAAC,CAHX,EAIE;UACE,IAAIrC,MAAJ;;UACA,IAAIkL,WAAW,CAAC9B,OAAhB,EAAyB;YACrB,MAAM8K,KAAK,GAAG,YAAYC,IAAZ,CACVb,QAAQ,CAAC,aAAD,CADE,CAAd;YAGAtT,MAAM,GAAGkU,KAAK,GAAGA,KAAK,CAAC,CAAD,CAAR,GAAc3W,SAA5B;UACH,CALD,MAKO,IACH+V,QAAQ,CAAC,0BAAD,CADL,EAEL;YACEtT,MAAM,GACFsT,QAAQ,CACJ,0BADI,CAAR,CAEEc,QAFF,EADJ;UAIH;;UACD,IAAIpU,MAAJ,EAAY;YACRkL,WAAW,CAAClL,MAAZ,GACI,CAAC,KAAKqU,qBAAL,CACG1S,KADH,EAEGuJ,WAFH,EAGGlL,MAHH,CAAD,GAKMA,MALN,GAMM,EAPV;UAQH;QACJ;;QACDkL,WAAW,CAACV,UAAZ,GACI8I,QAAQ,CAAC,aAAD,CAAR,KAA4B,KADhC;QAGA,MAAMgB,iBAAiB,GAAGf,iBAAiB,CAACnL,IAAlB,CACrBmM,UAAD,IACIA,UAAU,CAAC,iBAAD,CAAV,KAAkC,SAFhB,CAA1B;;QAIA,IAAID,iBAAJ,EAAuB;UACnBpJ,WAAW,CAAClD,SAAZ,GAAwB,IAAxB,CADmB,CAEnB;;UACA,MAAMwM,yBAAyB,GAC3BzB,aAAa,CAAC5Q,MAAd,CACKoS,UAAD,IACIA,UAAU,CAAC,YAAD,CAAV,KACIjB,QAAQ,CAAC,YAAD,CADZ,IAEAiB,UAAU,CAAC,cAAD,CAAV,KACIjB,QAAQ,CAAC,cAAD,CAHZ,IAIAiB,UAAU,CAAC,aAAD,CAAV,KACIjB,QAAQ,CAAC,aAAD,CALZ,IAMAiB,UAAU,CAAC,iBAAD,CAAV,KACI,SATZ,CADJ,CAHmB,CAgBnB;;UACA,MAAMrQ,WAAW,GACbsQ,yBAAyB,CAACrO,GAA1B,CACKoO,UAAD,IACIA,UAAU,CAAC,aAAD,CAFlB,CADJ;UAKArQ,WAAW,CAACpH,IAAZ,CAAiBwW,QAAQ,CAAC,aAAD,CAAzB,EAtBmB,CAwBnB;;UACA,MAAMrL,MAAM,GACR,KAAK/L,UAAL,CAAgB8H,cAAhB,CAA+BqC,cAA/B,CACI1E,KADJ,EAEIuC,WAFJ,CADJ,CAzBmB,CA+BnB;;UACA,IACIoQ,iBAAiB,CAAC,iBAAD,CAAjB,KACArM,MAFJ,EAGE;YACEiD,WAAW,CAAChF,wBAAZ,GACIoO,iBAAiB,CAAC,iBAAD,CADrB;UAEH;QACJ;;QAED,MAAM7H,iBAAiB,GAAG8G,iBAAiB,CAACpR,MAAlB,CACrBoS,UAAD,IACIA,UAAU,CAAC,iBAAD,CAAV,KAAkC,QAFhB,CAA1B;QAIA,MAAME,qBAAqB,GACvBhI,iBAAiB,CAACiI,KAAlB,CAAyBpM,gBAAD,IAAqB;UACzC,OAAOyK,aAAa,CAAC4B,IAAd,CACFnB,YAAD,IACIA,YAAY,CAAC,iBAAD,CAAZ,KACI,QADJ,IAEAA,YAAY,CAAC,iBAAD,CAAZ,KACIlL,gBAAgB,CACZ,iBADY,CAHpB,IAMAkL,YAAY,CAAC,aAAD,CAAZ,KACIF,QAAQ,CAAC,aAAD,CATb,CAAP;QAWH,CAZD,CADJ;QAcApI,WAAW,CAAC7C,QAAZ,GACIoE,iBAAiB,CAACzM,MAAlB,GAA2B,CAA3B,IACA,CAACyU,qBAFL;;QAIA,IAAInB,QAAQ,CAACsB,WAAT,KAAyB,KAA7B,EAAoC;UAChC;UACA1J,WAAW,CAAC1E,WAAZ,GAA0B,IAA1B;UACA0E,WAAW,CAACzE,kBAAZ,GAAiC,UAAjC;UACAyE,WAAW,CAAC2J,iBAAZ,GACIvB,QAAQ,CAACwB,mBADb;QAEH,CAND,MAMO,IACHxB,QAAQ,CAAC,gBAAD,CAAR,KAA+B,IAA/B,IACAA,QAAQ,CAAC,gBAAD,CAAR,KAA+B/V,SAF5B,EAGL;UACE,MAAMwX,iBAAiB,GAAG,YAAY,KAAKlO,iBAAL,CAClClF,KADkC,EAElC2R,QAAQ,CAAC,aAAD,CAF0B,CAGrC,cAHD;UAIA,MAAM0B,iBAAiB,GAAG,YAAY,KAAKrO,iBAAL,CAClChF,KADkC,EAElC2R,QAAQ,CAAC,aAAD,CAF0B,CAGrC,cAHD;UAKA,MAAM2B,oBAAoB,GAAG3B,QAAQ,CACjC,gBADiC,CAAR,CAE3BO,OAF2B,CAEnB,IAFmB,EAEb,EAFa,CAA7B;;UAIA,IACIoB,oBAAoB,KAChBF,iBADJ,IAEAE,oBAAoB,KAAKD,iBAH7B,EAIE;YACE9J,WAAW,CAAC1E,WAAZ,GAA0B,IAA1B;YACA0E,WAAW,CAACzE,kBAAZ,GAAiC,WAAjC;UACH,CAPD,MAOO,IACH6M,QAAQ,CAAC,gBAAD,CAAR,KACI,mBADJ,IAEA,yBAAyB4B,IAAzB,CACI5B,QAAQ,CAAC,gBAAD,CADZ,CAHG,EAML;YACE,IAAIpI,WAAW,CAAC7I,IAAZ,KAAqB,MAAzB,EAAiC;cAC7B6I,WAAW,CAAC1E,WAAZ,GAA0B,IAA1B;cACA0E,WAAW,CAACzE,kBAAZ,GAAiC,MAAjC;YACH,CAHD,MAGO;cACHyE,WAAW,CAACb,OAAZ,GACIiJ,QAAQ,CAAC,gBAAD,CADZ;YAEH;UACJ,CAdM,MAcA,IACHA,QAAQ,CAAC,gBAAD,CAAR,KAA+B,OAA/B,IACAA,QAAQ,CAAC,gBAAD,CAAR,CAA2B7V,OAA3B,CACI,aADJ,MAEM,CAAC,CAJJ,EAKL;YACEyN,WAAW,CAACb,OAAZ,GACIiJ,QAAQ,CAAC,gBAAD,CADZ;UAEH,CARM,MAQA;YACHpI,WAAW,CAACb,OAAZ,GAAsBiJ,QAAQ,CAC1B,gBAD0B,CAAR,CAEpBO,OAFoB,CAEZ,oBAFY,EAEU,EAFV,CAAtB;YAGA3I,WAAW,CAACb,OAAZ,GACIa,WAAW,CAACb,OAAZ,CAAoBwJ,OAApB,CACI,WADJ,EAEI,MAFJ,CADJ;UAKH;QACJ;;QAED,IACIP,QAAQ,CAAC,cAAD,CAAR,KAA6B,QAA7B,IACAA,QAAQ,CAAC,uBAAD,CAFZ,EAGE;UACE;UACApI,WAAW,CAACpI,aAAZ,GAA4B,QAA5B,CAFF,CAGE;;UACA,MAAMqS,iBAAiB,GACnB,MAAM,KAAKC,wBAAL,CAA8B;YAChCtV,QAAQ,EAAEsR,eADsB;YAEhCjR,MAAM,EAAE+S,OAAO,CAAC,cAAD,CAFiB;YAGhCvR,KAAK,EAAEuR,OAAO,CAAC,YAAD,CAHkB;YAIhC7Q,IAAI,EAAExG,iBAAiB,CAACwH,gBAJQ;YAKhCH,IAAI,EAAEgI,WAAW,CAAChI;UALc,CAA9B,CADV;UASA,MAAM0Q,OAAO,GAAG,MAAM,KAAK5V,KAAL,CAClBmX,iBAAiB,CAACnX,KADA,EAElBmX,iBAAiB,CAAChX,UAFA,CAAtB;;UAIA,IAAIyV,OAAO,CAAC,CAAD,CAAP,IAAcA,OAAO,CAAC,CAAD,CAAP,CAAWtQ,KAA7B,EAAoC;YAChC4H,WAAW,CAACnI,YAAZ,GAA2B6Q,OAAO,CAAC,CAAD,CAAP,CAAWtQ,KAAtC;UACH,CAFD,MAEO;YACH4H,WAAW,CAACnI,YAAZ,GAA2B,EAA3B;UACH;QACJ;;QAEDmI,WAAW,CAAC3C,OAAZ,GAAsB+K,QAAQ,CAAC,aAAD,CAAR,GAChBA,QAAQ,CAAC,aAAD,CADQ,GAEhB/V,SAFN;QAGA,IAAI+V,QAAQ,CAAC,oBAAD,CAAZ,EACIpI,WAAW,CAACmK,OAAZ,GACI/B,QAAQ,CAAC,oBAAD,CADZ;QAEJ,IAAIA,QAAQ,CAAC,gBAAD,CAAZ,EACIpI,WAAW,CAACoK,SAAZ,GACIhC,QAAQ,CAAC,gBAAD,CADZ;QAEJ,OAAOpI,WAAP;MACH,CAjZL,CADkB,CAAtB,CApB2B,CAya3B;;MACA,MAAMqK,sBAAsB,GAAG7Z,QAAQ,CAAC8Z,IAAT,CAC3BzC,aAAa,CAAC5Q,MAAd,CAAsBqR,YAAD,IAAiB;QAClC,OACIA,YAAY,CAAC,YAAD,CAAZ,KACIN,OAAO,CAAC,YAAD,CADX,IAEAM,YAAY,CAAC,cAAD,CAAZ,KACIN,OAAO,CAAC,cAAD,CAHX,IAIAM,YAAY,CAAC,iBAAD,CAAZ,KAAoC,QALxC;MAOH,CARD,CAD2B,EAU1BA,YAAD,IAAkBA,YAAY,CAAC,iBAAD,CAVH,CAA/B;MAaA7R,KAAK,CAACqF,OAAN,GAAgBuO,sBAAsB,CAACpP,GAAvB,CAA4BoO,UAAD,IAAe;QACtD,MAAMvN,OAAO,GAAG+L,aAAa,CAAC5Q,MAAd,CACXsT,GAAD,IACIA,GAAG,CAAC,iBAAD,CAAH,KACAlB,UAAU,CAAC,iBAAD,CAHF,CAAhB;QAKA,OAAO,IAAIjZ,WAAJ,CAAgB;UACnB4H,IAAI,EAAEqR,UAAU,CAAC,iBAAD,CADG;UAEnBrQ,WAAW,EAAE8C,OAAO,CAACb,GAAR,CAAa0G,CAAD,IAAOA,CAAC,CAAC,aAAD,CAApB,CAFM;UAGnB6I,UAAU,EAAEnB,UAAU,CAAC,YAAD,CAAV,GACNA,UAAU,CAAC,UAAD,CADJ,GAENhX;QALa,CAAhB,CAAP;MAOH,CAbe,CAAhB,CAvb2B,CAsc3B;;MACA,MAAMoY,qBAAqB,GAAGja,QAAQ,CAAC8Z,IAAT,CAC1BzC,aAAa,CAAC5Q,MAAd,CAAsBqR,YAAD,IAAiB;QAClC,OACIA,YAAY,CAAC,YAAD,CAAZ,KACIN,OAAO,CAAC,YAAD,CADX,IAEAM,YAAY,CAAC,cAAD,CAAZ,KACIN,OAAO,CAAC,cAAD,CAHX,IAIAM,YAAY,CAAC,iBAAD,CAAZ,KAAoC,OALxC;MAOH,CARD,CAD0B,EAUzBA,YAAD,IAAkBA,YAAY,CAAC,iBAAD,CAVJ,CAA9B;MAaA7R,KAAK,CAACyJ,MAAN,GAAeuK,qBAAqB,CAACxP,GAAtB,CAA2BoO,UAAD,IAAe;QACpD,MAAMnJ,MAAM,GAAG2H,aAAa,CAAC5Q,MAAd,CACVsT,GAAD,IACIA,GAAG,CAAC,iBAAD,CAAH,KACAlB,UAAU,CAAC,iBAAD,CAHH,CAAf;QAKA,OAAO,IAAItZ,UAAJ,CAAe;UAClBiI,IAAI,EAAEqR,UAAU,CAAC,iBAAD,CADE;UAElBrQ,WAAW,EAAEkH,MAAM,CAACjF,GAAP,CAAY6C,CAAD,IAAOA,CAAC,CAAC,aAAD,CAAnB,CAFK;UAGlBmE,UAAU,EAAEoH,UAAU,CAAC,YAAD,CAAV,CAAyBV,OAAzB,CACR,2BADQ,EAER,IAFQ;QAHM,CAAf,CAAP;MAQH,CAdc,CAAf,CApd2B,CAoe3B;;MACA,MAAM+B,yBAAyB,GAAGla,QAAQ,CAAC8Z,IAAT,CAC9BzC,aAAa,CAAC5Q,MAAd,CAAsBqR,YAAD,IAAiB;QAClC,OACIA,YAAY,CAAC,YAAD,CAAZ,KACIN,OAAO,CAAC,YAAD,CADX,IAEAM,YAAY,CAAC,cAAD,CAAZ,KACIN,OAAO,CAAC,cAAD,CAHX,IAIAM,YAAY,CAAC,iBAAD,CAAZ,KAAoC,SALxC;MAOH,CARD,CAD8B,EAU7BA,YAAD,IAAkBA,YAAY,CAAC,iBAAD,CAVA,CAAlC;MAaA7R,KAAK,CAAC8M,UAAN,GAAmBmH,yBAAyB,CAACzP,GAA1B,CACdoO,UAAD,IAAe;QACX,OAAO,IAAIpZ,cAAJ,CAAmB;UACtB+H,IAAI,EAAEqR,UAAU,CAAC,iBAAD,CADM;UAEtBpH,UAAU,EAAEoH,UAAU,CAAC,YAAD,CAAV,CAAyBsB,SAAzB,CAAmC,CAAnC,CAFU,CAE6B;;QAF7B,CAAnB,CAAP;MAIH,CANc,CAAnB,CAlf2B,CA2f3B;;MACA,MAAMC,0BAA0B,GAAGpa,QAAQ,CAAC8Z,IAAT,CAC/BvC,aAAa,CAAC9Q,MAAd,CAAsB4T,YAAD,IAAiB;QAClC,OACIA,YAAY,CAAC,YAAD,CAAZ,KACI7C,OAAO,CAAC,YAAD,CADX,IAEA6C,YAAY,CAAC,cAAD,CAAZ,KACI7C,OAAO,CAAC,cAAD,CAJf;MAMH,CAPD,CAD+B,EAS9B6C,YAAD,IAAkBA,YAAY,CAAC,iBAAD,CATC,CAAnC;MAYApU,KAAK,CAACgC,WAAN,GAAoBmS,0BAA0B,CAAC3P,GAA3B,CACf4P,YAAD,IAAiB;QACb,MAAMpS,WAAW,GAAGsP,aAAa,CAAC9Q,MAAd,CACf6T,IAAD,IACIA,IAAI,CAAC,iBAAD,CAAJ,KACAD,YAAY,CAAC,iBAAD,CAHA,CAApB,CADa,CAOb;;QACA,MAAM5V,MAAM,GAAGgT,gBAAgB,CAC3B4C,YAD2B,EAE3B,yBAF2B,CAA/B;QAIA,MAAME,mBAAmB,GAAG,KAAKja,MAAL,CAAY2V,cAAZ,CACxBoE,YAAY,CAAC,uBAAD,CADY,EAExB5V,MAFwB,CAA5B;QAKA,OAAO,IAAI/E,eAAJ,CAAoB;UACvB8H,IAAI,EAAE6S,YAAY,CAAC,iBAAD,CADK;UAEvB7R,WAAW,EAAEP,WAAW,CAACwC,GAAZ,CACR6P,IAAD,IAAUA,IAAI,CAAC,aAAD,CADL,CAFU;UAKvBE,gBAAgB,EACZH,YAAY,CAAC,yBAAD,CANO;UAOvBE,mBAAmB,EAAEA,mBAPE;UAQvBxO,qBAAqB,EAAE9D,WAAW,CAACwC,GAAZ,CAClB6P,IAAD,IAAUA,IAAI,CAAC,wBAAD,CADK,CARA;UAWvBG,QAAQ,EAAEJ,YAAY,CAAC,WAAD,CAXC;UAYvBK,QAAQ,EAAEL,YAAY,CAAC,WAAD,CAZC;UAavBL,UAAU,EAAEK,YAAY,CAAC,YAAD,CAAZ,GACNA,YAAY,CAAC,UAAD,CADN,GAENxY;QAfiB,CAApB,CAAP;MAiBH,CAnCe,CAApB,CAxgB2B,CA8iB3B;;MACA,MAAM8Y,qBAAqB,GAAG3a,QAAQ,CAAC8Z,IAAT,CAC1BxC,SAAS,CAAC7Q,MAAV,CAAkBmU,OAAD,IAAY;QACzB,OACIA,OAAO,CAAC,YAAD,CAAP,KAA0BpD,OAAO,CAAC,YAAD,CAAjC,IACAoD,OAAO,CAAC,cAAD,CAAP,KAA4BpD,OAAO,CAAC,cAAD,CAFvC;MAIH,CALD,CAD0B,EAOzBoD,OAAD,IAAaA,OAAO,CAAC,iBAAD,CAPM,CAA9B;MAUA3U,KAAK,CAACoC,OAAN,GAAgBsS,qBAAqB,CAAClQ,GAAtB,CAA2BoO,UAAD,IAAe;QACrD,MAAMxQ,OAAO,GAAGiP,SAAS,CAAC7Q,MAAV,CAAkB3E,KAAD,IAAU;UACvC,OACIA,KAAK,CAAC,cAAD,CAAL,KACI+W,UAAU,CAAC,cAAD,CADd,IAEA/W,KAAK,CAAC,YAAD,CAAL,KAAwB+W,UAAU,CAAC,YAAD,CAFlC,IAGA/W,KAAK,CAAC,iBAAD,CAAL,KACI+W,UAAU,CAAC,iBAAD,CALlB;QAOH,CARe,CAAhB;QASA,OAAO,IAAIlZ,UAAJ,CAAkC;UACrCsG,KAAK,EAAEA,KAD8B;UAErCuB,IAAI,EAAEqR,UAAU,CAAC,iBAAD,CAFqB;UAGrCrQ,WAAW,EAAEH,OAAO,CAACoC,GAAR,CAAauJ,CAAD,IAAOA,CAAC,CAAC,aAAD,CAApB,CAHwB;UAIrCrH,QAAQ,EAAEkM,UAAU,CAAC,WAAD,CAAV,KAA4B,MAJD;UAKrCpQ,KAAK,EAAEoQ,UAAU,CAAC,WAAD,CALoB;UAMrCgC,SAAS,EAAExS,OAAO,CAAC2Q,KAAR,CACNhF,CAAD,IACI,KAAK1T,MAAL,CAAYwa,YAAZ,CAAyB/Y,OAAzB,CACIiS,CAAC,CAAC,WAAD,CADL,KAEK,CAJF,CAN0B;UAYrC+G,UAAU,EAAE;QAZyB,CAAlC,CAAP;MAcH,CAxBe,CAAhB;MA0BA,OAAO9U,KAAP;IACH,CAplBD,CADG,CAAP;EAulBH;EAED;;;;;EAGU8B,cAAc,CAAC9B,KAAD,EAAeC,iBAAf,EAA0C;IAC9D,MAAM8U,iBAAiB,GAAG/U,KAAK,CAACO,OAAN,CACrBiE,GADqB,CAChB/D,MAAD,IAAY,KAAK2F,oBAAL,CAA0BpG,KAA1B,EAAiCS,MAAjC,CADK,EAErB8F,IAFqB,CAEhB,IAFgB,CAA1B;IAGA,IAAIzH,GAAG,GAAG,gBAAgB,KAAKuF,UAAL,CAAgBrE,KAAhB,CAAsB,KAAK+U,iBAAiB,EAAtE;IAEA/U,KAAK,CAACO,OAAN,CACKC,MADL,CACaC,MAAD,IAAYA,MAAM,CAACiG,QAD/B,EAEKzE,OAFL,CAEcxB,MAAD,IAAW;MAChB,MAAMuU,aAAa,GAAGhV,KAAK,CAACqF,OAAN,CAAc2N,IAAd,CACjB1N,MAAD,IACIA,MAAM,CAAC/C,WAAP,CAAmBlE,MAAnB,KAA8B,CAA9B,IACAiH,MAAM,CAAC/C,WAAP,CAAmB,CAAnB,MAA0B9B,MAAM,CAACc,IAHnB,CAAtB;MAKA,IAAI,CAACyT,aAAL,EACIhV,KAAK,CAACqF,OAAN,CAAclK,IAAd,CACI,IAAIxB,WAAJ,CAAgB;QACZ4H,IAAI,EAAE,KAAKhH,UAAL,CAAgB8H,cAAhB,CAA+BmD,oBAA/B,CACFxF,KADE,EAEF,CAACS,MAAM,CAACc,IAAR,CAFE,CADM;QAKZgB,WAAW,EAAE,CAAC9B,MAAM,CAACc,IAAR;MALD,CAAhB,CADJ;IASP,CAlBL;;IAoBA,IAAIvB,KAAK,CAACqF,OAAN,CAAchH,MAAd,GAAuB,CAA3B,EAA8B;MAC1B,MAAM4W,UAAU,GAAGjV,KAAK,CAACqF,OAAN,CACdb,GADc,CACTc,MAAD,IAAW;QACZ,MAAM4P,UAAU,GAAG5P,MAAM,CAAC/D,IAAP,GACb+D,MAAM,CAAC/D,IADM,GAEb,KAAKhH,UAAL,CAAgB8H,cAAhB,CAA+BmD,oBAA/B,CACIxF,KADJ,EAEIsF,MAAM,CAAC/C,WAFX,CAFN;QAMA,MAAMA,WAAW,GAAG+C,MAAM,CAAC/C,WAAP,CACfiC,GADe,CACVvF,UAAD,IAAgB,IAAIA,UAAU,GADnB,EAEfsH,IAFe,CAEV,IAFU,CAApB;QAGA,IAAIqM,UAAU,GAAG,eAAesC,UAAU,aAAa3S,WAAW,GAAlE;QACA,IAAI+C,MAAM,CAACyO,UAAX,EACInB,UAAU,IAAI,eAAetN,MAAM,CAACyO,UAAU,EAA9C;QACJ,OAAOnB,UAAP;MACH,CAfc,EAgBdrM,IAhBc,CAgBT,IAhBS,CAAnB;MAkBAzH,GAAG,IAAI,KAAKmW,UAAU,EAAtB;IACH;;IAED,IAAIjV,KAAK,CAACyJ,MAAN,CAAapL,MAAb,GAAsB,CAA1B,EAA6B;MACzB,MAAM8W,SAAS,GAAGnV,KAAK,CAACyJ,MAAN,CACbjF,GADa,CACRkF,KAAD,IAAU;QACX,MAAM0L,SAAS,GAAG1L,KAAK,CAACnI,IAAN,GACZmI,KAAK,CAACnI,IADM,GAEZ,KAAKhH,UAAL,CAAgB8H,cAAhB,CAA+BkJ,mBAA/B,CACIvL,KADJ,EAEI0J,KAAK,CAAC8B,UAFV,CAFN;QAMA,OAAO,eAAe4J,SAAS,YAAY1L,KAAK,CAAC8B,UAAU,GAA3D;MACH,CATa,EAUbjF,IAVa,CAUR,IAVQ,CAAlB;MAYAzH,GAAG,IAAI,KAAKqW,SAAS,EAArB;IACH;;IAED,IAAInV,KAAK,CAAC8M,UAAN,CAAiBzO,MAAjB,GAA0B,CAA9B,EAAiC;MAC7B,MAAMgX,aAAa,GAAGrV,KAAK,CAAC8M,UAAN,CACjBtI,GADiB,CACZ8Q,SAAD,IAAc;QACf,MAAMC,aAAa,GAAGD,SAAS,CAAC/T,IAAV,GAChB+T,SAAS,CAAC/T,IADM,GAEhB,KAAKhH,UAAL,CAAgB8H,cAAhB,CAA+BgK,uBAA/B,CACIrM,KADJ,EAEIsV,SAAS,CAAC9J,UAFd,CAFN;QAMA,OAAO,eAAe+J,aAAa,aAAaD,SAAS,CAAC9J,UAAU,EAApE;MACH,CATiB,EAUjBjF,IAViB,CAUZ,IAVY,CAAtB;MAYAzH,GAAG,IAAI,KAAKuW,aAAa,EAAzB;IACH;;IAED,IAAIrV,KAAK,CAACgC,WAAN,CAAkB3D,MAAlB,GAA2B,CAA3B,IAAgC4B,iBAApC,EAAuD;MACnD,MAAMiR,cAAc,GAAGlR,KAAK,CAACgC,WAAN,CAClBwC,GADkB,CACb+I,EAAD,IAAO;QACR,MAAMhL,WAAW,GAAGgL,EAAE,CAAChL,WAAH,CACfiC,GADe,CACVvF,UAAD,IAAgB,IAAIA,UAAU,GADnB,EAEfsH,IAFe,CAEV,IAFU,CAApB;QAGA,IAAI,CAACgH,EAAE,CAAChM,IAAR,EACIgM,EAAE,CAAChM,IAAH,GAAU,KAAKhH,UAAL,CAAgB8H,cAAhB,CAA+BwD,cAA/B,CACN7F,KADM,EAENuN,EAAE,CAAChL,WAFG,EAGN,KAAKS,YAAL,CAAkBuK,EAAlB,CAHM,EAINA,EAAE,CAACzH,qBAJG,CAAV;QAOJ,MAAMA,qBAAqB,GAAGyH,EAAE,CAACzH,qBAAH,CACzBtB,GADyB,CACpBvF,UAAD,IAAgB,IAAIA,UAAU,GADT,EAEzBsH,IAFyB,CAEpB,IAFoB,CAA9B;QAIA,IAAIqM,UAAU,GAAG,eACbrF,EAAE,CAAChM,IACP,kBAAkBgB,WAAW,gBAAgB,KAAK8B,UAAL,CACzC,KAAKrB,YAAL,CAAkBuK,EAAlB,CADyC,CAE5C,KAAKzH,qBAAqB,GAJ3B;QAKA,IAAIyH,EAAE,CAACiH,QAAP,EAAiB5B,UAAU,IAAI,cAAcrF,EAAE,CAACiH,QAAQ,EAAvC;QACjB,IAAIjH,EAAE,CAACkH,QAAP,EAAiB7B,UAAU,IAAI,cAAcrF,EAAE,CAACkH,QAAQ,EAAvC;QACjB,IAAIlH,EAAE,CAACwG,UAAP,EACInB,UAAU,IAAI,eAAerF,EAAE,CAACwG,UAAU,EAA1C;QAEJ,OAAOnB,UAAP;MACH,CA5BkB,EA6BlBrM,IA7BkB,CA6Bb,IA7Ba,CAAvB;MA+BAzH,GAAG,IAAI,KAAKoS,cAAc,EAA1B;IACH;;IAED,MAAM5M,cAAc,GAAGtE,KAAK,CAACO,OAAN,CAAcC,MAAd,CAClBC,MAAD,IAAYA,MAAM,CAAC4F,SADA,CAAvB;;IAGA,IAAI/B,cAAc,CAACjG,MAAf,GAAwB,CAA5B,EAA+B;MAC3B,MAAMqG,cAAc,GAAGJ,cAAc,CAAC,CAAD,CAAd,CAAkBC,wBAAlB,GACjBD,cAAc,CAAC,CAAD,CAAd,CAAkBC,wBADD,GAEjB,KAAKhK,UAAL,CAAgB8H,cAAhB,CAA+BqC,cAA/B,CACI1E,KADJ,EAEIsE,cAAc,CAACE,GAAf,CAAoB/D,MAAD,IAAYA,MAAM,CAACc,IAAtC,CAFJ,CAFN;MAOA,MAAMgB,WAAW,GAAG+B,cAAc,CAC7BE,GADe,CACV/D,MAAD,IAAY,IAAIA,MAAM,CAACc,IAAI,GADhB,EAEfgF,IAFe,CAEV,IAFU,CAApB;MAGAzH,GAAG,IAAI,iBAAiB4F,cAAc,kBAAkBnC,WAAW,GAAnE;IACH;;IAEDzD,GAAG,IAAI,GAAP;IAEAkB,KAAK,CAACO,OAAN,CACKC,MADL,CACagV,EAAD,IAAQA,EAAE,CAAC5O,OADvB,EAEK3E,OAFL,CAGSuT,EAAD,IACK1W,GAAG,IAAI,uBAAuB,KAAKuF,UAAL,CAAgBrE,KAAhB,CAAsB,KACjDwV,EAAE,CAACjU,IACP,QAAQ,KAAKsF,aAAL,CAAmB2O,EAAE,CAAC5O,OAAtB,CAA8B,EANlD;IASA,OAAO,IAAI3M,KAAJ,CAAU6E,GAAV,CAAP;EACH;EAED;;;;;EAG0B,MAAV4P,UAAU;IACtB,MAAMtR,MAAM,GAAG,MAAM,KAAKf,KAAL,CAAW,kBAAX,CAArB;IACA,OAAOe,MAAM,CAAC,CAAD,CAAN,CAAU,SAAV,EAAqB8U,OAArB,CAA6B,2BAA7B,EAA0D,IAA1D,CAAP;EACH;EAED;;;;;EAGUnQ,YAAY,CAAC0T,WAAD,EAA4B;IAC9C,OAAO,IAAIxb,KAAJ,CAAU,cAAc,KAAKoK,UAAL,CAAgBoR,WAAhB,CAA4B,EAApD,CAAP;EACH;;EAESrS,aAAa,CAACD,IAAD,EAAW;IAC9B,MAAMuS,kBAAkB,GAAGvS,IAAI,CAAC8M,YAAL,GAAoB,eAApB,GAAsC,EAAjE;IACA,MAAMxM,QAAQ,GAAG,KAAKY,UAAL,CAAgBlB,IAAhB,CAAjB;;IAEA,IAAI,OAAOA,IAAI,CAACqI,UAAZ,KAA2B,QAA/B,EAAyC;MACrC,OAAO,IAAIvR,KAAJ,CACH,UAAUyb,kBAAkB,QAAQjS,QAAQ,OAAON,IAAI,CAACqI,UAAU,EAD/D,CAAP;IAGH,CAJD,MAIO;MACH,OAAO,IAAIvR,KAAJ,CACH,UAAUyb,kBAAkB,QAAQjS,QAAQ,OAAON,IAAI,CAClDqI,UAD8C,CACnC,KAAKjR,UAD8B,EAE9Cob,QAF8C,EAEpC,EAHZ,CAAP;IAKH;EACJ;;EAEsC,MAAvBtS,uBAAuB,CAACF,IAAD,EAAW;IAC9C,MAAMuM,aAAa,GAAG,MAAM,KAAKjR,gBAAL,EAA5B;IAEA,IAAI;MAAED,MAAF;MAAUO,SAAS,EAAEwC;IAArB,IAA8B,KAAKlH,MAAL,CAAYwE,cAAZ,CAA2BsE,IAA3B,CAAlC;;IAEA,IAAI,CAAC3E,MAAL,EAAa;MACTA,MAAM,GAAGkR,aAAT;IACH;;IAED,MAAMhP,IAAI,GAAGyC,IAAI,CAAC8M,YAAL,GACP/V,iBAAiB,CAAC2V,iBADX,GAEP3V,iBAAiB,CAAC0V,IAFxB;IAGA,MAAMpE,UAAU,GACZ,OAAOrI,IAAI,CAACqI,UAAZ,KAA2B,QAA3B,GACMrI,IAAI,CAACqI,UAAL,CAAgBoK,IAAhB,EADN,GAEMzS,IAAI,CAACqI,UAAL,CAAgB,KAAKjR,UAArB,EAAiCob,QAAjC,EAHV;IAIA,OAAO,KAAKlU,wBAAL,CAA8B;MACjCf,IADiC;MAEjClC,MAFiC;MAGjC+C,IAHiC;MAIjCI,KAAK,EAAE6J;IAJ0B,CAA9B,CAAP;EAMH;EAED;;;;;EAGUlI,WAAW,CAACH,IAAD,EAAW;IAC5B,MAAMuS,kBAAkB,GAAGvS,IAAI,CAAC8M,YAAL,GAAoB,eAApB,GAAsC,EAAjE;IACA,OAAO,IAAIhW,KAAJ,CACH,QAAQyb,kBAAkB,QAAQ,KAAKrR,UAAL,CAAgBlB,IAAhB,CAAqB,EADpD,CAAP;EAGH;EAED;;;;;EAGuC,MAAvBI,uBAAuB,CAACJ,IAAD,EAAW;IAC9C,MAAMuM,aAAa,GAAG,MAAM,KAAKjR,gBAAL,EAA5B;IAEA,IAAI;MAAED,MAAF;MAAUO,SAAS,EAAEwC;IAArB,IAA8B,KAAKlH,MAAL,CAAYwE,cAAZ,CAA2BsE,IAA3B,CAAlC;;IAEA,IAAI,CAAC3E,MAAL,EAAa;MACTA,MAAM,GAAGkR,aAAT;IACH;;IAED,MAAMhP,IAAI,GAAGyC,IAAI,CAAC8M,YAAL,GACP/V,iBAAiB,CAAC2V,iBADX,GAEP3V,iBAAiB,CAAC0V,IAFxB;IAGA,OAAO,KAAK/N,wBAAL,CAA8B;MAAEnB,IAAF;MAAQlC,MAAR;MAAgB+C;IAAhB,CAA9B,CAAP;EACH;EAED;;;;;EAG6B,MAAb4N,aAAa,CAAC0G,WAAD,EAAoB;IAC7C,MAAMC,gBAAgB,GAClB,qHACA,0DADA,GAEA,kEAFA,GAGA,2BAA2BD,WAAW,yCAJ1C;IAKA,MAAME,WAAW,GAAoB,MAAM,KAAK1Z,KAAL,CAAWyZ,gBAAX,CAA3C;IACA,MAAMnb,OAAO,CAACkR,GAAR,CAAYkK,WAAW,CAACvR,GAAZ,CAAiBqK,CAAD,IAAO,KAAKxS,KAAL,CAAWwS,CAAC,CAAC,OAAD,CAAZ,CAAvB,CAAZ,CAAN;EACH;EAED;;;;;EAG2B,MAAXhO,WAAW,CACvBb,KADuB,EAEvBS,MAFuB,EAEJ;IAEnB,IAAI;MAAEjC;IAAF,IAAa,KAAKnE,MAAL,CAAYwE,cAAZ,CAA2BmB,KAA3B,CAAjB;;IAEA,IAAI,CAACxB,MAAL,EAAa;MACTA,MAAM,GAAG,MAAM,KAAKC,gBAAL,EAAf;IACH;;IAED,MAAMqC,QAAQ,GAAG,KAAKC,aAAL,CAAmBf,KAAnB,EAA0BS,MAA1B,EAAkC,KAAlC,EAAyC,IAAzC,CAAjB;IACA,MAAM3B,GAAG,GACL,4DACA,kEADA,GAEA,0BAA0BN,MAAM,0BAA0BsC,QAAQ,GAHtE;IAIA,MAAM1D,MAAM,GAAG,MAAM,KAAKf,KAAL,CAAWyC,GAAX,CAArB;IACA,OAAO1B,MAAM,CAACiB,MAAP,GAAgB,IAAhB,GAAuB,KAA9B;EACH;EAED;;;;;EAGU2C,iBAAiB,CACvBhB,KADuB,EAEvBS,MAFuB,EAGvBK,QAHuB,EAGN;IAEjB,IAAI,CAACA,QAAL,EAAeA,QAAQ,GAAG,KAAKC,aAAL,CAAmBf,KAAnB,EAA0BS,MAA1B,CAAX;IACf,MAAMuV,UAAU,GAAGvV,MAAM,CACpB0H,IADc,CACR3D,GADQ,CACH7C,KAAD,IAAW,IAAIA,KAAK,CAACuQ,OAAN,CAAc,GAAd,EAAmB,IAAnB,CAAwB,GADnC,EAEd3L,IAFc,CAET,IAFS,CAAnB;IAGA,OAAO,IAAItM,KAAJ,CAAU,eAAe6G,QAAQ,YAAYkV,UAAU,GAAvD,CAAP;EACH;EAED;;;;;EAGU/U,eAAe,CACrBjB,KADqB,EAErBS,MAFqB,EAGrBK,QAHqB,EAGJ;IAEjB,IAAI,CAACA,QAAL,EAAeA,QAAQ,GAAG,KAAKC,aAAL,CAAmBf,KAAnB,EAA0BS,MAA1B,CAAX;IACf,OAAO,IAAIxG,KAAJ,CAAU,aAAa6G,QAAQ,EAA/B,CAAP;EACH;EAED;;;;;EAGU2B,cAAc,CAACzC,KAAD,EAAenE,KAAf,EAAgC;IACpD,MAAM0E,OAAO,GAAG1E,KAAK,CAAC0G,WAAN,CACXiC,GADW,CACNvF,UAAD,IAAgB,IAAIA,UAAU,GADvB,EAEXsH,IAFW,CAEN,IAFM,CAAhB;IAGA,OAAO,IAAItM,KAAJ,CACH,UAAU4B,KAAK,CAAC6K,QAAN,GAAiB,SAAjB,GAA6B,EAAE,UACrC7K,KAAK,CAAC0F,IACV,QAAQ,KAAK8C,UAAL,CAAgBrE,KAAhB,CAAsB,IAC1BnE,KAAK,CAAC+Y,SAAN,GAAkB,aAAlB,GAAkC,EACtC,IAAIrU,OAAO,KAAK1E,KAAK,CAAC2G,KAAN,GAAc,WAAW3G,KAAK,CAAC2G,KAA/B,GAAuC,EAAE,EALtD,CAAP;EAOH;EAED;;;;;EAGUE,YAAY,CAClB1C,KADkB,EAElB6N,WAFkB,EAEc;IAEhC,IAAIvL,SAAS,GAAGxI,eAAe,CAACgU,YAAhB,CAA6BD,WAA7B,IACVA,WAAW,CAACtM,IADF,GAEVsM,WAFN;IAGA,MAAM;MAAErP;IAAF,IAAa,KAAKnE,MAAL,CAAYwE,cAAZ,CAA2BmB,KAA3B,CAAnB;IACA,OAAOxB,MAAM,GACP,IAAIvE,KAAJ,CAAU,eAAeuE,MAAM,MAAM8D,SAAS,GAA9C,CADO,GAEP,IAAIrI,KAAJ,CAAU,eAAeqI,SAAS,GAAlC,CAFN;EAGH;EAED;;;;;EAGUgI,mBAAmB,CACzBtK,KADyB,EAEzBuC,WAFyB,EAGzB8H,cAHyB,EAGF;IAEvB,MAAM3F,cAAc,GAAG2F,cAAc,GAC/BA,cAD+B,GAE/B,KAAK9P,UAAL,CAAgB8H,cAAhB,CAA+BqC,cAA/B,CAA8C1E,KAA9C,EAAqDuC,WAArD,CAFN;IAIA,MAAMkI,iBAAiB,GAAGlI,WAAW,CAChCiC,GADqB,CAChBvF,UAAD,IAAgB,IAAIA,UAAU,GADb,EAErBsH,IAFqB,CAEhB,IAFgB,CAA1B;IAIA,OAAO,IAAItM,KAAJ,CACH,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,oBAAoB0E,cAAc,kBAAkB+F,iBAAiB,GAHnE,CAAP;EAKH;EAED;;;;;EAGUF,iBAAiB,CAACvK,KAAD,EAAa;IACpC,IAAI,CAACA,KAAK,CAACsE,cAAN,CAAqBjG,MAA1B,EACI,MAAM,IAAItF,YAAJ,CAAiB,SAASiH,KAAK,uBAA/B,CAAN;IAEJ,MAAMuC,WAAW,GAAGvC,KAAK,CAACsE,cAAN,CAAqBE,GAArB,CAA0B/D,MAAD,IAAYA,MAAM,CAACc,IAA5C,CAApB;IACA,MAAM8I,cAAc,GAAGrK,KAAK,CAACsE,cAAN,CAAqB,CAArB,EAAwBC,wBAA/C;IACA,MAAMG,cAAc,GAAG2F,cAAc,GAC/BA,cAD+B,GAE/B,KAAK9P,UAAL,CAAgB8H,cAAhB,CAA+BqC,cAA/B,CAA8C1E,KAA9C,EAAqDuC,WAArD,CAFN;IAIA,OAAO,IAAItI,KAAJ,CACH,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,qBAAqB0E,cAAc,GAHjC,CAAP;EAKH;EAED;;;;;EAGUqF,yBAAyB,CAC/B/J,KAD+B,EAE/B2G,gBAF+B,EAEF;IAE7B,MAAMpE,WAAW,GAAGoE,gBAAgB,CAACpE,WAAjB,CACfiC,GADe,CACV/D,MAAD,IAAY,MAAMA,MAAN,GAAe,GADhB,EAEf8F,IAFe,CAEV,IAFU,CAApB;IAGA,IAAIzH,GAAG,GAAG,eAAe,KAAKuF,UAAL,CAAgBrE,KAAhB,CAAsB,oBAC3C2G,gBAAgB,CAACpF,IACrB,aAAagB,WAAW,GAFxB;IAGA,IAAIoE,gBAAgB,CAACoN,UAArB,EACIjV,GAAG,IAAI,eAAe6H,gBAAgB,CAACoN,UAAU,EAAjD;IACJ,OAAO,IAAI9Z,KAAJ,CAAU6E,GAAV,CAAP;EACH;EAED;;;;;EAGUgL,uBAAuB,CAC7B9J,KAD6B,EAE7BgL,YAF6B,EAEK;IAElC,MAAMkK,UAAU,GAAGpb,eAAe,CAACmR,aAAhB,CAA8BD,YAA9B,IACbA,YAAY,CAACzJ,IADA,GAEbyJ,YAFN;IAGA,OAAO,IAAI/Q,KAAJ,CACH,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,qBAAqBkV,UAAU,GAH7B,CAAP;EAKH;EAED;;;;;EAGUtL,wBAAwB,CAC9B5J,KAD8B,EAE9BsL,eAF8B,EAEH;IAE3B,OAAO,IAAIrR,KAAJ,CACH,eAAe,KAAKoK,UAAL,CAAgBrE,KAAhB,CAAsB,oBACjCsL,eAAe,CAAC/J,IACpB,YAAY+J,eAAe,CAACE,UAAU,GAHnC,CAAP;EAKH;EAED;;;;;EAGU7B,sBAAsB,CAC5B3J,KAD4B,EAE5B+L,WAF4B,EAEI;IAEhC,MAAMqJ,SAAS,GAAGtb,eAAe,CAACkS,YAAhB,CAA6BD,WAA7B,IACZA,WAAW,CAACxK,IADA,GAEZwK,WAFN;IAGA,OAAO,IAAI9R,KAAJ,CACH,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,qBAAqBoV,SAAS,GAH5B,CAAP;EAKH;EAED;;;;;EAGU9I,4BAA4B,CAClCtM,KADkC,EAElCoM,mBAFkC,EAEC;IAEnC,OAAO,IAAInS,KAAJ,CACH,eAAe,KAAKoK,UAAL,CAAgBrE,KAAhB,CAAsB,oBACjCoM,mBAAmB,CAAC7K,IACxB,aAAa6K,mBAAmB,CAACZ,UAAU,EAHxC,CAAP;EAKH;EAED;;;;;EAGUe,0BAA0B,CAChCvM,KADgC,EAEhC4M,eAFgC,EAEQ;IAExC,MAAM2I,aAAa,GAAGzb,eAAe,CAAC+S,gBAAhB,CAAiCD,eAAjC,IAChBA,eAAe,CAACrL,IADA,GAEhBqL,eAFN;IAGA,OAAO,IAAI3S,KAAJ,CACH,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,qBAAqBuV,aAAa,GAHhC,CAAP;EAKH;EAED;;;;;EAGUrI,mBAAmB,CACzBlN,KADyB,EAEzBkC,UAFyB,EAEE;IAE3B,MAAMK,WAAW,GAAGL,UAAU,CAACK,WAAX,CACfiC,GADe,CACV/D,MAAD,IAAY,MAAMA,MAAN,GAAe,GADhB,EAEf8F,IAFe,CAEV,IAFU,CAApB;IAGA,MAAMT,qBAAqB,GAAG5D,UAAU,CAAC4D,qBAAX,CACzBtB,GADyB,CACpB/D,MAAD,IAAY,MAAMA,MAAN,GAAe,GADN,EAEzB8F,IAFyB,CAEpB,GAFoB,CAA9B;IAGA,IAAIzH,GAAG,GACH,eAAe,KAAKuF,UAAL,CAAgBrE,KAAhB,CAAsB,oBACjCkC,UAAU,CAACX,IACf,kBAAkBgB,WAAW,IAF7B,GAGA,cAAc,KAAK8B,UAAL,CACV,KAAKrB,YAAL,CAAkBd,UAAlB,CADU,CAEb,IAAI4D,qBAAqB,GAN9B;IAOA,IAAI5D,UAAU,CAACsS,QAAf,EAAyB1V,GAAG,IAAI,cAAcoD,UAAU,CAACsS,QAAQ,EAAxC;IACzB,IAAItS,UAAU,CAACuS,QAAf,EAAyB3V,GAAG,IAAI,cAAcoD,UAAU,CAACuS,QAAQ,EAAxC;IACzB,IAAIvS,UAAU,CAAC6R,UAAf,EAA2BjV,GAAG,IAAI,eAAeoD,UAAU,CAAC6R,UAAU,EAA3C;IAE3B,OAAO,IAAI9Z,KAAJ,CAAU6E,GAAV,CAAP;EACH;EAED;;;;;EAGUqD,iBAAiB,CACvBnC,KADuB,EAEvBqN,gBAFuB,EAEmB;IAE1C,MAAMxH,cAAc,GAAG/L,eAAe,CAACwT,iBAAhB,CACnBD,gBADmB,IAGjBA,gBAAgB,CAAC9L,IAHA,GAIjB8L,gBAJN;IAKA,OAAO,IAAIpT,KAAJ,CACH,eAAe,KAAKoK,UAAL,CACXrE,KADW,CAEd,qBAAqB6F,cAAc,GAHjC,CAAP;EAKH;EAED;;;;;EAGUX,iBAAiB,CACvBlF,KADuB,EAEvBqJ,YAFuB,EAEW;IAElC,MAAM;MAAEtK;IAAF,IAAgB,KAAK1E,MAAL,CAAYwE,cAAZ,CAA2BmB,KAA3B,CAAtB;IAEA,MAAMf,UAAU,GAAGnF,eAAe,CAACsN,aAAhB,CAA8BiC,YAA9B,IACbA,YAAY,CAAC9H,IADA,GAEb8H,YAFN;IAIA,IAAI4M,OAAO,GAAG,GAAGlX,SAAS,IAAIE,UAAU,MAAxC;;IAEA,IAAIgX,OAAO,CAAC5X,MAAR,GAAiB,KAAK9D,UAAL,CAAgBF,MAAhB,CAAuB6b,cAA5C,EAA6D;MACzD;MACAD,OAAO,GAAG,GAAGlX,SAAS,CAACmV,SAAV,CAAoB,CAApB,EAAuB,EAAvB,CAA0B,IAAIjV,UAAU,CAACiV,SAAX,CACvC,CADuC,EAEvCiC,IAAI,CAACC,GAAL,CAAS,EAAT,EAAa,KAAKpW,KAAK,CAACuB,IAAN,CAAWlD,MAAhB,GAAyB,CAAtC,CAFuC,CAG1C,MAHD;IAIH;;IAED,OAAO4X,OAAP;EACH;;EAESjR,iBAAiB,CACvBhF,KADuB,EAEvBqJ,YAFuB,EAEW;IAElC,MAAM;MAAE7K;IAAF,IAAa,KAAKnE,MAAL,CAAYwE,cAAZ,CAA2BmB,KAA3B,CAAnB;IAEA,OAAOxB,MAAM,GACP,GAAGA,MAAM,IAAI,KAAK0G,iBAAL,CAAuBlF,KAAvB,EAA8BqJ,YAA9B,CAA2C,EADjD,GAEP,KAAKnE,iBAAL,CAAuBlF,KAAvB,EAA8BqJ,YAA9B,CAFN;EAGH;EAED;;;;;EAGUtI,aAAa,CACnBf,KADmB,EAEnBS,MAFmB,EAKJ;IAAA,IAFf4V,UAEe,uEAFO,IAEP;IAAA,IADfC,aACe;IAAA,IAAfC,KAAe;IAEf,MAAM;MAAE/X,MAAF;MAAUO;IAAV,IAAwB,KAAK1E,MAAL,CAAYwE,cAAZ,CAA2BmB,KAA3B,CAA9B;IACA,IAAIc,QAAQ,GAAGL,MAAM,CAACK,QAAP,GACTL,MAAM,CAACK,QADE,GAET,GAAG/B,SAAS,IAAI0B,MAAM,CAACc,IAAP,CAAY0H,WAAZ,EAAyB,OAF/C;IAGA,IAAIzK,MAAM,IAAI6X,UAAd,EAA0BvV,QAAQ,GAAG,GAAGtC,MAAM,IAAIsC,QAAQ,EAAhC;IAC1B,IAAIyV,KAAJ,EAAWzV,QAAQ,GAAGA,QAAQ,GAAG,MAAtB;IACX,OAAOA,QAAQ,CACVlB,KADE,CACI,GADJ,EAEF4E,GAFE,CAEGuJ,CAAD,IAAM;MACP,OAAOuI,aAAa,GAAGvI,CAAH,GAAO,IAAIA,CAAC,GAAhC;IACH,CAJE,EAKFxH,IALE,CAKG,GALH,CAAP;EAMH;;EAEqC,MAAtBN,sBAAsB,CAACjG,KAAD,EAAeS,MAAf,EAAkC;IACpE,IAAI;MAAEjC,MAAF;MAAUO,SAAS,EAAEwC;IAArB,IAA8B,KAAKlH,MAAL,CAAYwE,cAAZ,CAA2BmB,KAA3B,CAAlC;;IAEA,IAAI,CAACxB,MAAL,EAAa;MACTA,MAAM,GAAG,MAAM,KAAKC,gBAAL,EAAf;IACH;;IAED,MAAMrB,MAAM,GAAG,MAAM,KAAKf,KAAL,CACjB,qCACI,+DAA+DmC,MAAM,yBAAyB+C,IAAI,wBAAwBd,MAAM,CAACc,IAAI,GAFxH,CAArB,CAPoE,CAYpE;IACA;IACA;IACA;IACA;;IACA,IAAIiV,OAAO,GAAGpZ,MAAM,CAAC,CAAD,CAAN,CAAU,UAAV,CAAd;;IACA,IAAIoZ,OAAO,CAAC1a,OAAR,CAAgB,GAAhB,MAAyB,CAA7B,EAAgC;MAC5B0a,OAAO,GAAGA,OAAO,CAACC,MAAR,CAAe,CAAf,EAAkBD,OAAO,CAACnY,MAA1B,CAAV;IACH;;IACD,OAAO;MACHG,MAAM,EAAEpB,MAAM,CAAC,CAAD,CAAN,CAAU,YAAV,CADL;MAEHmE,IAAI,EAAEiV;IAFH,CAAP;EAIH;EAED;;;;;EAGU3P,aAAa,CAACD,OAAD,EAAiB;IACpC,IAAI,CAACA,OAAD,IAAYA,OAAO,CAACvI,MAAR,KAAmB,CAAnC,EAAsC;MAClC,OAAO,MAAP;IACH;;IAEDuI,OAAO,GAAGA,OAAO,CAACsL,OAAR,CAAgB,IAAhB,EAAsB,IAAtB,EAA4BA,OAA5B,CAAoC,SAApC,EAA+C,EAA/C,CAAV,CALoC,CAKyB;;IAE7D,OAAO,IAAItL,OAAO,GAAlB;EACH;EAED;;;;;EAGUvC,UAAU,CAACzB,MAAD,EAA8B;IAC9C,MAAM;MAAEpE,MAAF;MAAUO;IAAV,IAAwB,KAAK1E,MAAL,CAAYwE,cAAZ,CAA2B+D,MAA3B,CAA9B;;IAEA,IAAIpE,MAAM,IAAIA,MAAM,KAAK,KAAKnE,MAAL,CAAYqc,YAArC,EAAmD;MAC/C,OAAO,IAAIlY,MAAM,MAAMO,SAAS,GAAhC;IACH;;IAED,OAAO,IAAIA,SAAS,GAApB;EACH;EAED;;;;;;EAIsC,MAAtBuC,sBAAsB,CAACsB,MAAD,EAAuB;IACzD,MAAM7D,SAAS,GAAGjF,eAAe,CAACkK,OAAhB,CAAwBpB,MAAxB,IAAkCA,MAAM,CAACrB,IAAzC,GAAgDqB,MAAlE;;IACA,IAAI7D,SAAS,CAACjD,OAAV,CAAkB,GAAlB,MAA2B,CAAC,CAAhC,EAAmC;MAC/B,MAAM6a,YAAY,GAAG,MAAM,KAAKta,KAAL,CAAW,yBAAX,CAA3B;MACA,MAAMmC,MAAM,GAAGmY,YAAY,CAAC,CAAD,CAAZ,CAAgB,gBAAhB,CAAf;MACA,OAAO,GAAGnY,MAAM,IAAIO,SAAS,EAA7B;IACH,CAJD,MAIO;MACH,OAAO,GAAGA,SAAS,CAACa,KAAV,CAAgB,GAAhB,EAAqB,CAArB,CAAuB,IAAIb,SAAS,CAACa,KAAV,CAAgB,GAAhB,EAAqB,CAArB,CAAuB,EAA5D;IACH;EACJ;EAED;;;;;EAGUwG,oBAAoB,CAACpG,KAAD,EAAeS,MAAf,EAAkC;IAC5D,IAAI4G,CAAC,GAAG,MAAM5G,MAAM,CAACc,IAAb,GAAoB,GAA5B;;IACA,IACId,MAAM,CAACoE,WAAP,KAAuB,IAAvB,IACApE,MAAM,CAACqE,kBAAP,KAA8B,MAFlC,EAGE;MACE,IAAIrE,MAAM,CAACqE,kBAAP,KAA8B,UAAlC,EAA8C;QAC1C;QACA,MAAM8R,0BAA0B,GAC5BnW,MAAM,CAACyS,iBAAP,IAA4B,YADhC;QAEA7L,CAAC,IAAI,IAAI5G,MAAM,CAACC,IAAI,cAAckW,0BAA0B,cAA5D;MACH,CALD,MAKO;QACH;QACA,IACInW,MAAM,CAACC,IAAP,KAAgB,SAAhB,IACAD,MAAM,CAACC,IAAP,KAAgB,KADhB,IAEAD,MAAM,CAACC,IAAP,KAAgB,MAHpB,EAKI2G,CAAC,IAAI,SAAL;QACJ,IAAI5G,MAAM,CAACC,IAAP,KAAgB,UAAhB,IAA8BD,MAAM,CAACC,IAAP,KAAgB,MAAlD,EACI2G,CAAC,IAAI,cAAL;QACJ,IAAI5G,MAAM,CAACC,IAAP,KAAgB,QAAhB,IAA4BD,MAAM,CAACC,IAAP,KAAgB,MAAhD,EACI2G,CAAC,IAAI,YAAL;MACP;IACJ;;IACD,IAAI5G,MAAM,CAACC,IAAP,KAAgB,MAAhB,IAA0BD,MAAM,CAACC,IAAP,KAAgB,aAA9C,EAA6D;MACzD2G,CAAC,IAAI,MAAM,KAAKtG,aAAL,CAAmBf,KAAnB,EAA0BS,MAA1B,CAAX;MACA,IAAIA,MAAM,CAACgH,OAAX,EAAoBJ,CAAC,IAAI,QAAL;IACvB,CAHD,MAGO,IAAI,CAAC5G,MAAM,CAACoE,WAAR,IAAuBpE,MAAM,CAACC,IAAP,KAAgB,MAA3C,EAAmD;MACtD2G,CAAC,IAAI,MAAM,KAAK9M,UAAL,CAAgBF,MAAhB,CAAuB4N,cAAvB,CAAsCxH,MAAtC,CAAX;IACH,CA9B2D,CAgC5D;;;IACA,IAAIA,MAAM,CAACU,aAAP,KAAyB,QAAzB,IAAqCV,MAAM,CAACW,YAAhD,EAA8D;MAC1DiG,CAAC,IAAI,yBAAyB5G,MAAM,CAACW,YAAY,UAAjD;IACH;;IAED,IAAIX,MAAM,CAACiT,OAAX,EAAoBrM,CAAC,IAAI,qBAAqB5G,MAAM,CAACiT,OAA5B,GAAsC,GAA3C;IACpB,IAAIjT,MAAM,CAACkT,SAAX,EAAsBtM,CAAC,IAAI,eAAe5G,MAAM,CAACkT,SAAtB,GAAkC,GAAvC;IACtB,IAAIlT,MAAM,CAACoI,UAAP,KAAsB,IAA1B,EAAgCxB,CAAC,IAAI,WAAL;IAChC,IAAI5G,MAAM,CAACiI,OAAP,KAAmB9M,SAAnB,IAAgC6E,MAAM,CAACiI,OAAP,KAAmB,IAAvD,EACIrB,CAAC,IAAI,cAAc5G,MAAM,CAACiI,OAA1B;IACJ,IACIjI,MAAM,CAACoE,WAAP,IACApE,MAAM,CAACqE,kBAAP,KAA8B,MAD9B,IAEA,CAACrE,MAAM,CAACiI,OAHZ,EAKIrB,CAAC,IAAI,YAAY,KAAKhN,MAAL,CAAY0O,aAAa,EAA1C;IAEJ,OAAO1B,CAAP;EACH;EAED;;;;;EAG8C,MAA9B2J,8BAA8B;IAC1C,MAAM5T,MAAM,GAAG,MAAM,KAAKf,KAAL,CACjB,8GADiB,CAArB;IAGA,OAAOe,MAAM,CAACiB,MAAP,GAAgB,IAAhB,GAAuB,KAA9B;EACH;;AAh6IsB","names":["TypeORMError","QueryFailedError","QueryRunnerAlreadyReleasedError","TransactionNotStartedError","BaseQueryRunner","QueryResult","Table","TableCheck","TableColumn","TableExclusion","TableForeignKey","TableIndex","TableUnique","View","Broadcaster","InstanceChecker","OrmUtils","VersionUtils","Query","MetadataTableType","PostgresQueryRunner","constructor","driver","mode","connection","broadcaster","connect","databaseConnection","Promise","resolve","databaseConnectionPromise","isReplicated","obtainSlaveConnection","then","release","connectedQueryRunners","push","onErrorCallback","err","releasePostgresConnection","releaseCallback","removeListener","on","obtainMasterConnection","isReleased","undefined","index","indexOf","splice","startTransaction","isolationLevel","isTransactionActive","broadcast","transactionDepth","query","commitTransaction","rollbackTransaction","parameters","useStructuredResult","logger","logQuery","queryStartTime","Date","raw","maxQueryExecutionTime","options","queryEndTime","queryExecutionTime","logQuerySlow","result","hasOwnProperty","records","rows","affected","rowCount","command","logQueryError","stream","onEnd","onError","QueryStream","loadStreamDependency","getDatabases","getSchemas","database","hasDatabase","length","getCurrentDatabase","hasSchema","schema","getCurrentSchema","hasTable","tableOrName","parsedTableName","parseTableName","sql","tableName","hasColumn","columnName","createDatabase","ifNotExist","databaseAlreadyExists","up","down","executeQueries","dropDatabase","ifExist","createSchema","schemaPath","split","dropSchema","isCascade","createTable","table","createForeignKeys","createIndices","isTableExist","upQueries","downQueries","enumColumns","columns","filter","column","type","createdEnumTypes","hasEnum","hasEnumType","enumName","buildEnumName","createEnumTypeSql","dropEnumTypeSql","generatedColumns","generatedType","asExpression","tableNameWithSchema","getTableNameWithSchema","name","insertQuery","insertTypeormMetadataSql","GENERATED_COLUMN","value","deleteQuery","deleteTypeormMetadataSql","createTableSql","dropTableSql","foreignKeys","forEach","foreignKey","dropForeignKeySql","indices","namingStrategy","indexName","columnNames","where","createIndexSql","dropIndexSql","dropTable","target","dropForeignKeys","dropIndices","tablePath","getTablePath","getCachedTable","createView","view","createViewSql","insertViewDefinitionSql","dropViewSql","deleteViewDefinitionSql","dropView","viewName","isView","getCachedView","renameTable","oldTableOrName","newTableName","oldTable","isTable","newTable","clone","schemaName","oldTableName","escapePath","primaryColumns","primaryKeyConstraintName","map","oldPkName","primaryKeyName","newPkName","col","isGenerated","generationStrategy","sequencePath","buildSequencePath","sequenceName","buildSequenceName","newSequencePath","newSequenceName","uniques","unique","oldUniqueName","uniqueConstraintName","newUniqueName","oldIndexName","newIndexName","oldForeignKeyName","foreignKeyName","referencedColumnNames","newForeignKeyName","oldEnumType","getUserDefinedTypeName","addColumn","clonedTable","buildCreateColumnSql","isPrimary","pkName","join","columnIndex","find","isUnique","uniqueConstraint","comment","escapeComment","replaceCachedTable","addColumns","renameColumn","oldTableColumnOrName","newTableColumnOrName","oldColumn","isTableColumn","c","newColumn","changeColumn","defaultValueChanged","isArray","dropColumn","findColumnUniques","findColumnIndices","findColumnForeignKeys","oldTableColumn","precision","scale","createFullType","isArraysEqual","enum","arraySuffix","newEnumName","oldEnumName","oldEnumNameWithoutSchema","oldEnumNameWithSchema_old","oldEnumNameWithoutSchema_old","default","upType","downType","isNullable","primaryColumn","uuidGenerator","spatialFeatureType","toLowerCase","srid","changeColumns","changedColumns","columnOrName","findColumnByName","tableColumn","columnCheck","checks","check","dropCheckConstraintSql","createCheckConstraintSql","columnUnique","dropUniqueConstraintSql","createUniqueConstraintSql","enumType","escapedEnumName","removeColumn","dropColumns","createPrimaryKey","constraintName","createPrimaryKeySql","dropPrimaryKeySql","updatePrimaryKeys","columnNamesString","dropPrimaryKey","createUniqueConstraint","addUniqueConstraint","createUniqueConstraints","uniqueConstraints","dropUniqueConstraint","uniqueOrName","isTableUnique","u","removeUniqueConstraint","dropUniqueConstraints","createCheckConstraint","checkConstraint","checkConstraintName","expression","addCheckConstraint","createCheckConstraints","checkConstraints","promises","all","dropCheckConstraint","checkOrName","isTableCheck","removeCheckConstraint","dropCheckConstraints","createExclusionConstraint","exclusionConstraint","exclusionConstraintName","createExclusionConstraintSql","dropExclusionConstraintSql","addExclusionConstraint","createExclusionConstraints","exclusionConstraints","dropExclusionConstraint","exclusionOrName","isTableExclusion","exclusions","removeExclusionConstraint","dropExclusionConstraints","createForeignKey","createForeignKeySql","addForeignKey","dropForeignKey","foreignKeyOrName","isTableForeignKey","fk","removeForeignKey","createIndex","generateIndexName","addIndex","dropIndex","indexOrName","isTableIndex","i","removeIndex","clearTable","clearDatabase","schemas","entityMetadatas","metadata","isSchemaExist","schemaNamesString","isAnotherTransactionActive","version","getVersion","selectViewDropsQuery","dropViewQueries","q","isGreaterOrEqual","selectMatViewDropsQuery","dropMatViewQueries","selectTableDropsQuery","dropTableQueries","dropEnumTypes","error","rollbackError","loadViews","viewNames","getTypeormMetadataTableName","currentDatabase","currentSchema","viewsCondition","VIEW","MATERIALIZED_VIEW","dbViews","dbView","buildTableName","materialized","loadTables","tableNames","dbTables","tablesSql","tablesCondition","columnsCondition","table_schema","table_name","columnsSql","constraintsCondition","constraintsSql","indicesSql","foreignKeysCondition","hasRelispartitionColumn","hasSupportForPartitionedTables","isPartitionCondition","foreignKeysSql","dbColumns","dbConstraints","dbIndices","dbForeignKeys","dbTable","getSchemaFromKey","dbObject","key","dbColumn","columnConstraints","dbConstraint","isDefaultColumnPrecision","isDefaultColumnScale","builtEnumName","results","replace","normalizeType","geometryColumnSql","geographyColumnSql","withLengthColumnTypes","match","exec","toString","isDefaultColumnLength","primaryConstraint","constraint","anotherPrimaryConstraints","isConstraintComposite","every","some","is_identity","generatedIdentity","identity_generation","serialDefaultName","serialDefaultPath","defaultWithoutQuotes","test","asExpressionQuery","selectTypeormMetadataSql","charset","collation","tableUniqueConstraints","uniq","dbC","deferrable","tableCheckConstraints","tableExclusionConstraints","substring","tableForeignKeyConstraints","dbForeignKey","dbFk","referencedTableName","referencedSchema","onDelete","onUpdate","tableIndexConstraints","dbIndex","isSpatial","spatialTypes","isFulltext","columnDefinitions","isUniqueExist","uniquesSql","uniqueName","checksSql","checkName","exclusionsSql","exclusion","exclusionName","it","tableOrPath","materializedClause","getQuery","trim","schemaNames","selectDropsQuery","dropQueries","enumValues","seqName","maxAliasLength","Math","max","withSchema","disableEscape","toOld","udtName","substr","searchSchema","schemaResult","generatedIdentityOrDefault"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\driver\\postgres\\PostgresQueryRunner.ts"],"sourcesContent":["import { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { TypeORMError } from \"../../error\"\nimport { QueryFailedError } from \"../../error/QueryFailedError\"\nimport { QueryRunnerAlreadyReleasedError } from \"../../error/QueryRunnerAlreadyReleasedError\"\nimport { TransactionNotStartedError } from \"../../error/TransactionNotStartedError\"\nimport { ReadStream } from \"../../platform/PlatformTools\"\nimport { BaseQueryRunner } from \"../../query-runner/BaseQueryRunner\"\nimport { QueryResult } from \"../../query-runner/QueryResult\"\nimport { QueryRunner } from \"../../query-runner/QueryRunner\"\nimport { TableIndexOptions } from \"../../schema-builder/options/TableIndexOptions\"\nimport { Table } from \"../../schema-builder/table/Table\"\nimport { TableCheck } from \"../../schema-builder/table/TableCheck\"\nimport { TableColumn } from \"../../schema-builder/table/TableColumn\"\nimport { TableExclusion } from \"../../schema-builder/table/TableExclusion\"\nimport { TableForeignKey } from \"../../schema-builder/table/TableForeignKey\"\nimport { TableIndex } from \"../../schema-builder/table/TableIndex\"\nimport { TableUnique } from \"../../schema-builder/table/TableUnique\"\nimport { View } from \"../../schema-builder/view/View\"\nimport { Broadcaster } from \"../../subscriber/Broadcaster\"\nimport { InstanceChecker } from \"../../util/InstanceChecker\"\nimport { OrmUtils } from \"../../util/OrmUtils\"\nimport { VersionUtils } from \"../../util/VersionUtils\"\nimport { Query } from \"../Query\"\nimport { ColumnType } from \"../types/ColumnTypes\"\nimport { IsolationLevel } from \"../types/IsolationLevel\"\nimport { MetadataTableType } from \"../types/MetadataTableType\"\nimport { ReplicationMode } from \"../types/ReplicationMode\"\nimport { PostgresDriver } from \"./PostgresDriver\"\n\n/**\n * Runs queries on a single postgres database connection.\n */\nexport class PostgresQueryRunner\n    extends BaseQueryRunner\n    implements QueryRunner\n{\n    // -------------------------------------------------------------------------\n    // Public Implemented Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Database driver used by connection.\n     */\n    driver: PostgresDriver\n\n    // -------------------------------------------------------------------------\n    // Protected Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Promise used to obtain a database connection for a first time.\n     */\n    protected databaseConnectionPromise: Promise<any>\n\n    /**\n     * Special callback provided by a driver used to release a created connection.\n     */\n    protected releaseCallback?: (err: any) => void\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(driver: PostgresDriver, mode: ReplicationMode) {\n        super()\n        this.driver = driver\n        this.connection = driver.connection\n        this.mode = mode\n        this.broadcaster = new Broadcaster(this)\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates/uses database connection from the connection pool to perform further operations.\n     * Returns obtained database connection.\n     */\n    connect(): Promise<any> {\n        if (this.databaseConnection)\n            return Promise.resolve(this.databaseConnection)\n\n        if (this.databaseConnectionPromise)\n            return this.databaseConnectionPromise\n\n        if (this.mode === \"slave\" && this.driver.isReplicated) {\n            this.databaseConnectionPromise = this.driver\n                .obtainSlaveConnection()\n                .then(([connection, release]: any[]) => {\n                    this.driver.connectedQueryRunners.push(this)\n                    this.databaseConnection = connection\n\n                    const onErrorCallback = (err: Error) =>\n                        this.releasePostgresConnection(err)\n                    this.releaseCallback = (err?: Error) => {\n                        this.databaseConnection.removeListener(\n                            \"error\",\n                            onErrorCallback,\n                        )\n                        release(err)\n                    }\n                    this.databaseConnection.on(\"error\", onErrorCallback)\n\n                    return this.databaseConnection\n                })\n        } else {\n            // master\n            this.databaseConnectionPromise = this.driver\n                .obtainMasterConnection()\n                .then(([connection, release]: any[]) => {\n                    this.driver.connectedQueryRunners.push(this)\n                    this.databaseConnection = connection\n\n                    const onErrorCallback = (err: Error) =>\n                        this.releasePostgresConnection(err)\n                    this.releaseCallback = (err?: Error) => {\n                        this.databaseConnection.removeListener(\n                            \"error\",\n                            onErrorCallback,\n                        )\n                        release(err)\n                    }\n                    this.databaseConnection.on(\"error\", onErrorCallback)\n\n                    return this.databaseConnection\n                })\n        }\n\n        return this.databaseConnectionPromise\n    }\n\n    /**\n     * Release a connection back to the pool, optionally specifying an Error to release with.\n     * Per pg-pool documentation this will prevent the pool from re-using the broken connection.\n     */\n    private async releasePostgresConnection(err?: Error) {\n        if (this.isReleased) {\n            return\n        }\n\n        this.isReleased = true\n        if (this.releaseCallback) {\n            this.releaseCallback(err)\n            this.releaseCallback = undefined\n        }\n\n        const index = this.driver.connectedQueryRunners.indexOf(this)\n\n        if (index !== -1) {\n            this.driver.connectedQueryRunners.splice(index, 1)\n        }\n    }\n\n    /**\n     * Releases used database connection.\n     * You cannot use query runner methods once its released.\n     */\n    release(): Promise<void> {\n        return this.releasePostgresConnection()\n    }\n\n    /**\n     * Starts transaction.\n     */\n    async startTransaction(isolationLevel?: IsolationLevel): Promise<void> {\n        this.isTransactionActive = true\n        try {\n            await this.broadcaster.broadcast(\"BeforeTransactionStart\")\n        } catch (err) {\n            this.isTransactionActive = false\n            throw err\n        }\n\n        if (this.transactionDepth === 0) {\n            await this.query(\"START TRANSACTION\")\n            if (isolationLevel) {\n                await this.query(\n                    \"SET TRANSACTION ISOLATION LEVEL \" + isolationLevel,\n                )\n            }\n        } else {\n            await this.query(`SAVEPOINT typeorm_${this.transactionDepth}`)\n        }\n        this.transactionDepth += 1\n\n        await this.broadcaster.broadcast(\"AfterTransactionStart\")\n    }\n\n    /**\n     * Commits transaction.\n     * Error will be thrown if transaction was not started.\n     */\n    async commitTransaction(): Promise<void> {\n        if (!this.isTransactionActive) throw new TransactionNotStartedError()\n\n        await this.broadcaster.broadcast(\"BeforeTransactionCommit\")\n\n        if (this.transactionDepth > 1) {\n            await this.query(\n                `RELEASE SAVEPOINT typeorm_${this.transactionDepth - 1}`,\n            )\n        } else {\n            await this.query(\"COMMIT\")\n            this.isTransactionActive = false\n        }\n        this.transactionDepth -= 1\n\n        await this.broadcaster.broadcast(\"AfterTransactionCommit\")\n    }\n\n    /**\n     * Rollbacks transaction.\n     * Error will be thrown if transaction was not started.\n     */\n    async rollbackTransaction(): Promise<void> {\n        if (!this.isTransactionActive) throw new TransactionNotStartedError()\n\n        await this.broadcaster.broadcast(\"BeforeTransactionRollback\")\n\n        if (this.transactionDepth > 1) {\n            await this.query(\n                `ROLLBACK TO SAVEPOINT typeorm_${this.transactionDepth - 1}`,\n            )\n        } else {\n            await this.query(\"ROLLBACK\")\n            this.isTransactionActive = false\n        }\n        this.transactionDepth -= 1\n\n        await this.broadcaster.broadcast(\"AfterTransactionRollback\")\n    }\n\n    /**\n     * Executes a given SQL query.\n     */\n    async query(\n        query: string,\n        parameters?: any[],\n        useStructuredResult: boolean = false,\n    ): Promise<any> {\n        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError()\n\n        const databaseConnection = await this.connect()\n\n        this.driver.connection.logger.logQuery(query, parameters, this)\n        try {\n            const queryStartTime = +new Date()\n            const raw = await databaseConnection.query(query, parameters)\n            // log slow queries if maxQueryExecution time is set\n            const maxQueryExecutionTime =\n                this.driver.options.maxQueryExecutionTime\n            const queryEndTime = +new Date()\n            const queryExecutionTime = queryEndTime - queryStartTime\n            if (\n                maxQueryExecutionTime &&\n                queryExecutionTime > maxQueryExecutionTime\n            )\n                this.driver.connection.logger.logQuerySlow(\n                    queryExecutionTime,\n                    query,\n                    parameters,\n                    this,\n                )\n\n            const result = new QueryResult()\n            if (raw) {\n                if (raw.hasOwnProperty(\"rows\")) {\n                    result.records = raw.rows\n                }\n\n                if (raw.hasOwnProperty(\"rowCount\")) {\n                    result.affected = raw.rowCount\n                }\n\n                switch (raw.command) {\n                    case \"DELETE\":\n                    case \"UPDATE\":\n                        // for UPDATE and DELETE query additionally return number of affected rows\n                        result.raw = [raw.rows, raw.rowCount]\n                        break\n                    default:\n                        result.raw = raw.rows\n                }\n\n                if (!useStructuredResult) {\n                    return result.raw\n                }\n            }\n\n            return result\n        } catch (err) {\n            this.driver.connection.logger.logQueryError(\n                err,\n                query,\n                parameters,\n                this,\n            )\n            throw new QueryFailedError(query, parameters, err)\n        }\n    }\n\n    /**\n     * Returns raw data stream.\n     */\n    async stream(\n        query: string,\n        parameters?: any[],\n        onEnd?: Function,\n        onError?: Function,\n    ): Promise<ReadStream> {\n        const QueryStream = this.driver.loadStreamDependency()\n        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError()\n\n        const databaseConnection = await this.connect()\n        this.driver.connection.logger.logQuery(query, parameters, this)\n        const stream = databaseConnection.query(\n            new QueryStream(query, parameters),\n        )\n        if (onEnd) stream.on(\"end\", onEnd)\n        if (onError) stream.on(\"error\", onError)\n\n        return stream\n    }\n\n    /**\n     * Returns all available database names including system databases.\n     */\n    async getDatabases(): Promise<string[]> {\n        return Promise.resolve([])\n    }\n\n    /**\n     * Returns all available schema names including system schemas.\n     * If database parameter specified, returns schemas of that database.\n     */\n    async getSchemas(database?: string): Promise<string[]> {\n        return Promise.resolve([])\n    }\n\n    /**\n     * Checks if database with the given name exist.\n     */\n    async hasDatabase(database: string): Promise<boolean> {\n        const result = await this.query(\n            `SELECT * FROM pg_database WHERE datname='${database}';`,\n        )\n        return result.length ? true : false\n    }\n\n    /**\n     * Loads currently using database\n     */\n    async getCurrentDatabase(): Promise<string> {\n        const query = await this.query(`SELECT * FROM current_database()`)\n        return query[0][\"current_database\"]\n    }\n\n    /**\n     * Checks if schema with the given name exist.\n     */\n    async hasSchema(schema: string): Promise<boolean> {\n        const result = await this.query(\n            `SELECT * FROM \"information_schema\".\"schemata\" WHERE \"schema_name\" = '${schema}'`,\n        )\n        return result.length ? true : false\n    }\n\n    /**\n     * Loads currently using database schema\n     */\n    async getCurrentSchema(): Promise<string> {\n        const query = await this.query(`SELECT * FROM current_schema()`)\n        return query[0][\"current_schema\"]\n    }\n\n    /**\n     * Checks if table with the given name exist in the database.\n     */\n    async hasTable(tableOrName: Table | string): Promise<boolean> {\n        const parsedTableName = this.driver.parseTableName(tableOrName)\n\n        if (!parsedTableName.schema) {\n            parsedTableName.schema = await this.getCurrentSchema()\n        }\n\n        const sql = `SELECT * FROM \"information_schema\".\"tables\" WHERE \"table_schema\" = '${parsedTableName.schema}' AND \"table_name\" = '${parsedTableName.tableName}'`\n        const result = await this.query(sql)\n        return result.length ? true : false\n    }\n\n    /**\n     * Checks if column with the given name exist in the given table.\n     */\n    async hasColumn(\n        tableOrName: Table | string,\n        columnName: string,\n    ): Promise<boolean> {\n        const parsedTableName = this.driver.parseTableName(tableOrName)\n\n        if (!parsedTableName.schema) {\n            parsedTableName.schema = await this.getCurrentSchema()\n        }\n\n        const sql = `SELECT * FROM \"information_schema\".\"columns\" WHERE \"table_schema\" = '${parsedTableName.schema}' AND \"table_name\" = '${parsedTableName.tableName}' AND \"column_name\" = '${columnName}'`\n        const result = await this.query(sql)\n        return result.length ? true : false\n    }\n\n    /**\n     * Creates a new database.\n     * Note: Postgres does not support database creation inside a transaction block.\n     */\n    async createDatabase(\n        database: string,\n        ifNotExist?: boolean,\n    ): Promise<void> {\n        if (ifNotExist) {\n            const databaseAlreadyExists = await this.hasDatabase(database)\n\n            if (databaseAlreadyExists) return Promise.resolve()\n        }\n\n        const up = `CREATE DATABASE \"${database}\"`\n        const down = `DROP DATABASE \"${database}\"`\n        await this.executeQueries(new Query(up), new Query(down))\n    }\n\n    /**\n     * Drops database.\n     * Note: Postgres does not support database dropping inside a transaction block.\n     */\n    async dropDatabase(database: string, ifExist?: boolean): Promise<void> {\n        const up = ifExist\n            ? `DROP DATABASE IF EXISTS \"${database}\"`\n            : `DROP DATABASE \"${database}\"`\n        const down = `CREATE DATABASE \"${database}\"`\n        await this.executeQueries(new Query(up), new Query(down))\n    }\n\n    /**\n     * Creates a new table schema.\n     */\n    async createSchema(\n        schemaPath: string,\n        ifNotExist?: boolean,\n    ): Promise<void> {\n        const schema =\n            schemaPath.indexOf(\".\") === -1\n                ? schemaPath\n                : schemaPath.split(\".\")[1]\n\n        const up = ifNotExist\n            ? `CREATE SCHEMA IF NOT EXISTS \"${schema}\"`\n            : `CREATE SCHEMA \"${schema}\"`\n        const down = `DROP SCHEMA \"${schema}\" CASCADE`\n        await this.executeQueries(new Query(up), new Query(down))\n    }\n\n    /**\n     * Drops table schema.\n     */\n    async dropSchema(\n        schemaPath: string,\n        ifExist?: boolean,\n        isCascade?: boolean,\n    ): Promise<void> {\n        const schema =\n            schemaPath.indexOf(\".\") === -1\n                ? schemaPath\n                : schemaPath.split(\".\")[1]\n\n        const up = ifExist\n            ? `DROP SCHEMA IF EXISTS \"${schema}\" ${isCascade ? \"CASCADE\" : \"\"}`\n            : `DROP SCHEMA \"${schema}\" ${isCascade ? \"CASCADE\" : \"\"}`\n        const down = `CREATE SCHEMA \"${schema}\"`\n        await this.executeQueries(new Query(up), new Query(down))\n    }\n\n    /**\n     * Creates a new table.\n     */\n    async createTable(\n        table: Table,\n        ifNotExist: boolean = false,\n        createForeignKeys: boolean = true,\n        createIndices: boolean = true,\n    ): Promise<void> {\n        if (ifNotExist) {\n            const isTableExist = await this.hasTable(table)\n            if (isTableExist) return Promise.resolve()\n        }\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        // if table have column with ENUM type, we must create this type in postgres.\n        const enumColumns = table.columns.filter(\n            (column) => column.type === \"enum\" || column.type === \"simple-enum\",\n        )\n        const createdEnumTypes: string[] = []\n        for (const column of enumColumns) {\n            // TODO: Should also check if values of existing type matches expected ones\n            const hasEnum = await this.hasEnumType(table, column)\n            const enumName = this.buildEnumName(table, column)\n\n            // if enum with the same \"enumName\" is defined more then once, me must prevent double creation\n            if (!hasEnum && createdEnumTypes.indexOf(enumName) === -1) {\n                createdEnumTypes.push(enumName)\n                upQueries.push(this.createEnumTypeSql(table, column, enumName))\n                downQueries.push(this.dropEnumTypeSql(table, column, enumName))\n            }\n        }\n\n        // if table have column with generated type, we must add the expression to the metadata table\n        const generatedColumns = table.columns.filter(\n            (column) =>\n                column.generatedType === \"STORED\" && column.asExpression,\n        )\n        for (const column of generatedColumns) {\n            const tableNameWithSchema = (\n                await this.getTableNameWithSchema(table.name)\n            ).split(\".\")\n            const tableName = tableNameWithSchema[1]\n            const schema = tableNameWithSchema[0]\n\n            const insertQuery = this.insertTypeormMetadataSql({\n                database: this.driver.database,\n                schema,\n                table: tableName,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n                value: column.asExpression,\n            })\n\n            const deleteQuery = this.deleteTypeormMetadataSql({\n                database: this.driver.database,\n                schema,\n                table: tableName,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n            })\n\n            upQueries.push(insertQuery)\n            downQueries.push(deleteQuery)\n        }\n\n        upQueries.push(this.createTableSql(table, createForeignKeys))\n        downQueries.push(this.dropTableSql(table))\n\n        // if createForeignKeys is true, we must drop created foreign keys in down query.\n        // createTable does not need separate method to create foreign keys, because it create fk's in the same query with table creation.\n        if (createForeignKeys)\n            table.foreignKeys.forEach((foreignKey) =>\n                downQueries.push(this.dropForeignKeySql(table, foreignKey)),\n            )\n\n        if (createIndices) {\n            table.indices.forEach((index) => {\n                // new index may be passed without name. In this case we generate index name manually.\n                if (!index.name)\n                    index.name = this.connection.namingStrategy.indexName(\n                        table,\n                        index.columnNames,\n                        index.where,\n                    )\n                upQueries.push(this.createIndexSql(table, index))\n                downQueries.push(this.dropIndexSql(table, index))\n            })\n        }\n\n        await this.executeQueries(upQueries, downQueries)\n    }\n\n    /**\n     * Drops the table.\n     */\n    async dropTable(\n        target: Table | string,\n        ifExist?: boolean,\n        dropForeignKeys: boolean = true,\n        dropIndices: boolean = true,\n    ): Promise<void> {\n        // It needs because if table does not exist and dropForeignKeys or dropIndices is true, we don't need\n        // to perform drop queries for foreign keys and indices.\n        if (ifExist) {\n            const isTableExist = await this.hasTable(target)\n            if (!isTableExist) return Promise.resolve()\n        }\n\n        // if dropTable called with dropForeignKeys = true, we must create foreign keys in down query.\n        const createForeignKeys: boolean = dropForeignKeys\n        const tablePath = this.getTablePath(target)\n        const table = await this.getCachedTable(tablePath)\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        if (dropIndices) {\n            table.indices.forEach((index) => {\n                upQueries.push(this.dropIndexSql(table, index))\n                downQueries.push(this.createIndexSql(table, index))\n            })\n        }\n\n        if (dropForeignKeys)\n            table.foreignKeys.forEach((foreignKey) =>\n                upQueries.push(this.dropForeignKeySql(table, foreignKey)),\n            )\n\n        upQueries.push(this.dropTableSql(table))\n        downQueries.push(this.createTableSql(table, createForeignKeys))\n\n        // if table had columns with generated type, we must remove the expression from the metadata table\n        const generatedColumns = table.columns.filter(\n            (column) => column.generatedType && column.asExpression,\n        )\n        for (const column of generatedColumns) {\n            const tableNameWithSchema = (\n                await this.getTableNameWithSchema(table.name)\n            ).split(\".\")\n            const tableName = tableNameWithSchema[1]\n            const schema = tableNameWithSchema[0]\n\n            const deleteQuery = this.deleteTypeormMetadataSql({\n                database: this.driver.database,\n                schema,\n                table: tableName,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n            })\n\n            const insertQuery = this.insertTypeormMetadataSql({\n                database: this.driver.database,\n                schema,\n                table: tableName,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n                value: column.asExpression,\n            })\n\n            upQueries.push(deleteQuery)\n            downQueries.push(insertQuery)\n        }\n\n        await this.executeQueries(upQueries, downQueries)\n    }\n\n    /**\n     * Creates a new view.\n     */\n    async createView(view: View): Promise<void> {\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n        upQueries.push(this.createViewSql(view))\n        upQueries.push(await this.insertViewDefinitionSql(view))\n        downQueries.push(this.dropViewSql(view))\n        downQueries.push(await this.deleteViewDefinitionSql(view))\n        await this.executeQueries(upQueries, downQueries)\n    }\n\n    /**\n     * Drops the view.\n     */\n    async dropView(target: View | string): Promise<void> {\n        const viewName = InstanceChecker.isView(target) ? target.name : target\n        const view = await this.getCachedView(viewName)\n\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n        upQueries.push(await this.deleteViewDefinitionSql(view))\n        upQueries.push(this.dropViewSql(view))\n        downQueries.push(await this.insertViewDefinitionSql(view))\n        downQueries.push(this.createViewSql(view))\n        await this.executeQueries(upQueries, downQueries)\n    }\n\n    /**\n     * Renames the given table.\n     */\n    async renameTable(\n        oldTableOrName: Table | string,\n        newTableName: string,\n    ): Promise<void> {\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n        const oldTable = InstanceChecker.isTable(oldTableOrName)\n            ? oldTableOrName\n            : await this.getCachedTable(oldTableOrName)\n        const newTable = oldTable.clone()\n\n        const { schema: schemaName, tableName: oldTableName } =\n            this.driver.parseTableName(oldTable)\n\n        newTable.name = schemaName\n            ? `${schemaName}.${newTableName}`\n            : newTableName\n\n        upQueries.push(\n            new Query(\n                `ALTER TABLE ${this.escapePath(\n                    oldTable,\n                )} RENAME TO \"${newTableName}\"`,\n            ),\n        )\n        downQueries.push(\n            new Query(\n                `ALTER TABLE ${this.escapePath(\n                    newTable,\n                )} RENAME TO \"${oldTableName}\"`,\n            ),\n        )\n\n        // rename column primary key constraint if it has default constraint name\n        if (\n            newTable.primaryColumns.length > 0 &&\n            !newTable.primaryColumns[0].primaryKeyConstraintName\n        ) {\n            const columnNames = newTable.primaryColumns.map(\n                (column) => column.name,\n            )\n\n            const oldPkName = this.connection.namingStrategy.primaryKeyName(\n                oldTable,\n                columnNames,\n            )\n\n            const newPkName = this.connection.namingStrategy.primaryKeyName(\n                newTable,\n                columnNames,\n            )\n\n            upQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        newTable,\n                    )} RENAME CONSTRAINT \"${oldPkName}\" TO \"${newPkName}\"`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        newTable,\n                    )} RENAME CONSTRAINT \"${newPkName}\" TO \"${oldPkName}\"`,\n                ),\n            )\n        }\n\n        // rename sequences\n        newTable.columns.map((col) => {\n            if (col.isGenerated && col.generationStrategy === \"increment\") {\n                const sequencePath = this.buildSequencePath(oldTable, col.name)\n                const sequenceName = this.buildSequenceName(oldTable, col.name)\n\n                const newSequencePath = this.buildSequencePath(\n                    newTable,\n                    col.name,\n                )\n                const newSequenceName = this.buildSequenceName(\n                    newTable,\n                    col.name,\n                )\n\n                const up = `ALTER SEQUENCE ${this.escapePath(\n                    sequencePath,\n                )} RENAME TO \"${newSequenceName}\"`\n                const down = `ALTER SEQUENCE ${this.escapePath(\n                    newSequencePath,\n                )} RENAME TO \"${sequenceName}\"`\n\n                upQueries.push(new Query(up))\n                downQueries.push(new Query(down))\n            }\n        })\n\n        // rename unique constraints\n        newTable.uniques.forEach((unique) => {\n            const oldUniqueName =\n                this.connection.namingStrategy.uniqueConstraintName(\n                    oldTable,\n                    unique.columnNames,\n                )\n\n            // Skip renaming if Unique has user defined constraint name\n            if (unique.name !== oldUniqueName) return\n\n            // build new constraint name\n            const newUniqueName =\n                this.connection.namingStrategy.uniqueConstraintName(\n                    newTable,\n                    unique.columnNames,\n                )\n\n            // build queries\n            upQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        newTable,\n                    )} RENAME CONSTRAINT \"${\n                        unique.name\n                    }\" TO \"${newUniqueName}\"`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        newTable,\n                    )} RENAME CONSTRAINT \"${newUniqueName}\" TO \"${\n                        unique.name\n                    }\"`,\n                ),\n            )\n\n            // replace constraint name\n            unique.name = newUniqueName\n        })\n\n        // rename index constraints\n        newTable.indices.forEach((index) => {\n            const oldIndexName = this.connection.namingStrategy.indexName(\n                oldTable,\n                index.columnNames,\n                index.where,\n            )\n\n            // Skip renaming if Index has user defined constraint name\n            if (index.name !== oldIndexName) return\n\n            // build new constraint name\n            const { schema } = this.driver.parseTableName(newTable)\n            const newIndexName = this.connection.namingStrategy.indexName(\n                newTable,\n                index.columnNames,\n                index.where,\n            )\n\n            // build queries\n            const up = schema\n                ? `ALTER INDEX \"${schema}\".\"${index.name}\" RENAME TO \"${newIndexName}\"`\n                : `ALTER INDEX \"${index.name}\" RENAME TO \"${newIndexName}\"`\n            const down = schema\n                ? `ALTER INDEX \"${schema}\".\"${newIndexName}\" RENAME TO \"${index.name}\"`\n                : `ALTER INDEX \"${newIndexName}\" RENAME TO \"${index.name}\"`\n            upQueries.push(new Query(up))\n            downQueries.push(new Query(down))\n\n            // replace constraint name\n            index.name = newIndexName\n        })\n\n        // rename foreign key constraints\n        newTable.foreignKeys.forEach((foreignKey) => {\n            const oldForeignKeyName =\n                this.connection.namingStrategy.foreignKeyName(\n                    oldTable,\n                    foreignKey.columnNames,\n                    this.getTablePath(foreignKey),\n                    foreignKey.referencedColumnNames,\n                )\n\n            // Skip renaming if foreign key has user defined constraint name\n            if (foreignKey.name !== oldForeignKeyName) return\n\n            // build new constraint name\n            const newForeignKeyName =\n                this.connection.namingStrategy.foreignKeyName(\n                    newTable,\n                    foreignKey.columnNames,\n                    this.getTablePath(foreignKey),\n                    foreignKey.referencedColumnNames,\n                )\n\n            // build queries\n            upQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        newTable,\n                    )} RENAME CONSTRAINT \"${\n                        foreignKey.name\n                    }\" TO \"${newForeignKeyName}\"`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        newTable,\n                    )} RENAME CONSTRAINT \"${newForeignKeyName}\" TO \"${\n                        foreignKey.name\n                    }\"`,\n                ),\n            )\n\n            // replace constraint name\n            foreignKey.name = newForeignKeyName\n        })\n\n        // rename ENUM types\n        const enumColumns = newTable.columns.filter(\n            (column) => column.type === \"enum\" || column.type === \"simple-enum\",\n        )\n        for (let column of enumColumns) {\n            // skip renaming for user-defined enum name\n            if (column.enumName) continue\n\n            const oldEnumType = await this.getUserDefinedTypeName(\n                oldTable,\n                column,\n            )\n            upQueries.push(\n                new Query(\n                    `ALTER TYPE \"${oldEnumType.schema}\".\"${\n                        oldEnumType.name\n                    }\" RENAME TO ${this.buildEnumName(\n                        newTable,\n                        column,\n                        false,\n                    )}`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `ALTER TYPE ${this.buildEnumName(\n                        newTable,\n                        column,\n                    )} RENAME TO \"${oldEnumType.name}\"`,\n                ),\n            )\n        }\n        await this.executeQueries(upQueries, downQueries)\n    }\n\n    /**\n     * Creates a new column from the column in the table.\n     */\n    async addColumn(\n        tableOrName: Table | string,\n        column: TableColumn,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const clonedTable = table.clone()\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        if (column.type === \"enum\" || column.type === \"simple-enum\") {\n            const hasEnum = await this.hasEnumType(table, column)\n            if (!hasEnum) {\n                upQueries.push(this.createEnumTypeSql(table, column))\n                downQueries.push(this.dropEnumTypeSql(table, column))\n            }\n        }\n\n        upQueries.push(\n            new Query(\n                `ALTER TABLE ${this.escapePath(\n                    table,\n                )} ADD ${this.buildCreateColumnSql(table, column)}`,\n            ),\n        )\n        downQueries.push(\n            new Query(\n                `ALTER TABLE ${this.escapePath(table)} DROP COLUMN \"${\n                    column.name\n                }\"`,\n            ),\n        )\n\n        // create or update primary key constraint\n        if (column.isPrimary) {\n            const primaryColumns = clonedTable.primaryColumns\n            // if table already have primary key, me must drop it and recreate again\n            if (primaryColumns.length > 0) {\n                const pkName = primaryColumns[0].primaryKeyConstraintName\n                    ? primaryColumns[0].primaryKeyConstraintName\n                    : this.connection.namingStrategy.primaryKeyName(\n                          clonedTable,\n                          primaryColumns.map((column) => column.name),\n                      )\n\n                const columnNames = primaryColumns\n                    .map((column) => `\"${column.name}\"`)\n                    .join(\", \")\n\n                upQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(\n                            table,\n                        )} DROP CONSTRAINT \"${pkName}\"`,\n                    ),\n                )\n                downQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(\n                            table,\n                        )} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`,\n                    ),\n                )\n            }\n\n            primaryColumns.push(column)\n            const pkName = primaryColumns[0].primaryKeyConstraintName\n                ? primaryColumns[0].primaryKeyConstraintName\n                : this.connection.namingStrategy.primaryKeyName(\n                      clonedTable,\n                      primaryColumns.map((column) => column.name),\n                  )\n\n            const columnNames = primaryColumns\n                .map((column) => `\"${column.name}\"`)\n                .join(\", \")\n\n            upQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        table,\n                    )} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        table,\n                    )} DROP CONSTRAINT \"${pkName}\"`,\n                ),\n            )\n        }\n\n        // create column index\n        const columnIndex = clonedTable.indices.find(\n            (index) =>\n                index.columnNames.length === 1 &&\n                index.columnNames[0] === column.name,\n        )\n        if (columnIndex) {\n            upQueries.push(this.createIndexSql(table, columnIndex))\n            downQueries.push(this.dropIndexSql(table, columnIndex))\n        }\n\n        // create unique constraint\n        if (column.isUnique) {\n            const uniqueConstraint = new TableUnique({\n                name: this.connection.namingStrategy.uniqueConstraintName(\n                    table,\n                    [column.name],\n                ),\n                columnNames: [column.name],\n            })\n            clonedTable.uniques.push(uniqueConstraint)\n            upQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${\n                        uniqueConstraint.name\n                    }\" UNIQUE (\"${column.name}\")`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${\n                        uniqueConstraint.name\n                    }\"`,\n                ),\n            )\n        }\n\n        if (column.generatedType === \"STORED\" && column.asExpression) {\n            const tableNameWithSchema = (\n                await this.getTableNameWithSchema(table.name)\n            ).split(\".\")\n            const tableName = tableNameWithSchema[1]\n            const schema = tableNameWithSchema[0]\n\n            const insertQuery = this.insertTypeormMetadataSql({\n                database: this.driver.database,\n                schema,\n                table: tableName,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n                value: column.asExpression,\n            })\n\n            const deleteQuery = this.deleteTypeormMetadataSql({\n                database: this.driver.database,\n                schema,\n                table: tableName,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n            })\n\n            upQueries.push(insertQuery)\n            downQueries.push(deleteQuery)\n        }\n\n        // create column's comment\n        if (column.comment) {\n            upQueries.push(\n                new Query(\n                    `COMMENT ON COLUMN ${this.escapePath(table)}.\"${\n                        column.name\n                    }\" IS ${this.escapeComment(column.comment)}`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `COMMENT ON COLUMN ${this.escapePath(table)}.\"${\n                        column.name\n                    }\" IS ${this.escapeComment(column.comment)}`,\n                ),\n            )\n        }\n\n        await this.executeQueries(upQueries, downQueries)\n\n        clonedTable.addColumn(column)\n        this.replaceCachedTable(table, clonedTable)\n    }\n\n    /**\n     * Creates a new columns from the column in the table.\n     */\n    async addColumns(\n        tableOrName: Table | string,\n        columns: TableColumn[],\n    ): Promise<void> {\n        for (const column of columns) {\n            await this.addColumn(tableOrName, column)\n        }\n    }\n\n    /**\n     * Renames column in the given table.\n     */\n    async renameColumn(\n        tableOrName: Table | string,\n        oldTableColumnOrName: TableColumn | string,\n        newTableColumnOrName: TableColumn | string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const oldColumn = InstanceChecker.isTableColumn(oldTableColumnOrName)\n            ? oldTableColumnOrName\n            : table.columns.find((c) => c.name === oldTableColumnOrName)\n        if (!oldColumn)\n            throw new TypeORMError(\n                `Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`,\n            )\n\n        let newColumn\n        if (InstanceChecker.isTableColumn(newTableColumnOrName)) {\n            newColumn = newTableColumnOrName\n        } else {\n            newColumn = oldColumn.clone()\n            newColumn.name = newTableColumnOrName\n        }\n\n        return this.changeColumn(table, oldColumn, newColumn)\n    }\n\n    /**\n     * Changes a column in the table.\n     */\n    async changeColumn(\n        tableOrName: Table | string,\n        oldTableColumnOrName: TableColumn | string,\n        newColumn: TableColumn,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        let clonedTable = table.clone()\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n        let defaultValueChanged = false\n\n        const oldColumn = InstanceChecker.isTableColumn(oldTableColumnOrName)\n            ? oldTableColumnOrName\n            : table.columns.find(\n                  (column) => column.name === oldTableColumnOrName,\n              )\n        if (!oldColumn)\n            throw new TypeORMError(\n                `Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`,\n            )\n\n        if (\n            oldColumn.type !== newColumn.type ||\n            oldColumn.length !== newColumn.length ||\n            newColumn.isArray !== oldColumn.isArray ||\n            (!oldColumn.generatedType &&\n                newColumn.generatedType === \"STORED\") ||\n            (oldColumn.asExpression !== newColumn.asExpression &&\n                newColumn.generatedType === \"STORED\")\n        ) {\n            // To avoid data conversion, we just recreate column\n            await this.dropColumn(table, oldColumn)\n            await this.addColumn(table, newColumn)\n\n            // update cloned table\n            clonedTable = table.clone()\n        } else {\n            if (oldColumn.name !== newColumn.name) {\n                // rename column\n                upQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(table)} RENAME COLUMN \"${\n                            oldColumn.name\n                        }\" TO \"${newColumn.name}\"`,\n                    ),\n                )\n                downQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(table)} RENAME COLUMN \"${\n                            newColumn.name\n                        }\" TO \"${oldColumn.name}\"`,\n                    ),\n                )\n\n                // rename ENUM type\n                if (\n                    oldColumn.type === \"enum\" ||\n                    oldColumn.type === \"simple-enum\"\n                ) {\n                    const oldEnumType = await this.getUserDefinedTypeName(\n                        table,\n                        oldColumn,\n                    )\n                    upQueries.push(\n                        new Query(\n                            `ALTER TYPE \"${oldEnumType.schema}\".\"${\n                                oldEnumType.name\n                            }\" RENAME TO ${this.buildEnumName(\n                                table,\n                                newColumn,\n                                false,\n                            )}`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TYPE ${this.buildEnumName(\n                                table,\n                                newColumn,\n                            )} RENAME TO \"${oldEnumType.name}\"`,\n                        ),\n                    )\n                }\n\n                // rename column primary key constraint\n                if (\n                    oldColumn.isPrimary === true &&\n                    !oldColumn.primaryKeyConstraintName\n                ) {\n                    const primaryColumns = clonedTable.primaryColumns\n\n                    // build old primary constraint name\n                    const columnNames = primaryColumns.map(\n                        (column) => column.name,\n                    )\n                    const oldPkName =\n                        this.connection.namingStrategy.primaryKeyName(\n                            clonedTable,\n                            columnNames,\n                        )\n\n                    // replace old column name with new column name\n                    columnNames.splice(columnNames.indexOf(oldColumn.name), 1)\n                    columnNames.push(newColumn.name)\n\n                    // build new primary constraint name\n                    const newPkName =\n                        this.connection.namingStrategy.primaryKeyName(\n                            clonedTable,\n                            columnNames,\n                        )\n\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} RENAME CONSTRAINT \"${oldPkName}\" TO \"${newPkName}\"`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} RENAME CONSTRAINT \"${newPkName}\" TO \"${oldPkName}\"`,\n                        ),\n                    )\n                }\n\n                // rename column sequence\n                if (\n                    oldColumn.isGenerated === true &&\n                    newColumn.generationStrategy === \"increment\"\n                ) {\n                    const sequencePath = this.buildSequencePath(\n                        table,\n                        oldColumn.name,\n                    )\n                    const sequenceName = this.buildSequenceName(\n                        table,\n                        oldColumn.name,\n                    )\n\n                    const newSequencePath = this.buildSequencePath(\n                        table,\n                        newColumn.name,\n                    )\n                    const newSequenceName = this.buildSequenceName(\n                        table,\n                        newColumn.name,\n                    )\n\n                    const up = `ALTER SEQUENCE ${this.escapePath(\n                        sequencePath,\n                    )} RENAME TO \"${newSequenceName}\"`\n                    const down = `ALTER SEQUENCE ${this.escapePath(\n                        newSequencePath,\n                    )} RENAME TO \"${sequenceName}\"`\n\n                    upQueries.push(new Query(up))\n                    downQueries.push(new Query(down))\n                }\n\n                // rename unique constraints\n                clonedTable.findColumnUniques(oldColumn).forEach((unique) => {\n                    const oldUniqueName =\n                        this.connection.namingStrategy.uniqueConstraintName(\n                            clonedTable,\n                            unique.columnNames,\n                        )\n\n                    // Skip renaming if Unique has user defined constraint name\n                    if (unique.name !== oldUniqueName) return\n\n                    // build new constraint name\n                    unique.columnNames.splice(\n                        unique.columnNames.indexOf(oldColumn.name),\n                        1,\n                    )\n                    unique.columnNames.push(newColumn.name)\n                    const newUniqueName =\n                        this.connection.namingStrategy.uniqueConstraintName(\n                            clonedTable,\n                            unique.columnNames,\n                        )\n\n                    // build queries\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} RENAME CONSTRAINT \"${\n                                unique.name\n                            }\" TO \"${newUniqueName}\"`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} RENAME CONSTRAINT \"${newUniqueName}\" TO \"${\n                                unique.name\n                            }\"`,\n                        ),\n                    )\n\n                    // replace constraint name\n                    unique.name = newUniqueName\n                })\n\n                // rename index constraints\n                clonedTable.findColumnIndices(oldColumn).forEach((index) => {\n                    const oldIndexName =\n                        this.connection.namingStrategy.indexName(\n                            clonedTable,\n                            index.columnNames,\n                            index.where,\n                        )\n\n                    // Skip renaming if Index has user defined constraint name\n                    if (index.name !== oldIndexName) return\n\n                    // build new constraint name\n                    index.columnNames.splice(\n                        index.columnNames.indexOf(oldColumn.name),\n                        1,\n                    )\n                    index.columnNames.push(newColumn.name)\n                    const { schema } = this.driver.parseTableName(table)\n                    const newIndexName =\n                        this.connection.namingStrategy.indexName(\n                            clonedTable,\n                            index.columnNames,\n                            index.where,\n                        )\n\n                    // build queries\n                    const up = schema\n                        ? `ALTER INDEX \"${schema}\".\"${index.name}\" RENAME TO \"${newIndexName}\"`\n                        : `ALTER INDEX \"${index.name}\" RENAME TO \"${newIndexName}\"`\n                    const down = schema\n                        ? `ALTER INDEX \"${schema}\".\"${newIndexName}\" RENAME TO \"${index.name}\"`\n                        : `ALTER INDEX \"${newIndexName}\" RENAME TO \"${index.name}\"`\n\n                    upQueries.push(new Query(up))\n                    downQueries.push(new Query(down))\n\n                    // replace constraint name\n                    index.name = newIndexName\n                })\n\n                // rename foreign key constraints\n                clonedTable\n                    .findColumnForeignKeys(oldColumn)\n                    .forEach((foreignKey) => {\n                        const foreignKeyName =\n                            this.connection.namingStrategy.foreignKeyName(\n                                clonedTable,\n                                foreignKey.columnNames,\n                                this.getTablePath(foreignKey),\n                                foreignKey.referencedColumnNames,\n                            )\n\n                        // Skip renaming if foreign key has user defined constraint name\n                        if (foreignKey.name !== foreignKeyName) return\n\n                        // build new constraint name\n                        foreignKey.columnNames.splice(\n                            foreignKey.columnNames.indexOf(oldColumn.name),\n                            1,\n                        )\n                        foreignKey.columnNames.push(newColumn.name)\n                        const newForeignKeyName =\n                            this.connection.namingStrategy.foreignKeyName(\n                                clonedTable,\n                                foreignKey.columnNames,\n                                this.getTablePath(foreignKey),\n                                foreignKey.referencedColumnNames,\n                            )\n\n                        // build queries\n                        upQueries.push(\n                            new Query(\n                                `ALTER TABLE ${this.escapePath(\n                                    table,\n                                )} RENAME CONSTRAINT \"${\n                                    foreignKey.name\n                                }\" TO \"${newForeignKeyName}\"`,\n                            ),\n                        )\n                        downQueries.push(\n                            new Query(\n                                `ALTER TABLE ${this.escapePath(\n                                    table,\n                                )} RENAME CONSTRAINT \"${newForeignKeyName}\" TO \"${\n                                    foreignKey.name\n                                }\"`,\n                            ),\n                        )\n\n                        // replace constraint name\n                        foreignKey.name = newForeignKeyName\n                    })\n\n                // rename old column in the Table object\n                const oldTableColumn = clonedTable.columns.find(\n                    (column) => column.name === oldColumn.name,\n                )\n                clonedTable.columns[\n                    clonedTable.columns.indexOf(oldTableColumn!)\n                ].name = newColumn.name\n                oldColumn.name = newColumn.name\n            }\n\n            if (\n                newColumn.precision !== oldColumn.precision ||\n                newColumn.scale !== oldColumn.scale\n            ) {\n                upQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${\n                            newColumn.name\n                        }\" TYPE ${this.driver.createFullType(newColumn)}`,\n                    ),\n                )\n                downQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${\n                            newColumn.name\n                        }\" TYPE ${this.driver.createFullType(oldColumn)}`,\n                    ),\n                )\n            }\n\n            if (\n                (newColumn.type === \"enum\" ||\n                    newColumn.type === \"simple-enum\") &&\n                (oldColumn.type === \"enum\" ||\n                    oldColumn.type === \"simple-enum\") &&\n                (!OrmUtils.isArraysEqual(newColumn.enum!, oldColumn.enum!) ||\n                    newColumn.enumName !== oldColumn.enumName)\n            ) {\n                const arraySuffix = newColumn.isArray ? \"[]\" : \"\"\n\n                // \"public\".\"new_enum\"\n                const newEnumName = this.buildEnumName(table, newColumn)\n\n                // \"public\".\"old_enum\"\n                const oldEnumName = this.buildEnumName(table, oldColumn)\n\n                // \"old_enum\"\n                const oldEnumNameWithoutSchema = this.buildEnumName(\n                    table,\n                    oldColumn,\n                    false,\n                )\n\n                //\"public\".\"old_enum_old\"\n                const oldEnumNameWithSchema_old = this.buildEnumName(\n                    table,\n                    oldColumn,\n                    true,\n                    false,\n                    true,\n                )\n\n                //\"old_enum_old\"\n                const oldEnumNameWithoutSchema_old = this.buildEnumName(\n                    table,\n                    oldColumn,\n                    false,\n                    false,\n                    true,\n                )\n\n                // rename old ENUM\n                upQueries.push(\n                    new Query(\n                        `ALTER TYPE ${oldEnumName} RENAME TO ${oldEnumNameWithoutSchema_old}`,\n                    ),\n                )\n                downQueries.push(\n                    new Query(\n                        `ALTER TYPE ${oldEnumNameWithSchema_old} RENAME TO ${oldEnumNameWithoutSchema}`,\n                    ),\n                )\n\n                // create new ENUM\n                upQueries.push(\n                    this.createEnumTypeSql(table, newColumn, newEnumName),\n                )\n                downQueries.push(\n                    this.dropEnumTypeSql(table, newColumn, newEnumName),\n                )\n\n                // if column have default value, we must drop it to avoid issues with type casting\n                if (\n                    oldColumn.default !== null &&\n                    oldColumn.default !== undefined\n                ) {\n                    // mark default as changed to prevent double update\n                    defaultValueChanged = true\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ALTER COLUMN \"${oldColumn.name}\" DROP DEFAULT`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ALTER COLUMN \"${oldColumn.name}\" SET DEFAULT ${\n                                oldColumn.default\n                            }`,\n                        ),\n                    )\n                }\n\n                // build column types\n                const upType = `${newEnumName}${arraySuffix} USING \"${newColumn.name}\"::\"text\"::${newEnumName}${arraySuffix}`\n                const downType = `${oldEnumNameWithSchema_old}${arraySuffix} USING \"${newColumn.name}\"::\"text\"::${oldEnumNameWithSchema_old}${arraySuffix}`\n\n                // update column to use new type\n                upQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${\n                            newColumn.name\n                        }\" TYPE ${upType}`,\n                    ),\n                )\n                downQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${\n                            newColumn.name\n                        }\" TYPE ${downType}`,\n                    ),\n                )\n\n                // restore column default or create new one\n                if (\n                    newColumn.default !== null &&\n                    newColumn.default !== undefined\n                ) {\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ALTER COLUMN \"${newColumn.name}\" SET DEFAULT ${\n                                newColumn.default\n                            }`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ALTER COLUMN \"${newColumn.name}\" DROP DEFAULT`,\n                        ),\n                    )\n                }\n\n                // remove old ENUM\n                upQueries.push(\n                    this.dropEnumTypeSql(\n                        table,\n                        oldColumn,\n                        oldEnumNameWithSchema_old,\n                    ),\n                )\n                downQueries.push(\n                    this.createEnumTypeSql(\n                        table,\n                        oldColumn,\n                        oldEnumNameWithSchema_old,\n                    ),\n                )\n            }\n\n            if (oldColumn.isNullable !== newColumn.isNullable) {\n                if (newColumn.isNullable) {\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ALTER COLUMN \"${oldColumn.name}\" DROP NOT NULL`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ALTER COLUMN \"${oldColumn.name}\" SET NOT NULL`,\n                        ),\n                    )\n                } else {\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ALTER COLUMN \"${oldColumn.name}\" SET NOT NULL`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ALTER COLUMN \"${oldColumn.name}\" DROP NOT NULL`,\n                        ),\n                    )\n                }\n            }\n\n            if (oldColumn.comment !== newColumn.comment) {\n                upQueries.push(\n                    new Query(\n                        `COMMENT ON COLUMN ${this.escapePath(table)}.\"${\n                            oldColumn.name\n                        }\" IS ${this.escapeComment(newColumn.comment)}`,\n                    ),\n                )\n                downQueries.push(\n                    new Query(\n                        `COMMENT ON COLUMN ${this.escapePath(table)}.\"${\n                            newColumn.name\n                        }\" IS ${this.escapeComment(oldColumn.comment)}`,\n                    ),\n                )\n            }\n\n            if (newColumn.isPrimary !== oldColumn.isPrimary) {\n                const primaryColumns = clonedTable.primaryColumns\n\n                // if primary column state changed, we must always drop existed constraint.\n                if (primaryColumns.length > 0) {\n                    const pkName = primaryColumns[0].primaryKeyConstraintName\n                        ? primaryColumns[0].primaryKeyConstraintName\n                        : this.connection.namingStrategy.primaryKeyName(\n                              clonedTable,\n                              primaryColumns.map((column) => column.name),\n                          )\n\n                    const columnNames = primaryColumns\n                        .map((column) => `\"${column.name}\"`)\n                        .join(\", \")\n\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} DROP CONSTRAINT \"${pkName}\"`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`,\n                        ),\n                    )\n                }\n\n                if (newColumn.isPrimary === true) {\n                    primaryColumns.push(newColumn)\n                    // update column in table\n                    const column = clonedTable.columns.find(\n                        (column) => column.name === newColumn.name,\n                    )\n                    column!.isPrimary = true\n                    const pkName = primaryColumns[0].primaryKeyConstraintName\n                        ? primaryColumns[0].primaryKeyConstraintName\n                        : this.connection.namingStrategy.primaryKeyName(\n                              clonedTable,\n                              primaryColumns.map((column) => column.name),\n                          )\n\n                    const columnNames = primaryColumns\n                        .map((column) => `\"${column.name}\"`)\n                        .join(\", \")\n\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} DROP CONSTRAINT \"${pkName}\"`,\n                        ),\n                    )\n                } else {\n                    const primaryColumn = primaryColumns.find(\n                        (c) => c.name === newColumn.name,\n                    )\n                    primaryColumns.splice(\n                        primaryColumns.indexOf(primaryColumn!),\n                        1,\n                    )\n\n                    // update column in table\n                    const column = clonedTable.columns.find(\n                        (column) => column.name === newColumn.name,\n                    )\n                    column!.isPrimary = false\n\n                    // if we have another primary keys, we must recreate constraint.\n                    if (primaryColumns.length > 0) {\n                        const pkName = primaryColumns[0]\n                            .primaryKeyConstraintName\n                            ? primaryColumns[0].primaryKeyConstraintName\n                            : this.connection.namingStrategy.primaryKeyName(\n                                  clonedTable,\n                                  primaryColumns.map((column) => column.name),\n                              )\n\n                        const columnNames = primaryColumns\n                            .map((column) => `\"${column.name}\"`)\n                            .join(\", \")\n\n                        upQueries.push(\n                            new Query(\n                                `ALTER TABLE ${this.escapePath(\n                                    table,\n                                )} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`,\n                            ),\n                        )\n                        downQueries.push(\n                            new Query(\n                                `ALTER TABLE ${this.escapePath(\n                                    table,\n                                )} DROP CONSTRAINT \"${pkName}\"`,\n                            ),\n                        )\n                    }\n                }\n            }\n\n            if (newColumn.isUnique !== oldColumn.isUnique) {\n                if (newColumn.isUnique === true) {\n                    const uniqueConstraint = new TableUnique({\n                        name: this.connection.namingStrategy.uniqueConstraintName(\n                            table,\n                            [newColumn.name],\n                        ),\n                        columnNames: [newColumn.name],\n                    })\n                    clonedTable.uniques.push(uniqueConstraint)\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ADD CONSTRAINT \"${\n                                uniqueConstraint.name\n                            }\" UNIQUE (\"${newColumn.name}\")`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} DROP CONSTRAINT \"${uniqueConstraint.name}\"`,\n                        ),\n                    )\n                } else {\n                    const uniqueConstraint = clonedTable.uniques.find(\n                        (unique) => {\n                            return (\n                                unique.columnNames.length === 1 &&\n                                !!unique.columnNames.find(\n                                    (columnName) =>\n                                        columnName === newColumn.name,\n                                )\n                            )\n                        },\n                    )\n                    clonedTable.uniques.splice(\n                        clonedTable.uniques.indexOf(uniqueConstraint!),\n                        1,\n                    )\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} DROP CONSTRAINT \"${uniqueConstraint!.name}\"`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ADD CONSTRAINT \"${\n                                uniqueConstraint!.name\n                            }\" UNIQUE (\"${newColumn.name}\")`,\n                        ),\n                    )\n                }\n            }\n\n            if (oldColumn.isGenerated !== newColumn.isGenerated) {\n                // if old column was \"generated\", we should clear defaults\n                if (oldColumn.isGenerated) {\n                    if (oldColumn.generationStrategy === \"uuid\") {\n                        upQueries.push(\n                            new Query(\n                                `ALTER TABLE ${this.escapePath(\n                                    table,\n                                )} ALTER COLUMN \"${\n                                    oldColumn.name\n                                }\" DROP DEFAULT`,\n                            ),\n                        )\n                        downQueries.push(\n                            new Query(\n                                `ALTER TABLE ${this.escapePath(\n                                    table,\n                                )} ALTER COLUMN \"${\n                                    oldColumn.name\n                                }\" SET DEFAULT ${this.driver.uuidGenerator}`,\n                            ),\n                        )\n                    } else if (oldColumn.generationStrategy === \"increment\") {\n                        upQueries.push(\n                            new Query(\n                                `ALTER TABLE ${this.escapePath(\n                                    table,\n                                )} ALTER COLUMN \"${\n                                    newColumn.name\n                                }\" DROP DEFAULT`,\n                            ),\n                        )\n                        downQueries.push(\n                            new Query(\n                                `ALTER TABLE ${this.escapePath(\n                                    table,\n                                )} ALTER COLUMN \"${\n                                    newColumn.name\n                                }\" SET DEFAULT nextval('${this.escapePath(\n                                    this.buildSequencePath(table, newColumn),\n                                )}')`,\n                            ),\n                        )\n\n                        upQueries.push(\n                            new Query(\n                                `DROP SEQUENCE ${this.escapePath(\n                                    this.buildSequencePath(table, newColumn),\n                                )}`,\n                            ),\n                        )\n                        downQueries.push(\n                            new Query(\n                                `CREATE SEQUENCE IF NOT EXISTS ${this.escapePath(\n                                    this.buildSequencePath(table, newColumn),\n                                )} OWNED BY ${this.escapePath(table)}.\"${\n                                    newColumn.name\n                                }\"`,\n                            ),\n                        )\n                    }\n                }\n\n                if (newColumn.generationStrategy === \"uuid\") {\n                    if (newColumn.isGenerated === true) {\n                        upQueries.push(\n                            new Query(\n                                `ALTER TABLE ${this.escapePath(\n                                    table,\n                                )} ALTER COLUMN \"${\n                                    newColumn.name\n                                }\" SET DEFAULT ${this.driver.uuidGenerator}`,\n                            ),\n                        )\n                        downQueries.push(\n                            new Query(\n                                `ALTER TABLE ${this.escapePath(\n                                    table,\n                                )} ALTER COLUMN \"${\n                                    newColumn.name\n                                }\" DROP DEFAULT`,\n                            ),\n                        )\n                    } else {\n                        upQueries.push(\n                            new Query(\n                                `ALTER TABLE ${this.escapePath(\n                                    table,\n                                )} ALTER COLUMN \"${\n                                    newColumn.name\n                                }\" DROP DEFAULT`,\n                            ),\n                        )\n                        downQueries.push(\n                            new Query(\n                                `ALTER TABLE ${this.escapePath(\n                                    table,\n                                )} ALTER COLUMN \"${\n                                    newColumn.name\n                                }\" SET DEFAULT ${this.driver.uuidGenerator}`,\n                            ),\n                        )\n                    }\n                } else if (newColumn.generationStrategy === \"increment\") {\n                    if (newColumn.isGenerated === true) {\n                        upQueries.push(\n                            new Query(\n                                `CREATE SEQUENCE IF NOT EXISTS ${this.escapePath(\n                                    this.buildSequencePath(table, newColumn),\n                                )} OWNED BY ${this.escapePath(table)}.\"${\n                                    newColumn.name\n                                }\"`,\n                            ),\n                        )\n                        downQueries.push(\n                            new Query(\n                                `DROP SEQUENCE ${this.escapePath(\n                                    this.buildSequencePath(table, newColumn),\n                                )}`,\n                            ),\n                        )\n\n                        upQueries.push(\n                            new Query(\n                                `ALTER TABLE ${this.escapePath(\n                                    table,\n                                )} ALTER COLUMN \"${\n                                    newColumn.name\n                                }\" SET DEFAULT nextval('${this.escapePath(\n                                    this.buildSequencePath(table, newColumn),\n                                )}')`,\n                            ),\n                        )\n                        downQueries.push(\n                            new Query(\n                                `ALTER TABLE ${this.escapePath(\n                                    table,\n                                )} ALTER COLUMN \"${\n                                    newColumn.name\n                                }\" DROP DEFAULT`,\n                            ),\n                        )\n                    } else {\n                        upQueries.push(\n                            new Query(\n                                `ALTER TABLE ${this.escapePath(\n                                    table,\n                                )} ALTER COLUMN \"${\n                                    newColumn.name\n                                }\" DROP DEFAULT`,\n                            ),\n                        )\n                        downQueries.push(\n                            new Query(\n                                `ALTER TABLE ${this.escapePath(\n                                    table,\n                                )} ALTER COLUMN \"${\n                                    newColumn.name\n                                }\" SET DEFAULT nextval('${this.escapePath(\n                                    this.buildSequencePath(table, newColumn),\n                                )}')`,\n                            ),\n                        )\n\n                        upQueries.push(\n                            new Query(\n                                `DROP SEQUENCE ${this.escapePath(\n                                    this.buildSequencePath(table, newColumn),\n                                )}`,\n                            ),\n                        )\n                        downQueries.push(\n                            new Query(\n                                `CREATE SEQUENCE IF NOT EXISTS ${this.escapePath(\n                                    this.buildSequencePath(table, newColumn),\n                                )} OWNED BY ${this.escapePath(table)}.\"${\n                                    newColumn.name\n                                }\"`,\n                            ),\n                        )\n                    }\n                }\n            }\n\n            // the default might have changed when the enum changed\n            if (\n                newColumn.default !== oldColumn.default &&\n                !defaultValueChanged\n            ) {\n                if (\n                    newColumn.default !== null &&\n                    newColumn.default !== undefined\n                ) {\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ALTER COLUMN \"${newColumn.name}\" SET DEFAULT ${\n                                newColumn.default\n                            }`,\n                        ),\n                    )\n\n                    if (\n                        oldColumn.default !== null &&\n                        oldColumn.default !== undefined\n                    ) {\n                        downQueries.push(\n                            new Query(\n                                `ALTER TABLE ${this.escapePath(\n                                    table,\n                                )} ALTER COLUMN \"${\n                                    newColumn.name\n                                }\" SET DEFAULT ${oldColumn.default}`,\n                            ),\n                        )\n                    } else {\n                        downQueries.push(\n                            new Query(\n                                `ALTER TABLE ${this.escapePath(\n                                    table,\n                                )} ALTER COLUMN \"${\n                                    newColumn.name\n                                }\" DROP DEFAULT`,\n                            ),\n                        )\n                    }\n                } else if (\n                    oldColumn.default !== null &&\n                    oldColumn.default !== undefined\n                ) {\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ALTER COLUMN \"${newColumn.name}\" DROP DEFAULT`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ALTER COLUMN \"${newColumn.name}\" SET DEFAULT ${\n                                oldColumn.default\n                            }`,\n                        ),\n                    )\n                }\n            }\n\n            if (\n                (newColumn.spatialFeatureType || \"\").toLowerCase() !==\n                    (oldColumn.spatialFeatureType || \"\").toLowerCase() ||\n                newColumn.srid !== oldColumn.srid\n            ) {\n                upQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${\n                            newColumn.name\n                        }\" TYPE ${this.driver.createFullType(newColumn)}`,\n                    ),\n                )\n                downQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${\n                            newColumn.name\n                        }\" TYPE ${this.driver.createFullType(oldColumn)}`,\n                    ),\n                )\n            }\n\n            if (newColumn.generatedType !== oldColumn.generatedType) {\n                // Convert generated column data to normal column\n                if (\n                    !newColumn.generatedType ||\n                    newColumn.generatedType === \"VIRTUAL\"\n                ) {\n                    // We can copy the generated data to the new column\n                    const tableNameWithSchema = (\n                        await this.getTableNameWithSchema(table.name)\n                    ).split(\".\")\n                    const tableName = tableNameWithSchema[1]\n                    const schema = tableNameWithSchema[0]\n\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} RENAME COLUMN \"${oldColumn.name}\" TO \"TEMP_OLD_${\n                                oldColumn.name\n                            }\"`,\n                        ),\n                    )\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ADD ${this.buildCreateColumnSql(\n                                table,\n                                newColumn,\n                            )}`,\n                        ),\n                    )\n                    upQueries.push(\n                        new Query(\n                            `UPDATE ${this.escapePath(table)} SET \"${\n                                newColumn.name\n                            }\" = \"TEMP_OLD_${oldColumn.name}\"`,\n                        ),\n                    )\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} DROP COLUMN \"TEMP_OLD_${oldColumn.name}\"`,\n                        ),\n                    )\n                    upQueries.push(\n                        this.deleteTypeormMetadataSql({\n                            database: this.driver.database,\n                            schema,\n                            table: tableName,\n                            type: MetadataTableType.GENERATED_COLUMN,\n                            name: oldColumn.name,\n                        }),\n                    )\n                    // However, we can't copy it back on downgrade. It needs to regenerate.\n                    downQueries.push(\n                        this.insertTypeormMetadataSql({\n                            database: this.driver.database,\n                            schema,\n                            table: tableName,\n                            type: MetadataTableType.GENERATED_COLUMN,\n                            name: oldColumn.name,\n                            value: oldColumn.asExpression,\n                        }),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ADD ${this.buildCreateColumnSql(\n                                table,\n                                oldColumn,\n                            )}`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} DROP COLUMN \"${newColumn.name}\"`,\n                        ),\n                    )\n                    // downQueries.push(\n                    //     this.deleteTypeormMetadataSql({\n                    //         database: this.driver.database,\n                    //         schema,\n                    //         table: tableName,\n                    //         type: MetadataTableType.GENERATED_COLUMN,\n                    //         name: newColumn.name,\n                    //     }),\n                    // )\n                }\n            }\n        }\n\n        await this.executeQueries(upQueries, downQueries)\n        this.replaceCachedTable(table, clonedTable)\n    }\n\n    /**\n     * Changes a column in the table.\n     */\n    async changeColumns(\n        tableOrName: Table | string,\n        changedColumns: { newColumn: TableColumn; oldColumn: TableColumn }[],\n    ): Promise<void> {\n        for (const { oldColumn, newColumn } of changedColumns) {\n            await this.changeColumn(tableOrName, oldColumn, newColumn)\n        }\n    }\n\n    /**\n     * Drops column in the table.\n     */\n    async dropColumn(\n        tableOrName: Table | string,\n        columnOrName: TableColumn | string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const column = InstanceChecker.isTableColumn(columnOrName)\n            ? columnOrName\n            : table.findColumnByName(columnOrName)\n        if (!column)\n            throw new TypeORMError(\n                `Column \"${columnOrName}\" was not found in table \"${table.name}\"`,\n            )\n\n        const clonedTable = table.clone()\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        // drop primary key constraint\n        if (column.isPrimary) {\n            const pkName = column.primaryKeyConstraintName\n                ? column.primaryKeyConstraintName\n                : this.connection.namingStrategy.primaryKeyName(\n                      clonedTable,\n                      clonedTable.primaryColumns.map((column) => column.name),\n                  )\n\n            const columnNames = clonedTable.primaryColumns\n                .map((primaryColumn) => `\"${primaryColumn.name}\"`)\n                .join(\", \")\n\n            upQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        clonedTable,\n                    )} DROP CONSTRAINT \"${pkName}\"`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        clonedTable,\n                    )} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`,\n                ),\n            )\n\n            // update column in table\n            const tableColumn = clonedTable.findColumnByName(column.name)\n            tableColumn!.isPrimary = false\n\n            // if primary key have multiple columns, we must recreate it without dropped column\n            if (clonedTable.primaryColumns.length > 0) {\n                const pkName = clonedTable.primaryColumns[0]\n                    .primaryKeyConstraintName\n                    ? clonedTable.primaryColumns[0].primaryKeyConstraintName\n                    : this.connection.namingStrategy.primaryKeyName(\n                          clonedTable,\n                          clonedTable.primaryColumns.map(\n                              (column) => column.name,\n                          ),\n                      )\n\n                const columnNames = clonedTable.primaryColumns\n                    .map((primaryColumn) => `\"${primaryColumn.name}\"`)\n                    .join(\", \")\n\n                upQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(\n                            clonedTable,\n                        )} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`,\n                    ),\n                )\n                downQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(\n                            clonedTable,\n                        )} DROP CONSTRAINT \"${pkName}\"`,\n                    ),\n                )\n            }\n        }\n\n        // drop column index\n        const columnIndex = clonedTable.indices.find(\n            (index) =>\n                index.columnNames.length === 1 &&\n                index.columnNames[0] === column.name,\n        )\n        if (columnIndex) {\n            clonedTable.indices.splice(\n                clonedTable.indices.indexOf(columnIndex),\n                1,\n            )\n            upQueries.push(this.dropIndexSql(table, columnIndex))\n            downQueries.push(this.createIndexSql(table, columnIndex))\n        }\n\n        // drop column check\n        const columnCheck = clonedTable.checks.find(\n            (check) =>\n                !!check.columnNames &&\n                check.columnNames.length === 1 &&\n                check.columnNames[0] === column.name,\n        )\n        if (columnCheck) {\n            clonedTable.checks.splice(\n                clonedTable.checks.indexOf(columnCheck),\n                1,\n            )\n            upQueries.push(this.dropCheckConstraintSql(table, columnCheck))\n            downQueries.push(this.createCheckConstraintSql(table, columnCheck))\n        }\n\n        // drop column unique\n        const columnUnique = clonedTable.uniques.find(\n            (unique) =>\n                unique.columnNames.length === 1 &&\n                unique.columnNames[0] === column.name,\n        )\n        if (columnUnique) {\n            clonedTable.uniques.splice(\n                clonedTable.uniques.indexOf(columnUnique),\n                1,\n            )\n            upQueries.push(this.dropUniqueConstraintSql(table, columnUnique))\n            downQueries.push(\n                this.createUniqueConstraintSql(table, columnUnique),\n            )\n        }\n\n        upQueries.push(\n            new Query(\n                `ALTER TABLE ${this.escapePath(table)} DROP COLUMN \"${\n                    column.name\n                }\"`,\n            ),\n        )\n        downQueries.push(\n            new Query(\n                `ALTER TABLE ${this.escapePath(\n                    table,\n                )} ADD ${this.buildCreateColumnSql(table, column)}`,\n            ),\n        )\n\n        // drop enum type\n        if (column.type === \"enum\" || column.type === \"simple-enum\") {\n            const hasEnum = await this.hasEnumType(table, column)\n            if (hasEnum) {\n                const enumType = await this.getUserDefinedTypeName(\n                    table,\n                    column,\n                )\n                const escapedEnumName = `\"${enumType.schema}\".\"${enumType.name}\"`\n                upQueries.push(\n                    this.dropEnumTypeSql(table, column, escapedEnumName),\n                )\n                downQueries.push(\n                    this.createEnumTypeSql(table, column, escapedEnumName),\n                )\n            }\n        }\n\n        if (column.generatedType === \"STORED\") {\n            const tableNameWithSchema = (\n                await this.getTableNameWithSchema(table.name)\n            ).split(\".\")\n            const tableName = tableNameWithSchema[1]\n            const schema = tableNameWithSchema[0]\n            const deleteQuery = this.deleteTypeormMetadataSql({\n                database: this.driver.database,\n                schema,\n                table: tableName,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n            })\n            const insertQuery = this.insertTypeormMetadataSql({\n                database: this.driver.database,\n                schema,\n                table: tableName,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n                value: column.asExpression,\n            })\n\n            upQueries.push(deleteQuery)\n            downQueries.push(insertQuery)\n        }\n\n        await this.executeQueries(upQueries, downQueries)\n\n        clonedTable.removeColumn(column)\n        this.replaceCachedTable(table, clonedTable)\n    }\n\n    /**\n     * Drops the columns in the table.\n     */\n    async dropColumns(\n        tableOrName: Table | string,\n        columns: TableColumn[] | string[],\n    ): Promise<void> {\n        for (const column of columns) {\n            await this.dropColumn(tableOrName, column)\n        }\n    }\n\n    /**\n     * Creates a new primary key.\n     */\n    async createPrimaryKey(\n        tableOrName: Table | string,\n        columnNames: string[],\n        constraintName?: string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const clonedTable = table.clone()\n\n        const up = this.createPrimaryKeySql(table, columnNames, constraintName)\n\n        // mark columns as primary, because dropPrimaryKeySql build constraint name from table primary column names.\n        clonedTable.columns.forEach((column) => {\n            if (columnNames.find((columnName) => columnName === column.name))\n                column.isPrimary = true\n        })\n        const down = this.dropPrimaryKeySql(clonedTable)\n\n        await this.executeQueries(up, down)\n        this.replaceCachedTable(table, clonedTable)\n    }\n\n    /**\n     * Updates composite primary keys.\n     */\n    async updatePrimaryKeys(\n        tableOrName: Table | string,\n        columns: TableColumn[],\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const clonedTable = table.clone()\n        const columnNames = columns.map((column) => column.name)\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        // if table already have primary columns, we must drop them.\n        const primaryColumns = clonedTable.primaryColumns\n        if (primaryColumns.length > 0) {\n            const pkName = primaryColumns[0].primaryKeyConstraintName\n                ? primaryColumns[0].primaryKeyConstraintName\n                : this.connection.namingStrategy.primaryKeyName(\n                      clonedTable,\n                      primaryColumns.map((column) => column.name),\n                  )\n\n            const columnNamesString = primaryColumns\n                .map((column) => `\"${column.name}\"`)\n                .join(\", \")\n\n            upQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        table,\n                    )} DROP CONSTRAINT \"${pkName}\"`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        table,\n                    )} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNamesString})`,\n                ),\n            )\n        }\n\n        // update columns in table.\n        clonedTable.columns\n            .filter((column) => columnNames.indexOf(column.name) !== -1)\n            .forEach((column) => (column.isPrimary = true))\n\n        const pkName = primaryColumns[0].primaryKeyConstraintName\n            ? primaryColumns[0].primaryKeyConstraintName\n            : this.connection.namingStrategy.primaryKeyName(\n                  clonedTable,\n                  columnNames,\n              )\n\n        const columnNamesString = columnNames\n            .map((columnName) => `\"${columnName}\"`)\n            .join(\", \")\n\n        upQueries.push(\n            new Query(\n                `ALTER TABLE ${this.escapePath(\n                    table,\n                )} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNamesString})`,\n            ),\n        )\n        downQueries.push(\n            new Query(\n                `ALTER TABLE ${this.escapePath(\n                    table,\n                )} DROP CONSTRAINT \"${pkName}\"`,\n            ),\n        )\n\n        await this.executeQueries(upQueries, downQueries)\n        this.replaceCachedTable(table, clonedTable)\n    }\n\n    /**\n     * Drops a primary key.\n     */\n    async dropPrimaryKey(\n        tableOrName: Table | string,\n        constraintName?: string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const up = this.dropPrimaryKeySql(table)\n        const down = this.createPrimaryKeySql(\n            table,\n            table.primaryColumns.map((column) => column.name),\n            constraintName,\n        )\n        await this.executeQueries(up, down)\n        table.primaryColumns.forEach((column) => {\n            column.isPrimary = false\n        })\n    }\n\n    /**\n     * Creates new unique constraint.\n     */\n    async createUniqueConstraint(\n        tableOrName: Table | string,\n        uniqueConstraint: TableUnique,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n\n        // new unique constraint may be passed without name. In this case we generate unique name manually.\n        if (!uniqueConstraint.name)\n            uniqueConstraint.name =\n                this.connection.namingStrategy.uniqueConstraintName(\n                    table,\n                    uniqueConstraint.columnNames,\n                )\n\n        const up = this.createUniqueConstraintSql(table, uniqueConstraint)\n        const down = this.dropUniqueConstraintSql(table, uniqueConstraint)\n        await this.executeQueries(up, down)\n        table.addUniqueConstraint(uniqueConstraint)\n    }\n\n    /**\n     * Creates new unique constraints.\n     */\n    async createUniqueConstraints(\n        tableOrName: Table | string,\n        uniqueConstraints: TableUnique[],\n    ): Promise<void> {\n        for (const uniqueConstraint of uniqueConstraints) {\n            await this.createUniqueConstraint(tableOrName, uniqueConstraint)\n        }\n    }\n\n    /**\n     * Drops unique constraint.\n     */\n    async dropUniqueConstraint(\n        tableOrName: Table | string,\n        uniqueOrName: TableUnique | string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const uniqueConstraint = InstanceChecker.isTableUnique(uniqueOrName)\n            ? uniqueOrName\n            : table.uniques.find((u) => u.name === uniqueOrName)\n        if (!uniqueConstraint)\n            throw new TypeORMError(\n                `Supplied unique constraint was not found in table ${table.name}`,\n            )\n\n        const up = this.dropUniqueConstraintSql(table, uniqueConstraint)\n        const down = this.createUniqueConstraintSql(table, uniqueConstraint)\n        await this.executeQueries(up, down)\n        table.removeUniqueConstraint(uniqueConstraint)\n    }\n\n    /**\n     * Drops unique constraints.\n     */\n    async dropUniqueConstraints(\n        tableOrName: Table | string,\n        uniqueConstraints: TableUnique[],\n    ): Promise<void> {\n        for (const uniqueConstraint of uniqueConstraints) {\n            await this.dropUniqueConstraint(tableOrName, uniqueConstraint)\n        }\n    }\n\n    /**\n     * Creates new check constraint.\n     */\n    async createCheckConstraint(\n        tableOrName: Table | string,\n        checkConstraint: TableCheck,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n\n        // new unique constraint may be passed without name. In this case we generate unique name manually.\n        if (!checkConstraint.name)\n            checkConstraint.name =\n                this.connection.namingStrategy.checkConstraintName(\n                    table,\n                    checkConstraint.expression!,\n                )\n\n        const up = this.createCheckConstraintSql(table, checkConstraint)\n        const down = this.dropCheckConstraintSql(table, checkConstraint)\n        await this.executeQueries(up, down)\n        table.addCheckConstraint(checkConstraint)\n    }\n\n    /**\n     * Creates new check constraints.\n     */\n    async createCheckConstraints(\n        tableOrName: Table | string,\n        checkConstraints: TableCheck[],\n    ): Promise<void> {\n        const promises = checkConstraints.map((checkConstraint) =>\n            this.createCheckConstraint(tableOrName, checkConstraint),\n        )\n        await Promise.all(promises)\n    }\n\n    /**\n     * Drops check constraint.\n     */\n    async dropCheckConstraint(\n        tableOrName: Table | string,\n        checkOrName: TableCheck | string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const checkConstraint = InstanceChecker.isTableCheck(checkOrName)\n            ? checkOrName\n            : table.checks.find((c) => c.name === checkOrName)\n        if (!checkConstraint)\n            throw new TypeORMError(\n                `Supplied check constraint was not found in table ${table.name}`,\n            )\n\n        const up = this.dropCheckConstraintSql(table, checkConstraint)\n        const down = this.createCheckConstraintSql(table, checkConstraint)\n        await this.executeQueries(up, down)\n        table.removeCheckConstraint(checkConstraint)\n    }\n\n    /**\n     * Drops check constraints.\n     */\n    async dropCheckConstraints(\n        tableOrName: Table | string,\n        checkConstraints: TableCheck[],\n    ): Promise<void> {\n        const promises = checkConstraints.map((checkConstraint) =>\n            this.dropCheckConstraint(tableOrName, checkConstraint),\n        )\n        await Promise.all(promises)\n    }\n\n    /**\n     * Creates new exclusion constraint.\n     */\n    async createExclusionConstraint(\n        tableOrName: Table | string,\n        exclusionConstraint: TableExclusion,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n\n        // new unique constraint may be passed without name. In this case we generate unique name manually.\n        if (!exclusionConstraint.name)\n            exclusionConstraint.name =\n                this.connection.namingStrategy.exclusionConstraintName(\n                    table,\n                    exclusionConstraint.expression!,\n                )\n\n        const up = this.createExclusionConstraintSql(table, exclusionConstraint)\n        const down = this.dropExclusionConstraintSql(table, exclusionConstraint)\n        await this.executeQueries(up, down)\n        table.addExclusionConstraint(exclusionConstraint)\n    }\n\n    /**\n     * Creates new exclusion constraints.\n     */\n    async createExclusionConstraints(\n        tableOrName: Table | string,\n        exclusionConstraints: TableExclusion[],\n    ): Promise<void> {\n        const promises = exclusionConstraints.map((exclusionConstraint) =>\n            this.createExclusionConstraint(tableOrName, exclusionConstraint),\n        )\n        await Promise.all(promises)\n    }\n\n    /**\n     * Drops exclusion constraint.\n     */\n    async dropExclusionConstraint(\n        tableOrName: Table | string,\n        exclusionOrName: TableExclusion | string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const exclusionConstraint = InstanceChecker.isTableExclusion(\n            exclusionOrName,\n        )\n            ? exclusionOrName\n            : table.exclusions.find((c) => c.name === exclusionOrName)\n        if (!exclusionConstraint)\n            throw new TypeORMError(\n                `Supplied exclusion constraint was not found in table ${table.name}`,\n            )\n\n        const up = this.dropExclusionConstraintSql(table, exclusionConstraint)\n        const down = this.createExclusionConstraintSql(\n            table,\n            exclusionConstraint,\n        )\n        await this.executeQueries(up, down)\n        table.removeExclusionConstraint(exclusionConstraint)\n    }\n\n    /**\n     * Drops exclusion constraints.\n     */\n    async dropExclusionConstraints(\n        tableOrName: Table | string,\n        exclusionConstraints: TableExclusion[],\n    ): Promise<void> {\n        const promises = exclusionConstraints.map((exclusionConstraint) =>\n            this.dropExclusionConstraint(tableOrName, exclusionConstraint),\n        )\n        await Promise.all(promises)\n    }\n\n    /**\n     * Creates a new foreign key.\n     */\n    async createForeignKey(\n        tableOrName: Table | string,\n        foreignKey: TableForeignKey,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n\n        // new FK may be passed without name. In this case we generate FK name manually.\n        if (!foreignKey.name)\n            foreignKey.name = this.connection.namingStrategy.foreignKeyName(\n                table,\n                foreignKey.columnNames,\n                this.getTablePath(foreignKey),\n                foreignKey.referencedColumnNames,\n            )\n\n        const up = this.createForeignKeySql(table, foreignKey)\n        const down = this.dropForeignKeySql(table, foreignKey)\n        await this.executeQueries(up, down)\n        table.addForeignKey(foreignKey)\n    }\n\n    /**\n     * Creates a new foreign keys.\n     */\n    async createForeignKeys(\n        tableOrName: Table | string,\n        foreignKeys: TableForeignKey[],\n    ): Promise<void> {\n        for (const foreignKey of foreignKeys) {\n            await this.createForeignKey(tableOrName, foreignKey)\n        }\n    }\n\n    /**\n     * Drops a foreign key from the table.\n     */\n    async dropForeignKey(\n        tableOrName: Table | string,\n        foreignKeyOrName: TableForeignKey | string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const foreignKey = InstanceChecker.isTableForeignKey(foreignKeyOrName)\n            ? foreignKeyOrName\n            : table.foreignKeys.find((fk) => fk.name === foreignKeyOrName)\n        if (!foreignKey)\n            throw new TypeORMError(\n                `Supplied foreign key was not found in table ${table.name}`,\n            )\n\n        const up = this.dropForeignKeySql(table, foreignKey)\n        const down = this.createForeignKeySql(table, foreignKey)\n        await this.executeQueries(up, down)\n        table.removeForeignKey(foreignKey)\n    }\n\n    /**\n     * Drops a foreign keys from the table.\n     */\n    async dropForeignKeys(\n        tableOrName: Table | string,\n        foreignKeys: TableForeignKey[],\n    ): Promise<void> {\n        for (const foreignKey of foreignKeys) {\n            await this.dropForeignKey(tableOrName, foreignKey)\n        }\n    }\n\n    /**\n     * Creates a new index.\n     */\n    async createIndex(\n        tableOrName: Table | string,\n        index: TableIndex,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n\n        // new index may be passed without name. In this case we generate index name manually.\n        if (!index.name) index.name = this.generateIndexName(table, index)\n\n        const up = this.createIndexSql(table, index)\n        const down = this.dropIndexSql(table, index)\n        await this.executeQueries(up, down)\n        table.addIndex(index)\n    }\n\n    /**\n     * Creates a new indices\n     */\n    async createIndices(\n        tableOrName: Table | string,\n        indices: TableIndex[],\n    ): Promise<void> {\n        for (const index of indices) {\n            await this.createIndex(tableOrName, index)\n        }\n    }\n\n    /**\n     * Drops an index from the table.\n     */\n    async dropIndex(\n        tableOrName: Table | string,\n        indexOrName: TableIndex | string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const index = InstanceChecker.isTableIndex(indexOrName)\n            ? indexOrName\n            : table.indices.find((i) => i.name === indexOrName)\n        if (!index)\n            throw new TypeORMError(\n                `Supplied index ${indexOrName} was not found in table ${table.name}`,\n            )\n        // old index may be passed without name. In this case we generate index name manually.\n        if (!index.name) index.name = this.generateIndexName(table, index)\n\n        const up = this.dropIndexSql(table, index)\n        const down = this.createIndexSql(table, index)\n        await this.executeQueries(up, down)\n        table.removeIndex(index)\n    }\n\n    /**\n     * Drops an indices from the table.\n     */\n    async dropIndices(\n        tableOrName: Table | string,\n        indices: TableIndex[],\n    ): Promise<void> {\n        for (const index of indices) {\n            await this.dropIndex(tableOrName, index)\n        }\n    }\n\n    /**\n     * Clears all table contents.\n     * Note: this operation uses SQL's TRUNCATE query which cannot be reverted in transactions.\n     */\n    async clearTable(tableName: string): Promise<void> {\n        await this.query(`TRUNCATE TABLE ${this.escapePath(tableName)}`)\n    }\n\n    /**\n     * Removes all tables from the currently connected database.\n     */\n    async clearDatabase(): Promise<void> {\n        const schemas: string[] = []\n        this.connection.entityMetadatas\n            .filter((metadata) => metadata.schema)\n            .forEach((metadata) => {\n                const isSchemaExist = !!schemas.find(\n                    (schema) => schema === metadata.schema,\n                )\n                if (!isSchemaExist) schemas.push(metadata.schema!)\n            })\n        schemas.push(this.driver.options.schema || \"current_schema()\")\n        const schemaNamesString = schemas\n            .map((name) => {\n                return name === \"current_schema()\" ? name : \"'\" + name + \"'\"\n            })\n            .join(\", \")\n\n        const isAnotherTransactionActive = this.isTransactionActive\n        if (!isAnotherTransactionActive) await this.startTransaction()\n        try {\n            const version = await this.getVersion()\n            // drop views\n            const selectViewDropsQuery =\n                `SELECT 'DROP VIEW IF EXISTS \"' || schemaname || '\".\"' || viewname || '\" CASCADE;' as \"query\" ` +\n                `FROM \"pg_views\" WHERE \"schemaname\" IN (${schemaNamesString}) AND \"viewname\" NOT IN ('geography_columns', 'geometry_columns', 'raster_columns', 'raster_overviews')`\n            const dropViewQueries: ObjectLiteral[] = await this.query(\n                selectViewDropsQuery,\n            )\n            await Promise.all(\n                dropViewQueries.map((q) => this.query(q[\"query\"])),\n            )\n\n            // drop materialized views\n            // Note: materialized views introduced in Postgres 9.3\n            if (VersionUtils.isGreaterOrEqual(version, \"9.3\")) {\n                const selectMatViewDropsQuery =\n                    `SELECT 'DROP MATERIALIZED VIEW IF EXISTS \"' || schemaname || '\".\"' || matviewname || '\" CASCADE;' as \"query\" ` +\n                    `FROM \"pg_matviews\" WHERE \"schemaname\" IN (${schemaNamesString})`\n                const dropMatViewQueries: ObjectLiteral[] = await this.query(\n                    selectMatViewDropsQuery,\n                )\n                await Promise.all(\n                    dropMatViewQueries.map((q) => this.query(q[\"query\"])),\n                )\n            }\n\n            // ignore spatial_ref_sys; it's a special table supporting PostGIS\n            // TODO generalize this as this.driver.ignoreTables\n\n            // drop tables\n            const selectTableDropsQuery = `SELECT 'DROP TABLE IF EXISTS \"' || schemaname || '\".\"' || tablename || '\" CASCADE;' as \"query\" FROM \"pg_tables\" WHERE \"schemaname\" IN (${schemaNamesString}) AND \"tablename\" NOT IN ('spatial_ref_sys')`\n            const dropTableQueries: ObjectLiteral[] = await this.query(\n                selectTableDropsQuery,\n            )\n            await Promise.all(\n                dropTableQueries.map((q) => this.query(q[\"query\"])),\n            )\n\n            // drop enum types\n            await this.dropEnumTypes(schemaNamesString)\n\n            if (!isAnotherTransactionActive) {\n                await this.commitTransaction()\n            }\n        } catch (error) {\n            try {\n                // we throw original error even if rollback thrown an error\n                if (!isAnotherTransactionActive) {\n                    await this.rollbackTransaction()\n                }\n            } catch (rollbackError) {}\n            throw error\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    protected async loadViews(viewNames?: string[]): Promise<View[]> {\n        const hasTable = await this.hasTable(this.getTypeormMetadataTableName())\n\n        if (!hasTable) return []\n\n        if (!viewNames) {\n            viewNames = []\n        }\n\n        const currentDatabase = await this.getCurrentDatabase()\n        const currentSchema = await this.getCurrentSchema()\n        const viewsCondition =\n            viewNames.length === 0\n                ? \"1=1\"\n                : viewNames\n                      .map((tableName) => this.driver.parseTableName(tableName))\n                      .map(({ schema, tableName }) => {\n                          if (!schema) {\n                              schema =\n                                  this.driver.options.schema || currentSchema\n                          }\n\n                          return `(\"t\".\"schema\" = '${schema}' AND \"t\".\"name\" = '${tableName}')`\n                      })\n                      .join(\" OR \")\n\n        const query =\n            `SELECT \"t\".* FROM ${this.escapePath(\n                this.getTypeormMetadataTableName(),\n            )} \"t\" ` +\n            `INNER JOIN \"pg_catalog\".\"pg_class\" \"c\" ON \"c\".\"relname\" = \"t\".\"name\" ` +\n            `INNER JOIN \"pg_namespace\" \"n\" ON \"n\".\"oid\" = \"c\".\"relnamespace\" AND \"n\".\"nspname\" = \"t\".\"schema\" ` +\n            `WHERE \"t\".\"type\" IN ('${MetadataTableType.VIEW}', '${\n                MetadataTableType.MATERIALIZED_VIEW\n            }') ${viewsCondition ? `AND (${viewsCondition})` : \"\"}`\n\n        const dbViews = await this.query(query)\n        return dbViews.map((dbView: any) => {\n            const view = new View()\n            const schema =\n                dbView[\"schema\"] === currentSchema &&\n                !this.driver.options.schema\n                    ? undefined\n                    : dbView[\"schema\"]\n            view.database = currentDatabase\n            view.schema = dbView[\"schema\"]\n            view.name = this.driver.buildTableName(dbView[\"name\"], schema)\n            view.expression = dbView[\"value\"]\n            view.materialized =\n                dbView[\"type\"] === MetadataTableType.MATERIALIZED_VIEW\n            return view\n        })\n    }\n\n    /**\n     * Loads all tables (with given names) from the database and creates a Table from them.\n     */\n    protected async loadTables(tableNames?: string[]): Promise<Table[]> {\n        // if no tables given then no need to proceed\n        if (tableNames && tableNames.length === 0) {\n            return []\n        }\n\n        const currentSchema = await this.getCurrentSchema()\n        const currentDatabase = await this.getCurrentDatabase()\n\n        const dbTables: { table_schema: string; table_name: string }[] = []\n\n        if (!tableNames) {\n            const tablesSql = `SELECT \"table_schema\", \"table_name\" FROM \"information_schema\".\"tables\"`\n            dbTables.push(...(await this.query(tablesSql)))\n        } else {\n            const tablesCondition = tableNames\n                .map((tableName) => this.driver.parseTableName(tableName))\n                .map(({ schema, tableName }) => {\n                    return `(\"table_schema\" = '${\n                        schema || currentSchema\n                    }' AND \"table_name\" = '${tableName}')`\n                })\n                .join(\" OR \")\n\n            const tablesSql =\n                `SELECT \"table_schema\", \"table_name\" FROM \"information_schema\".\"tables\" WHERE ` +\n                tablesCondition\n            dbTables.push(...(await this.query(tablesSql)))\n        }\n\n        // if tables were not found in the db, no need to proceed\n        if (dbTables.length === 0) {\n            return []\n        }\n\n        /**\n         * Uses standard SQL information_schema.columns table and postgres-specific\n         * pg_catalog.pg_attribute table to get column information.\n         * @see https://stackoverflow.com/a/19541865\n         */\n        const columnsCondition = dbTables\n            .map(({ table_schema, table_name }) => {\n                return `(\"table_schema\" = '${table_schema}' AND \"table_name\" = '${table_name}')`\n            })\n            .join(\" OR \")\n        const columnsSql =\n            `SELECT columns.*, pg_catalog.col_description(('\"' || table_catalog || '\".\"' || table_schema || '\".\"' || table_name || '\"')::regclass::oid, ordinal_position) AS description, ` +\n            `('\"' || \"udt_schema\" || '\".\"' || \"udt_name\" || '\"')::\"regtype\" AS \"regtype\", pg_catalog.format_type(\"col_attr\".\"atttypid\", \"col_attr\".\"atttypmod\") AS \"format_type\" ` +\n            `FROM \"information_schema\".\"columns\" ` +\n            `LEFT JOIN \"pg_catalog\".\"pg_attribute\" AS \"col_attr\" ON \"col_attr\".\"attname\" = \"columns\".\"column_name\" ` +\n            `AND \"col_attr\".\"attrelid\" = ( ` +\n            `SELECT \"cls\".\"oid\" FROM \"pg_catalog\".\"pg_class\" AS \"cls\" ` +\n            `LEFT JOIN \"pg_catalog\".\"pg_namespace\" AS \"ns\" ON \"ns\".\"oid\" = \"cls\".\"relnamespace\" ` +\n            `WHERE \"cls\".\"relname\" = \"columns\".\"table_name\" ` +\n            `AND \"ns\".\"nspname\" = \"columns\".\"table_schema\" ` +\n            `) ` +\n            `WHERE ` +\n            columnsCondition\n\n        const constraintsCondition = dbTables\n            .map(({ table_schema, table_name }) => {\n                return `(\"ns\".\"nspname\" = '${table_schema}' AND \"t\".\"relname\" = '${table_name}')`\n            })\n            .join(\" OR \")\n\n        const constraintsSql =\n            `SELECT \"ns\".\"nspname\" AS \"table_schema\", \"t\".\"relname\" AS \"table_name\", \"cnst\".\"conname\" AS \"constraint_name\", ` +\n            `pg_get_constraintdef(\"cnst\".\"oid\") AS \"expression\", ` +\n            `CASE \"cnst\".\"contype\" WHEN 'p' THEN 'PRIMARY' WHEN 'u' THEN 'UNIQUE' WHEN 'c' THEN 'CHECK' WHEN 'x' THEN 'EXCLUDE' END AS \"constraint_type\", \"a\".\"attname\" AS \"column_name\" ` +\n            `FROM \"pg_constraint\" \"cnst\" ` +\n            `INNER JOIN \"pg_class\" \"t\" ON \"t\".\"oid\" = \"cnst\".\"conrelid\" ` +\n            `INNER JOIN \"pg_namespace\" \"ns\" ON \"ns\".\"oid\" = \"cnst\".\"connamespace\" ` +\n            `LEFT JOIN \"pg_attribute\" \"a\" ON \"a\".\"attrelid\" = \"cnst\".\"conrelid\" AND \"a\".\"attnum\" = ANY (\"cnst\".\"conkey\") ` +\n            `WHERE \"t\".\"relkind\" IN ('r', 'p') AND (${constraintsCondition})`\n\n        const indicesSql =\n            `SELECT \"ns\".\"nspname\" AS \"table_schema\", \"t\".\"relname\" AS \"table_name\", \"i\".\"relname\" AS \"constraint_name\", \"a\".\"attname\" AS \"column_name\", ` +\n            `CASE \"ix\".\"indisunique\" WHEN 't' THEN 'TRUE' ELSE'FALSE' END AS \"is_unique\", pg_get_expr(\"ix\".\"indpred\", \"ix\".\"indrelid\") AS \"condition\", ` +\n            `\"types\".\"typname\" AS \"type_name\" ` +\n            `FROM \"pg_class\" \"t\" ` +\n            `INNER JOIN \"pg_index\" \"ix\" ON \"ix\".\"indrelid\" = \"t\".\"oid\" ` +\n            `INNER JOIN \"pg_attribute\" \"a\" ON \"a\".\"attrelid\" = \"t\".\"oid\"  AND \"a\".\"attnum\" = ANY (\"ix\".\"indkey\") ` +\n            `INNER JOIN \"pg_namespace\" \"ns\" ON \"ns\".\"oid\" = \"t\".\"relnamespace\" ` +\n            `INNER JOIN \"pg_class\" \"i\" ON \"i\".\"oid\" = \"ix\".\"indexrelid\" ` +\n            `INNER JOIN \"pg_type\" \"types\" ON \"types\".\"oid\" = \"a\".\"atttypid\" ` +\n            `LEFT JOIN \"pg_constraint\" \"cnst\" ON \"cnst\".\"conname\" = \"i\".\"relname\" ` +\n            `WHERE \"t\".\"relkind\" IN ('r', 'p') AND \"cnst\".\"contype\" IS NULL AND (${constraintsCondition})`\n\n        const foreignKeysCondition = dbTables\n            .map(({ table_schema, table_name }) => {\n                return `(\"ns\".\"nspname\" = '${table_schema}' AND \"cl\".\"relname\" = '${table_name}')`\n            })\n            .join(\" OR \")\n\n        const hasRelispartitionColumn =\n            await this.hasSupportForPartitionedTables()\n        const isPartitionCondition = hasRelispartitionColumn\n            ? ` AND \"cl\".\"relispartition\" = 'f'`\n            : \"\"\n\n        const foreignKeysSql =\n            `SELECT \"con\".\"conname\" AS \"constraint_name\", \"con\".\"nspname\" AS \"table_schema\", \"con\".\"relname\" AS \"table_name\", \"att2\".\"attname\" AS \"column_name\", ` +\n            `\"ns\".\"nspname\" AS \"referenced_table_schema\", \"cl\".\"relname\" AS \"referenced_table_name\", \"att\".\"attname\" AS \"referenced_column_name\", \"con\".\"confdeltype\" AS \"on_delete\", ` +\n            `\"con\".\"confupdtype\" AS \"on_update\", \"con\".\"condeferrable\" AS \"deferrable\", \"con\".\"condeferred\" AS \"deferred\" ` +\n            `FROM ( ` +\n            `SELECT UNNEST (\"con1\".\"conkey\") AS \"parent\", UNNEST (\"con1\".\"confkey\") AS \"child\", \"con1\".\"confrelid\", \"con1\".\"conrelid\", \"con1\".\"conname\", \"con1\".\"contype\", \"ns\".\"nspname\", ` +\n            `\"cl\".\"relname\", \"con1\".\"condeferrable\", ` +\n            `CASE WHEN \"con1\".\"condeferred\" THEN 'INITIALLY DEFERRED' ELSE 'INITIALLY IMMEDIATE' END as condeferred, ` +\n            `CASE \"con1\".\"confdeltype\" WHEN 'a' THEN 'NO ACTION' WHEN 'r' THEN 'RESTRICT' WHEN 'c' THEN 'CASCADE' WHEN 'n' THEN 'SET NULL' WHEN 'd' THEN 'SET DEFAULT' END as \"confdeltype\", ` +\n            `CASE \"con1\".\"confupdtype\" WHEN 'a' THEN 'NO ACTION' WHEN 'r' THEN 'RESTRICT' WHEN 'c' THEN 'CASCADE' WHEN 'n' THEN 'SET NULL' WHEN 'd' THEN 'SET DEFAULT' END as \"confupdtype\" ` +\n            `FROM \"pg_class\" \"cl\" ` +\n            `INNER JOIN \"pg_namespace\" \"ns\" ON \"cl\".\"relnamespace\" = \"ns\".\"oid\" ` +\n            `INNER JOIN \"pg_constraint\" \"con1\" ON \"con1\".\"conrelid\" = \"cl\".\"oid\" ` +\n            `WHERE \"con1\".\"contype\" = 'f' AND (${foreignKeysCondition}) ` +\n            `) \"con\" ` +\n            `INNER JOIN \"pg_attribute\" \"att\" ON \"att\".\"attrelid\" = \"con\".\"confrelid\" AND \"att\".\"attnum\" = \"con\".\"child\" ` +\n            `INNER JOIN \"pg_class\" \"cl\" ON \"cl\".\"oid\" = \"con\".\"confrelid\" ${isPartitionCondition}` +\n            `INNER JOIN \"pg_namespace\" \"ns\" ON \"cl\".\"relnamespace\" = \"ns\".\"oid\" ` +\n            `INNER JOIN \"pg_attribute\" \"att2\" ON \"att2\".\"attrelid\" = \"con\".\"conrelid\" AND \"att2\".\"attnum\" = \"con\".\"parent\"`\n\n        const [\n            dbColumns,\n            dbConstraints,\n            dbIndices,\n            dbForeignKeys,\n        ]: ObjectLiteral[][] = await Promise.all([\n            this.query(columnsSql),\n            this.query(constraintsSql),\n            this.query(indicesSql),\n            this.query(foreignKeysSql),\n        ])\n\n        // create tables for loaded tables\n        return Promise.all(\n            dbTables.map(async (dbTable) => {\n                const table = new Table()\n\n                const getSchemaFromKey = (dbObject: any, key: string) => {\n                    return dbObject[key] === currentSchema &&\n                        (!this.driver.options.schema ||\n                            this.driver.options.schema === currentSchema)\n                        ? undefined\n                        : dbObject[key]\n                }\n                // We do not need to join schema name, when database is by default.\n                const schema = getSchemaFromKey(dbTable, \"table_schema\")\n                table.database = currentDatabase\n                table.schema = dbTable[\"table_schema\"]\n                table.name = this.driver.buildTableName(\n                    dbTable[\"table_name\"],\n                    schema,\n                )\n\n                // create columns from the loaded columns\n                table.columns = await Promise.all(\n                    dbColumns\n                        .filter(\n                            (dbColumn) =>\n                                dbColumn[\"table_name\"] ===\n                                    dbTable[\"table_name\"] &&\n                                dbColumn[\"table_schema\"] ===\n                                    dbTable[\"table_schema\"],\n                        )\n                        .map(async (dbColumn) => {\n                            const columnConstraints = dbConstraints.filter(\n                                (dbConstraint) => {\n                                    return (\n                                        dbConstraint[\"table_name\"] ===\n                                            dbColumn[\"table_name\"] &&\n                                        dbConstraint[\"table_schema\"] ===\n                                            dbColumn[\"table_schema\"] &&\n                                        dbConstraint[\"column_name\"] ===\n                                            dbColumn[\"column_name\"]\n                                    )\n                                },\n                            )\n\n                            const tableColumn = new TableColumn()\n                            tableColumn.name = dbColumn[\"column_name\"]\n                            tableColumn.type = dbColumn[\"regtype\"].toLowerCase()\n\n                            if (\n                                tableColumn.type === \"numeric\" ||\n                                tableColumn.type === \"decimal\" ||\n                                tableColumn.type === \"float\"\n                            ) {\n                                // If one of these properties was set, and another was not, Postgres sets '0' in to unspecified property\n                                // we set 'undefined' in to unspecified property to avoid changing column on sync\n                                if (\n                                    dbColumn[\"numeric_precision\"] !== null &&\n                                    !this.isDefaultColumnPrecision(\n                                        table,\n                                        tableColumn,\n                                        dbColumn[\"numeric_precision\"],\n                                    )\n                                ) {\n                                    tableColumn.precision =\n                                        dbColumn[\"numeric_precision\"]\n                                } else if (\n                                    dbColumn[\"numeric_scale\"] !== null &&\n                                    !this.isDefaultColumnScale(\n                                        table,\n                                        tableColumn,\n                                        dbColumn[\"numeric_scale\"],\n                                    )\n                                ) {\n                                    tableColumn.precision = undefined\n                                }\n                                if (\n                                    dbColumn[\"numeric_scale\"] !== null &&\n                                    !this.isDefaultColumnScale(\n                                        table,\n                                        tableColumn,\n                                        dbColumn[\"numeric_scale\"],\n                                    )\n                                ) {\n                                    tableColumn.scale =\n                                        dbColumn[\"numeric_scale\"]\n                                } else if (\n                                    dbColumn[\"numeric_precision\"] !== null &&\n                                    !this.isDefaultColumnPrecision(\n                                        table,\n                                        tableColumn,\n                                        dbColumn[\"numeric_precision\"],\n                                    )\n                                ) {\n                                    tableColumn.scale = undefined\n                                }\n                            }\n\n                            if (\n                                tableColumn.type === \"interval\" ||\n                                tableColumn.type === \"time without time zone\" ||\n                                tableColumn.type === \"time with time zone\" ||\n                                tableColumn.type ===\n                                    \"timestamp without time zone\" ||\n                                tableColumn.type === \"timestamp with time zone\"\n                            ) {\n                                tableColumn.precision =\n                                    !this.isDefaultColumnPrecision(\n                                        table,\n                                        tableColumn,\n                                        dbColumn[\"datetime_precision\"],\n                                    )\n                                        ? dbColumn[\"datetime_precision\"]\n                                        : undefined\n                            }\n\n                            // check if column has user-defined data type.\n                            // NOTE: if ENUM type defined with \"array:true\" it comes with ARRAY type instead of USER-DEFINED\n                            if (\n                                dbColumn[\"data_type\"] === \"USER-DEFINED\" ||\n                                dbColumn[\"data_type\"] === \"ARRAY\"\n                            ) {\n                                const { name } =\n                                    await this.getUserDefinedTypeName(\n                                        table,\n                                        tableColumn,\n                                    )\n\n                                // check if `enumName` is specified by user\n                                const builtEnumName = this.buildEnumName(\n                                    table,\n                                    tableColumn,\n                                    false,\n                                    true,\n                                )\n                                const enumName =\n                                    builtEnumName !== name ? name : undefined\n\n                                // check if type is ENUM\n                                const sql =\n                                    `SELECT \"e\".\"enumlabel\" AS \"value\" FROM \"pg_enum\" \"e\" ` +\n                                    `INNER JOIN \"pg_type\" \"t\" ON \"t\".\"oid\" = \"e\".\"enumtypid\" ` +\n                                    `INNER JOIN \"pg_namespace\" \"n\" ON \"n\".\"oid\" = \"t\".\"typnamespace\" ` +\n                                    `WHERE \"n\".\"nspname\" = '${\n                                        dbTable[\"table_schema\"]\n                                    }' AND \"t\".\"typname\" = '${\n                                        enumName || name\n                                    }'`\n                                const results: ObjectLiteral[] =\n                                    await this.query(sql)\n\n                                if (results.length) {\n                                    tableColumn.type = \"enum\"\n                                    tableColumn.enum = results.map(\n                                        (result) => result[\"value\"],\n                                    )\n                                    tableColumn.enumName = enumName\n                                }\n\n                                if (dbColumn[\"data_type\"] === \"ARRAY\") {\n                                    tableColumn.isArray = true\n                                    const type = tableColumn.type.replace(\n                                        \"[]\",\n                                        \"\",\n                                    )\n                                    tableColumn.type =\n                                        this.connection.driver.normalizeType({\n                                            type: type,\n                                        })\n                                }\n                            }\n\n                            if (tableColumn.type === \"geometry\") {\n                                const geometryColumnSql = `SELECT * FROM (\n                        SELECT\n                          \"f_table_schema\" \"table_schema\",\n                          \"f_table_name\" \"table_name\",\n                          \"f_geometry_column\" \"column_name\",\n                          \"srid\",\n                          \"type\"\n                        FROM \"geometry_columns\"\n                      ) AS _\n                      WHERE\n                          \"column_name\" = '${dbColumn[\"column_name\"]}' AND\n                          \"table_schema\" = '${dbColumn[\"table_schema\"]}' AND\n                          \"table_name\" = '${dbColumn[\"table_name\"]}'`\n\n                                const results: ObjectLiteral[] =\n                                    await this.query(geometryColumnSql)\n\n                                if (results.length > 0) {\n                                    tableColumn.spatialFeatureType =\n                                        results[0].type\n                                    tableColumn.srid = results[0].srid\n                                }\n                            }\n\n                            if (tableColumn.type === \"geography\") {\n                                const geographyColumnSql = `SELECT * FROM (\n                        SELECT\n                          \"f_table_schema\" \"table_schema\",\n                          \"f_table_name\" \"table_name\",\n                          \"f_geography_column\" \"column_name\",\n                          \"srid\",\n                          \"type\"\n                        FROM \"geography_columns\"\n                      ) AS _\n                      WHERE\n                          \"column_name\" = '${dbColumn[\"column_name\"]}' AND\n                          \"table_schema\" = '${dbColumn[\"table_schema\"]}' AND\n                          \"table_name\" = '${dbColumn[\"table_name\"]}'`\n\n                                const results: ObjectLiteral[] =\n                                    await this.query(geographyColumnSql)\n\n                                if (results.length > 0) {\n                                    tableColumn.spatialFeatureType =\n                                        results[0].type\n                                    tableColumn.srid = results[0].srid\n                                }\n                            }\n\n                            // check only columns that have length property\n                            if (\n                                this.driver.withLengthColumnTypes.indexOf(\n                                    tableColumn.type as ColumnType,\n                                ) !== -1\n                            ) {\n                                let length\n                                if (tableColumn.isArray) {\n                                    const match = /\\((\\d+)\\)/.exec(\n                                        dbColumn[\"format_type\"],\n                                    )\n                                    length = match ? match[1] : undefined\n                                } else if (\n                                    dbColumn[\"character_maximum_length\"]\n                                ) {\n                                    length =\n                                        dbColumn[\n                                            \"character_maximum_length\"\n                                        ].toString()\n                                }\n                                if (length) {\n                                    tableColumn.length =\n                                        !this.isDefaultColumnLength(\n                                            table,\n                                            tableColumn,\n                                            length,\n                                        )\n                                            ? length\n                                            : \"\"\n                                }\n                            }\n                            tableColumn.isNullable =\n                                dbColumn[\"is_nullable\"] === \"YES\"\n\n                            const primaryConstraint = columnConstraints.find(\n                                (constraint) =>\n                                    constraint[\"constraint_type\"] === \"PRIMARY\",\n                            )\n                            if (primaryConstraint) {\n                                tableColumn.isPrimary = true\n                                // find another columns involved in primary key constraint\n                                const anotherPrimaryConstraints =\n                                    dbConstraints.filter(\n                                        (constraint) =>\n                                            constraint[\"table_name\"] ===\n                                                dbColumn[\"table_name\"] &&\n                                            constraint[\"table_schema\"] ===\n                                                dbColumn[\"table_schema\"] &&\n                                            constraint[\"column_name\"] !==\n                                                dbColumn[\"column_name\"] &&\n                                            constraint[\"constraint_type\"] ===\n                                                \"PRIMARY\",\n                                    )\n\n                                // collect all column names\n                                const columnNames =\n                                    anotherPrimaryConstraints.map(\n                                        (constraint) =>\n                                            constraint[\"column_name\"],\n                                    )\n                                columnNames.push(dbColumn[\"column_name\"])\n\n                                // build default primary key constraint name\n                                const pkName =\n                                    this.connection.namingStrategy.primaryKeyName(\n                                        table,\n                                        columnNames,\n                                    )\n\n                                // if primary key has user-defined constraint name, write it in table column\n                                if (\n                                    primaryConstraint[\"constraint_name\"] !==\n                                    pkName\n                                ) {\n                                    tableColumn.primaryKeyConstraintName =\n                                        primaryConstraint[\"constraint_name\"]\n                                }\n                            }\n\n                            const uniqueConstraints = columnConstraints.filter(\n                                (constraint) =>\n                                    constraint[\"constraint_type\"] === \"UNIQUE\",\n                            )\n                            const isConstraintComposite =\n                                uniqueConstraints.every((uniqueConstraint) => {\n                                    return dbConstraints.some(\n                                        (dbConstraint) =>\n                                            dbConstraint[\"constraint_type\"] ===\n                                                \"UNIQUE\" &&\n                                            dbConstraint[\"constraint_name\"] ===\n                                                uniqueConstraint[\n                                                    \"constraint_name\"\n                                                ] &&\n                                            dbConstraint[\"column_name\"] !==\n                                                dbColumn[\"column_name\"],\n                                    )\n                                })\n                            tableColumn.isUnique =\n                                uniqueConstraints.length > 0 &&\n                                !isConstraintComposite\n\n                            if (dbColumn.is_identity === \"YES\") {\n                                // Postgres 10+ Identity column\n                                tableColumn.isGenerated = true\n                                tableColumn.generationStrategy = \"identity\"\n                                tableColumn.generatedIdentity =\n                                    dbColumn.identity_generation\n                            } else if (\n                                dbColumn[\"column_default\"] !== null &&\n                                dbColumn[\"column_default\"] !== undefined\n                            ) {\n                                const serialDefaultName = `nextval('${this.buildSequenceName(\n                                    table,\n                                    dbColumn[\"column_name\"],\n                                )}'::regclass)`\n                                const serialDefaultPath = `nextval('${this.buildSequencePath(\n                                    table,\n                                    dbColumn[\"column_name\"],\n                                )}'::regclass)`\n\n                                const defaultWithoutQuotes = dbColumn[\n                                    \"column_default\"\n                                ].replace(/\"/g, \"\")\n\n                                if (\n                                    defaultWithoutQuotes ===\n                                        serialDefaultName ||\n                                    defaultWithoutQuotes === serialDefaultPath\n                                ) {\n                                    tableColumn.isGenerated = true\n                                    tableColumn.generationStrategy = \"increment\"\n                                } else if (\n                                    dbColumn[\"column_default\"] ===\n                                        \"gen_random_uuid()\" ||\n                                    /^uuid_generate_v\\d\\(\\)/.test(\n                                        dbColumn[\"column_default\"],\n                                    )\n                                ) {\n                                    if (tableColumn.type === \"uuid\") {\n                                        tableColumn.isGenerated = true\n                                        tableColumn.generationStrategy = \"uuid\"\n                                    } else {\n                                        tableColumn.default =\n                                            dbColumn[\"column_default\"]\n                                    }\n                                } else if (\n                                    dbColumn[\"column_default\"] === \"now()\" ||\n                                    dbColumn[\"column_default\"].indexOf(\n                                        \"'now'::text\",\n                                    ) !== -1\n                                ) {\n                                    tableColumn.default =\n                                        dbColumn[\"column_default\"]\n                                } else {\n                                    tableColumn.default = dbColumn[\n                                        \"column_default\"\n                                    ].replace(/::[\\w\\s\\.\\[\\]\\\"]+/g, \"\")\n                                    tableColumn.default =\n                                        tableColumn.default.replace(\n                                            /^(-?\\d+)$/,\n                                            \"'$1'\",\n                                        )\n                                }\n                            }\n\n                            if (\n                                dbColumn[\"is_generated\"] === \"ALWAYS\" &&\n                                dbColumn[\"generation_expression\"]\n                            ) {\n                                // In postgres there is no VIRTUAL generated column type\n                                tableColumn.generatedType = \"STORED\"\n                                // We cannot relay on information_schema.columns.generation_expression, because it is formatted different.\n                                const asExpressionQuery =\n                                    await this.selectTypeormMetadataSql({\n                                        database: currentDatabase,\n                                        schema: dbTable[\"table_schema\"],\n                                        table: dbTable[\"table_name\"],\n                                        type: MetadataTableType.GENERATED_COLUMN,\n                                        name: tableColumn.name,\n                                    })\n\n                                const results = await this.query(\n                                    asExpressionQuery.query,\n                                    asExpressionQuery.parameters,\n                                )\n                                if (results[0] && results[0].value) {\n                                    tableColumn.asExpression = results[0].value\n                                } else {\n                                    tableColumn.asExpression = \"\"\n                                }\n                            }\n\n                            tableColumn.comment = dbColumn[\"description\"]\n                                ? dbColumn[\"description\"]\n                                : undefined\n                            if (dbColumn[\"character_set_name\"])\n                                tableColumn.charset =\n                                    dbColumn[\"character_set_name\"]\n                            if (dbColumn[\"collation_name\"])\n                                tableColumn.collation =\n                                    dbColumn[\"collation_name\"]\n                            return tableColumn\n                        }),\n                )\n\n                // find unique constraints of table, group them by constraint name and build TableUnique.\n                const tableUniqueConstraints = OrmUtils.uniq(\n                    dbConstraints.filter((dbConstraint) => {\n                        return (\n                            dbConstraint[\"table_name\"] ===\n                                dbTable[\"table_name\"] &&\n                            dbConstraint[\"table_schema\"] ===\n                                dbTable[\"table_schema\"] &&\n                            dbConstraint[\"constraint_type\"] === \"UNIQUE\"\n                        )\n                    }),\n                    (dbConstraint) => dbConstraint[\"constraint_name\"],\n                )\n\n                table.uniques = tableUniqueConstraints.map((constraint) => {\n                    const uniques = dbConstraints.filter(\n                        (dbC) =>\n                            dbC[\"constraint_name\"] ===\n                            constraint[\"constraint_name\"],\n                    )\n                    return new TableUnique({\n                        name: constraint[\"constraint_name\"],\n                        columnNames: uniques.map((u) => u[\"column_name\"]),\n                        deferrable: constraint[\"deferrable\"]\n                            ? constraint[\"deferred\"]\n                            : undefined,\n                    })\n                })\n\n                // find check constraints of table, group them by constraint name and build TableCheck.\n                const tableCheckConstraints = OrmUtils.uniq(\n                    dbConstraints.filter((dbConstraint) => {\n                        return (\n                            dbConstraint[\"table_name\"] ===\n                                dbTable[\"table_name\"] &&\n                            dbConstraint[\"table_schema\"] ===\n                                dbTable[\"table_schema\"] &&\n                            dbConstraint[\"constraint_type\"] === \"CHECK\"\n                        )\n                    }),\n                    (dbConstraint) => dbConstraint[\"constraint_name\"],\n                )\n\n                table.checks = tableCheckConstraints.map((constraint) => {\n                    const checks = dbConstraints.filter(\n                        (dbC) =>\n                            dbC[\"constraint_name\"] ===\n                            constraint[\"constraint_name\"],\n                    )\n                    return new TableCheck({\n                        name: constraint[\"constraint_name\"],\n                        columnNames: checks.map((c) => c[\"column_name\"]),\n                        expression: constraint[\"expression\"].replace(\n                            /^\\s*CHECK\\s*\\((.*)\\)\\s*$/i,\n                            \"$1\",\n                        ),\n                    })\n                })\n\n                // find exclusion constraints of table, group them by constraint name and build TableExclusion.\n                const tableExclusionConstraints = OrmUtils.uniq(\n                    dbConstraints.filter((dbConstraint) => {\n                        return (\n                            dbConstraint[\"table_name\"] ===\n                                dbTable[\"table_name\"] &&\n                            dbConstraint[\"table_schema\"] ===\n                                dbTable[\"table_schema\"] &&\n                            dbConstraint[\"constraint_type\"] === \"EXCLUDE\"\n                        )\n                    }),\n                    (dbConstraint) => dbConstraint[\"constraint_name\"],\n                )\n\n                table.exclusions = tableExclusionConstraints.map(\n                    (constraint) => {\n                        return new TableExclusion({\n                            name: constraint[\"constraint_name\"],\n                            expression: constraint[\"expression\"].substring(8), // trim EXCLUDE from start of expression\n                        })\n                    },\n                )\n\n                // find foreign key constraints of table, group them by constraint name and build TableForeignKey.\n                const tableForeignKeyConstraints = OrmUtils.uniq(\n                    dbForeignKeys.filter((dbForeignKey) => {\n                        return (\n                            dbForeignKey[\"table_name\"] ===\n                                dbTable[\"table_name\"] &&\n                            dbForeignKey[\"table_schema\"] ===\n                                dbTable[\"table_schema\"]\n                        )\n                    }),\n                    (dbForeignKey) => dbForeignKey[\"constraint_name\"],\n                )\n\n                table.foreignKeys = tableForeignKeyConstraints.map(\n                    (dbForeignKey) => {\n                        const foreignKeys = dbForeignKeys.filter(\n                            (dbFk) =>\n                                dbFk[\"constraint_name\"] ===\n                                dbForeignKey[\"constraint_name\"],\n                        )\n\n                        // if referenced table located in currently used schema, we don't need to concat schema name to table name.\n                        const schema = getSchemaFromKey(\n                            dbForeignKey,\n                            \"referenced_table_schema\",\n                        )\n                        const referencedTableName = this.driver.buildTableName(\n                            dbForeignKey[\"referenced_table_name\"],\n                            schema,\n                        )\n\n                        return new TableForeignKey({\n                            name: dbForeignKey[\"constraint_name\"],\n                            columnNames: foreignKeys.map(\n                                (dbFk) => dbFk[\"column_name\"],\n                            ),\n                            referencedSchema:\n                                dbForeignKey[\"referenced_table_schema\"],\n                            referencedTableName: referencedTableName,\n                            referencedColumnNames: foreignKeys.map(\n                                (dbFk) => dbFk[\"referenced_column_name\"],\n                            ),\n                            onDelete: dbForeignKey[\"on_delete\"],\n                            onUpdate: dbForeignKey[\"on_update\"],\n                            deferrable: dbForeignKey[\"deferrable\"]\n                                ? dbForeignKey[\"deferred\"]\n                                : undefined,\n                        })\n                    },\n                )\n\n                // find index constraints of table, group them by constraint name and build TableIndex.\n                const tableIndexConstraints = OrmUtils.uniq(\n                    dbIndices.filter((dbIndex) => {\n                        return (\n                            dbIndex[\"table_name\"] === dbTable[\"table_name\"] &&\n                            dbIndex[\"table_schema\"] === dbTable[\"table_schema\"]\n                        )\n                    }),\n                    (dbIndex) => dbIndex[\"constraint_name\"],\n                )\n\n                table.indices = tableIndexConstraints.map((constraint) => {\n                    const indices = dbIndices.filter((index) => {\n                        return (\n                            index[\"table_schema\"] ===\n                                constraint[\"table_schema\"] &&\n                            index[\"table_name\"] === constraint[\"table_name\"] &&\n                            index[\"constraint_name\"] ===\n                                constraint[\"constraint_name\"]\n                        )\n                    })\n                    return new TableIndex(<TableIndexOptions>{\n                        table: table,\n                        name: constraint[\"constraint_name\"],\n                        columnNames: indices.map((i) => i[\"column_name\"]),\n                        isUnique: constraint[\"is_unique\"] === \"TRUE\",\n                        where: constraint[\"condition\"],\n                        isSpatial: indices.every(\n                            (i) =>\n                                this.driver.spatialTypes.indexOf(\n                                    i[\"type_name\"],\n                                ) >= 0,\n                        ),\n                        isFulltext: false,\n                    })\n                })\n\n                return table\n            }),\n        )\n    }\n\n    /**\n     * Builds create table sql.\n     */\n    protected createTableSql(table: Table, createForeignKeys?: boolean): Query {\n        const columnDefinitions = table.columns\n            .map((column) => this.buildCreateColumnSql(table, column))\n            .join(\", \")\n        let sql = `CREATE TABLE ${this.escapePath(table)} (${columnDefinitions}`\n\n        table.columns\n            .filter((column) => column.isUnique)\n            .forEach((column) => {\n                const isUniqueExist = table.uniques.some(\n                    (unique) =>\n                        unique.columnNames.length === 1 &&\n                        unique.columnNames[0] === column.name,\n                )\n                if (!isUniqueExist)\n                    table.uniques.push(\n                        new TableUnique({\n                            name: this.connection.namingStrategy.uniqueConstraintName(\n                                table,\n                                [column.name],\n                            ),\n                            columnNames: [column.name],\n                        }),\n                    )\n            })\n\n        if (table.uniques.length > 0) {\n            const uniquesSql = table.uniques\n                .map((unique) => {\n                    const uniqueName = unique.name\n                        ? unique.name\n                        : this.connection.namingStrategy.uniqueConstraintName(\n                              table,\n                              unique.columnNames,\n                          )\n                    const columnNames = unique.columnNames\n                        .map((columnName) => `\"${columnName}\"`)\n                        .join(\", \")\n                    let constraint = `CONSTRAINT \"${uniqueName}\" UNIQUE (${columnNames})`\n                    if (unique.deferrable)\n                        constraint += ` DEFERRABLE ${unique.deferrable}`\n                    return constraint\n                })\n                .join(\", \")\n\n            sql += `, ${uniquesSql}`\n        }\n\n        if (table.checks.length > 0) {\n            const checksSql = table.checks\n                .map((check) => {\n                    const checkName = check.name\n                        ? check.name\n                        : this.connection.namingStrategy.checkConstraintName(\n                              table,\n                              check.expression!,\n                          )\n                    return `CONSTRAINT \"${checkName}\" CHECK (${check.expression})`\n                })\n                .join(\", \")\n\n            sql += `, ${checksSql}`\n        }\n\n        if (table.exclusions.length > 0) {\n            const exclusionsSql = table.exclusions\n                .map((exclusion) => {\n                    const exclusionName = exclusion.name\n                        ? exclusion.name\n                        : this.connection.namingStrategy.exclusionConstraintName(\n                              table,\n                              exclusion.expression!,\n                          )\n                    return `CONSTRAINT \"${exclusionName}\" EXCLUDE ${exclusion.expression}`\n                })\n                .join(\", \")\n\n            sql += `, ${exclusionsSql}`\n        }\n\n        if (table.foreignKeys.length > 0 && createForeignKeys) {\n            const foreignKeysSql = table.foreignKeys\n                .map((fk) => {\n                    const columnNames = fk.columnNames\n                        .map((columnName) => `\"${columnName}\"`)\n                        .join(\", \")\n                    if (!fk.name)\n                        fk.name = this.connection.namingStrategy.foreignKeyName(\n                            table,\n                            fk.columnNames,\n                            this.getTablePath(fk),\n                            fk.referencedColumnNames,\n                        )\n\n                    const referencedColumnNames = fk.referencedColumnNames\n                        .map((columnName) => `\"${columnName}\"`)\n                        .join(\", \")\n\n                    let constraint = `CONSTRAINT \"${\n                        fk.name\n                    }\" FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(\n                        this.getTablePath(fk),\n                    )} (${referencedColumnNames})`\n                    if (fk.onDelete) constraint += ` ON DELETE ${fk.onDelete}`\n                    if (fk.onUpdate) constraint += ` ON UPDATE ${fk.onUpdate}`\n                    if (fk.deferrable)\n                        constraint += ` DEFERRABLE ${fk.deferrable}`\n\n                    return constraint\n                })\n                .join(\", \")\n\n            sql += `, ${foreignKeysSql}`\n        }\n\n        const primaryColumns = table.columns.filter(\n            (column) => column.isPrimary,\n        )\n        if (primaryColumns.length > 0) {\n            const primaryKeyName = primaryColumns[0].primaryKeyConstraintName\n                ? primaryColumns[0].primaryKeyConstraintName\n                : this.connection.namingStrategy.primaryKeyName(\n                      table,\n                      primaryColumns.map((column) => column.name),\n                  )\n\n            const columnNames = primaryColumns\n                .map((column) => `\"${column.name}\"`)\n                .join(\", \")\n            sql += `, CONSTRAINT \"${primaryKeyName}\" PRIMARY KEY (${columnNames})`\n        }\n\n        sql += `)`\n\n        table.columns\n            .filter((it) => it.comment)\n            .forEach(\n                (it) =>\n                    (sql += `; COMMENT ON COLUMN ${this.escapePath(table)}.\"${\n                        it.name\n                    }\" IS ${this.escapeComment(it.comment)}`),\n            )\n\n        return new Query(sql)\n    }\n\n    /**\n     * Loads Postgres version.\n     */\n    protected async getVersion(): Promise<string> {\n        const result = await this.query(`SELECT version()`)\n        return result[0][\"version\"].replace(/^PostgreSQL ([\\d\\.]+) .*$/, \"$1\")\n    }\n\n    /**\n     * Builds drop table sql.\n     */\n    protected dropTableSql(tableOrPath: Table | string): Query {\n        return new Query(`DROP TABLE ${this.escapePath(tableOrPath)}`)\n    }\n\n    protected createViewSql(view: View): Query {\n        const materializedClause = view.materialized ? \"MATERIALIZED \" : \"\"\n        const viewName = this.escapePath(view)\n\n        if (typeof view.expression === \"string\") {\n            return new Query(\n                `CREATE ${materializedClause}VIEW ${viewName} AS ${view.expression}`,\n            )\n        } else {\n            return new Query(\n                `CREATE ${materializedClause}VIEW ${viewName} AS ${view\n                    .expression(this.connection)\n                    .getQuery()}`,\n            )\n        }\n    }\n\n    protected async insertViewDefinitionSql(view: View): Promise<Query> {\n        const currentSchema = await this.getCurrentSchema()\n\n        let { schema, tableName: name } = this.driver.parseTableName(view)\n\n        if (!schema) {\n            schema = currentSchema\n        }\n\n        const type = view.materialized\n            ? MetadataTableType.MATERIALIZED_VIEW\n            : MetadataTableType.VIEW\n        const expression =\n            typeof view.expression === \"string\"\n                ? view.expression.trim()\n                : view.expression(this.connection).getQuery()\n        return this.insertTypeormMetadataSql({\n            type,\n            schema,\n            name,\n            value: expression,\n        })\n    }\n\n    /**\n     * Builds drop view sql.\n     */\n    protected dropViewSql(view: View): Query {\n        const materializedClause = view.materialized ? \"MATERIALIZED \" : \"\"\n        return new Query(\n            `DROP ${materializedClause}VIEW ${this.escapePath(view)}`,\n        )\n    }\n\n    /**\n     * Builds remove view sql.\n     */\n    protected async deleteViewDefinitionSql(view: View): Promise<Query> {\n        const currentSchema = await this.getCurrentSchema()\n\n        let { schema, tableName: name } = this.driver.parseTableName(view)\n\n        if (!schema) {\n            schema = currentSchema\n        }\n\n        const type = view.materialized\n            ? MetadataTableType.MATERIALIZED_VIEW\n            : MetadataTableType.VIEW\n        return this.deleteTypeormMetadataSql({ type, schema, name })\n    }\n\n    /**\n     * Drops ENUM type from given schemas.\n     */\n    protected async dropEnumTypes(schemaNames: string): Promise<void> {\n        const selectDropsQuery =\n            `SELECT 'DROP TYPE IF EXISTS \"' || n.nspname || '\".\"' || t.typname || '\" CASCADE;' as \"query\" FROM \"pg_type\" \"t\" ` +\n            `INNER JOIN \"pg_enum\" \"e\" ON \"e\".\"enumtypid\" = \"t\".\"oid\" ` +\n            `INNER JOIN \"pg_namespace\" \"n\" ON \"n\".\"oid\" = \"t\".\"typnamespace\" ` +\n            `WHERE \"n\".\"nspname\" IN (${schemaNames}) GROUP BY \"n\".\"nspname\", \"t\".\"typname\"`\n        const dropQueries: ObjectLiteral[] = await this.query(selectDropsQuery)\n        await Promise.all(dropQueries.map((q) => this.query(q[\"query\"])))\n    }\n\n    /**\n     * Checks if enum with the given name exist in the database.\n     */\n    protected async hasEnumType(\n        table: Table,\n        column: TableColumn,\n    ): Promise<boolean> {\n        let { schema } = this.driver.parseTableName(table)\n\n        if (!schema) {\n            schema = await this.getCurrentSchema()\n        }\n\n        const enumName = this.buildEnumName(table, column, false, true)\n        const sql =\n            `SELECT \"n\".\"nspname\", \"t\".\"typname\" FROM \"pg_type\" \"t\" ` +\n            `INNER JOIN \"pg_namespace\" \"n\" ON \"n\".\"oid\" = \"t\".\"typnamespace\" ` +\n            `WHERE \"n\".\"nspname\" = '${schema}' AND \"t\".\"typname\" = '${enumName}'`\n        const result = await this.query(sql)\n        return result.length ? true : false\n    }\n\n    /**\n     * Builds create ENUM type sql.\n     */\n    protected createEnumTypeSql(\n        table: Table,\n        column: TableColumn,\n        enumName?: string,\n    ): Query {\n        if (!enumName) enumName = this.buildEnumName(table, column)\n        const enumValues = column\n            .enum!.map((value) => `'${value.replace(\"'\", \"''\")}'`)\n            .join(\", \")\n        return new Query(`CREATE TYPE ${enumName} AS ENUM(${enumValues})`)\n    }\n\n    /**\n     * Builds create ENUM type sql.\n     */\n    protected dropEnumTypeSql(\n        table: Table,\n        column: TableColumn,\n        enumName?: string,\n    ): Query {\n        if (!enumName) enumName = this.buildEnumName(table, column)\n        return new Query(`DROP TYPE ${enumName}`)\n    }\n\n    /**\n     * Builds create index sql.\n     */\n    protected createIndexSql(table: Table, index: TableIndex): Query {\n        const columns = index.columnNames\n            .map((columnName) => `\"${columnName}\"`)\n            .join(\", \")\n        return new Query(\n            `CREATE ${index.isUnique ? \"UNIQUE \" : \"\"}INDEX \"${\n                index.name\n            }\" ON ${this.escapePath(table)} ${\n                index.isSpatial ? \"USING GiST \" : \"\"\n            }(${columns}) ${index.where ? \"WHERE \" + index.where : \"\"}`,\n        )\n    }\n\n    /**\n     * Builds drop index sql.\n     */\n    protected dropIndexSql(\n        table: Table,\n        indexOrName: TableIndex | string,\n    ): Query {\n        let indexName = InstanceChecker.isTableIndex(indexOrName)\n            ? indexOrName.name\n            : indexOrName\n        const { schema } = this.driver.parseTableName(table)\n        return schema\n            ? new Query(`DROP INDEX \"${schema}\".\"${indexName}\"`)\n            : new Query(`DROP INDEX \"${indexName}\"`)\n    }\n\n    /**\n     * Builds create primary key sql.\n     */\n    protected createPrimaryKeySql(\n        table: Table,\n        columnNames: string[],\n        constraintName?: string,\n    ): Query {\n        const primaryKeyName = constraintName\n            ? constraintName\n            : this.connection.namingStrategy.primaryKeyName(table, columnNames)\n\n        const columnNamesString = columnNames\n            .map((columnName) => `\"${columnName}\"`)\n            .join(\", \")\n\n        return new Query(\n            `ALTER TABLE ${this.escapePath(\n                table,\n            )} ADD CONSTRAINT \"${primaryKeyName}\" PRIMARY KEY (${columnNamesString})`,\n        )\n    }\n\n    /**\n     * Builds drop primary key sql.\n     */\n    protected dropPrimaryKeySql(table: Table): Query {\n        if (!table.primaryColumns.length)\n            throw new TypeORMError(`Table ${table} has no primary keys.`)\n\n        const columnNames = table.primaryColumns.map((column) => column.name)\n        const constraintName = table.primaryColumns[0].primaryKeyConstraintName\n        const primaryKeyName = constraintName\n            ? constraintName\n            : this.connection.namingStrategy.primaryKeyName(table, columnNames)\n\n        return new Query(\n            `ALTER TABLE ${this.escapePath(\n                table,\n            )} DROP CONSTRAINT \"${primaryKeyName}\"`,\n        )\n    }\n\n    /**\n     * Builds create unique constraint sql.\n     */\n    protected createUniqueConstraintSql(\n        table: Table,\n        uniqueConstraint: TableUnique,\n    ): Query {\n        const columnNames = uniqueConstraint.columnNames\n            .map((column) => `\"` + column + `\"`)\n            .join(\", \")\n        let sql = `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${\n            uniqueConstraint.name\n        }\" UNIQUE (${columnNames})`\n        if (uniqueConstraint.deferrable)\n            sql += ` DEFERRABLE ${uniqueConstraint.deferrable}`\n        return new Query(sql)\n    }\n\n    /**\n     * Builds drop unique constraint sql.\n     */\n    protected dropUniqueConstraintSql(\n        table: Table,\n        uniqueOrName: TableUnique | string,\n    ): Query {\n        const uniqueName = InstanceChecker.isTableUnique(uniqueOrName)\n            ? uniqueOrName.name\n            : uniqueOrName\n        return new Query(\n            `ALTER TABLE ${this.escapePath(\n                table,\n            )} DROP CONSTRAINT \"${uniqueName}\"`,\n        )\n    }\n\n    /**\n     * Builds create check constraint sql.\n     */\n    protected createCheckConstraintSql(\n        table: Table,\n        checkConstraint: TableCheck,\n    ): Query {\n        return new Query(\n            `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${\n                checkConstraint.name\n            }\" CHECK (${checkConstraint.expression})`,\n        )\n    }\n\n    /**\n     * Builds drop check constraint sql.\n     */\n    protected dropCheckConstraintSql(\n        table: Table,\n        checkOrName: TableCheck | string,\n    ): Query {\n        const checkName = InstanceChecker.isTableCheck(checkOrName)\n            ? checkOrName.name\n            : checkOrName\n        return new Query(\n            `ALTER TABLE ${this.escapePath(\n                table,\n            )} DROP CONSTRAINT \"${checkName}\"`,\n        )\n    }\n\n    /**\n     * Builds create exclusion constraint sql.\n     */\n    protected createExclusionConstraintSql(\n        table: Table,\n        exclusionConstraint: TableExclusion,\n    ): Query {\n        return new Query(\n            `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${\n                exclusionConstraint.name\n            }\" EXCLUDE ${exclusionConstraint.expression}`,\n        )\n    }\n\n    /**\n     * Builds drop exclusion constraint sql.\n     */\n    protected dropExclusionConstraintSql(\n        table: Table,\n        exclusionOrName: TableExclusion | string,\n    ): Query {\n        const exclusionName = InstanceChecker.isTableExclusion(exclusionOrName)\n            ? exclusionOrName.name\n            : exclusionOrName\n        return new Query(\n            `ALTER TABLE ${this.escapePath(\n                table,\n            )} DROP CONSTRAINT \"${exclusionName}\"`,\n        )\n    }\n\n    /**\n     * Builds create foreign key sql.\n     */\n    protected createForeignKeySql(\n        table: Table,\n        foreignKey: TableForeignKey,\n    ): Query {\n        const columnNames = foreignKey.columnNames\n            .map((column) => `\"` + column + `\"`)\n            .join(\", \")\n        const referencedColumnNames = foreignKey.referencedColumnNames\n            .map((column) => `\"` + column + `\"`)\n            .join(\",\")\n        let sql =\n            `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${\n                foreignKey.name\n            }\" FOREIGN KEY (${columnNames}) ` +\n            `REFERENCES ${this.escapePath(\n                this.getTablePath(foreignKey),\n            )}(${referencedColumnNames})`\n        if (foreignKey.onDelete) sql += ` ON DELETE ${foreignKey.onDelete}`\n        if (foreignKey.onUpdate) sql += ` ON UPDATE ${foreignKey.onUpdate}`\n        if (foreignKey.deferrable) sql += ` DEFERRABLE ${foreignKey.deferrable}`\n\n        return new Query(sql)\n    }\n\n    /**\n     * Builds drop foreign key sql.\n     */\n    protected dropForeignKeySql(\n        table: Table,\n        foreignKeyOrName: TableForeignKey | string,\n    ): Query {\n        const foreignKeyName = InstanceChecker.isTableForeignKey(\n            foreignKeyOrName,\n        )\n            ? foreignKeyOrName.name\n            : foreignKeyOrName\n        return new Query(\n            `ALTER TABLE ${this.escapePath(\n                table,\n            )} DROP CONSTRAINT \"${foreignKeyName}\"`,\n        )\n    }\n\n    /**\n     * Builds sequence name from given table and column.\n     */\n    protected buildSequenceName(\n        table: Table,\n        columnOrName: TableColumn | string,\n    ): string {\n        const { tableName } = this.driver.parseTableName(table)\n\n        const columnName = InstanceChecker.isTableColumn(columnOrName)\n            ? columnOrName.name\n            : columnOrName\n\n        let seqName = `${tableName}_${columnName}_seq`\n\n        if (seqName.length > this.connection.driver.maxAliasLength!) {\n            // note doesn't yet handle corner cases where .length differs from number of UTF-8 bytes\n            seqName = `${tableName.substring(0, 29)}_${columnName.substring(\n                0,\n                Math.max(29, 63 - table.name.length - 5),\n            )}_seq`\n        }\n\n        return seqName\n    }\n\n    protected buildSequencePath(\n        table: Table,\n        columnOrName: TableColumn | string,\n    ): string {\n        const { schema } = this.driver.parseTableName(table)\n\n        return schema\n            ? `${schema}.${this.buildSequenceName(table, columnOrName)}`\n            : this.buildSequenceName(table, columnOrName)\n    }\n\n    /**\n     * Builds ENUM type name from given table and column.\n     */\n    protected buildEnumName(\n        table: Table,\n        column: TableColumn,\n        withSchema: boolean = true,\n        disableEscape?: boolean,\n        toOld?: boolean,\n    ): string {\n        const { schema, tableName } = this.driver.parseTableName(table)\n        let enumName = column.enumName\n            ? column.enumName\n            : `${tableName}_${column.name.toLowerCase()}_enum`\n        if (schema && withSchema) enumName = `${schema}.${enumName}`\n        if (toOld) enumName = enumName + \"_old\"\n        return enumName\n            .split(\".\")\n            .map((i) => {\n                return disableEscape ? i : `\"${i}\"`\n            })\n            .join(\".\")\n    }\n\n    protected async getUserDefinedTypeName(table: Table, column: TableColumn) {\n        let { schema, tableName: name } = this.driver.parseTableName(table)\n\n        if (!schema) {\n            schema = await this.getCurrentSchema()\n        }\n\n        const result = await this.query(\n            `SELECT \"udt_schema\", \"udt_name\" ` +\n                `FROM \"information_schema\".\"columns\" WHERE \"table_schema\" = '${schema}' AND \"table_name\" = '${name}' AND \"column_name\"='${column.name}'`,\n        )\n\n        // docs: https://www.postgresql.org/docs/current/xtypes.html\n        // When you define a new base type, PostgreSQL automatically provides support for arrays of that type.\n        // The array type typically has the same name as the base type with the underscore character (_) prepended.\n        // ----\n        // so, we must remove this underscore character from enum type name\n        let udtName = result[0][\"udt_name\"]\n        if (udtName.indexOf(\"_\") === 0) {\n            udtName = udtName.substr(1, udtName.length)\n        }\n        return {\n            schema: result[0][\"udt_schema\"],\n            name: udtName,\n        }\n    }\n\n    /**\n     * Escapes a given comment so it's safe to include in a query.\n     */\n    protected escapeComment(comment?: string) {\n        if (!comment || comment.length === 0) {\n            return \"NULL\"\n        }\n\n        comment = comment.replace(/'/g, \"''\").replace(/\\u0000/g, \"\") // Null bytes aren't allowed in comments\n\n        return `'${comment}'`\n    }\n\n    /**\n     * Escapes given table or view path.\n     */\n    protected escapePath(target: Table | View | string): string {\n        const { schema, tableName } = this.driver.parseTableName(target)\n\n        if (schema && schema !== this.driver.searchSchema) {\n            return `\"${schema}\".\"${tableName}\"`\n        }\n\n        return `\"${tableName}\"`\n    }\n\n    /**\n     * Get the table name with table schema\n     * Note: Without ' or \"\n     */\n    protected async getTableNameWithSchema(target: Table | string) {\n        const tableName = InstanceChecker.isTable(target) ? target.name : target\n        if (tableName.indexOf(\".\") === -1) {\n            const schemaResult = await this.query(`SELECT current_schema()`)\n            const schema = schemaResult[0][\"current_schema\"]\n            return `${schema}.${tableName}`\n        } else {\n            return `${tableName.split(\".\")[0]}.${tableName.split(\".\")[1]}`\n        }\n    }\n\n    /**\n     * Builds a query for create column.\n     */\n    protected buildCreateColumnSql(table: Table, column: TableColumn) {\n        let c = '\"' + column.name + '\"'\n        if (\n            column.isGenerated === true &&\n            column.generationStrategy !== \"uuid\"\n        ) {\n            if (column.generationStrategy === \"identity\") {\n                // Postgres 10+ Identity generated column\n                const generatedIdentityOrDefault =\n                    column.generatedIdentity || \"BY DEFAULT\"\n                c += ` ${column.type} GENERATED ${generatedIdentityOrDefault} AS IDENTITY`\n            } else {\n                // classic SERIAL primary column\n                if (\n                    column.type === \"integer\" ||\n                    column.type === \"int\" ||\n                    column.type === \"int4\"\n                )\n                    c += \" SERIAL\"\n                if (column.type === \"smallint\" || column.type === \"int2\")\n                    c += \" SMALLSERIAL\"\n                if (column.type === \"bigint\" || column.type === \"int8\")\n                    c += \" BIGSERIAL\"\n            }\n        }\n        if (column.type === \"enum\" || column.type === \"simple-enum\") {\n            c += \" \" + this.buildEnumName(table, column)\n            if (column.isArray) c += \" array\"\n        } else if (!column.isGenerated || column.type === \"uuid\") {\n            c += \" \" + this.connection.driver.createFullType(column)\n        }\n\n        // Postgres only supports the stored generated column type\n        if (column.generatedType === \"STORED\" && column.asExpression) {\n            c += ` GENERATED ALWAYS AS (${column.asExpression}) STORED`\n        }\n\n        if (column.charset) c += ' CHARACTER SET \"' + column.charset + '\"'\n        if (column.collation) c += ' COLLATE \"' + column.collation + '\"'\n        if (column.isNullable !== true) c += \" NOT NULL\"\n        if (column.default !== undefined && column.default !== null)\n            c += \" DEFAULT \" + column.default\n        if (\n            column.isGenerated &&\n            column.generationStrategy === \"uuid\" &&\n            !column.default\n        )\n            c += ` DEFAULT ${this.driver.uuidGenerator}`\n\n        return c\n    }\n\n    /**\n     * Checks if the PostgreSQL server has support for partitioned tables\n     */\n    protected async hasSupportForPartitionedTables() {\n        const result = await this.query(\n            `SELECT TRUE FROM information_schema.columns WHERE table_name = 'pg_class' and column_name = 'relispartition'`,\n        )\n        return result.length ? true : false\n    }\n}\n"]},"metadata":{},"sourceType":"module"}