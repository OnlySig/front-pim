{"ast":null,"code":"import { QueryRunnerAlreadyReleasedError } from \"../../error/QueryRunnerAlreadyReleasedError\";\nimport { QueryFailedError } from \"../../error/QueryFailedError\";\nimport { AbstractSqliteQueryRunner } from \"../sqlite-abstract/AbstractSqliteQueryRunner\";\nimport { Broadcaster } from \"../../subscriber/Broadcaster\";\nimport { QueryResult } from \"../../query-runner/QueryResult\";\n/**\n * Runs queries on a single sqlite database connection.\n */\n\nexport class CapacitorQueryRunner extends AbstractSqliteQueryRunner {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(driver) {\n    super();\n    this.driver = driver;\n    this.connection = driver.connection;\n    this.broadcaster = new Broadcaster(this);\n  }\n  /**\n   * Called before migrations are run.\n   */\n\n\n  async beforeMigration() {\n    await this.query(`PRAGMA foreign_keys = OFF`);\n  }\n  /**\n   * Called after migrations are run.\n   */\n\n\n  async afterMigration() {\n    await this.query(`PRAGMA foreign_keys = ON`);\n  }\n\n  async executeSet(set) {\n    if (this.isReleased) throw new QueryRunnerAlreadyReleasedError();\n    const databaseConnection = await this.connect();\n    return databaseConnection.executeSet(set, false);\n  }\n  /**\n   * Executes a given SQL query.\n   */\n\n\n  async query(query, parameters) {\n    let useStructuredResult = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (this.isReleased) throw new QueryRunnerAlreadyReleasedError();\n    const databaseConnection = await this.connect();\n    this.driver.connection.logger.logQuery(query, parameters, this);\n    const command = query.substr(0, query.indexOf(\" \"));\n\n    try {\n      let raw;\n\n      if ([\"BEGIN\", \"ROLLBACK\", \"COMMIT\", \"CREATE\", \"ALTER\", \"DROP\"].indexOf(command) !== -1) {\n        raw = await databaseConnection.execute(query, false);\n      } else if ([\"INSERT\", \"UPDATE\", \"DELETE\"].indexOf(command) !== -1) {\n        raw = await databaseConnection.run(query, parameters, false);\n      } else {\n        raw = await databaseConnection.query(query, parameters || []);\n      }\n\n      const result = new QueryResult();\n\n      if (raw === null || raw === void 0 ? void 0 : raw.hasOwnProperty(\"values\")) {\n        result.raw = raw.values;\n        result.records = raw.values;\n      }\n\n      if (raw === null || raw === void 0 ? void 0 : raw.hasOwnProperty(\"changes\")) {\n        result.affected = raw.changes.changes;\n        result.raw = raw.changes.lastId || raw.changes.changes;\n      }\n\n      if (!useStructuredResult) {\n        return result.raw;\n      }\n\n      return result;\n    } catch (err) {\n      this.driver.connection.logger.logQueryError(err, query, parameters, this);\n      throw new QueryFailedError(query, parameters, err);\n    }\n  } // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Parametrizes given object of values. Used to create column=value queries.\n   */\n\n\n  parametrize(objectLiteral) {\n    return Object.keys(objectLiteral).map(key => `\"${key}\"` + \"=?\");\n  }\n\n}","map":{"version":3,"mappings":"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","names":["QueryRunnerAlreadyReleasedError","QueryFailedError","AbstractSqliteQueryRunner","Broadcaster","QueryResult","CapacitorQueryRunner","constructor","driver","connection","broadcaster","beforeMigration","query","afterMigration","executeSet","set","isReleased","databaseConnection","connect","parameters","useStructuredResult","logger","logQuery","command","substr","indexOf","raw","execute","run","result","hasOwnProperty","values","records","affected","changes","lastId","err","logQueryError","parametrize","objectLiteral","Object","keys","map","key"],"sources":["C:\\Users\\darkh\\node_modules\\typeorm\\browser\\src\\driver\\capacitor\\CapacitorQueryRunner.ts"],"sourcesContent":["import { QueryRunnerAlreadyReleasedError } from \"../../error/QueryRunnerAlreadyReleasedError\"\nimport { QueryFailedError } from \"../../error/QueryFailedError\"\nimport { AbstractSqliteQueryRunner } from \"../sqlite-abstract/AbstractSqliteQueryRunner\"\nimport { CapacitorDriver } from \"./CapacitorDriver\"\nimport { Broadcaster } from \"../../subscriber/Broadcaster\"\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { QueryResult } from \"../../query-runner/QueryResult\"\n\n/**\n * Runs queries on a single sqlite database connection.\n */\nexport class CapacitorQueryRunner extends AbstractSqliteQueryRunner {\n    /**\n     * Database driver used by connection.\n     */\n    driver: CapacitorDriver\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(driver: CapacitorDriver) {\n        super()\n        this.driver = driver\n        this.connection = driver.connection\n        this.broadcaster = new Broadcaster(this)\n    }\n\n    /**\n     * Called before migrations are run.\n     */\n    async beforeMigration(): Promise<void> {\n        await this.query(`PRAGMA foreign_keys = OFF`)\n    }\n\n    /**\n     * Called after migrations are run.\n     */\n    async afterMigration(): Promise<void> {\n        await this.query(`PRAGMA foreign_keys = ON`)\n    }\n\n    async executeSet(set: { statement: string; values?: any[] }[]) {\n        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError()\n\n        const databaseConnection = await this.connect()\n\n        return databaseConnection.executeSet(set, false)\n    }\n\n    /**\n     * Executes a given SQL query.\n     */\n    async query(\n        query: string,\n        parameters?: any[],\n        useStructuredResult = false,\n    ): Promise<any> {\n        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError()\n\n        const databaseConnection = await this.connect()\n\n        this.driver.connection.logger.logQuery(query, parameters, this)\n\n        const command = query.substr(0, query.indexOf(\" \"))\n\n        try {\n            let raw: any\n\n            if (\n                [\n                    \"BEGIN\",\n                    \"ROLLBACK\",\n                    \"COMMIT\",\n                    \"CREATE\",\n                    \"ALTER\",\n                    \"DROP\",\n                ].indexOf(command) !== -1\n            ) {\n                raw = await databaseConnection.execute(query, false)\n            } else if ([\"INSERT\", \"UPDATE\", \"DELETE\"].indexOf(command) !== -1) {\n                raw = await databaseConnection.run(query, parameters, false)\n            } else {\n                raw = await databaseConnection.query(query, parameters || [])\n            }\n\n            const result = new QueryResult()\n\n            if (raw?.hasOwnProperty(\"values\")) {\n                result.raw = raw.values\n                result.records = raw.values\n            }\n\n            if (raw?.hasOwnProperty(\"changes\")) {\n                result.affected = raw.changes.changes\n                result.raw = raw.changes.lastId || raw.changes.changes\n            }\n\n            if (!useStructuredResult) {\n                return result.raw\n            }\n\n            return result\n        } catch (err) {\n            this.driver.connection.logger.logQueryError(\n                err,\n                query,\n                parameters,\n                this,\n            )\n\n            throw new QueryFailedError(query, parameters, err)\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Parametrizes given object of values. Used to create column=value queries.\n     */\n    protected parametrize(objectLiteral: ObjectLiteral): string[] {\n        return Object.keys(objectLiteral).map((key) => `\"${key}\"` + \"=?\")\n    }\n}\n"]},"metadata":{},"sourceType":"module"}